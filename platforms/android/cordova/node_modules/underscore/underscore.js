entClassTypeAt(node));
        }
        function getAllAttributesTypeFromJsxOpeningLikeElement(node) {
            if (isJsxIntrinsicIdentifier(node.tagName)) {
                return getIntrinsicAttributesTypeFromJsxOpeningLikeElement(node);
            }
            else {
                return getCustomJsxElementAttributesType(node, true);
            }
        }
        function getAttributesTypeFromJsxOpeningLikeElement(node) {
            if (isJsxIntrinsicIdentifier(node.tagName)) {
                return getIntrinsicAttributesTypeFromJsxOpeningLikeElement(node);
            }
            else {
                return getCustomJsxElementAttributesType(node, false);
            }
        }
        function getJsxAttributePropertySymbol(attrib) {
            var attributesType = getAttributesTypeFromJsxOpeningLikeElement(attrib.parent.parent);
            var prop = getPropertyOfType(attributesType, attrib.name.escapedText);
            return prop || unknownSymbol;
        }
        function getJsxElementClassTypeAt(location) {
            var type = getJsxType(JsxNames.ElementClass, location);
            if (type === unknownType)
                return undefined;
            return type;
        }
        function getJsxElementTypeAt(location) {
            return getJsxType(JsxNames.Element, location);
        }
        function getJsxStatelessElementTypeAt(location) {
            var jsxElementType = getJsxElementTypeAt(location);
            if (jsxElementType) {
                return getUnionType([jsxElementType, nullType]);
            }
        }
        function getJsxIntrinsicTagNamesAt(location) {
            var intrinsics = getJsxType(JsxNames.IntrinsicElements, location);
            return intrinsics ? getPropertiesOfType(intrinsics) : ts.emptyArray;
        }
        function checkJsxPreconditions(errorNode) {
            if ((compilerOptions.jsx || 0) === 0) {
                error(errorNode, ts.Diagnostics.Cannot_use_JSX_unless_the_jsx_flag_is_provided);
            }
            if (getJsxElementTypeAt(errorNode) === undefined) {
                if (noImplicitAny) {
                    error(errorNode, ts.Diagnostics.JSX_element_implicitly_has_type_any_because_the_global_type_JSX_Element_does_not_exist);
                }
            }
        }
        function checkJsxOpeningLikeElementOrOpeningFragment(node, checkMode) {
            var isNodeOpeningLikeElement = ts.isJsxOpeningLikeElement(node);
            if (isNodeOpeningLikeElement) {
                checkGrammarJsxElement(node);
            }
            checkJsxPreconditions(node);
            var reactRefErr = diagnostics && compilerOptions.jsx === 2 ? ts.Diagnostics.Cannot_find_name_0 : undefined;
            var reactNamespace = getJsxNamespace(node);
            var reactLocation = isNodeOpeningLikeElement ? node.tagName : node;
            var reactSym = resolveName(reactLocation, reactNamespace, 67216319, reactRefErr, reactNamespace, true);
            if (reactSym) {
                reactSym.isReferenced = 67108863;
                if (reactSym.flags & 2097152 && !isConstEnumOrConstEnumOnlyModule(resolveAlias(reactSym))) {
                    markAliasSymbolAsReferenced(reactSym);
                }
            }
            if (isNodeOpeningLikeElement) {
                checkJsxAttributesAssignableToTagNameAttributes(node, checkMode);
            }
            else {
                checkJsxChildren(node.parent);
            }
        }
        function isKnownProperty(targetType, name, isComparingJsxAttributes) {
            if (targetType.flags & 65536) {
                var resolved = resolveStructuredTypeMembers(targetType);
                if (resolved.stringIndexInfo ||
                    resolved.numberIndexInfo && isNumericLiteralName(name) ||
                    getPropertyOfObjectType(targetType, name) ||
                    isComparingJsxAttributes && !isUnhyphenatedJsxName(name)) {
                    return true;
                }
            }
            else if (targetType.flags & 393216) {
                for (var _i = 0, _a = targetType.types; _i < _a.length; _i++) {
                    var t = _a[_i];
                    if (isKnownProperty(t, name, isComparingJsxAttributes)) {
                        return true;
                    }
                }
            }
            return false;
        }
        function checkJsxAttributesAssignableToTagNameAttributes(openingLikeElement, checkMode) {
            var targetAttributesType = isJsxIntrinsicIdentifier(openingLikeElement.tagName) ?
                getIntrinsicAttributesTypeFromJsxOpeningLikeElement(openingLikeElement) :
                getCustomJsxElementAttributesType(openingLikeElement, false);
            var sourceAttributesType = createJsxAttributesTypeFromAttributesProperty(openingLikeElement, checkMode);
            var isSourceAttributeTypeAssignableToTarget = isTypeAssignableTo(sourceAttributesType, targetAttributesType);
            if (isSourceAttributeTypeAssignableToTarget && !isTypeAny(sourceAttributesType) && !isTypeAny(targetAttributesType)) {
                for (var _i = 0, _a = openingLikeElement.attributes.properties; _i < _a.length; _i++) {
                    var attribute = _a[_i];
                    if (!ts.isJsxAttribute(attribute)) {
                        continue;
                    }
                    var attrName = attribute.name;
                    var isNotIgnoredJsxProperty = (isUnhyphenatedJsxName(ts.idText(attrName)) || !!(getPropertyOfType(targetAttributesType, attrName.escapedText)));
                    if (isNotIgnoredJsxProperty && !isKnownProperty(targetAttributesType, attrName.escapedText, true)) {
                        error(attribute, ts.Diagnostics.Property_0_does_not_exist_on_type_1, ts.idText(attrName), typeToString(targetAttributesType));
                        break;
                    }
                }
            }
            else if (!isSourceAttributeTypeAssignableToTarget) {
                if (ts.length(openingLikeElement.attributes.properties)) {
                    var reportedError = false;
                    var _loop_7 = function (prop) {
                        if (ts.isJsxSpreadAttribute(prop))
                            return "continue";
                        var name = ts.idText(prop.name);
                        var sourcePropType = getIndexedAccessType(sourceAttributesType, getLiteralType(name));
                        var targetPropType = getIndexedAccessType(targetAttributesType, getLiteralType(name));
                        var rootChain = function () { return ts.chainDiagnosticMessages(undefined, ts.Diagnostics.Types_of_property_0_are_incompatible, name); };
                        if (!checkTypeAssignableTo(sourcePropType, targetPropType, prop, undefined, rootChain)) {
                            reportedError = true;
                        }
                    };
                    for (var _b = 0, _c = openingLikeElement.attributes.properties; _b < _c.length; _b++) {
                        var prop = _c[_b];
                        _loop_7(prop);
                    }
                    if (reportedError) {
                        return;
                    }
                }
                checkTypeAssignableTo(sourceAttributesType, targetAttributesType, openingLikeElement.tagName);
            }
        }
        function checkJsxExpression(node, checkMode) {
            if (node.expression) {
                var type = checkExpression(node.expression, checkMode);
                if (node.dotDotDotToken && type !== anyType && !isArrayType(type)) {
                    error(node, ts.Diagnostics.JSX_spread_child_must_be_an_array_type);
                }
                return type;
            }
            else {
                return unknownType;
            }
        }
        function getDeclarationKindFromSymbol(s) {
            return s.valueDeclaration ? s.valueDeclaration.kind : 151;
        }
        function getDeclarationNodeFlagsFromSymbol(s) {
            return s.valueDeclaration ? ts.getCombinedNodeFlags(s.valueDeclaration) : 0;
        }
        function isPrototypeProperty(symbol) {
            if (symbol.flags & 8192 || ts.getCheckFlags(symbol) & 4) {
                return true;
            }
            if (ts.isInJavaScriptFile(symbol.valueDeclaration)) {
                var parent = symbol.valueDeclaration.parent;
                return parent && ts.isBinaryExpression(parent) &&
                    ts.getSpecialPropertyAssignmentKind(parent) === 3;
            }
        }
        function checkPropertyAccessibility(node, left, type, prop) {
            var flags = ts.getDeclarationModifierFlagsFromSymbol(prop);
            var errorNode = node.kind === 184 || node.kind === 231 ?
                node.name :
                node.kind === 178 ?
                    node :
                    node.right;
            if (ts.getCheckFlags(prop) & 256) {
                error(errorNode, ts.Diagnostics.Property_0_has_conflicting_declarations_and_is_inaccessible_in_type_1, symbolToString(prop), typeToString(type));
                return false;
            }
            if (left.kind === 97) {
                if (languageVersion < 2) {
                    if (symbolHasNonMethodDeclaration(prop)) {
                        error(errorNode, ts.Diagnostics.Only_public_and_protected_methods_of_the_base_class_are_accessible_via_the_super_keyword);
                        return false;
                    }
                }
                if (flags & 128) {
                    error(errorNode, ts.Diagnostics.Abstract_method_0_in_class_1_cannot_be_accessed_via_super_expression, symbolToString(prop), typeToString(getDeclaringClass(prop)));
                    return false;
                }
            }
            if ((flags & 128) && ts.isThisProperty(node) && symbolHasNonMethodDeclaration(prop)) {
                var declaringClassDeclaration = ts.getClassLikeDeclarationOfSymbol(getParentOfSymbol(prop));
                if (declaringClassDeclaration && isNodeWithinConstructorOfClass(node, declaringClassDeclaration)) {
                    error(errorNode, ts.Diagnostics.Abstract_property_0_in_class_1_cannot_be_accessed_in_the_constructor, symbolToString(prop), ts.getTextOfIdentifierOrLiteral(declaringClassDeclaration.name));
                    return false;
                }
            }
            if (!(flags & 24)) {
                return true;
            }
            if (flags & 8) {
                var declaringClassDeclaration = ts.getClassLikeDeclarationOfSymbol(getParentOfSymbol(prop));
                if (!isNodeWithinClass(node, declaringClassDeclaration)) {
                    error(errorNode, ts.Diagnostics.Property_0_is_private_and_only_accessible_within_class_1, symbolToString(prop), typeToString(getDeclaringClass(prop)));
                    return false;
                }
                return true;
            }
            if (left.kind === 97) {
                return true;
            }
            var enclosingClass = forEachEnclosingClass(node, function (enclosingDeclaration) {
                var enclosingClass = getDeclaredTypeOfSymbol(getSymbolOfNode(enclosingDeclaration));
                return isClassDerivedFromDeclaringClasses(enclosingClass, prop) ? enclosingClass : undefined;
            });
            if (!enclosingClass) {
                error(errorNode, ts.Diagnostics.Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses, symbolToString(prop), typeToString(getDeclaringClass(prop) || type));
                return false;
            }
            if (flags & 32) {
                return true;
            }
            if (type.flags & 32768) {
                type = type.isThisType ? getConstraintOfTypeParameter(type) : getBaseConstraintOfType(type);
            }
            if (!type || !hasBaseType(type, enclosingClass)) {
                error(errorNode, ts.Diagnostics.Property_0_is_protected_and_only_accessible_through_an_instance_of_class_1, symbolToString(prop), typeToString(enclosingClass));
                return false;
            }
            return true;
        }
        function symbolHasNonMethodDeclaration(symbol) {
            return forEachProperty(symbol, function (prop) {
                var propKind = getDeclarationKindFromSymbol(prop);
                return propKind !== 153 && propKind !== 152;
            });
        }
        function checkNonNullExpression(node, nullDiagnostic, undefinedDiagnostic, nullOrUndefinedDiagnostic) {
            return checkNonNullType(checkExpression(node), node, nullDiagnostic, undefinedDiagnostic, nullOrUndefinedDiagnostic);
        }
        function checkNonNullType(type, node, nullDiagnostic, undefinedDiagnostic, nullOrUndefinedDiagnostic) {
            var kind = (strictNullChecks ? getFalsyFlags(type) : type.flags) & 12288;
            if (kind) {
                error(node, kind & 4096 ? kind & 8192 ?
                    (nullOrUndefinedDiagnostic || ts.Diagnostics.Object_is_possibly_null_or_undefined) :
                    (undefinedDiagnostic || ts.Diagnostics.Object_is_possibly_undefined) :
                    (nullDiagnostic || ts.Diagnostics.Object_is_possibly_null));
                var t = getNonNullableType(type);
                return t.flags & (12288 | 16384) ? unknownType : t;
            }
            return type;
        }
        function checkPropertyAccessExpression(node) {
            return checkPropertyAccessExpressionOrQualifiedName(node, node.expression, node.name);
        }
        function checkQualifiedName(node) {
            return checkPropertyAccessExpressionOrQualifiedName(node, node.left, node.right);
        }
        function checkPropertyAccessExpressionOrQualifiedName(node, left, right) {
            var propType;
            var leftType = checkNonNullExpression(left);
            var parentSymbol = getNodeLinks(left).resolvedSymbol;
            var apparentType = getApparentType(getWidenedType(leftType));
            if (isTypeAny(apparentType) || apparentType === silentNeverType) {
                if (ts.isIdentifier(left) && parentSymbol) {
                    markAliasReferenced(parentSymbol, node);
                }
                return apparentType;
            }
            var assignmentKind = ts.getAssignmentTargetKind(node);
            var prop = getPropertyOfType(apparentType, right.escapedText);
            if (ts.isIdentifier(left) && parentSymbol && !(prop && isConstEnumOrConstEnumOnlyModule(prop))) {
                markAliasReferenced(parentSymbol, node);
            }
            if (!prop) {
                var indexInfo = getIndexInfoOfType(apparentType, 0);
                if (!(indexInfo && indexInfo.type)) {
                    if (right.escapedText && !checkAndReportErrorForExtendingInterface(node)) {
                        reportNonexistentProperty(right, leftType.flags & 32768 && leftType.isThisType ? apparentType : leftType);
                    }
                    return unknownType;
                }
                if (indexInfo.isReadonly && (ts.isAssignmentTarget(node) || ts.isDeleteTarget(node))) {
                    error(node, ts.Diagnostics.Index_signature_in_type_0_only_permits_reading, typeToString(apparentType));
                }
                propType = indexInfo.type;
            }
            else {
                checkPropertyNotUsedBeforeDeclaration(prop, node, right);
                markPropertyAsReferenced(prop, node, left.kind === 99);
                getNodeLinks(node).resolvedSymbol = prop;
                checkPropertyAccessibility(node, left, apparentType, prop);
                if (assignmentKind) {
                    if (isReferenceToReadonlyEntity(node, prop) || isReferenceThroughNamespaceImport(node)) {
                        error(right, ts.Diagnostics.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property, ts.idText(right));
                        return unknownType;
                    }
                }
                propType = getConstraintForLocation(getTypeOfSymbol(prop), node);
            }
            if (node.kind !== 184 ||
                assignmentKind === 1 ||
                prop && !(prop.flags & (3 | 4 | 98304)) && !(prop.flags & 8192 && propType.flags & 131072)) {
                return propType;
            }
            var assumeUninitialized = false;
            if (strictNullChecks && strictPropertyInitialization && left.kind === 99) {
                var declaration = prop && prop.valueDeclaration;
                if (declaration && isInstancePropertyWithoutInitializer(declaration)) {
                    var flowContainer = getControlFlowContainer(node);
                    if (flowContainer.kind === 154 && flowContainer.parent === declaration.parent) {
                        assumeUninitialized = true;
                    }
                }
            }
            var flowType = getFlowTypeOfReference(node, propType, assumeUninitialized ? getOptionalType(propType) : propType);
            if (assumeUninitialized && !(getFalsyFlags(propType) & 4096) && getFalsyFlags(flowType) & 4096) {
                error(right, ts.Diagnostics.Property_0_is_used_before_being_assigned, symbolToString(prop));
                return propType;
            }
            return assignmentKind ? getBaseTypeOfLiteralType(flowType) : flowType;
        }
        function checkPropertyNotUsedBeforeDeclaration(prop, node, right) {
            var valueDeclaration = prop.valueDeclaration;
            if (!valueDeclaration) {
                return;
            }
            if (isInPropertyInitializer(node) &&
                !isBlockScopedNameDeclaredBeforeUse(valueDeclaration, right)
                && !isPropertyDeclaredInAncestorClass(prop)) {
                error(right, ts.Diagnostics.Block_scoped_variable_0_used_before_its_declaration, ts.idText(right));
            }
            else if (valueDeclaration.kind === 234 &&
                node.parent.kind !== 161 &&
                !(valueDeclaration.flags & 4194304) &&
                !isBlockScopedNameDeclaredBeforeUse(valueDeclaration, right)) {
                error(right, ts.Diagnostics.Class_0_used_before_its_declaration, ts.idText(right));
            }
        }
        function isInPropertyInitializer(node) {
            return !!ts.findAncestor(node, function (node) {
                switch (node.kind) {
                    case 151:
                        return true;
                    case 269:
                        return false;
                    default:
                        return ts.isExpressionNode(node) ? false : "quit";
                }
            });
        }
        function isPropertyDeclaredInAncestorClass(prop) {
            if (!(prop.parent.flags & 32)) {
                return false;
            }
            var classType = getTypeOfSymbol(prop.parent);
            while (true) {
                classType = classType.symbol && getSuperClass(classType);
                if (!classType) {
                    return false;
                }
                var superProperty = getPropertyOfType(classType, prop.escapedName);
                if (superProperty && superProperty.valueDeclaration) {
                    return true;
                }
            }
        }
        function getSuperClass(classType) {
            var x = getBaseTypes(classType);
            if (x.length === 0) {
                return undefined;
            }
            return getIntersectionType(x);
        }
        function reportNonexistentProperty(propNode, containingType) {
            var errorInfo;
            if (containingType.flags & 131072 && !(containingType.flags & 16382)) {
                for (var _i = 0, _a = containingType.types; _i < _a.length; _i++) {
                    var subtype = _a[_i];
                    if (!getPropertyOfType(subtype, propNode.escapedText)) {
                        errorInfo = ts.chainDiagnosticMessages(errorInfo, ts.Diagnostics.Property_0_does_not_exist_on_type_1, ts.declarationNameToString(propNode), typeToString(subtype));
                        break;
                    }
                }
            }
            var promisedType = getPromisedTypeOfPromise(containingType);
            if (promisedType && getPropertyOfType(promisedType, propNode.escapedText)) {
                errorInfo = ts.chainDiagnosticMessages(errorInfo, ts.Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_forget_to_use_await, ts.declarationNameToString(propNode), typeToString(containingType));
            }
            else {
                var suggestion = getSuggestionForNonexistentProperty(propNode, containingType);
                if (suggestion !== undefined) {
                    errorInfo = ts.chainDiagnosticMessages(errorInfo, ts.Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_2, ts.declarationNameToString(propNode), typeToString(containingType), suggestion);
                }
                else {
                    errorInfo = ts.chainDiagnosticMessages(errorInfo, ts.Diagnostics.Property_0_does_not_exist_on_type_1, ts.declarationNameToString(propNode), typeToString(containingType));
                }
            }
            diagnostics.add(ts.createDiagnosticForNodeFromMessageChain(propNode, errorInfo));
        }
        function getSuggestionForNonexistentProperty(node, containingType) {
            var suggestion = getSpellingSuggestionForName(ts.idText(node), getPropertiesOfType(containingType), 67216319);
            return suggestion && ts.symbolName(suggestion);
        }
        function getSuggestionForNonexistentSymbol(location, outerName, meaning) {
            ts.Debug.assert(outerName !== undefined, "outername should always be defined");
            var result = resolveNameHelper(location, outerName, meaning, undefined, outerName, false, false, function (symbols, name, meaning) {
                ts.Debug.assertEqual(outerName, name, "name should equal outerName");
                var symbol = getSymbol(symbols, name, meaning);
                return symbol || getSpellingSuggestionForName(ts.unescapeLeadingUnderscores(name), ts.arrayFrom(symbols.values()), meaning);
            });
            return result && ts.symbolName(result);
        }
        function getSuggestionForNonexistentModule(name, targetModule) {
            var suggestion = targetModule.exports && getSpellingSuggestionForName(ts.idText(name), getExportsOfModuleAsArray(targetModule), 2623475);
            return suggestion && ts.symbolName(suggestion);
        }
        function getSpellingSuggestionForName(name, symbols, meaning) {
            var maximumLengthDifference = Math.min(2, Math.floor(name.length * 0.34));
            var bestDistance = Math.floor(name.length * 0.4) + 1;
            var bestCandidate;
            var justCheckExactMatches = false;
            var nameLowerCase = name.toLowerCase();
            for (var _i = 0, symbols_3 = symbols; _i < symbols_3.length; _i++) {
                var candidate = symbols_3[_i];
                var candidateName = ts.symbolName(candidate);
                if (candidateName.charCodeAt(0) === 34
                    || !(candidate.flags & meaning && Math.abs(candidateName.length - nameLowerCase.length) <= maximumLengthDifference)) {
                    continue;
                }
                var candidateNameLowerCase = candidateName.toLowerCase();
                if (candidateNameLowerCase === nameLowerCase) {
                    return candidate;
                }
                if (justCheckExactMatches) {
                    continue;
                }
                if (candidateName.length < 3) {
                    continue;
                }
                var distance = levenshteinWithMax(nameLowerCase, candidateNameLowerCase, bestDistance - 1);
                if (distance === undefined) {
                    continue;
                }
                if (distance < 3) {
                    justCheckExactMatches = true;
                    bestCandidate = candidate;
                }
                else {
                    ts.Debug.assert(distance < bestDistance);
                    bestDistance = distance;
                    bestCandidate = candidate;
                }
            }
            return bestCandidate;
        }
        function levenshteinWithMax(s1, s2, max) {
            var previous = new Array(s2.length + 1);
            var current = new Array(s2.length + 1);
            var big = max + 1;
            for (var i = 0; i <= s2.length; i++) {
                previous[i] = i;
            }
            for (var i = 1; i <= s1.length; i++) {
                var c1 = s1.charCodeAt(i - 1);
                var minJ = i > max ? i - max : 1;
                var maxJ = s2.length > max + i ? max + i : s2.length;
                current[0] = i;
                var colMin = i;
                for (var j = 1; j < minJ; j++) {
                    current[j] = big;
                }
                for (var j = minJ; j <= maxJ; j++) {
                    var dist = c1 === s2.charCodeAt(j - 1)
                        ? previous[j - 1]
                        : Math.min(previous[j] + 1, current[j - 1] + 1, previous[j - 1] + 2);
                    current[j] = dist;
                    colMin = Math.min(colMin, dist);
                }
                for (var j = maxJ + 1; j <= s2.length; j++) {
                    current[j] = big;
                }
                if (colMin > max) {
                    return undefined;
                }
                var temp = previous;
                previous = current;
                current = temp;
            }
            var res = previous[s2.length];
            return res > max ? undefined : res;
        }
        function markPropertyAsReferenced(prop, nodeForCheckWriteOnly, isThisAccess) {
            if (!prop || !(prop.flags & 106500) || !prop.valueDeclaration || !ts.hasModifier(prop.valueDeclaration, 8)) {
                return;
            }
            if (nodeForCheckWriteOnly && ts.isWriteOnlyAccess(nodeForCheckWriteOnly) && !(prop.flags & 65536 && !(prop.flags & 32768))) {
                return;
            }
            if (isThisAccess) {
                var containingMethod = ts.findAncestor(nodeForCheckWriteOnly, ts.isFunctionLikeDeclaration);
                if (containingMethod && containingMethod.symbol === prop) {
                    return;
                }
            }
            (ts.getCheckFlags(prop) & 1 ? getSymbolLinks(prop).target : prop).isReferenced = 67108863;
        }
        function isValidPropertyAccess(node, propertyName) {
            switch (node.kind) {
                case 184:
                    return isValidPropertyAccessWithType(node, node.expression, propertyName, getWidenedType(checkExpression(node.expression)));
                case 145:
                    return isValidPropertyAccessWithType(node, node.left, propertyName, getWidenedType(checkExpression(node.left)));
                case 178:
                    return isValidPropertyAccessWithType(node, node, propertyName, getTypeFromTypeNode(node));
            }
        }
        function isValidPropertyAccessForCompletions(node, type, property) {
            return isValidPropertyAccessWithType(node, node.kind === 178 ? node : node.expression, property.escapedName, type)
                && (!(property.flags & 8192) || isValidMethodAccess(property, type));
        }
        function isValidMethodAccess(method, actualThisType) {
            var propType = getTypeOfFuncClassEnumModule(method);
            var signatures = getSignaturesOfType(getNonNullableType(propType), 0);
            ts.Debug.assert(signatures.length !== 0);
            return signatures.some(function (sig) {
                var signatureThisType = getThisTypeOfSignature(sig);
                return !signatureThisType || isTypeAssignableTo(actualThisType, getInstantiatedSignatureThisType(sig, signatureThisType, actualThisType));
            });
        }
        function getInstantiatedSignatureThisType(sig, signatureThisType, actualThisType) {
            if (!sig.typeParameters) {
                return signatureThisType;
            }
            var context = createInferenceContext(sig.typeParameters, sig, 0);
            inferTypes(context.inferences, actualThisType, signatureThisType);
            return instantiateType(signatureThisType, createSignatureTypeMapper(sig, getInferredTypes(context)));
        }
        function isValidPropertyAccessWithType(node, left, propertyName, type) {
            if (type === unknownType || isTypeAny(type)) {
                return true;
            }
            var prop = getPropertyOfType(type, propertyName);
            return prop ? checkPropertyAccessibility(node, left, type, prop)
                : ts.isInJavaScriptFile(node) && (type.flags & 131072) && type.types.some(function (elementType) { return isValidPropertyAccessWithType(node, left, propertyName, elementType); });
        }
        function getForInVariableSymbol(node) {
            var initializer = node.initializer;
            if (initializer.kind === 232) {
                var variable = initializer.declarations[0];
                if (variable && !ts.isBindingPattern(variable.name)) {
                    return getSymbolOfNode(variable);
                }
            }
            else if (initializer.kind === 71) {
                return getResolvedSymbol(initializer);
            }
            return undefined;
        }
        function hasNumericPropertyNames(type) {
            return getIndexTypeOfType(type, 1) && !getIndexTypeOfType(type, 0);
        }
        function isForInVariableForNumericPropertyNames(expr) {
            var e = ts.skipParentheses(expr);
            if (e.kind === 71) {
                var symbol = getResolvedSymbol(e);
                if (symbol.flags & 3) {
                    var child = expr;
                    var node = expr.parent;
                    while (node) {
                        if (node.kind === 220 &&
                            child === node.statement &&
                            getForInVariableSymbol(node) === symbol &&
                            hasNumericPropertyNames(getTypeOfExpression(node.expression))) {
                            return true;
                        }
                        child = node;
                        node = node.parent;
                    }
                }
            }
            return false;
        }
        function checkIndexedAccess(node) {
            var objectType = checkNonNullExpression(node.expression);
            var indexExpression = node.argumentExpression;
            if (!indexExpression) {
                var sourceFile = ts.getSourceFileOfNode(node);
                if (node.parent.kind === 187 && node.parent.expression === node) {
                    var start = ts.skipTrivia(sourceFile.text, node.expression.end);
                    var end = node.end;
                    grammarErrorAtPos(sourceFile, start, end - start, ts.Diagnostics.new_T_cannot_be_used_to_create_an_array_Use_new_Array_T_instead);
                }
                else {
                    var start = node.end - "]".length;
                    var end = node.end;
                    grammarErrorAtPos(sourceFile, start, end - start, ts.Diagnostics.Expression_expected);
                }
                return unknownType;
            }
            var indexType = isForInVariableForNumericPropertyNames(indexExpression) ? numberType : checkExpression(indexExpression);
            if (objectType === unknownType || objectType === silentNeverType) {
                return objectType;
            }
            if (isConstEnumObjectType(objectType) && indexExpression.kind !== 9) {
                error(indexExpression, ts.Diagnostics.A_const_enum_member_can_only_be_accessed_using_a_string_literal);
                return unknownType;
            }
            return checkIndexedAccessIndexType(getIndexedAccessType(objectType, indexType, node), node);
        }
        function checkThatExpressionIsProperSymbolReference(expression, expressionType, reportError) {
            if (expressionType === unknownType) {
                return false;
            }
            if (!ts.isWellKnownSymbolSyntactically(expression)) {
                return false;
            }
            if ((expressionType.flags & 1536) === 0) {
                if (reportError) {
                    error(expression, ts.Diagnostics.A_computed_property_name_of_the_form_0_must_be_of_type_symbol, ts.getTextOfNode(expression));
                }
                return false;
            }
            var leftHandSide = expression.expression;
            var leftHandSideSymbol = getResolvedSymbol(leftHandSide);
            if (!leftHandSideSymbol) {
                return false;
            }
            var globalESSymbol = getGlobalESSymbolConstructorSymbol(true);
            if (!globalESSymbol) {
                return false;
            }
            if (leftHandSideSymbol !== globalESSymbol) {
                if (reportError) {
                    error(leftHandSide, ts.Diagnostics.Symbol_reference_does_not_refer_to_the_global_Symbol_constructor_object);
                }
                return false;
            }
            return true;
        }
        function callLikeExpressionMayHaveTypeArguments(node) {
            return ts.isCallOrNewExpression(node);
        }
        function resolveUntypedCall(node) {
            if (callLikeExpressionMayHaveTypeArguments(node)) {
                ts.forEach(node.typeArguments, checkSourceElement);
            }
            if (node.kind === 188) {
                checkExpression(node.template);
            }
            else if (node.kind !== 149) {
                ts.forEach(node.arguments, function (argument) {
                    checkExpression(argument);
                });
            }
            return anySignature;
        }
        function resolveErrorCall(node) {
            resolveUntypedCall(node);
            return unknownSignature;
        }
        function reorderCandidates(signatures, result) {
            var lastParent;
            var lastSymbol;
            var cutoffIndex = 0;
            var index;
            var specializedIndex = -1;
            var spliceIndex;
            ts.Debug.assert(!result.length);
            for (var _i = 0, signatures_4 = signatures; _i < signatures_4.length; _i++) {
                var signature = signatures_4[_i];
                var symbol = signature.declaration && getSymbolOfNode(signature.declaration);
                var parent = signature.declaration && signature.declaration.parent;
                if (!lastSymbol || symbol === lastSymbol) {
                    if (lastParent && parent === lastParent) {
                        index++;
                    }
                    else {
                        lastParent = parent;
                        index = cutoffIndex;
                    }
                }
                else {
                    index = cutoffIndex = result.length;
                    lastParent = parent;
                }
                lastSymbol = symbol;
                if (signature.hasLiteralTypes) {
                    specializedIndex++;
                    spliceIndex = specializedIndex;
                    cutoffIndex++;
                }
                else {
                    spliceIndex = index;
                }
                result.splice(spliceIndex, 0, signature);
            }
        }
        function getSpreadArgumentIndex(args) {
            for (var i = 0; i < args.length; i++) {
                var arg = args[i];
                if (arg && arg.kind === 203) {
                    return i;
                }
            }
            return -1;
        }
        function hasCorrectArity(node, args, signature, signatureHelpTrailingComma) {
            if (signatureHelpTrailingComma === void 0) { signatureHelpTrailingComma = false; }
            var argCount;
            var typeArguments;
            var callIsIncomplete;
            var spreadArgIndex = -1;
            if (ts.isJsxOpeningLikeElement(node)) {
                return true;
            }
            if (node.kind === 188) {
                argCount = args.length;
                typeArguments = node.typeArguments;
                if (node.template.kind === 201) {
                    var lastSpan = ts.lastOrUndefined(node.template.templateSpans);
                    ts.Debug.assert(lastSpan !== undefined);
                    callIsIncomplete = ts.nodeIsMissing(lastSpan.literal) || !!lastSpan.literal.isUnterminated;
                }
                else {
                    var templateLiteral = node.template;
                    ts.Debug.assert(templateLiteral.kind === 13);
                    callIsIncomplete = !!templateLiteral.isUnterminated;
                }
            }
            else if (node.kind === 149) {
                typeArguments = undefined;
                argCount = getEffectiveArgumentCount(node, undefined, signature);
            }
            else {
                if (!node.arguments) {
                    ts.Debug.assert(node.kind === 187);
                    return signature.minArgumentCount === 0;
                }
                argCount = signatureHelpTrailingComma ? args.length + 1 : args.length;
                callIsIncomplete = node.arguments.end === node.end;
                typeArguments = node.typeArguments;
                spreadArgIndex = getSpreadArgumentIndex(args);
            }
            if (!hasCorrectTypeArgumentArity(signature, typeArguments)) {
                return false;
            }
            if (spreadArgIndex >= 0) {
                return isRestParameterIndex(signature, spreadArgIndex) ||
                    signature.minArgumentCount <= spreadArgIndex && spreadArgIndex < signature.parameters.length;
            }
            if (!signature.hasRestParameter && argCount > signature.parameters.length) {
                return false;
            }
            var hasEnoughArguments = argCount >= signature.minArgumentCount;
            return callIsIncomplete || hasEnoughArguments;
        }
        function hasCorrectTypeArgumentArity(signature, typeArguments) {
            var numTypeParameters = ts.length(signature.typeParameters);
            var minTypeArgumentCount = getMinTypeArgumentCount(signature.typeParameters);
            return !typeArguments ||
                (typeArguments.length >= minTypeArgumentCount && typeArguments.length <= numTypeParameters);
        }
        function getSingleCallSignature(type) {
            if (type.flags & 65536) {
                var resolved = resolveStructuredTypeMembers(type);
                if (resolved.callSignatures.length === 1 && resolved.constructSignatures.length === 0 &&
                    resolved.properties.length === 0 && !resolved.stringIndexInfo && !resolved.numberIndexInfo) {
                    return resolved.callSignatures[0];
                }
            }
            return undefined;
        }
        function instantiateSignatureInContextOf(signature, contextualSignature, contextualMapper, compareTypes) {
            var context = createInferenceContext(signature.typeParameters, signature, 1, compareTypes);
            forEachMatchingParameterType(contextualSignature, signature, function (source, target) {
                inferTypes(context.inferences, instantiateType(source, contextualMapper || identityMapper), target);
            });
            if (!contextualMapper) {
                inferTypes(context.inferences, getReturnTypeOfSignature(contextualSignature), getReturnTypeOfSignature(signature), 8);
            }
            return getSignatureInstantiation(signature, getInferredTypes(context), ts.isInJavaScriptFile(contextualSignature.declaration));
        }
        function inferJsxTypeArguments(signature, node, context) {
            var skipContextParamType = getTypeAtPosition(signature, 0);
            var checkAttrTypeSkipContextSensitive = checkExpressionWithContextualType(node.attributes, skipContextParamType, identityMapper);
            inferTypes(context.inferences, checkAttrTypeSkipContextSensitive, skipContextParamType);
            var paramType = getTypeAtPosition(signature, 0);
            var checkAttrType = checkExpressionWithContextualType(node.attributes, paramType, context);
            inferTypes(context.inferences, checkAttrType, paramType);
            return getInferredTypes(context);
        }
        function inferTypeArguments(node, signature, args, excludeArgument, context) {
            for (var _i = 0, _a = context.inferences; _i < _a.length; _i++) {
                var inference = _a[_i];
                if (!inference.isFixed) {
                    inference.inferredType = undefined;
                }
            }
            if (node.kind !== 149) {
                var contextualType = getContextualType(node);
                if (contextualType) {
                    var instantiatedType = instantiateType(contextualType, cloneTypeMapper(getContextualMapper(node)));
                    var contextualSignature = getSingleCallSignature(instantiatedType);
                    var inferenceSourceType = contextualSignature && contextualSignature.typeParameters ?
                        getOrCreateTypeFromSignature(getSignatureInstantiation(contextualSignature, contextualSignature.typeParameters, ts.isInJavaScriptFile(node))) :
                        instantiatedType;
                    var inferenceTargetType = getReturnTypeOfSignature(signature);
                    inferTypes(context.inferences, inferenceSourceType, inferenceTargetType, 8);
                }
            }
            var thisType = getThisTypeOfSignature(signature);
            if (thisType) {
                var thisArgumentNode = getThisArgumentOfCall(node);
                var thisArgumentType = thisArgumentNode ? checkExpression(thisArgumentNode) : voidType;
                inferTypes(context.inferences, thisArgumentType, thisType);
            }
            var argCount = getEffectiveArgumentCount(node, args, signature);
            for (var i = 0; i < argCount; i++) {
                var arg = getEffectiveArgument(node, args, i);
                if (arg === undefined || arg.kind !== 205) {
                    var paramType = getTypeAtPosition(signature, i);
                    var argType = getEffectiveArgumentType(node, i);
                    if (argType === undefined) {
                        var mapper = excludeArgument && excludeArgument[i] !== undefined ? identityMapper : context;
                        argType = checkExpressionWithContextualType(arg, paramType, mapper);
                    }
                    inferTypes(context.inferences, argType, paramType);
                }
            }
            if (excludeArgument) {
                for (var i = 0; i < argCount; i++) {
                    if (excludeArgument[i] === false) {
                        var arg = args[i];
                        var paramType = getTypeAtPosition(signature, i);
                        inferTypes(context.inferences, checkExpressionWithContextualType(arg, paramType, context), paramType);
                    }
                }
            }
            return getInferredTypes(context);
        }
        function checkTypeArguments(signature, typeArgumentNodes, reportErrors, headMessage) {
            var isJavascript = ts.isInJavaScriptFile(signature.declaration);
            var typeParameters = signature.typeParameters;
            var typeArgumentTypes = fillMissingTypeArguments(ts.map(typeArgumentNodes, getTypeFromTypeNode), typeParameters, getMinTypeArgumentCount(typeParameters), isJavascript);
            var mapper;
            for (var i = 0; i < typeArgumentNodes.length; i++) {
                ts.Debug.assert(typeParameters[i] !== undefined, "Should not call checkTypeArguments with too many type arguments");
                var constraint = getConstraintOfTypeParameter(typeParameters[i]);
                if (!constraint)
                    continue;
                var errorInfo = reportErrors && headMessage && (function () { return ts.chainDiagnosticMessages(undefined, ts.Diagnostics.Type_0_does_not_satisfy_the_constraint_1); });
                var typeArgumentHeadMessage = headMessage || ts.Diagnostics.Type_0_does_not_satisfy_the_constraint_1;
                if (!mapper) {
                    mapper = createTypeMapper(typeParameters, typeArgumentTypes);
                }
                var typeArgument = typeArgumentTypes[i];
                if (!checkTypeAssignableTo(typeArgument, getTypeWithThisArgument(instantiateType(constraint, mapper), typeArgument), reportErrors ? typeArgumentNodes[i] : undefined, typeArgumentHeadMessage, errorInfo)) {
                    return false;
                }
            }
            return typeArgumentTypes;
        }
        function checkApplicableSignatureForJsxOpeningLikeElement(node, signature, relation) {
            var callIsIncomplete = node.attributes.end === node.end;
            if (callIsIncomplete) {
                return true;
            }
            var headMessage = ts.Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1;
            var paramType = getTypeAtPosition(signature, 0);
            var attributesType = checkExpressionWithContextualType(node.attributes, paramType, undefined);
            var argProperties = getPropertiesOfType(attributesType);
            for (var _i = 0, argProperties_1 = argProperties; _i < argProperties_1.length; _i++) {
                var arg = argProperties_1[_i];
                if (!getPropertyOfType(paramType, arg.escapedName) && isUnhyphenatedJsxName(arg.escapedName)) {
                    return false;
                }
            }
            return checkTypeRelatedTo(attributesType, paramType, relation, undefined, headMessage);
        }
        function checkApplicableSignature(node, args, signature, relation, excludeArgument, reportErrors) {
            if (ts.isJsxOpeningLikeElement(node)) {
                return checkApplicableSignatureForJsxOpeningLikeElement(node, signature, relation);
            }
            var thisType = getThisTypeOfSignature(signature);
            if (thisType && thisType !== voidType && node.kind !== 187) {
                var thisArgumentNode = getThisArgumentOfCall(node);
                var thisArgumentType = thisArgumentNode ? checkExpression(thisArgumentNode) : voidType;
                var errorNode = reportErrors ? (thisArgumentNode || node) : undefined;
                var headMessage_1 = ts.Diagnostics.The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1;
                if (!checkTypeRelatedTo(thisArgumentType, getThisTypeOfSignature(signature), relation, errorNode, headMessage_1)) {
                    return false;
                }
            }
            var headMessage = ts.Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1;
            var argCount = getEffectiveArgumentCount(node, args, signature);
            for (var i = 0; i < argCount; i++) {
                var arg = getEffectiveArgument(node, args, i);
                if (arg === undefined || arg.kind !== 205) {
                    var paramType = getTypeAtPosition(signature, i);
                    var argType = getEffectiveArgumentType(node, i) ||
                        checkExpressionWithContextualType(arg, paramType, excludeArgument && excludeArgument[i] ? identityMapper : undefined);
                    var checkArgType = excludeArgument ? getRegularTypeOfObjectLiteral(argType) : argType;
                    var errorNode = reportErrors ? getEffectiveArgumentErrorNode(node, i, arg) : undefined;
                    if (!checkTypeRelatedTo(checkArgType, paramType, relation, errorNode, headMessage)) {
                        return false;
                    }
                }
            }
            return true;
        }
        function getThisArgumentOfCall(node) {
            if (node.kind === 186) {
                var callee = ts.skipOuterExpressions(node.expression);
                if (callee.kind === 184 || callee.kind === 185) {
                    return callee.expression;
                }
            }
        }
        function getEffectiveCallArguments(node) {
            if (node.kind === 188) {
                var template = node.template;
                var args_4 = [undefined];
                if (template.kind === 201) {
                    ts.forEach(template.templateSpans, function (span) {
                        args_4.push(span.expression);
                    });
                }
                return args_4;
            }
            else if (node.kind === 149) {
                return undefined;
            }
            else if (ts.isJsxOpeningLikeElement(node)) {
                return node.attributes.properties.length > 0 ? [node.attributes] : ts.emptyArray;
            }
            else {
                return node.arguments || ts.emptyArray;
            }
        }
        function getEffectiveArgumentCount(node, args, signature) {
            if (node.kind === 149) {
                switch (node.parent.kind) {
                    case 234:
                    case 204:
                        return 1;
                    case 151:
                        return 2;
                    case 153:
                    case 155:
                    case 156:
                        if (languageVersion === 0) {
                            return 2;
                        }
                        return signature.parameters.length >= 3 ? 3 : 2;
                    case 148:
                        return 3;
                }
            }
            else {
                return args.length;
            }
        }
        function getEffectiveDecoratorFirstArgumentType(node) {
            if (node.kind === 234) {
                var classSymbol = getSymbolOfNode(node);
                return getTypeOfSymbol(classSymbol);
            }
            if (node.kind === 148) {
                node = node.parent;
                if (node.kind === 154) {
                    var classSymbol = getSymbolOfNode(node);
                    return getTypeOfSymbol(classSymbol);
                }
            }
            if (node.kind === 151 ||
                node.kind === 153 ||
                node.kind === 155 ||
                node.kind === 156) {
                return getParentTypeOfClassElement(node);
            }
            ts.Debug.fail("Unsupported decorator target.");
            return unknownType;
        }
        function getEffectiveDecoratorSecondArgumentType(node) {
            if (node.kind === 234) {
                ts.Debug.fail("Class decorators should not have a second synthetic argument.");
                return unknownType;
            }
            if (node.kind === 148) {
                node = node.parent;
                if (node.kind === 154) {
                    return anyType;
                }
            }
            if (node.kind === 151 ||
                node.kind === 153 ||
                node.kind === 155 ||
                node.kind === 156) {
                var element = node;
                switch (element.name.kind) {
                    case 71:
                        return getLiteralType(ts.idText(element.name));
                    case 8:
                    case 9:
                        return getLiteralType(element.name.text);
                    case 146:
                        var nameType = checkComputedPropertyName(element.name);
                        if (isTypeAssignableToKind(nameType, 1536)) {
                            return nameType;
                        }
                        else {
                            return stringType;
                        }
                    default:
                        ts.Debug.fail("Unsupported property name.");
                        return unknownType;
                }
            }
            ts.Debug.fail("Unsupported decorator target.");
            return unknownType;
        }
        function getEffectiveDecoratorThirdArgumentType(node) {
            if (node.kind === 234) {
                ts.Debug.fail("Class decorators should not have a third synthetic argument.");
                return unknownType;
            }
            if (node.kind === 148) {
                return numberType;
            }
            if (node.kind === 151) {
                ts.Debug.fail("Property decorators should not have a third synthetic argument.");
                return unknownType;
            }
            if (node.kind === 153 ||
                node.kind === 155 ||
                node.kind === 156) {
                var /*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved. 
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0  
 
THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, 
MERCHANTABLITY OR NON-INFRINGEMENT. 
 
See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */



/// <reference no-default-lib="true"/>


interface Array<T> {
    /**
      * Determines whether an array includes a certain element, returning true or false as appropriate.
      * @param searchElement The element to search for.
      * @param fromIndex The position in this array at which to begin searching for searchElement.
      */
    includes(searchElement: T, fromIndex?: number): boolean;
}

interface ReadonlyArray<T> {
    /**
      * Determines whether an array includes a certain element, returning true or false as appropriate.
      * @param searchElement The element to search for.
      * @param fromIndex The position in this array at which to begin searching for searchElement.
      */
    includes(searchElement: T, fromIndex?: number): boolean;
}

interface Int8Array {
    /**
      * Determines whether an array includes a certain element, returning true or false as appropriate.
      * @param searchElement The element to search for.
      * @param fromIndex The position in this array at which to begin searching for searchElement.
      */
    includes(searchElement: number, fromIndex?: number): boolean;
}

interface Uint8Array {
    /**
      * Determines whether an array includes a certain element, returning true or false as appropriate.
      * @param searchElement The element to search for.
      * @param fromIndex The position in this array at which to begin searching for searchElement.
      */
    includes(searchElement: number, fromIndex?: number): boolean;
}

interface Uint8ClampedArray {
    /**
      * Determines whether an array includes a certain element, returning true or false as appropriate.
      * @param searchElement The element to search for.
      * @param fromIndex The position in this array at which to begin searching for searchElement.
      */
    includes(searchElement: number, fromIndex?: number): boolean;
}

interface Int16Array {
    /**
      * Determines whether an array includes a certain element, returning true or false as appropriate.
      * @param searchElement The element to search for.
      * @param fromIndex The position in this array at which to begin searching for searchElement.
      */
    includes(searchElement: number, fromIndex?: number): boolean;
}

interface Uint16Array {
    /**
      * Determines whether an array includes a certain element, returning true or false as appropriate.
      * @param searchElement The element to search for.
      * @param fromIndex The position in this array at which to begin searching for searchElement.
      */
    includes(searchElement: number, fromIndex?: number): boolean;
}

interface Int32Array {
    /**
      * Determines whether an array includes a certain element, returning true or false as appropriate.
      * @param searchElement The element to search for.
      * @param fromIndex The position in this array at which to begin searching for searchElement.
      */
    includes(searchElement: number, fromIndex?: number): boolean;
}

interface Uint32Array {
    /**
      * Determines whether an array includes a certain element, returning true or false as appropriate.
      * @param searchElement The element to search for.
      * @param fromIndex The position in this array at which to begin searching for searchElement.
      */
    includes(searchElement: number, fromIndex?: number): boolean;
}

interface Float32Array {
    /**
      * Determines whether an array includes a certain element, returning true or false as appropriate.
      * @param searchElement The element to search for.
      * @param fromIndex The position in this array at which to begin searching for searchElement.
      */
    includes(searchElement: number, fromIndex?: number): boolean;
}

interface Float64Array {
    /**
      * Determines whether an array includes a certain element, returning true or false as appropriate.
      * @param searchElement The element to search for.
      * @param fromIndex The position in this array at which to begin searching for searchElement.
      */
    includes(searchElement: number, fromIndex?: number): boolean;
}                                                                                                                                                             