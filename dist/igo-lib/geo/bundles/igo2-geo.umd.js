(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('ol/source/OSM'), require('ol/source/XYZ'), require('ol/format/filter'), require('ol/format/WFS'), require('ol/source/ImageWMS'), require('ol/source/WMTS'), require('ol/tilegrid/WMTS'), require('ol/extent.js'), require('ol/source/CartoDB'), require('ol/loadingstrategy'), require('ol/source/TileArcGISRest'), require('ts-md5'), require('ol/source/VectorTile'), require('ol/format/MVT'), require('ol/source/Cluster'), require('ngx-cacheable'), require('ol/source/WMTS.js'), require('ol/Map'), require('ol/View'), require('ol/Geolocation'), require('ol/control/Attribution'), require('ol/control/ScaleLine'), require('ol/layer/Image'), require('ol/layer/Tile'), require('ol/color'), require('ol/layer/VectorTile'), require('ol/easing'), require('ol/has'), require('proj4'), require('ol/proj/proj4'), require('@angular/animations'), require('ol/format/GML2'), require('ol/format/GML3'), require('ol/format/EsriJSON'), require('ol/proj/Projection'), require('@angular/platform-browser'), require('moment'), require('ol/format/WKT'), require('ol/geom/Point'), require('ol/Overlay'), require('ol/sphere'), require('ol/style/Style'), require('ol/geom/LineString'), require('@turf/line-intersect'), require('@turf/helpers'), require('ol/interaction/Modify'), require('ol/interaction/Translate'), require('ol/interaction/Draw'), require('ol/geom/Polygon'), require('ol/geom/LinearRing'), require('ol/interaction/DragBox'), require('ol/source/Vector'), require('ol/layer/Vector'), require('file-saver'), require('jspdf'), require('html2canvas'), require('jszip'), require('ol/Feature'), require('ol/geom'), require('ol/proj'), require('ol/style'), require('ol/events/condition'), require('ol/interaction'), require('ol/extent'), require('ol/Observable'), require('@angular/forms'), require('ol/format/GeoJSON'), require('@angular/material'), require('@angular/common'), require('@igo2/common'), require('rxjs'), require('ol/format'), require('@angular/core'), require('@angular/common/http'), require('rxjs/operators'), require('@igo2/utils'), require('@igo2/core')) :
    typeof define === 'function' && define.amd ? define('@igo2/geo', ['exports', 'ol/source/OSM', 'ol/source/XYZ', 'ol/format/filter', 'ol/format/WFS', 'ol/source/ImageWMS', 'ol/source/WMTS', 'ol/tilegrid/WMTS', 'ol/extent.js', 'ol/source/CartoDB', 'ol/loadingstrategy', 'ol/source/TileArcGISRest', 'ts-md5', 'ol/source/VectorTile', 'ol/format/MVT', 'ol/source/Cluster', 'ngx-cacheable', 'ol/source/WMTS.js', 'ol/Map', 'ol/View', 'ol/Geolocation', 'ol/control/Attribution', 'ol/control/ScaleLine', 'ol/layer/Image', 'ol/layer/Tile', 'ol/color', 'ol/layer/VectorTile', 'ol/easing', 'ol/has', 'proj4', 'ol/proj/proj4', '@angular/animations', 'ol/format/GML2', 'ol/format/GML3', 'ol/format/EsriJSON', 'ol/proj/Projection', '@angular/platform-browser', 'moment', 'ol/format/WKT', 'ol/geom/Point', 'ol/Overlay', 'ol/sphere', 'ol/style/Style', 'ol/geom/LineString', '@turf/line-intersect', '@turf/helpers', 'ol/interaction/Modify', 'ol/interaction/Translate', 'ol/interaction/Draw', 'ol/geom/Polygon', 'ol/geom/LinearRing', 'ol/interaction/DragBox', 'ol/source/Vector', 'ol/layer/Vector', 'file-saver', 'jspdf', 'html2canvas', 'jszip', 'ol/Feature', 'ol/geom', 'ol/proj', 'ol/style', 'ol/events/condition', 'ol/interaction', 'ol/extent', 'ol/Observable', '@angular/forms', 'ol/format/GeoJSON', '@angular/material', '@angular/common', '@igo2/common', 'rxjs', 'ol/format', '@angular/core', '@angular/common/http', 'rxjs/operators', '@igo2/utils', '@igo2/core'], factory) :
    (factory((global.igo2 = global.igo2 || {}, global.igo2.geo = {}),global.olSourceOSM,global.olSourceXYZ,global.olfilter,global.olFormatWFS,global.olSourceImageWMS,global.olSourceWMTS,global.olTileGridWMTS,global.extent_js,global.olSourceCarto,global.OlLoadingStrategy,global.olSourceTileArcGISRest,global.tsMd5,global.olSourceVectorTile,global.olFormatMVT,global.olSourceCluster,global.ngxCacheable,global.WMTS_js,global.olMap,global.olView,global.olGeolocation,global.olAttribution,global.olControlScaleLine,global.olLayerImage,global.olLayerTile,global.color,global.olLayerVectorTile,global.oleasing,global.has,global.proj4,global.olproj4,global.ng.animations,global.olFormatGML2,global.olFormatGML3,global.olFormatEsriJSON,global.olProjection,global.ng.platformBrowser,global.moment,global.olWKT,global.OlPoint,global.OlOverlay,global.sphere,global.OlStyle,global.OlLineString,global.lineIntersect,global.helpers,global.OlModify,global.OlTranslate,global.OlDraw,global.OlPolygon,global.OlLinearRing,global.OlDragBoxInteraction,global.OlVectorSource,global.OlVectorLayer,global.fileSaver,global.jsPDF,global._html2canvas,global.JSZip,global.OlFeature,global.olgeom,global.olproj,global.olstyle,global.olcondition,global.olinteraction,global.olextent,global.olobservable,global.ng.forms,global.OlGeoJSON,global.ng.material,global.ng.common,global.common$1,global.rxjs,global.olformat,global.ng.core,global.ng.common.http,global.rxjs.operators,global.utils,global.i1$1));
}(this, (function (exports,olSourceOSM,olSourceXYZ,olfilter,olFormatWFS,olSourceImageWMS,olSourceWMTS,olTileGridWMTS,extent_js,olSourceCarto,OlLoadingStrategy,olSourceTileArcGISRest,tsMd5,olSourceVectorTile,olFormatMVT,olSourceCluster,ngxCacheable,WMTS_js,olMap,olView,olGeolocation,olAttribution,olControlScaleLine,olLayerImage,olLayerTile,color,olLayerVectorTile,oleasing,has,proj4,olproj4,animations,olFormatGML2,olFormatGML3,olFormatEsriJSON,olProjection,platformBrowser,moment,olWKT,OlPoint,OlOverlay,sphere,OlStyle,OlLineString,lineIntersect,helpers,OlModify,OlTranslate,OlDraw,OlPolygon,OlLinearRing,OlDragBoxInteraction,OlVectorSource,OlVectorLayer,fileSaver,jsPDF,_html2canvas,JSZip,OlFeature,olgeom,olproj,olstyle,olcondition,olinteraction,olextent,olobservable,forms,OlGeoJSON,material,common,common$1,rxjs,olformat,i0,i1,operators,utils,i1$1) { 'use strict';

    olSourceOSM = olSourceOSM && olSourceOSM.hasOwnProperty('default') ? olSourceOSM['default'] : olSourceOSM;
    olSourceXYZ = olSourceXYZ && olSourceXYZ.hasOwnProperty('default') ? olSourceXYZ['default'] : olSourceXYZ;
    olFormatWFS = olFormatWFS && olFormatWFS.hasOwnProperty('default') ? olFormatWFS['default'] : olFormatWFS;
    olSourceImageWMS = olSourceImageWMS && olSourceImageWMS.hasOwnProperty('default') ? olSourceImageWMS['default'] : olSourceImageWMS;
    olSourceWMTS = olSourceWMTS && olSourceWMTS.hasOwnProperty('default') ? olSourceWMTS['default'] : olSourceWMTS;
    olTileGridWMTS = olTileGridWMTS && olTileGridWMTS.hasOwnProperty('default') ? olTileGridWMTS['default'] : olTileGridWMTS;
    olSourceCarto = olSourceCarto && olSourceCarto.hasOwnProperty('default') ? olSourceCarto['default'] : olSourceCarto;
    olSourceTileArcGISRest = olSourceTileArcGISRest && olSourceTileArcGISRest.hasOwnProperty('default') ? olSourceTileArcGISRest['default'] : olSourceTileArcGISRest;
    olSourceVectorTile = olSourceVectorTile && olSourceVectorTile.hasOwnProperty('default') ? olSourceVectorTile['default'] : olSourceVectorTile;
    olFormatMVT = olFormatMVT && olFormatMVT.hasOwnProperty('default') ? olFormatMVT['default'] : olFormatMVT;
    olSourceCluster = olSourceCluster && olSourceCluster.hasOwnProperty('default') ? olSourceCluster['default'] : olSourceCluster;
    olMap = olMap && olMap.hasOwnProperty('default') ? olMap['default'] : olMap;
    olView = olView && olView.hasOwnProperty('default') ? olView['default'] : olView;
    olGeolocation = olGeolocation && olGeolocation.hasOwnProperty('default') ? olGeolocation['default'] : olGeolocation;
    olAttribution = olAttribution && olAttribution.hasOwnProperty('default') ? olAttribution['default'] : olAttribution;
    olControlScaleLine = olControlScaleLine && olControlScaleLine.hasOwnProperty('default') ? olControlScaleLine['default'] : olControlScaleLine;
    olLayerImage = olLayerImage && olLayerImage.hasOwnProperty('default') ? olLayerImage['default'] : olLayerImage;
    olLayerTile = olLayerTile && olLayerTile.hasOwnProperty('default') ? olLayerTile['default'] : olLayerTile;
    olLayerVectorTile = olLayerVectorTile && olLayerVectorTile.hasOwnProperty('default') ? olLayerVectorTile['default'] : olLayerVectorTile;
    proj4 = proj4 && proj4.hasOwnProperty('default') ? proj4['default'] : proj4;
    olFormatGML2 = olFormatGML2 && olFormatGML2.hasOwnProperty('default') ? olFormatGML2['default'] : olFormatGML2;
    olFormatGML3 = olFormatGML3 && olFormatGML3.hasOwnProperty('default') ? olFormatGML3['default'] : olFormatGML3;
    olFormatEsriJSON = olFormatEsriJSON && olFormatEsriJSON.hasOwnProperty('default') ? olFormatEsriJSON['default'] : olFormatEsriJSON;
    olProjection = olProjection && olProjection.hasOwnProperty('default') ? olProjection['default'] : olProjection;
    olWKT = olWKT && olWKT.hasOwnProperty('default') ? olWKT['default'] : olWKT;
    OlPoint = OlPoint && OlPoint.hasOwnProperty('default') ? OlPoint['default'] : OlPoint;
    OlOverlay = OlOverlay && OlOverlay.hasOwnProperty('default') ? OlOverlay['default'] : OlOverlay;
    OlStyle = OlStyle && OlStyle.hasOwnProperty('default') ? OlStyle['default'] : OlStyle;
    OlLineString = OlLineString && OlLineString.hasOwnProperty('default') ? OlLineString['default'] : OlLineString;
    lineIntersect = lineIntersect && lineIntersect.hasOwnProperty('default') ? lineIntersect['default'] : lineIntersect;
    OlModify = OlModify && OlModify.hasOwnProperty('default') ? OlModify['default'] : OlModify;
    OlTranslate = OlTranslate && OlTranslate.hasOwnProperty('default') ? OlTranslate['default'] : OlTranslate;
    OlDraw = OlDraw && OlDraw.hasOwnProperty('default') ? OlDraw['default'] : OlDraw;
    OlPolygon = OlPolygon && OlPolygon.hasOwnProperty('default') ? OlPolygon['default'] : OlPolygon;
    OlLinearRing = OlLinearRing && OlLinearRing.hasOwnProperty('default') ? OlLinearRing['default'] : OlLinearRing;
    OlDragBoxInteraction = OlDragBoxInteraction && OlDragBoxInteraction.hasOwnProperty('default') ? OlDragBoxInteraction['default'] : OlDragBoxInteraction;
    OlVectorSource = OlVectorSource && OlVectorSource.hasOwnProperty('default') ? OlVectorSource['default'] : OlVectorSource;
    OlVectorLayer = OlVectorLayer && OlVectorLayer.hasOwnProperty('default') ? OlVectorLayer['default'] : OlVectorLayer;
    OlFeature = OlFeature && OlFeature.hasOwnProperty('default') ? OlFeature['default'] : OlFeature;
    OlGeoJSON = OlGeoJSON && OlGeoJSON.hasOwnProperty('default') ? OlGeoJSON['default'] : OlGeoJSON;

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MetadataService = /** @class */ (function () {
        function MetadataService() {
        }
        /**
         * @param {?} metadata
         * @return {?}
         */
        MetadataService.prototype.open = /**
         * @param {?} metadata
         * @return {?}
         */
            function (metadata) {
                if (metadata.extern) {
                    window.open(metadata.url, '_blank');
                }
            };
        MetadataService.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        MetadataService.ctorParameters = function () { return []; };
        /** @nocollapse */ MetadataService.ngInjectableDef = i0.defineInjectable({ factory: function MetadataService_Factory() { return new MetadataService(); }, token: MetadataService, providedIn: "root" });
        return MetadataService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MetadataButtonComponent = /** @class */ (function () {
        function MetadataButtonComponent(metadataService) {
            this.metadataService = metadataService;
            this._color = 'primary';
        }
        Object.defineProperty(MetadataButtonComponent.prototype, "layer", {
            get: /**
             * @return {?}
             */ function () {
                return this._layer;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._layer = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MetadataButtonComponent.prototype, "color", {
            get: /**
             * @return {?}
             */ function () {
                return this._color;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._color = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} metadata
         * @return {?}
         */
        MetadataButtonComponent.prototype.openMetadata = /**
         * @param {?} metadata
         * @return {?}
         */
            function (metadata) {
                this.metadataService.open(metadata);
            };
        Object.defineProperty(MetadataButtonComponent.prototype, "options", {
            get: /**
             * @return {?}
             */ function () {
                if (!this.layer) {
                    return;
                }
                return this.layer.options;
            },
            enumerable: true,
            configurable: true
        });
        MetadataButtonComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'igo-metadata-button',
                        template: "<button\r\n  *ngIf=\"options && options.metadata && options.metadata.url\"\r\n  mat-icon-button\r\n  tooltip-position=\"below\"\r\n  matTooltipShowDelay=\"500\"\r\n  [matTooltip]=\"'igo.geo.metadata.show' | translate\"\r\n  [color]=\"color\"\r\n  (click)=\"openMetadata(options.metadata)\">\r\n  <mat-icon svgIcon=\"information-outline\"></mat-icon>\r\n</button>\r\n",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        styles: [""]
                    }] }
        ];
        /** @nocollapse */
        MetadataButtonComponent.ctorParameters = function () {
            return [
                { type: MetadataService }
            ];
        };
        MetadataButtonComponent.propDecorators = {
            layer: [{ type: i0.Input }],
            color: [{ type: i0.Input }]
        };
        return MetadataButtonComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var IgoMetadataModule = /** @class */ (function () {
        function IgoMetadataModule() {
        }
        /**
         * @return {?}
         */
        IgoMetadataModule.forRoot = /**
         * @return {?}
         */
            function () {
                return {
                    ngModule: IgoMetadataModule,
                    providers: []
                };
            };
        IgoMetadataModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            material.MatIconModule,
                            material.MatButtonModule,
                            material.MatTooltipModule,
                            i1$1.IgoLanguageModule
                        ],
                        exports: [MetadataButtonComponent],
                        declarations: [MetadataButtonComponent]
                    },] }
        ];
        return IgoMetadataModule;
    }());

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (b.hasOwnProperty(p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m)
            return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length)
                    o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @abstract
     */
    var /**
     * @abstract
     */ DataService = /** @class */ (function () {
        function DataService() {
        }
        return DataService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Generate a id from it's datasource options.
     * @param {?} options Data source options
     * @return {?} A id
     */
    function generateIdFromSourceOptions(options) {
        /** @type {?} */
        var generators = {
            wms: generateWMSIdFromSourceOptions,
            wmts: generateWMTSIdFromSourceOptions,
            xyz: generateXYZIdFromSourceOptions,
            feature: generateFeatureIdFromSourceOptions,
            osm: ( /**
             * @param {?} _options
             * @return {?}
             */function (_options) { return 'OSM'; })
        };
        /** @type {?} */
        var generator = generators[options.type] || generateId;
        return generator(options);
    }
    /**
     * Generate a id from WMS data source options
     * @param {?} options WMS data source options
     * @return {?} A md5 hash of the the url and layers
     */
    function generateWMSIdFromSourceOptions(options) {
        /** @type {?} */
        var layers = options.params.layers;
        /** @type {?} */
        var chain = 'wms' + options.url + layers;
        return ( /** @type {?} */(tsMd5.Md5.hashStr(chain)));
    }
    /**
     * Generate a id from WMTS data source options
     * @param {?} options WMTS data source options
     * @return {?} A md5 hash of the the url and layer
     */
    function generateWMTSIdFromSourceOptions(options) {
        /** @type {?} */
        var layer = options.layer;
        /** @type {?} */
        var chain = 'wmts' + options.url + layer;
        return ( /** @type {?} */(tsMd5.Md5.hashStr(chain)));
    }
    /**
     * Generate a id from XYZ data source options
     * @param {?} options XYZ data source options
     * @return {?} A md5 hash of the the url and layer
     */
    function generateXYZIdFromSourceOptions(options) {
        /** @type {?} */
        var chain = 'xyz' + options.url;
        return ( /** @type {?} */(tsMd5.Md5.hashStr(chain)));
    }
    /**
     * Generate a id from feature data source options
     * @param {?} options XYZ data source options
     * @return {?} A md5 hash of the the url and layer
     */
    function generateFeatureIdFromSourceOptions(options) {
        if (!options.url) {
            return generateId(options);
        }
        /** @type {?} */
        var chain = 'feature' + options.url;
        return ( /** @type {?} */(tsMd5.Md5.hashStr(chain)));
    }
    /**
     * Generate a unique id
     * @param {?} options
     * @return {?} A uuid
     */
    function generateId(options) {
        return utils.uuid();
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @abstract
     */
    var /**
     * @abstract
     */ DataSource = /** @class */ (function () {
        function DataSource(options, dataService) {
            if (options === void 0) {
                options = {};
            }
            this.options = options;
            this.dataService = dataService;
            this.options = options;
            this.id = this.generateId();
            this.ol = this.createOlSource();
        }
        /**
         * @protected
         * @return {?}
         */
        DataSource.prototype.generateId = /**
         * @protected
         * @return {?}
         */
            function () {
                return generateIdFromSourceOptions(this.options);
            };
        /**
         * @param {?=} scale
         * @return {?}
         */
        DataSource.prototype.getLegend = /**
         * @param {?=} scale
         * @return {?}
         */
            function (scale) {
                return this.options.legend ? [this.options.legend] : [];
            };
        return DataSource;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var FeatureDataSource = /** @class */ (function (_super) {
        __extends(FeatureDataSource, _super);
        function FeatureDataSource() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @protected
         * @return {?}
         */
        FeatureDataSource.prototype.createOlSource = /**
         * @protected
         * @return {?}
         */
            function () {
                /** @type {?} */
                var sourceOptions = {
                    format: this.getSourceFormatFromOptions(this.options)
                };
                return new OlVectorSource(Object.assign(sourceOptions, this.options));
            };
        /**
         * @protected
         * @param {?} options
         * @return {?}
         */
        FeatureDataSource.prototype.getSourceFormatFromOptions = /**
         * @protected
         * @param {?} options
         * @return {?}
         */
            function (options) {
                if (options.format) {
                    return options.format;
                }
                /** @type {?} */
                var olFormatCls;
                /** @type {?} */
                var formatType = options.formatType;
                if (!formatType) {
                    olFormatCls = olformat.GeoJSON;
                }
                else {
                    olFormatCls = olformat[formatType];
                    if (olFormatCls === undefined) {
                        throw new Error('Invalid vector source format ${formatType}.');
                    }
                }
                /** @type {?} */
                var formatOptions = options.formatOptions;
                /** @type {?} */
                var format;
                if (formatOptions) {
                    format = new olFormatCls(formatOptions);
                }
                else {
                    format = new olFormatCls();
                }
                return format;
            };
        /**
         * @return {?}
         */
        FeatureDataSource.prototype.onUnwatch = /**
         * @return {?}
         */
            function () { };
        return FeatureDataSource;
    }(DataSource));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var OSMDataSource = /** @class */ (function (_super) {
        __extends(OSMDataSource, _super);
        function OSMDataSource() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @protected
         * @return {?}
         */
        OSMDataSource.prototype.createOlSource = /**
         * @protected
         * @return {?}
         */
            function () {
                this.options.url = 'https://tile.openstreetmap.org/{z}/{x}/{y}.png';
                return new olSourceOSM(this.options);
            };
        /**
         * @return {?}
         */
        OSMDataSource.prototype.onUnwatch = /**
         * @return {?}
         */
            function () { };
        return OSMDataSource;
    }(DataSource));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var XYZDataSource = /** @class */ (function (_super) {
        __extends(XYZDataSource, _super);
        function XYZDataSource() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @protected
         * @return {?}
         */
        XYZDataSource.prototype.createOlSource = /**
         * @protected
         * @return {?}
         */
            function () {
                return new olSourceXYZ(this.options);
            };
        /**
         * @return {?}
         */
        XYZDataSource.prototype.onUnwatch = /**
         * @return {?}
         */
            function () { };
        return XYZDataSource;
    }(DataSource));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var OgcFilterWriter = /** @class */ (function () {
        function OgcFilterWriter() {
            this.filterSequence = [];
            this.operators = {
                PropertyIsEqualTo: { spatial: false, fieldRestrict: [] },
                PropertyIsNotEqualTo: { spatial: false, fieldRestrict: [] },
                PropertyIsLike: { spatial: false, fieldRestrict: ['string'] },
                PropertyIsGreaterThan: { spatial: false, fieldRestrict: ['number'] },
                PropertyIsGreaterThanOrEqualTo: { spatial: false, fieldRestrict: ['number'] },
                PropertyIsLessThan: { spatial: false, fieldRestrict: ['number'] },
                PropertyIsLessThanOrEqualTo: { spatial: false, fieldRestrict: ['number'] },
                PropertyIsBetween: { spatial: false, fieldRestrict: ['number'] },
                During: { spatial: false, fieldRestrict: [] },
                PropertyIsNull: { spatial: false, fieldRestrict: [] },
                Intersects: { spatial: true, fieldRestrict: [] },
                Within: { spatial: true, fieldRestrict: [] },
                Contains: { spatial: true, fieldRestrict: [] }
            };
        }
        /**
         * @param {?} ogcFiltersOptions
         * @param {?} fieldNameGeometry
         * @param {?=} srcType
         * @return {?}
         */
        OgcFilterWriter.prototype.defineOgcFiltersDefaultOptions = /**
         * @param {?} ogcFiltersOptions
         * @param {?} fieldNameGeometry
         * @param {?=} srcType
         * @return {?}
         */
            function (ogcFiltersOptions, fieldNameGeometry, srcType) {
                /** @type {?} */
                var ogcFiltersDefaultValue = true;
                if (srcType && srcType === 'wms') {
                    ogcFiltersDefaultValue = false;
                }
                ogcFiltersOptions = ogcFiltersOptions || {};
                ogcFiltersOptions.enabled = ogcFiltersOptions.enabled === undefined ? ogcFiltersDefaultValue : ogcFiltersOptions.enabled;
                ogcFiltersOptions.editable = ogcFiltersOptions.editable === undefined ? ogcFiltersDefaultValue : ogcFiltersOptions.editable;
                ogcFiltersOptions.geometryName = fieldNameGeometry;
                ogcFiltersOptions.advancedOgcFilters = true;
                if (ogcFiltersOptions.enabled && ogcFiltersOptions.pushButtons) {
                    ogcFiltersOptions.advancedOgcFilters = false;
                }
                return ogcFiltersOptions;
            };
        /**
         * @param {?=} filters
         * @param {?=} extent
         * @param {?=} proj
         * @param {?=} fieldNameGeometry
         * @return {?}
         */
        OgcFilterWriter.prototype.buildFilter = /**
         * @param {?=} filters
         * @param {?=} extent
         * @param {?=} proj
         * @param {?=} fieldNameGeometry
         * @return {?}
         */
            function (filters, extent, proj, fieldNameGeometry) {
                /** @type {?} */
                var ourBboxFilter;
                /** @type {?} */
                var enableBbox;
                if (/intersects|contains|within/gi.test(JSON.stringify(filters))) {
                    enableBbox = false;
                }
                else {
                    enableBbox = true;
                }
                if (filters) {
                    fieldNameGeometry =
                        (( /** @type {?} */(filters))).geometryName !== undefined
                            ? (( /** @type {?} */(filters))).geometryName
                            : fieldNameGeometry;
                }
                if (extent && filters) {
                    ourBboxFilter = olfilter.bbox(fieldNameGeometry, extent, proj.getCode());
                }
                /** @type {?} */
                var filterAssembly;
                if (filters) {
                    filters = this.checkIgoFiltersProperties(filters, fieldNameGeometry);
                    if (extent && enableBbox) {
                        filterAssembly = olfilter.and(ourBboxFilter, this.bundleFilter(filters));
                    }
                    else {
                        filterAssembly = this.bundleFilter(filters);
                    }
                }
                else {
                    return 'bbox=' + extent.join(',') + ',' + proj.getCode();
                }
                /** @type {?} */
                var wfsOptions = {
                    srsName: '',
                    featureNS: '',
                    featurePrefix: '',
                    featureTypes: ['featureTypes'],
                    filter: filterAssembly,
                    outputFormat: '',
                    geometryName: fieldNameGeometry
                };
                /** @type {?} */
                var query = new olFormatWFS().writeGetFeature(wfsOptions);
                /** @type {?} */
                var str = new XMLSerializer().serializeToString(query);
                /** @type {?} */
                var regexp1 = /typenames *=|typename *=\"featureTypes\" *>/gi;
                /** @type {?} */
                var regexp2 = /<\/Query><\/GetFeature>/gi;
                return 'filter=' + str.split(regexp1)[1].split(regexp2)[0];
            };
        /**
         * @private
         * @param {?} filterObject
         * @return {?}
         */
        OgcFilterWriter.prototype.bundleFilter = /**
         * @private
         * @param {?} filterObject
         * @return {?}
         */
            function (filterObject) {
                var _this = this;
                if (filterObject instanceof Array) {
                    /** @type {?} */
                    var logicalArray_1 = [];
                    filterObject.forEach(( /**
                     * @param {?} element
                     * @return {?}
                     */function (element) {
                        logicalArray_1.push(_this.bundleFilter(element));
                    }));
                    return logicalArray_1;
                }
                else {
                    if (filterObject.hasOwnProperty('logical')) {
                        return this.createFilter({
                            operator: filterObject.logical,
                            logicalArray: this.bundleFilter(filterObject.filters)
                        });
                    }
                    else if (filterObject.hasOwnProperty('operator')) {
                        return this.createFilter(( /** @type {?} */(filterObject)));
                    }
                }
            };
        /**
         * @private
         * @param {?} filterOptions
         * @return {?}
         */
        OgcFilterWriter.prototype.createFilter = /**
         * @private
         * @param {?} filterOptions
         * @return {?}
         */
            function (filterOptions) {
                /** @type {?} */
                var operator = filterOptions.operator;
                /** @type {?} */
                var logicalArray = filterOptions.logicalArray;
                /** @type {?} */
                var wfsPropertyName = filterOptions.propertyName;
                /** @type {?} */
                var wfsPattern = filterOptions.pattern;
                /** @type {?} */
                var wfsMatchCase = filterOptions.matchCase
                    ? filterOptions.matchCase
                    : true;
                /** @type {?} */
                var wfsWildCard = filterOptions.wildCard ? filterOptions.wildCard : '*';
                /** @type {?} */
                var wfsSingleChar = filterOptions.singleChar
                    ? filterOptions.singleChar
                    : '.';
                /** @type {?} */
                var wfsEscapeChar = filterOptions.escapeChar
                    ? filterOptions.escapeChar
                    : '!';
                /** @type {?} */
                var wfsLowerBoundary = filterOptions.lowerBoundary;
                /** @type {?} */
                var wfsUpperBoundary = filterOptions.upperBoundary;
                /** @type {?} */
                var wfsGeometryName = filterOptions.geometryName;
                /** @type {?} */
                var wfsExtent = filterOptions.extent;
                /** @type {?} */
                var wfsWktGeometry = filterOptions.wkt_geometry;
                /** @type {?} */
                var wfsSrsName = filterOptions.srsName
                    ? filterOptions.srsName
                    : 'EPSG:3857';
                /** @type {?} */
                var wfsBegin = filterOptions.begin;
                /** @type {?} */
                var wfsEnd = filterOptions.end;
                /** @type {?} */
                var wfsExpression = filterOptions.expression;
                /** @type {?} */
                var geometry;
                if (wfsWktGeometry) {
                    /** @type {?} */
                    var wkt = new olWKT();
                    geometry = wkt.readGeometry(wfsWktGeometry, {
                        dataProjection: wfsSrsName,
                        featureProjection: 'EPSG:3857'
                    });
                }
                switch (operator) {
                    case 'BBOX':
                        return olfilter.bbox(wfsGeometryName, wfsExtent, wfsSrsName);
                    case 'PropertyIsBetween':
                        return olfilter.between(wfsPropertyName, wfsLowerBoundary, wfsUpperBoundary);
                    case 'Contains':
                        return olfilter.contains(wfsGeometryName, geometry, wfsSrsName);
                    case 'During':
                        return olfilter.during(wfsPropertyName, wfsBegin, wfsEnd);
                    case 'PropertyIsEqualTo':
                        return olfilter.equalTo(wfsPropertyName, wfsExpression, wfsMatchCase);
                    case 'PropertyIsGreaterThan':
                        return olfilter.greaterThan(wfsPropertyName, wfsExpression);
                    case 'PropertyIsGreaterThanOrEqualTo':
                        return olfilter.greaterThanOrEqualTo(wfsPropertyName, wfsExpression);
                    case 'Intersects':
                        return olfilter.intersects(wfsGeometryName, geometry, wfsSrsName);
                    case 'PropertyIsNull':
                        return olfilter.isNull(wfsPropertyName);
                    case 'PropertyIsLessThan':
                        return olfilter.lessThan(wfsPropertyName, wfsExpression);
                    case 'PropertyIsLessThanOrEqualTo':
                        return olfilter.lessThanOrEqualTo(wfsPropertyName, wfsExpression);
                    case 'PropertyIsLike':
                        return olfilter.like(wfsPropertyName, wfsPattern.replace(/[()_]/gi, wfsSingleChar), wfsWildCard, wfsSingleChar, wfsEscapeChar, wfsMatchCase);
                    case 'PropertyIsNotEqualTo':
                        return olfilter.notEqualTo(wfsPropertyName, wfsExpression, wfsMatchCase);
                    case 'Within':
                        return olfilter.within(wfsGeometryName, geometry, wfsSrsName);
                    // LOGICAL
                    case 'And':
                        return olfilter.and.apply(null, logicalArray);
                    case 'Or':
                        return olfilter.or.apply(null, logicalArray);
                    case 'Not':
                        return olfilter.not.apply(null, logicalArray);
                    default:
                        return undefined;
                }
            };
        /**
         * @param {?} filterObject
         * @param {?} geometryName
         * @param {?=} logical
         * @param {?=} level
         * @return {?}
         */
        OgcFilterWriter.prototype.defineInterfaceFilterSequence = /**
         * @param {?} filterObject
         * @param {?} geometryName
         * @param {?=} logical
         * @param {?=} level
         * @return {?}
         */
            function (filterObject, geometryName, logical, level) {
                var _this = this;
                if (logical === void 0) {
                    logical = '';
                }
                if (level === void 0) {
                    level = -1;
                }
                if (filterObject instanceof Array) {
                    filterObject.forEach(( /**
                     * @param {?} element
                     * @return {?}
                     */function (element) {
                        _this.filterSequence.concat(_this.defineInterfaceFilterSequence(element, geometryName, logical, level));
                    }));
                }
                else {
                    if (filterObject.hasOwnProperty('logical')) {
                        level = level + 1;
                        this.filterSequence.concat(this.defineInterfaceFilterSequence(filterObject.filters, geometryName, filterObject.logical, level));
                    }
                    else if (filterObject.hasOwnProperty('operator')) {
                        this.filterSequence.push(this.addInterfaceFilter(filterObject, geometryName, level, logical));
                    }
                }
                return this.filterSequence;
            };
        /**
         * @param {?=} igoOgcFilterObject
         * @param {?=} geometryName
         * @param {?=} level
         * @param {?=} parentLogical
         * @return {?}
         */
        OgcFilterWriter.prototype.addInterfaceFilter = /**
         * @param {?=} igoOgcFilterObject
         * @param {?=} geometryName
         * @param {?=} level
         * @param {?=} parentLogical
         * @return {?}
         */
            function (igoOgcFilterObject, geometryName, level, parentLogical) {
                if (level === void 0) {
                    level = 0;
                }
                if (parentLogical === void 0) {
                    parentLogical = 'Or';
                }
                if (!igoOgcFilterObject) {
                    igoOgcFilterObject = { operator: 'PropertyIsEqualTo' };
                }
                /** @type {?} */
                var f = {
                    propertyName: '',
                    operator: '',
                    active: '',
                    filterid: utils.uuid(),
                    begin: '',
                    end: '',
                    lowerBoundary: '',
                    upperBoundary: '',
                    expression: '',
                    pattern: '',
                    wildCard: '*',
                    singleChar: '.',
                    escapeChar: '!',
                    matchCase: true,
                    igoSpatialSelector: '',
                    geometryName: '',
                    geometry: '',
                    wkt_geometry: '',
                    extent: '',
                    srsName: '',
                    parentLogical: '',
                    level: 0
                };
                return Object.assign(f, {
                    parentLogical: parentLogical,
                    level: level,
                    geometryName: geometryName
                }, igoOgcFilterObject);
            };
        /**
         * @param {?} filterObject
         * @param {?} fieldNameGeometry
         * @param {?=} active
         * @return {?}
         */
        OgcFilterWriter.prototype.checkIgoFiltersProperties = /**
         * @param {?} filterObject
         * @param {?} fieldNameGeometry
         * @param {?=} active
         * @return {?}
         */
            function (filterObject, fieldNameGeometry, active) {
                var _this = this;
                if (active === void 0) {
                    active = false;
                }
                /** @type {?} */
                var filterArray = [];
                if (filterObject instanceof Array) {
                    filterObject.forEach(( /**
                     * @param {?} element
                     * @return {?}
                     */function (element) {
                        filterArray.push(_this.checkIgoFiltersProperties(element, fieldNameGeometry, active));
                    }));
                    return filterArray;
                }
                else {
                    if (filterObject.hasOwnProperty('logical')) {
                        return Object.assign({}, {
                            logical: filterObject.logical,
                            filters: this.checkIgoFiltersProperties(filterObject.filters, fieldNameGeometry, active)
                        });
                    }
                    else if (filterObject.hasOwnProperty('operator')) {
                        return this.addFilterProperties(( /** @type {?} */(filterObject)), fieldNameGeometry, active);
                    }
                }
            };
        /**
         * @private
         * @param {?} igoOgcFilterObject
         * @param {?} fieldNameGeometry
         * @param {?=} active
         * @return {?}
         */
        OgcFilterWriter.prototype.addFilterProperties = /**
         * @private
         * @param {?} igoOgcFilterObject
         * @param {?} fieldNameGeometry
         * @param {?=} active
         * @return {?}
         */
            function (igoOgcFilterObject, fieldNameGeometry, active) {
                if (active === void 0) {
                    active = false;
                }
                /** @type {?} */
                var filterid = igoOgcFilterObject.hasOwnProperty('filterid')
                    ? igoOgcFilterObject.filterid
                    : utils.uuid();
                /** @type {?} */
                var status = igoOgcFilterObject.hasOwnProperty('active')
                    ? igoOgcFilterObject.active
                    : active;
                return Object.assign({}, {
                    filterid: filterid,
                    active: status,
                    igoSpatialSelector: 'fixedExtent'
                }, igoOgcFilterObject, { geometryName: fieldNameGeometry });
            };
        /**
         * @param {?} sequence
         * @return {?}
         */
        OgcFilterWriter.prototype.rebuiltIgoOgcFilterObjectFromSequence = /**
         * @param {?} sequence
         * @return {?}
         */
            function (sequence) {
                if (sequence instanceof Array) {
                    if (sequence.length >= 1) {
                        /** @type {?} */
                        var lastParentLogical_1 = sequence[0].parentLogical;
                        /** @type {?} */
                        var nextElement_1;
                        /** @type {?} */
                        var logicalArray_2 = [];
                        /** @type {?} */
                        var lastProcessedFilter_1;
                        sequence.forEach(( /**
                         * @param {?} uiFilter
                         * @return {?}
                         */function (uiFilter) {
                            /** @type {?} */
                            var element = Object.assign({}, uiFilter);
                            /** @type {?} */
                            var index = sequence.indexOf(uiFilter);
                            if (index >= 0 && index < sequence.length - 1) {
                                nextElement_1 = sequence[index + 1];
                            }
                            else {
                                nextElement_1 = element;
                            }
                            delete element.active;
                            delete element.filterid;
                            delete element.parentLogical;
                            logicalArray_2.push(element);
                            if (sequence.length === 1) {
                                lastProcessedFilter_1 = element;
                            }
                            else if (lastParentLogical_1 !== nextElement_1.parentLogical) {
                                if (logicalArray_2.length === 1) {
                                    console.log('You must set at ' +
                                        'least two operator in a logical (' +
                                        lastParentLogical_1 +
                                        ')');
                                }
                                else {
                                    lastProcessedFilter_1 = Object.assign({}, { logical: lastParentLogical_1, filters: logicalArray_2 });
                                    logicalArray_2 = [lastProcessedFilter_1];
                                    lastParentLogical_1 = nextElement_1.parentLogical;
                                }
                            }
                        }));
                        return lastProcessedFilter_1;
                    }
                    else {
                        return undefined;
                    }
                }
                else {
                    return undefined;
                }
            };
        /**
         * @param {?} options
         * @param {?} fieldNameGeometry
         * @return {?}
         */
        OgcFilterWriter.prototype.handleOgcFiltersAppliedValue = /**
         * @param {?} options
         * @param {?} fieldNameGeometry
         * @return {?}
         */
            function (options, fieldNameGeometry) {
                /** @type {?} */
                var ogcFilters = options.ogcFilters;
                if (!ogcFilters) {
                    return;
                }
                /** @type {?} */
                var filterQueryStringPushButton = '';
                /** @type {?} */
                var filterQueryStringAdvancedFilters = '';
                if (ogcFilters.enabled && ogcFilters.pushButtons) {
                    /** @type {?} */
                    var pushButtonBundle = ogcFilters.pushButtons;
                    /** @type {?} */
                    var conditions_1 = [];
                    pushButtonBundle.map(( /**
                     * @param {?} buttonBundle
                     * @return {?}
                     */function (buttonBundle) {
                        /** @type {?} */
                        var bundleCondition = [];
                        buttonBundle.ogcPushButtons
                            .filter(( /**
                     * @param {?} ogcpb
                     * @return {?}
                     */function (ogcpb) { return ogcpb.enabled === true; }))
                            .forEach(( /**
                     * @param {?} enabledPb
                     * @return {?}
                     */function (enabledPb) { return bundleCondition.push(enabledPb.filters); }));
                        if (bundleCondition.length === 1) {
                            conditions_1.push(bundleCondition[0]);
                        }
                        else if (bundleCondition.length > 1) {
                            conditions_1.push({ logical: buttonBundle.logical, filters: bundleCondition });
                        }
                    }));
                    if (conditions_1.length >= 1) {
                        filterQueryStringPushButton = this.buildFilter(conditions_1.length === 1 ? conditions_1[0] : { logical: 'And', filters: conditions_1 });
                    }
                }
                if (ogcFilters.enabled && ogcFilters.filters) {
                    ogcFilters.geometryName = ogcFilters.geometryName || fieldNameGeometry;
                    /** @type {?} */
                    var igoFilters = ogcFilters.filters;
                    filterQueryStringAdvancedFilters = this.buildFilter(igoFilters);
                }
                /** @type {?} */
                var filterQueryString = ogcFilters.advancedOgcFilters ? filterQueryStringAdvancedFilters : filterQueryStringPushButton;
                if (options.type === 'wms') {
                    filterQueryString = this.formatProcessedOgcFilter(filterQueryString, (( /** @type {?} */(options))).params.layers);
                }
                if (options.type === 'wfs') {
                    filterQueryString = this.formatProcessedOgcFilter(filterQueryString, (( /** @type {?} */(options))).params.featureTypes);
                }
                return filterQueryString;
            };
        /**
         * @param {?} processedFilter
         * @param {?} layersOrTypenames
         * @return {?}
         */
        OgcFilterWriter.prototype.formatProcessedOgcFilter = /**
         * @param {?} processedFilter
         * @param {?} layersOrTypenames
         * @return {?}
         */
            function (processedFilter, layersOrTypenames) {
                /** @type {?} */
                var appliedFilter = '';
                if (processedFilter.length === 0 && layersOrTypenames.indexOf(',') === -1) {
                    appliedFilter = processedFilter;
                }
                else {
                    layersOrTypenames.split(',').forEach(( /**
                     * @param {?} layerOrTypenames
                     * @return {?}
                     */function (layerOrTypenames) {
                        appliedFilter = appliedFilter + "(" + processedFilter.replace('filter=', '') + ")";
                    }));
                }
                /** @type {?} */
                var filterValue = appliedFilter.length > 0 ? appliedFilter.replace('filter=', '') : undefined;
                return filterValue;
            };
        return OgcFilterWriter;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var defaultEpsg = 'EPSG:3857';
    /** @type {?} */
    var defaultMaxFeatures = 5000;
    /** @type {?} */
    var defaultWfsVersion = '2.0.0';
    /** @type {?} */
    var defaultFieldNameGeometry = 'geometry';
    /** @type {?} */
    var gmlRegex = new RegExp(/.*?gml.*?/gi);
    /** @type {?} */
    var jsonRegex = new RegExp(/.*?json.*?/gi);
    /**
     * This method build/standardize WFS call query params based on the layer property.
     * @param {?} wfsDataSourceOptions  WFSDataSourceOptions The common wfs datasource options interface
     * @param {?=} count  Number: Used to control the number of feature. Used to bypass whe wfs datasource options interface (maxFeatures)
     * @param {?=} epsg  String: Used to control the EPSG code (es: 'EPSG3857'). Used to bypass whe wfs datasource options interface (srsName)
     * @param {?=} properties  String: Used to control the queried fields  (WFS service).
     * @return {?} An array array of {name: '', value: ''} of predefined query params.
     */
    function formatWFSQueryString(wfsDataSourceOptions, count, epsg, properties) {
        /** @type {?} */
        var versionWfs200 = '2.0.0';
        // not the same usage as defaultWfsVersion.
        /** @type {?} */
        var url = wfsDataSourceOptions.urlWfs;
        /** @type {?} */
        var paramsWFS = wfsDataSourceOptions.paramsWFS;
        /** @type {?} */
        var effectiveCount = count || defaultMaxFeatures;
        /** @type {?} */
        var epsgCode = epsg || defaultEpsg;
        /** @type {?} */
        var outputFormat = paramsWFS.outputFormat ? "outputFormat=" + paramsWFS.outputFormat : '';
        /** @type {?} */
        var version = paramsWFS.version ? "version=" + paramsWFS.version : "version=" + defaultWfsVersion;
        /** @type {?} */
        var paramTypename = paramsWFS.version === versionWfs200 ? 'typenames' : 'typename';
        /** @type {?} */
        var featureTypes = paramTypename + "=" + paramsWFS.featureTypes;
        /** @type {?} */
        var paramMaxFeatures = paramsWFS.version === versionWfs200 ? 'count' : 'maxFeatures';
        /** @type {?} */
        var cnt = count ? paramMaxFeatures + "=" + effectiveCount :
            paramsWFS.maxFeatures ? paramMaxFeatures + "=" + paramsWFS.maxFeatures : paramMaxFeatures + "=" + effectiveCount;
        /** @type {?} */
        var srs = epsg ? "srsname=" + epsgCode : paramsWFS.srsName ? 'srsname=' + paramsWFS.srsName : "srsname=" + epsgCode;
        /** @type {?} */
        var propertyName = '';
        /** @type {?} */
        var valueReference = '';
        if (properties) {
            propertyName = "propertyName=" + properties;
            valueReference = "valueReference=" + properties;
        }
        /** @type {?} */
        var sourceFields = wfsDataSourceOptions.sourceFields;
        if (!propertyName && sourceFields && sourceFields.length > 0) {
            /** @type {?} */
            var fieldsNames_1 = [];
            wfsDataSourceOptions.sourceFields.forEach(( /**
             * @param {?} sourcefield
             * @return {?}
             */function (sourcefield) {
                fieldsNames_1.push(sourcefield.name);
            }));
            propertyName = "propertyName=" + fieldsNames_1.join(',') + "," + paramsWFS.fieldNameGeometry;
        }
        /** @type {?} */
        var getCapabilities = url + "?service=wfs&request=GetCapabilities&" + version;
        /** @type {?} */
        var getFeature = url + "?service=wfs&request=GetFeature&" + version + "&" + featureTypes + "&";
        getFeature += outputFormat + "&" + srs + "&" + cnt + "&" + propertyName;
        /** @type {?} */
        var getpropertyvalue = url + "?service=wfs&request=GetPropertyValue&version=" + versionWfs200 + "&" + featureTypes + "&";
        getpropertyvalue += "&" + cnt + "&" + valueReference;
        return [
            { name: 'outputformat', value: outputFormat },
            { name: 'version', value: version },
            { name: 'typename', value: featureTypes },
            { name: 'count', value: cnt },
            { name: 'srsname', value: srs },
            { name: 'propertyname', value: propertyName },
            { name: 'valuereference', value: valueReference },
            { name: 'getcapabilities', value: getCapabilities.replace(/&&/g, '&') },
            { name: 'getfeature', value: getFeature.replace(/&&/g, '&') },
            { name: 'getpropertyvalue', value: getpropertyvalue.replace(/&&/g, '&') }
        ];
    }
    /**
     * Validate/Modify layer's wfs options based on :
     * 1- an Openlayers's issue with GML provided from WFS. Refer to
     * https://github.com/openlayers/openlayers/pull/6400
     * 2- Set default values for optionals parameters.
     * @param {?} wfsDataSourceOptions  WFSDataSourceOptions The common wfs datasource options interface
     * @param {?=} srcType
     * @return {?} An array array of {name: '', value: ''} of predefined query params.
     */
    function checkWfsParams(wfsDataSourceOptions, srcType) {
        if (srcType && srcType === 'wfs') {
            // reassignation of params to paramsWFS and url to urlWFS to have a common interface with wms-wfs datasources
            wfsDataSourceOptions.paramsWFS = wfsDataSourceOptions.params;
        }
        /** @type {?} */
        var paramsWFS = wfsDataSourceOptions.paramsWFS;
        wfsDataSourceOptions.urlWfs = wfsDataSourceOptions.urlWfs || wfsDataSourceOptions.url;
        paramsWFS.version = paramsWFS.version || defaultWfsVersion;
        paramsWFS.fieldNameGeometry = paramsWFS.fieldNameGeometry || defaultFieldNameGeometry;
        paramsWFS.maxFeatures = paramsWFS.maxFeatures || defaultMaxFeatures;
        /** @type {?} */
        var outputFormat;
        if (paramsWFS.outputFormat) {
            outputFormat = paramsWFS.outputFormat;
        }
        if (gmlRegex.test(outputFormat) || !outputFormat) {
            paramsWFS.version = '1.1.0';
        }
        return Object.assign({}, wfsDataSourceOptions);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var WFSDataSource = /** @class */ (function (_super) {
        __extends(WFSDataSource, _super);
        function WFSDataSource(options, wfsService) {
            var _this = _super.call(this, checkWfsParams(options, 'wfs')) || this;
            _this.options = options;
            _this.wfsService = wfsService;
            /** @type {?} */
            var ogcFilters = (( /** @type {?} */(_this.options))).ogcFilters;
            /** @type {?} */
            var fieldNameGeometry = _this.options.paramsWFS.fieldNameGeometry || defaultFieldNameGeometry;
            /** @type {?} */
            var ogcFilterWriter = new OgcFilterWriter();
            (( /** @type {?} */(_this.options))).ogcFilters =
                ogcFilterWriter.defineOgcFiltersDefaultOptions(ogcFilters, fieldNameGeometry);
            if ((( /** @type {?} */(_this.options))).ogcFilters.enabled) {
                _this.wfsService.getSourceFieldsFromWFS(_this.options);
            }
            return _this;
        }
        /**
         * @protected
         * @return {?}
         */
        WFSDataSource.prototype.createOlSource = /**
         * @protected
         * @return {?}
         */
            function () {
                var _this = this;
                return new OlVectorSource({
                    format: this.getFormatFromOptions(),
                    overlaps: false,
                    url: ( /**
                     * @param {?} extent
                     * @param {?} resolution
                     * @param {?} proj
                     * @return {?}
                     */function (extent, resolution, proj) {
                        return _this.buildUrl(extent, proj, (( /** @type {?} */(_this.options))).ogcFilters);
                    }),
                    strategy: OlLoadingStrategy.bbox
                });
            };
        /**
         * @private
         * @param {?} extent
         * @param {?} proj
         * @param {?} ogcFilters
         * @return {?}
         */
        WFSDataSource.prototype.buildUrl = /**
         * @private
         * @param {?} extent
         * @param {?} proj
         * @param {?} ogcFilters
         * @return {?}
         */
            function (extent, proj, ogcFilters) {
                /** @type {?} */
                var paramsWFS = this.options.paramsWFS;
                /** @type {?} */
                var queryStringValues = formatWFSQueryString(this.options, undefined, proj.getCode());
                /** @type {?} */
                var igoFilters;
                if (ogcFilters && ogcFilters.enabled) {
                    igoFilters = ogcFilters.filters;
                }
                /** @type {?} */
                var ogcFilterWriter = new OgcFilterWriter();
                /** @type {?} */
                var filterOrBox = ogcFilterWriter.buildFilter(igoFilters, extent, proj, ogcFilters.geometryName);
                /** @type {?} */
                var filterOrPush = ogcFilterWriter.handleOgcFiltersAppliedValue(this.options, ogcFilters.geometryName);
                /** @type {?} */
                var prefix = 'filter';
                if (!filterOrPush) {
                    prefix = 'bbox';
                    filterOrPush = extent.join(',') + ',' + proj.getCode();
                }
                paramsWFS.xmlFilter = ogcFilters.advancedOgcFilters ? filterOrBox : prefix + "=" + filterOrPush;
                /** @type {?} */
                var baseUrl = queryStringValues.find(( /**
                 * @param {?} f
                 * @return {?}
                 */function (f) { return f.name === 'getfeature'; })).value;
                /** @type {?} */
                var patternFilter = /(filter|bbox)=.*/gi;
                baseUrl = patternFilter.test(paramsWFS.xmlFilter) ? baseUrl + "&" + paramsWFS.xmlFilter : baseUrl;
                this.options.download = Object.assign({}, this.options.download, { dynamicUrl: baseUrl });
                return baseUrl.replace(/&&/g, '&');
            };
        /**
         * @private
         * @return {?}
         */
        WFSDataSource.prototype.getFormatFromOptions = /**
         * @private
         * @return {?}
         */
            function () {
                /** @type {?} */
                var olFormatCls;
                /** @type {?} */
                var outputFormat;
                if (this.options.paramsWFS.outputFormat) {
                    outputFormat = this.options.paramsWFS.outputFormat.toLowerCase();
                }
                if (jsonRegex.test(outputFormat)) {
                    olFormatCls = olformat.GeoJSON;
                }
                if (gmlRegex.test(outputFormat) || !outputFormat) {
                    olFormatCls = olformat.WFS;
                }
                return new olFormatCls();
            };
        /**
         * @return {?}
         */
        WFSDataSource.prototype.onUnwatch = /**
         * @return {?}
         */
            function () { };
        return WFSDataSource;
    }(DataSource));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var WFSService = /** @class */ (function (_super) {
        __extends(WFSService, _super);
        function WFSService(http) {
            var _this = _super.call(this) || this;
            _this.http = http;
            return _this;
        }
        /**
         * @return {?}
         */
        WFSService.prototype.getData = /**
         * @return {?}
         */
            function () {
                console.log('This is defining a data service.');
                return 'This is defining a data service.';
            };
        /**
         * @param {?} datasource
         * @return {?}
         */
        WFSService.prototype.getSourceFieldsFromWFS = /**
         * @param {?} datasource
         * @return {?}
         */
            function (datasource) {
                if (!datasource.sourceFields || datasource.sourceFields.length === 0) {
                    datasource.sourceFields = [];
                    this.defineFieldAndValuefromWFS(datasource).subscribe(( /**
                     * @param {?} getfeatureSourceField
                     * @return {?}
                     */function (getfeatureSourceField) {
                        datasource.sourceFields = getfeatureSourceField;
                    }));
                }
                else {
                    this.defineFieldAndValuefromWFS(datasource).subscribe(( /**
                     * @param {?} getfeatureSourceField
                     * @return {?}
                     */function (getfeatureSourceField) {
                        datasource.sourceFields.forEach(( /**
                         * @param {?} sourcefield
                         * @return {?}
                         */function (sourcefield) {
                            if (sourcefield.alias === undefined) {
                                sourcefield.alias = sourcefield.name; // to allow only a list of sourcefield with names
                            }
                            if (sourcefield.values === undefined || sourcefield.values.length === 0) {
                                sourcefield.values = getfeatureSourceField.find(( /**
                                 * @param {?} sf
                                 * @return {?}
                                 */function (sf) { return sf.name === sourcefield.name; })).values;
                            }
                        }));
                    }));
                }
            };
        /**
         * @private
         * @param {?} wfsDataSourceOptions
         * @param {?=} nb
         * @param {?=} epsgCode
         * @param {?=} propertyName
         * @return {?}
         */
        WFSService.prototype.wfsGetFeature = /**
         * @private
         * @param {?} wfsDataSourceOptions
         * @param {?=} nb
         * @param {?=} epsgCode
         * @param {?=} propertyName
         * @return {?}
         */
            function (wfsDataSourceOptions, nb, epsgCode, propertyName) {
                if (nb === void 0) {
                    nb = defaultMaxFeatures;
                }
                if (epsgCode === void 0) {
                    epsgCode = defaultEpsg;
                }
                /** @type {?} */
                var queryStringValues = formatWFSQueryString(wfsDataSourceOptions, nb, epsgCode, propertyName);
                /** @type {?} */
                var baseUrl = queryStringValues.find(( /**
                 * @param {?} f
                 * @return {?}
                 */function (f) { return f.name === 'getfeature'; })).value;
                /** @type {?} */
                var outputFormat = wfsDataSourceOptions.paramsWFS.outputFormat;
                if (gmlRegex.test(outputFormat) || !outputFormat) {
                    return this.http.get(baseUrl, { responseType: 'text' });
                }
                else {
                    return this.http.get(baseUrl);
                }
            };
        /**
         * @param {?} wfsDataSourceOptions
         * @return {?}
         */
        WFSService.prototype.defineFieldAndValuefromWFS = /**
         * @param {?} wfsDataSourceOptions
         * @return {?}
         */
            function (wfsDataSourceOptions) {
                var _this = this;
                return new rxjs.Observable(( /**
                 * @param {?} d
                 * @return {?}
                 */function (d) {
                    /** @type {?} */
                    var sourceFields = [];
                    /** @type {?} */
                    var fieldList;
                    /** @type {?} */
                    var fieldListWoGeom;
                    /** @type {?} */
                    var fieldListWoGeomStr;
                    /** @type {?} */
                    var olFormats;
                    /** @type {?} */
                    var outputFormat = wfsDataSourceOptions.paramsWFS.outputFormat;
                    if (gmlRegex.test(outputFormat) || !outputFormat) {
                        olFormats = olformat.WFS;
                    }
                    else {
                        olFormats = olformat.GeoJSON;
                    }
                    _this.wfsGetFeature(wfsDataSourceOptions, 1).subscribe(( /**
                     * @param {?} oneFeature
                     * @return {?}
                     */function (oneFeature) {
                        /** @type {?} */
                        var features = new olFormats().readFeatures(oneFeature);
                        fieldList = features[0].getKeys();
                        fieldListWoGeom = fieldList.filter(( /**
                         * @param {?} field
                         * @return {?}
                         */function (field) {
                            return field !== features[0].getGeometryName() &&
                                !field.match(/boundedby/gi);
                        }));
                        fieldListWoGeomStr = fieldListWoGeom.join(',');
                        _this.wfsGetFeature(wfsDataSourceOptions, wfsDataSourceOptions.paramsWFS.maxFeatures || defaultMaxFeatures, undefined, fieldListWoGeomStr).subscribe(( /**
                         * @param {?} manyFeatures
                         * @return {?}
                         */function (manyFeatures) {
                            /** @type {?} */
                            var mfeatures = new olFormats().readFeatures(manyFeatures);
                            _this.built_properties_value(mfeatures).forEach(( /**
                             * @param {?} element
                             * @return {?}
                             */function (element) {
                                sourceFields.push(element);
                            }));
                            d.next(sourceFields);
                            d.complete();
                        }));
                    }));
                }));
            };
        /**
         * @private
         * @param {?} features
         * @return {?}
         */
        WFSService.prototype.built_properties_value = /**
         * @private
         * @param {?} features
         * @return {?}
         */
            function (features) {
                /** @type {?} */
                var kv = Object.assign({}, features[0].getProperties());
                delete kv[features[0].getGeometryName()];
                delete kv.boundedBy;
                /** @type {?} */
                var sourceFields = [];
                for (var property in kv) {
                    if (kv.hasOwnProperty(property)) {
                        /** @type {?} */
                        var fieldType = typeof features[0].get(property) === 'object'
                            ? undefined
                            : typeof features[0].get(property);
                        sourceFields.push({
                            name: property,
                            alias: property,
                            type: fieldType,
                            values: [kv[property]]
                        });
                    }
                }
                features.every(( /**
                 * @param {?} element
                 * @return {?}
                 */function (element) {
                    /** @type {?} */
                    var featureProperties = element.getProperties();
                    var _loop_1 = function (key) {
                        if (featureProperties.hasOwnProperty(key) && key in kv) {
                            sourceFields.filter(( /**
                             * @param {?} f
                             * @return {?}
                             */function (f) { return f.name === key; })).forEach(( /**
                             * @param {?} v
                             * @return {?}
                             */function (v) {
                                if (v.values.indexOf(featureProperties[key]) === -1) {
                                    v.values.push(featureProperties[key]);
                                }
                            }));
                        }
                    };
                    for (var key in featureProperties) {
                        _loop_1(key);
                    }
                    return true;
                }));
                return sourceFields;
            };
        WFSService.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        WFSService.ctorParameters = function () {
            return [
                { type: i1.HttpClient }
            ];
        };
        /** @nocollapse */ WFSService.ngInjectableDef = i0.defineInjectable({ factory: function WFSService_Factory() { return new WFSService(i0.inject(i1.HttpClient)); }, token: WFSService, providedIn: "root" });
        return WFSService;
    }(DataService));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @enum {string} */
    var QueryFormat = {
        GML2: 'gml2',
        GML3: 'gml3',
        JSON: 'json',
        GEOJSON: 'geojson',
        ESRIJSON: 'esrijson',
        TEXT: 'text',
        HTML: 'html',
        HTMLGML2: 'htmlgml2',
    };
    /** @enum {string} */
    var QueryHtmlTarget = {
        IFRAME: 'iframe',
        BLANK: '_blank',
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var WMSDataSource = /** @class */ (function (_super) {
        __extends(WMSDataSource, _super);
        function WMSDataSource(options, wfsService) {
            var _this = _super.call(this, options) || this;
            _this.options = options;
            _this.wfsService = wfsService;
            // Important: To use wms versions smaller than 1.3.0, SRS
            // needs to be supplied in the source "params"
            // We need to do this to override the default version
            // of openlayers which is uppercase
            /** @type {?} */
            var sourceParams = options.params;
            if (sourceParams && sourceParams.version) {
                sourceParams.VERSION = sourceParams.version;
            }
            if (sourceParams && sourceParams.VERSION) {
                if (sourceParams.version !== '1.3.0') {
                    if (!sourceParams.SRS && !sourceParams.srs) {
                        throw new Error("You must set a SRS (or srs) param for your WMS\n           (layer =  " + sourceParams.layers + ") because your want to use a WMS version under 1.3.0\n        Ex: \"srs\": \"EPSG:3857\" ");
                    }
                }
            }
            if (sourceParams && sourceParams.INFO_FORMAT) {
                sourceParams.info_format = sourceParams.INFO_FORMAT;
            }
            if (options.refreshIntervalSec && options.refreshIntervalSec > 0) {
                setInterval(( /**
                 * @return {?}
                 */function () {
                    _this.refresh();
                }), options.refreshIntervalSec * 1000); // Convert seconds to MS
            }
            /** @type {?} */
            var fieldNameGeometry = defaultFieldNameGeometry;
            // ####   START if paramsWFS
            if (options.paramsWFS) {
                /** @type {?} */
                var wfsCheckup = checkWfsParams(options, 'wms');
                utils.ObjectUtils.mergeDeep(options.paramsWFS, wfsCheckup.paramsWFS);
                fieldNameGeometry = options.paramsWFS.fieldNameGeometry || fieldNameGeometry;
                options.download = Object.assign({}, options.download, {
                    dynamicUrl: _this.buildDynamicDownloadUrlFromParamsWFS(options)
                });
            } //  ####   END  if paramsWFS
            if (!options.sourceFields || options.sourceFields.length === 0) {
                options.sourceFields = [];
            }
            else {
                options.sourceFields.forEach(( /**
                 * @param {?} sourceField
                 * @return {?}
                 */function (sourceField) {
                    sourceField.alias = sourceField.alias ? sourceField.alias : sourceField.name;
                    // to allow only a list of sourcefield with names
                }));
            }
            /** @type {?} */
            var initOgcFilters = (( /** @type {?} */(options))).ogcFilters;
            /** @type {?} */
            var ogcFilterWriter = new OgcFilterWriter();
            if (!initOgcFilters) {
                (( /** @type {?} */(options))).ogcFilters =
                    ogcFilterWriter.defineOgcFiltersDefaultOptions(initOgcFilters, fieldNameGeometry, 'wms');
            }
            else {
                initOgcFilters.advancedOgcFilters = initOgcFilters.pushButtons ? false : true;
            }
            if (sourceParams.layers.split(',').length > 1 && options && initOgcFilters.enabled) {
                console.log('*******************************');
                console.log('BE CAREFULL, YOUR WMS LAYERS (' + sourceParams.layers
                    + ') MUST SHARE THE SAME FIELDS TO ALLOW ogcFilters TO WORK !! ');
                console.log('*******************************');
            }
            if (options.paramsWFS && initOgcFilters.enabled) {
                _this.wfsService.getSourceFieldsFromWFS(options);
            }
            /** @type {?} */
            var filterQueryString = ogcFilterWriter.handleOgcFiltersAppliedValue(options, fieldNameGeometry);
            _this.ol.updateParams({ filter: filterQueryString });
            return _this;
        }
        Object.defineProperty(WMSDataSource.prototype, "params", {
            get: /**
             * @return {?}
             */ function () {
                return ( /** @type {?} */(this.options.params));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WMSDataSource.prototype, "queryTitle", {
            get: /**
             * @return {?}
             */ function () {
                return (( /** @type {?} */(this.options))).queryTitle
                    ? (( /** @type {?} */(this.options))).queryTitle
                    : 'title';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WMSDataSource.prototype, "queryHtmlTarget", {
            get: /**
             * @return {?}
             */ function () {
                return (( /** @type {?} */(this.options))).queryHtmlTarget
                    ? (( /** @type {?} */(this.options))).queryHtmlTarget
                    : QueryHtmlTarget.BLANK;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        WMSDataSource.prototype.refresh = /**
         * @return {?}
         */
            function () {
                this.ol.updateParams({ igoRefresh: Math.random() });
            };
        /**
         * @private
         * @param {?} asWFSDataSourceOptions
         * @return {?}
         */
        WMSDataSource.prototype.buildDynamicDownloadUrlFromParamsWFS = /**
         * @private
         * @param {?} asWFSDataSourceOptions
         * @return {?}
         */
            function (asWFSDataSourceOptions) {
                /** @type {?} */
                var queryStringValues = formatWFSQueryString(asWFSDataSourceOptions);
                /** @type {?} */
                var downloadUrl = queryStringValues.find(( /**
                 * @param {?} f
                 * @return {?}
                 */function (f) { return f.name === 'getfeature'; })).value;
                return downloadUrl;
            };
        /**
         * @protected
         * @return {?}
         */
        WMSDataSource.prototype.createOlSource = /**
         * @protected
         * @return {?}
         */
            function () {
                return new olSourceImageWMS(this.options);
            };
        /**
         * @param {?=} scale
         * @return {?}
         */
        WMSDataSource.prototype.getLegend = /**
         * @param {?=} scale
         * @return {?}
         */
            function (scale) {
                /** @type {?} */
                var legend = _super.prototype.getLegend.call(this);
                if (legend.length > 0) {
                    return legend;
                }
                /** @type {?} */
                var sourceParams = this.params;
                /** @type {?} */
                var layers = [];
                if (sourceParams.layers !== undefined) {
                    layers = sourceParams.layers.split(',');
                }
                /** @type {?} */
                var baseUrl = this.options.url.replace(/\?$/, '');
                /** @type {?} */
                var params = [
                    'REQUEST=GetLegendGraphic',
                    'SERVICE=wms',
                    'FORMAT=image/png',
                    'SLD_VERSION=1.1.0',
                    "VERSION=" + (sourceParams.version || '1.3.0')
                ];
                if (scale !== undefined) {
                    params.push("SCALE=" + scale);
                }
                legend = layers.map(( /**
                 * @param {?} layer
                 * @return {?}
                 */function (layer) {
                    return {
                        url: baseUrl + "?" + params.join('&') + "&LAYER=" + layer,
                        title: layers.length > 1 ? layer : undefined
                    };
                }));
                return legend;
            };
        /**
         * @return {?}
         */
        WMSDataSource.prototype.onUnwatch = /**
         * @return {?}
         */
            function () { };
        return WMSDataSource;
    }(DataSource));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?=} epsg
     * @return {?}
     */
    function createDefaultTileGrid(epsg) {
        /** @type {?} */
        var projection = epsg ? olproj.get(epsg) : olproj.get('EPSG:3857');
        /** @type {?} */
        var projectionExtent = projection.getExtent();
        /** @type {?} */
        var size = extent_js.getWidth(projectionExtent) / 256;
        /** @type {?} */
        var resolutions = new Array(20);
        /** @type {?} */
        var matrixIds = new Array(20);
        for (var z = 0; z < 20; ++z) {
            resolutions[z] = size / Math.pow(2, z);
            matrixIds[z] = z;
        }
        return new olTileGridWMTS({
            origin: extent_js.getTopLeft(projectionExtent),
            resolutions: resolutions,
            matrixIds: matrixIds
        });
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var WMTSDataSource = /** @class */ (function (_super) {
        __extends(WMTSDataSource, _super);
        function WMTSDataSource(options) {
            return _super.call(this, options) || this;
        }
        /**
         * @protected
         * @return {?}
         */
        WMTSDataSource.prototype.createOlSource = /**
         * @protected
         * @return {?}
         */
            function () {
                /** @type {?} */
                var sourceOptions = Object.assign({
                    tileGrid: createDefaultTileGrid(( /** @type {?} */(this.options.projection)))
                }, this.options);
                return new olSourceWMTS(sourceOptions);
            };
        /**
         * @return {?}
         */
        WMTSDataSource.prototype.onUnwatch = /**
         * @return {?}
         */
            function () { };
        return WMTSDataSource;
    }(DataSource));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var CartoDataSource = /** @class */ (function (_super) {
        __extends(CartoDataSource, _super);
        function CartoDataSource() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(CartoDataSource.prototype, "params", {
            get: /**
             * @return {?}
             */ function () {
                return ( /** @type {?} */(this.options.params));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CartoDataSource.prototype, "queryTitle", {
            get: /**
             * @return {?}
             */ function () {
                return (( /** @type {?} */(this.options))).queryTitle
                    ? (( /** @type {?} */(this.options))).queryTitle
                    : 'title';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CartoDataSource.prototype, "queryHtmlTarget", {
            get: /**
             * @return {?}
             */ function () {
                return (( /** @type {?} */(this.options))).queryHtmlTarget
                    ? (( /** @type {?} */(this.options))).queryHtmlTarget
                    : QueryHtmlTarget.BLANK;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @protected
         * @return {?}
         */
        CartoDataSource.prototype.createOlSource = /**
         * @protected
         * @return {?}
         */
            function () {
                /** @type {?} */
                var crossOrigin = this.options.crossOrigin
                    ? this.options.crossOrigin
                    : 'anonymous';
                /** @type {?} */
                var sourceOptions = Object.assign({
                    crossOrigin: crossOrigin
                }, this.options);
                return new olSourceCarto(sourceOptions);
            };
        /**
         * @return {?}
         */
        CartoDataSource.prototype.getLegend = /**
         * @return {?}
         */
            function () {
                var e_1, _a;
                /** @type {?} */
                var legend = _super.prototype.getLegend.call(this);
                if (legend.length > 0) {
                    return legend;
                }
                /** @type {?} */
                var htmlString = '<table>';
                if (this.options.config.layers[0].legend != null) {
                    this.options.config.layers[0].legend.items.forEach(( /**
                     * @param {?} f
                     * @return {?}
                     */function (f) {
                        if (f.visible === true) {
                            htmlString +=
                                '<tr><td>' +
                                    '<p><font size="5" color="' +
                                    f.value +
                                    '"> &#9679</font></p></td>' +
                                    '<td>' +
                                    f.name +
                                    '</td></tr>';
                        }
                    }));
                    htmlString += '</table>';
                    return [{ html: htmlString }];
                }
                else {
                    // Try to build the legend from the cartocss options
                    /** @type {?} */
                    var layerOptions = this.options.config.layers[0].options;
                    // All available cartocss style options
                    /** @type {?} */
                    var types = [
                        'polygon-fill:',
                        'marker-fill:',
                        'shield-fill:',
                        'building-fill:',
                        'line-color:'
                    ];
                    try {
                        for (var types_1 = __values(types), types_1_1 = types_1.next(); !types_1_1.done; types_1_1 = types_1.next()) {
                            var oneType = types_1_1.value;
                            if (layerOptions.cartocss.includes(oneType)) {
                                /** @type {?} */
                                var type = layerOptions.cartocss.split(oneType).pop();
                                /** @type {?} */
                                var color$$1 = type.substr(0, type.indexOf(';'));
                                if (color$$1.includes('ramp')) {
                                    /** @type {?} */
                                    var colors = color$$1.split(', (')[1].split(',');
                                    /** @type {?} */
                                    var data = color$$1.split(', (')[2].split(',');
                                    for (var j = 0; j < colors.length; j++) {
                                        colors[j] = colors[j].replace(/("|\))/g, '');
                                        data[j] = data[j].replace(/("|\))/g, '');
                                        if (data[j].replace(/\s+/g, '') === '=') {
                                            data[j] = 'Autres';
                                        }
                                        htmlString +=
                                            '<tr><td>' +
                                                '<p><font size="5" color="' +
                                                colors[j] +
                                                '"> &#9679</font></p></td>' +
                                                '<td>' +
                                                data[j] +
                                                '</td></tr>';
                                    }
                                    break;
                                }
                                else {
                                    /** @type {?} */
                                    var title = layerOptions.layer_name
                                        ? layerOptions.layer_name
                                        : '';
                                    htmlString +=
                                        '<tr><td>' +
                                            '<p><font size="5" color="' +
                                            color$$1 +
                                            '"> &#9679</font></p>' +
                                            '</td><td>' +
                                            title +
                                            '</td></tr>';
                                    break;
                                }
                            }
                        }
                    }
                    catch (e_1_1) {
                        e_1 = { error: e_1_1 };
                    }
                    finally {
                        try {
                            if (types_1_1 && !types_1_1.done && (_a = types_1.return))
                                _a.call(types_1);
                        }
                        finally {
                            if (e_1)
                                throw e_1.error;
                        }
                    }
                    htmlString += '</table>';
                    return [{ html: htmlString }];
                }
            };
        /**
         * @return {?}
         */
        CartoDataSource.prototype.onUnwatch = /**
         * @return {?}
         */
            function () { };
        return CartoDataSource;
    }(DataSource));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var ArcGISRestDataSource = /** @class */ (function (_super) {
        __extends(ArcGISRestDataSource, _super);
        function ArcGISRestDataSource() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @protected
         * @return {?}
         */
        ArcGISRestDataSource.prototype.createOlSource = /**
         * @protected
         * @return {?}
         */
            function () {
                /** @type {?} */
                var esrijsonFormat = new olFormatEsriJSON();
                return new OlVectorSource({
                    attributions: this.options.params.attributions,
                    overlaps: false,
                    format: esrijsonFormat,
                    url: ( /**
                     * @param {?} extent
                     * @param {?} resolution
                     * @param {?} proj
                     * @return {?}
                     */function (extent, resolution, proj) {
                        /** @type {?} */
                        var baseUrl = this.options.url + '/' + this.options.layer + '/query/';
                        /** @type {?} */
                        var geometry = encodeURIComponent('{"xmin":' +
                            extent[0] +
                            ',"ymin":' +
                            extent[1] +
                            ',"xmax":' +
                            extent[2] +
                            ',"ymax":' +
                            extent[3] +
                            ',"spatialReference":{"wkid":102100}}');
                        /** @type {?} */
                        var params = [
                            'f=json',
                            "geometry=" + geometry,
                            'geometryType=esriGeometryEnvelope',
                            'inSR=102100',
                            'spatialRel=esriSpatialRelIntersects',
                            'outFields=*',
                            'returnGeometry=true',
                            'outSR=102100'
                        ];
                        if (this.options.params.timeFilter) {
                            /** @type {?} */
                            var time = "time=" + this.options.params.timeExtent;
                            params.push(time);
                        }
                        if (this.options.params.customParams) {
                            this.options.params.customParams.forEach(( /**
                             * @param {?} element
                             * @return {?}
                             */function (element) {
                                params.push(element);
                            }));
                        }
                        return baseUrl + "?" + params.join('&');
                    }).bind(this),
                    strategy: OlLoadingStrategy.bbox
                });
            };
        /**
         * @return {?}
         */
        ArcGISRestDataSource.prototype.getLegend = /**
         * @return {?}
         */
            function () {
                var e_1, _a;
                /** @type {?} */
                var legendInfo = this.options.params.legendInfo;
                /** @type {?} */
                var legend = _super.prototype.getLegend.call(this);
                if (legendInfo === undefined || legend.length > 0) {
                    return legend;
                }
                /** @type {?} */
                var id = parseInt(this.options.layer, 10);
                /** @type {?} */
                var lyr = legendInfo.layers[id];
                /** @type {?} */
                var htmlString = '<table><tr><td>' + lyr.layerName + '</td></tr>';
                try {
                    for (var _b = __values(lyr.legend), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var lyrLegend = _c.value;
                        /** @type {?} */
                        var modifiedUrl = this.options.url.replace('FeatureServer', 'MapServer');
                        /** @type {?} */
                        var src = modifiedUrl + "/" + lyr.layerId + "/images/" + lyrLegend.url;
                        /** @type {?} */
                        var label = lyrLegend.label.replace('<Null>', 'Null');
                        htmlString +=
                            "<tr><td align='left'><img src=\"" +
                                src +
                                "\" alt ='' /></td><td>" +
                                label +
                                '</td></tr>';
                    }
                }
                catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return))
                            _a.call(_b);
                    }
                    finally {
                        if (e_1)
                            throw e_1.error;
                    }
                }
                htmlString += '</table>';
                return [{ html: htmlString }];
            };
        /**
         * @return {?}
         */
        ArcGISRestDataSource.prototype.onUnwatch = /**
         * @return {?}
         */
            function () { };
        return ArcGISRestDataSource;
    }(DataSource));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TileArcGISRestDataSource = /** @class */ (function (_super) {
        __extends(TileArcGISRestDataSource, _super);
        function TileArcGISRestDataSource() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(TileArcGISRestDataSource.prototype, "params", {
            get: /**
             * @return {?}
             */ function () {
                return ( /** @type {?} */(this.options.params));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TileArcGISRestDataSource.prototype, "queryTitle", {
            get: /**
             * @return {?}
             */ function () {
                return (( /** @type {?} */(this.options))).queryTitle
                    ? (( /** @type {?} */(this.options))).queryTitle
                    : 'title';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TileArcGISRestDataSource.prototype, "queryHtmlTarget", {
            get: /**
             * @return {?}
             */ function () {
                return (( /** @type {?} */(this.options))).queryHtmlTarget
                    ? (( /** @type {?} */(this.options))).queryHtmlTarget
                    : QueryHtmlTarget.BLANK;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @protected
         * @return {?}
         */
        TileArcGISRestDataSource.prototype.createOlSource = /**
         * @protected
         * @return {?}
         */
            function () {
                return new olSourceTileArcGISRest(this.options);
            };
        /**
         * @return {?}
         */
        TileArcGISRestDataSource.prototype.getLegend = /**
         * @return {?}
         */
            function () {
                var e_1, _a;
                /** @type {?} */
                var legend = _super.prototype.getLegend.call(this);
                if (this.options.legendInfo === undefined || legend.length > 0) {
                    return legend;
                }
                /** @type {?} */
                var id = parseInt(this.options.layer, 10);
                /** @type {?} */
                var lyr = this.options.legendInfo.layers[id];
                /** @type {?} */
                var htmlString = '<table><tr><td>' + lyr.layerName + '</td></tr>';
                try {
                    for (var _b = __values(lyr.legend), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var lyrLegend = _c.value;
                        /** @type {?} */
                        var src = this.options.url + "/" + lyr.layerId + "/images/" + lyrLegend.url;
                        /** @type {?} */
                        var label = lyrLegend.label.replace('<Null>', 'Null');
                        htmlString +=
                            "<tr><td align='left'><img src=\"" +
                                src +
                                "\" alt ='' /></td><td>" +
                                label +
                                '</td></tr>';
                    }
                }
                catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return))
                            _a.call(_b);
                    }
                    finally {
                        if (e_1)
                            throw e_1.error;
                    }
                }
                htmlString += '</table>';
                return [{ html: htmlString }];
            };
        /**
         * @return {?}
         */
        TileArcGISRestDataSource.prototype.onUnwatch = /**
         * @return {?}
         */
            function () { };
        return TileArcGISRestDataSource;
    }(DataSource));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var WebSocketDataSource = /** @class */ (function (_super) {
        __extends(WebSocketDataSource, _super);
        function WebSocketDataSource() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @protected
         * @return {?}
         */
        WebSocketDataSource.prototype.createOlSource = /**
         * @protected
         * @return {?}
         */
            function () {
                this.createWebSocket();
                this.options.format = this.getSourceFormatFromOptions(this.options);
                return _super.prototype.createOlSource.call(this);
            };
        /**
         * @private
         * @return {?}
         */
        WebSocketDataSource.prototype.createWebSocket = /**
         * @private
         * @return {?}
         */
            function () {
                this.ws = new WebSocket(this.options.url);
                this.ws.onmessage = this.onMessage.bind(this);
                if (this.options.onclose) {
                    this.ws.onclose = this.onClose.bind(this);
                }
                if (this.options.onerror) {
                    this.ws.onerror = this.onError.bind(this);
                }
                if (this.options.onopen) {
                    this.ws.onopen = this.onOpen.bind(this);
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        WebSocketDataSource.prototype.onMessage = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                /** @type {?} */
                var featureAdded = this.options.format.readFeature(event.data);
                switch (this.options.onmessage) {
                    case 'update':
                        // ol don't add if same ID
                        /** @type {?} */
                        var featureToRemove = this.ol.getFeatureById(featureAdded.getId());
                        if (featureToRemove) {
                            this.ol.removeFeature(featureToRemove);
                        }
                        this.ol.addFeature(featureAdded);
                        break;
                    case 'delete':
                        this.ol.clear(true);
                        this.ol.addFeature(featureAdded);
                        break;
                    case 'add':
                    default:
                        this.ol.addFeature(featureAdded);
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        WebSocketDataSource.prototype.onClose = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // thrown message to user
            };
        /**
         * @param {?} event
         * @return {?}
         */
        WebSocketDataSource.prototype.onError = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // thrown message to user
            };
        /**
         * @param {?} event
         * @return {?}
         */
        WebSocketDataSource.prototype.onOpen = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // thrown message to user ?
            };
        /**
         * @return {?}
         */
        WebSocketDataSource.prototype.onUnwatch = /**
         * @return {?}
         */
            function () {
                this.ws.close();
            };
        return WebSocketDataSource;
    }(FeatureDataSource));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MVTDataSource = /** @class */ (function (_super) {
        __extends(MVTDataSource, _super);
        function MVTDataSource() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @protected
         * @return {?}
         */
        MVTDataSource.prototype.createOlSource = /**
         * @protected
         * @return {?}
         */
            function () {
                /** @type {?} */
                var mvtFormat = new olFormatMVT({ featureClass: OlFeature });
                this.options.format = mvtFormat;
                return new olSourceVectorTile(this.options);
            };
        /**
         * @protected
         * @return {?}
         */
        MVTDataSource.prototype.generateId = /**
         * @protected
         * @return {?}
         */
            function () {
                if (!this.options.url) {
                    return utils.uuid();
                }
                /** @type {?} */
                var chain = 'mvt' + this.options.url;
                return ( /** @type {?} */(tsMd5.Md5.hashStr(chain)));
            };
        /**
         * @return {?}
         */
        MVTDataSource.prototype.onUnwatch = /**
         * @return {?}
         */
            function () { };
        return MVTDataSource;
    }(DataSource));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var ClusterDataSource = /** @class */ (function (_super) {
        __extends(ClusterDataSource, _super);
        function ClusterDataSource() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @protected
         * @return {?}
         */
        ClusterDataSource.prototype.createOlSource = /**
         * @protected
         * @return {?}
         */
            function () {
                this.options.format = this.getSourceFormatFromOptions(this.options);
                this.options.source = _super.prototype.createOlSource.call(this);
                return new olSourceCluster(this.options);
            };
        /**
         * @protected
         * @return {?}
         */
        ClusterDataSource.prototype.generateId = /**
         * @protected
         * @return {?}
         */
            function () {
                return utils.uuid();
            };
        /**
         * @return {?}
         */
        ClusterDataSource.prototype.onUnwatch = /**
         * @return {?}
         */
            function () { };
        return ClusterDataSource;
    }(FeatureDataSource));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var FEATURE = 'Feature';
    /** @enum {number} */
    var FeatureMotion = {
        None: 0,
        Move: 1,
        Zoom: 2,
        Default: 3,
    };
    FeatureMotion[FeatureMotion.None] = 'None';
    FeatureMotion[FeatureMotion.Move] = 'Move';
    FeatureMotion[FeatureMotion.Zoom] = 'Zoom';
    FeatureMotion[FeatureMotion.Default] = 'Default';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var LAYER = 'Layer';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @abstract
     */
    var /**
     * @abstract
     */ Layer = /** @class */ (function () {
        function Layer(options) {
            this.options = options;
            this.dataSource = this.options.source;
            this.ol = this.createOlLayer();
            if (this.options.zIndex !== undefined) {
                this.zIndex = this.options.zIndex;
            }
            if (this.options.baseLayer && this.options.visible === undefined) {
                this.options.visible = false;
            }
            this.visible =
                this.options.visible === undefined ? true : this.options.visible;
            this.opacity =
                this.options.opacity === undefined ? 1 : this.options.opacity;
            this.ol.set('_layer', this, true);
        }
        Object.defineProperty(Layer.prototype, "id", {
            get: /**
             * @return {?}
             */ function () {
                return this.options.id || this.dataSource.id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Layer.prototype, "alias", {
            get: /**
             * @return {?}
             */ function () {
                return this.options.alias;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Layer.prototype, "title", {
            get: /**
             * @return {?}
             */ function () {
                return this.options.title;
            },
            set: /**
             * @param {?} title
             * @return {?}
             */ function (title) {
                this.options.title = title;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Layer.prototype, "zIndex", {
            get: /**
             * @return {?}
             */ function () {
                return this.ol.getZIndex();
            },
            set: /**
             * @param {?} zIndex
             * @return {?}
             */ function (zIndex) {
                this.ol.setZIndex(zIndex);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Layer.prototype, "baseLayer", {
            get: /**
             * @return {?}
             */ function () {
                return this.options.baseLayer;
            },
            set: /**
             * @param {?} baseLayer
             * @return {?}
             */ function (baseLayer) {
                this.options.baseLayer = baseLayer;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Layer.prototype, "visible", {
            get: /**
             * @return {?}
             */ function () {
                return this.ol.get('visible');
            },
            set: /**
             * @param {?} visibility
             * @return {?}
             */ function (visibility) {
                this.ol.setVisible(visibility);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Layer.prototype, "opacity", {
            get: /**
             * @return {?}
             */ function () {
                return this.ol.get('opacity');
            },
            set: /**
             * @param {?} opacity
             * @return {?}
             */ function (opacity) {
                this.ol.setOpacity(opacity);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Layer.prototype, "isInResolutionsRange", {
            get: /**
             * @return {?}
             */ function () {
                if (!this.map) {
                    return false;
                }
                /** @type {?} */
                var resolution = this.map.viewController.getResolution();
                /** @type {?} */
                var minResolution = this.ol.getMinResolution();
                /** @type {?} */
                var maxResolution = this.ol.getMaxResolution();
                return resolution >= minResolution && resolution <= maxResolution;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Layer.prototype, "showInLayerList", {
            get: /**
             * @return {?}
             */ function () { return this.options.showInLayerList !== false; },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} map
         * @return {?}
         */
        Layer.prototype.setMap = /**
         * @param {?} map
         * @return {?}
         */
            function (map) {
                this.map = map;
            };
        return Layer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @enum {string} */
    var TooltipType = {
        TITLE: 'title',
        ABSTRACT: 'abstract',
        CUSTOM: 'custom',
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var ImageWatcher = /** @class */ (function (_super) {
        __extends(ImageWatcher, _super);
        function ImageWatcher(layer) {
            var _this = _super.call(this) || this;
            _this.loaded = 0;
            _this.loading = 0;
            _this.source = layer.options.source.ol;
            _this.id = utils.uuid();
            return _this;
        }
        /**
         * @protected
         * @return {?}
         */
        ImageWatcher.prototype.watch = /**
         * @protected
         * @return {?}
         */
            function () {
                var _this = this;
                this.source.on("imageloadstart", ( /**
                 * @param {?} e
                 * @return {?}
                 */function (e) { return _this.handleLoadStart(e); }));
                this.source.on("imageloadend", ( /**
                 * @param {?} e
                 * @return {?}
                 */function (e) { return _this.handleLoadEnd(e); }));
                this.source.on("imageloaderror", ( /**
                 * @param {?} e
                 * @return {?}
                 */function (e) { return _this.handleLoadEnd(e); }));
            };
        /**
         * @protected
         * @return {?}
         */
        ImageWatcher.prototype.unwatch = /**
         * @protected
         * @return {?}
         */
            function () {
                var _this = this;
                this.source.un("imageloadstart", ( /**
                 * @param {?} e
                 * @return {?}
                 */function (e) { return _this.handleLoadStart(e); }));
                this.source.un("imageloadend", ( /**
                 * @param {?} e
                 * @return {?}
                 */function (e) { return _this.handleLoadEnd(e); }));
                this.source.un("imageloaderror", ( /**
                 * @param {?} e
                 * @return {?}
                 */function (e) { return _this.handleLoadEnd(e); }));
            };
        /**
         * @private
         * @param {?} event
         * @return {?}
         */
        ImageWatcher.prototype.handleLoadStart = /**
         * @private
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (!event.image.__watchers__) {
                    event.image.__watchers__ = [];
                }
                event.image.__watchers__.push(this.id);
                this.loading += 1;
                this.status = utils.SubjectStatus.Working;
            };
        /**
         * @private
         * @param {?} event
         * @return {?}
         */
        ImageWatcher.prototype.handleLoadEnd = /**
         * @private
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (!event.image.__watchers__) {
                    return;
                }
                /** @type {?} */
                var watcherIndex = event.image.__watchers__.indexOf(this.id);
                if (watcherIndex < 0) {
                    return;
                }
                event.image.__watchers__.splice(watcherIndex, 1);
                this.loaded += 1;
                /** @type {?} */
                var loading = this.loading;
                if (this.loaded >= loading) {
                    if (loading === this.loading) {
                        this.status = utils.SubjectStatus.Done;
                        this.loaded = this.loading = 0;
                    }
                }
            };
        return ImageWatcher;
    }(utils.Watcher));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TileWatcher = /** @class */ (function (_super) {
        __extends(TileWatcher, _super);
        function TileWatcher(layer) {
            var _this = _super.call(this) || this;
            _this.loaded = 0;
            _this.loading = 0;
            _this.source = layer.options.source.ol;
            _this.id = utils.uuid();
            return _this;
        }
        /**
         * @protected
         * @return {?}
         */
        TileWatcher.prototype.watch = /**
         * @protected
         * @return {?}
         */
            function () {
                var _this = this;
                this.source.on("tileloadstart", ( /**
                 * @param {?} e
                 * @return {?}
                 */function (e) { return _this.handleLoadStart(e); }));
                this.source.on("tileloadend", ( /**
                 * @param {?} e
                 * @return {?}
                 */function (e) { return _this.handleLoadEnd(e); }));
                this.source.on("tileloaderror", ( /**
                 * @param {?} e
                 * @return {?}
                 */function (e) { return _this.handleLoadEnd(e); }));
            };
        /**
         * @protected
         * @return {?}
         */
        TileWatcher.prototype.unwatch = /**
         * @protected
         * @return {?}
         */
            function () {
                var _this = this;
                this.source.un("tileloadstart", ( /**
                 * @param {?} e
                 * @return {?}
                 */function (e) { return _this.handleLoadStart(e); }));
                this.source.un("tileloadend", ( /**
                 * @param {?} e
                 * @return {?}
                 */function (e) { return _this.handleLoadEnd(e); }));
                this.source.un("tileloaderror", ( /**
                 * @param {?} e
                 * @return {?}
                 */function (e) { return _this.handleLoadEnd(e); }));
            };
        /**
         * @private
         * @param {?} event
         * @return {?}
         */
        TileWatcher.prototype.handleLoadStart = /**
         * @private
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // This is to avoid increasing
                // the number of loaded tiles if a tile was loading
                // before subscribing to this watcher
                if (!event.tile.__watchers__) {
                    event.tile.__watchers__ = [];
                }
                event.tile.__watchers__.push(this.id);
                this.loading += 1;
                this.status = utils.SubjectStatus.Working;
            };
        /**
         * @private
         * @param {?} event
         * @return {?}
         */
        TileWatcher.prototype.handleLoadEnd = /**
         * @private
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (!event.tile.__watchers__) {
                    return;
                }
                /** @type {?} */
                var watcherIndex = event.tile.__watchers__.indexOf(this.id);
                if (watcherIndex < 0) {
                    return;
                }
                event.tile.__watchers__.splice(watcherIndex, 1);
                this.loaded += 1;
                /** @type {?} */
                var loading = this.loading;
                if (this.loaded >= loading) {
                    if (loading === this.loading) {
                        this.status = utils.SubjectStatus.Done;
                        this.loaded = this.loading = 0;
                    }
                }
            };
        return TileWatcher;
    }(utils.Watcher));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var VectorWatcher = /** @class */ (function (_super) {
        __extends(VectorWatcher, _super);
        function VectorWatcher(layer) {
            var _this = _super.call(this) || this;
            _this.loaded = 0;
            _this.loading = 0;
            _this.layer = layer;
            _this.id = utils.uuid();
            return _this;
        }
        /**
         * @protected
         * @return {?}
         */
        VectorWatcher.prototype.watch = /**
         * @protected
         * @return {?}
         */
            function () {
            };
        /**
         * @protected
         * @return {?}
         */
        VectorWatcher.prototype.unwatch = /**
         * @protected
         * @return {?}
         */
            function () {
                this.layer.onUnwatch();
            };
        return VectorWatcher;
    }(utils.Watcher));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Get all the layers legend
     * @param {?} layers
     * @param {?=} scale
     * @return {?} Array of legend
     */
    function getLayersLegends(layers, scale) {
        var e_1, _a, e_2, _b;
        /** @type {?} */
        var legends = [];
        /** @type {?} */
        var newCanvas = document.createElement('canvas');
        /** @type {?} */
        var newContext = newCanvas.getContext('2d');
        newContext.font = '20px Calibri';
        /** @type {?} */
        var heightPos = 0;
        try {
            for (var layers_1 = __values(layers), layers_1_1 = layers_1.next(); !layers_1_1.done; layers_1_1 = layers_1.next()) {
                var layer = layers_1_1.value;
                if (layer.visible === false) {
                    continue;
                }
                /** @type {?} */
                var legendUrls = layer.dataSource.getLegend(scale) || [];
                var _loop_1 = function (legendUrl) {
                    if (legendUrl.url === undefined) {
                        return "continue";
                    }
                    /** @type {?} */
                    var title = layer.title;
                    // Create an image for the legend
                    /** @type {?} */
                    var legendImage = new Image();
                    legendImage.crossOrigin = 'anonymous';
                    legendImage.src = legendUrl.url;
                    legendImage.onload = ( /**
                     * @return {?}
                     */function () {
                        newContext.fillText(title, 0, heightPos);
                        newContext.drawImage(legendImage, 0, heightPos + 20);
                        heightPos += legendImage.height + 5;
                    });
                    // Add legend info to the list
                    legends.push({
                        title: title,
                        url: legendUrl.url,
                        image: legendImage
                    });
                };
                try {
                    for (var legendUrls_1 = __values(legendUrls), legendUrls_1_1 = legendUrls_1.next(); !legendUrls_1_1.done; legendUrls_1_1 = legendUrls_1.next()) {
                        var legendUrl = legendUrls_1_1.value;
                        _loop_1(legendUrl);
                    }
                }
                catch (e_2_1) {
                    e_2 = { error: e_2_1 };
                }
                finally {
                    try {
                        if (legendUrls_1_1 && !legendUrls_1_1.done && (_b = legendUrls_1.return))
                            _b.call(legendUrls_1);
                    }
                    finally {
                        if (e_2)
                            throw e_2.error;
                    }
                }
            }
        }
        catch (e_1_1) {
            e_1 = { error: e_1_1 };
        }
        finally {
            try {
                if (layers_1_1 && !layers_1_1.done && (_a = layers_1.return))
                    _a.call(layers_1);
            }
            finally {
                if (e_1)
                    throw e_1.error;
            }
        }
        return legends;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var ImageLayer = /** @class */ (function (_super) {
        __extends(ImageLayer, _super);
        function ImageLayer(options) {
            var _this = _super.call(this, options) || this;
            _this.watcher = new ImageWatcher(_this);
            _this.status$ = _this.watcher.status$;
            return _this;
        }
        /**
         * @protected
         * @return {?}
         */
        ImageLayer.prototype.createOlLayer = /**
         * @protected
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var olOptions = Object.assign({}, this.options, {
                    source: ( /** @type {?} */(this.options.source.ol))
                });
                /** @type {?} */
                var image = new olLayerImage(olOptions);
                /** @type {?} */
                var token = this.options.token;
                if (token) {
                    (( /** @type {?} */(image.getSource()))).setImageLoadFunction(( /**
                     * @param {?} tile
                     * @param {?} src
                     * @return {?}
                     */function (tile, src) {
                        _this.customLoader(tile, src, token);
                    }));
                }
                return image;
            };
        /**
         * @param {?} map
         * @return {?}
         */
        ImageLayer.prototype.setMap = /**
         * @param {?} map
         * @return {?}
         */
            function (map) {
                if (map === undefined) {
                    this.watcher.unsubscribe();
                }
                else {
                    this.watcher.subscribe(( /**
                     * @return {?}
                     */function () { }));
                }
                _super.prototype.setMap.call(this, map);
            };
        /**
         * @private
         * @param {?} tile
         * @param {?} src
         * @param {?=} token
         * @return {?}
         */
        ImageLayer.prototype.customLoader = /**
         * @private
         * @param {?} tile
         * @param {?} src
         * @param {?=} token
         * @return {?}
         */
            function (tile, src, token) {
                /** @type {?} */
                var xhr = new XMLHttpRequest();
                xhr.open('GET', src);
                xhr.setRequestHeader('Authorization', 'Bearer ' + token);
                xhr.responseType = 'arraybuffer';
                xhr.onload = ( /**
                 * @return {?}
                 */function () {
                    /** @type {?} */
                    var arrayBufferView = new Uint8Array((( /** @type {?} */(this))).response);
                    /** @type {?} */
                    var blob = new Blob([arrayBufferView], { type: 'image/png' });
                    /** @type {?} */
                    var urlCreator = window.URL;
                    /** @type {?} */
                    var imageUrl = urlCreator.createObjectURL(blob);
                    tile.getImage().src = imageUrl;
                });
                xhr.send();
            };
        return ImageLayer;
    }(Layer));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TileLayer = /** @class */ (function (_super) {
        __extends(TileLayer, _super);
        function TileLayer(options) {
            var _this = _super.call(this, options) || this;
            _this.watcher = new TileWatcher(_this);
            _this.status$ = _this.watcher.status$;
            return _this;
        }
        /**
         * @protected
         * @return {?}
         */
        TileLayer.prototype.createOlLayer = /**
         * @protected
         * @return {?}
         */
            function () {
                /** @type {?} */
                var olOptions = Object.assign({}, this.options, {
                    source: ( /** @type {?} */(this.options.source.ol))
                });
                return new olLayerTile(olOptions);
            };
        /**
         * @param {?} map
         * @return {?}
         */
        TileLayer.prototype.setMap = /**
         * @param {?} map
         * @return {?}
         */
            function (map) {
                if (map === undefined) {
                    this.watcher.unsubscribe();
                }
                else {
                    this.watcher.subscribe(( /**
                     * @return {?}
                     */function () { }));
                }
                _super.prototype.setMap.call(this, map);
            };
        return TileLayer;
    }(Layer));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var VectorLayer = /** @class */ (function (_super) {
        __extends(VectorLayer, _super);
        function VectorLayer(options) {
            var _this = _super.call(this, options) || this;
            _this.watcher = new VectorWatcher(_this);
            _this.status$ = _this.watcher.status$;
            return _this;
        }
        Object.defineProperty(VectorLayer.prototype, "browsable", {
            get: /**
             * @return {?}
             */ function () {
                return this.options.browsable !== false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VectorLayer.prototype, "exportable", {
            get: /**
             * @return {?}
             */ function () {
                return this.options.exportable !== false;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @protected
         * @return {?}
         */
        VectorLayer.prototype.createOlLayer = /**
         * @protected
         * @return {?}
         */
            function () {
                /** @type {?} */
                var olOptions = Object.assign({}, this.options, {
                    source: ( /** @type {?} */(this.options.source.ol))
                });
                if (this.options.animation) {
                    this.dataSource.ol.on('addfeature', ( /**
                     * @param {?} e
                     * @return {?}
                     */function (e) {
                        this.flash(e.feature);
                    }).bind(this));
                }
                return new OlVectorLayer(olOptions);
            };
        /**
         * @protected
         * @param {?} feature
         * @return {?}
         */
        VectorLayer.prototype.flash = /**
         * @protected
         * @param {?} feature
         * @return {?}
         */
            function (feature) {
                /** @type {?} */
                var start = new Date().getTime();
                /** @type {?} */
                var listenerKey = this.map.ol.on('postcompose', animate.bind(this));
                /**
                 * @param {?} event
                 * @return {?}
                 */
                function animate(event) {
                    /** @type {?} */
                    var vectorContext = event.vectorContext;
                    /** @type {?} */
                    var frameState = event.frameState;
                    /** @type {?} */
                    var flashGeom = feature.getGeometry().clone();
                    /** @type {?} */
                    var elapsed = frameState.time - start;
                    /** @type {?} */
                    var elapsedRatio = elapsed / this.options.animation.duration;
                    /** @type {?} */
                    var opacity = oleasing.easeOut(1 - elapsedRatio);
                    /** @type {?} */
                    var newColor = color.asArray(this.options.animation.color || 'red');
                    newColor[3] = opacity;
                    /** @type {?} */
                    var style = this.ol.getStyleFunction().call(this, feature)[0];
                    /** @type {?} */
                    var styleClone = style.clone();
                    switch (feature.getGeometry().getType()) {
                        case 'Point':
                            /** @type {?} */
                            var radius = oleasing.easeOut(elapsedRatio) * (styleClone.getImage().getRadius() * 3);
                            styleClone.getImage().setRadius(radius);
                            styleClone.getImage().setOpacity(opacity);
                            break;
                        case 'LineString':
                            // TODO
                            if (styleClone.getImage().getStroke()) {
                                styleClone
                                    .getImage()
                                    .getStroke()
                                    .setColor(newColor);
                                styleClone
                                    .getImage()
                                    .getStroke()
                                    .setWidth(oleasing.easeOut(elapsedRatio) *
                                    (styleClone
                                        .getImage()
                                        .getStroke()
                                        .getWidth() *
                                        3));
                            }
                            if (styleClone.getStroke()) {
                                styleClone.getStroke().setColor(newColor);
                                styleClone
                                    .getStroke()
                                    .setWidth(oleasing.easeOut(elapsedRatio) * (styleClone.getStroke().getWidth() * 3));
                            }
                            break;
                        case 'Polygon':
                            // TODO
                            if (styleClone.getImage().getFill()) {
                                styleClone
                                    .getImage()
                                    .getFill()
                                    .setColor(newColor);
                            }
                            if (styleClone.getFill()) {
                                styleClone.getFill().setColor(newColor);
                            }
                            break;
                    }
                    vectorContext.setStyle(styleClone);
                    vectorContext.drawGeometry(flashGeom);
                    if (elapsed > this.options.animation.duration) {
                        olobservable.unByKey(listenerKey);
                        // remove last geometry
                        // there is a little flash before feature disappear, better solution ?
                        this.map.ol.render();
                        return;
                    }
                    // tell OpenLayers to continue postcompose animation
                    this.map.ol.render();
                }
            };
        /**
         * @param {?} map
         * @return {?}
         */
        VectorLayer.prototype.setMap = /**
         * @param {?} map
         * @return {?}
         */
            function (map) {
                if (map === undefined) {
                    this.watcher.unsubscribe();
                }
                else {
                    this.watcher.subscribe(( /**
                     * @return {?}
                     */function () { }));
                }
                _super.prototype.setMap.call(this, map);
            };
        /**
         * @return {?}
         */
        VectorLayer.prototype.onUnwatch = /**
         * @return {?}
         */
            function () {
                this.dataSource.onUnwatch();
                this.stopAnimation();
            };
        /**
         * @return {?}
         */
        VectorLayer.prototype.stopAnimation = /**
         * @return {?}
         */
            function () {
                this.dataSource.ol.un('addfeature', ( /**
                 * @param {?} e
                 * @return {?}
                 */function (e) {
                    this.flash(e.feature);
                }).bind(this));
            };
        return VectorLayer;
    }(Layer));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var VectorTileLayer = /** @class */ (function (_super) {
        __extends(VectorTileLayer, _super);
        function VectorTileLayer(options) {
            return _super.call(this, options) || this;
        }
        /**
         * @protected
         * @return {?}
         */
        VectorTileLayer.prototype.createOlLayer = /**
         * @protected
         * @return {?}
         */
            function () {
                /** @type {?} */
                var olOptions = Object.assign({}, this.options, {
                    source: ( /** @type {?} */(this.options.source.ol))
                });
                return new olLayerVectorTile(olOptions);
            };
        return VectorTileLayer;
    }(Layer));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var StyleService = /** @class */ (function () {
        function StyleService() {
        }
        /**
         * @param {?} options
         * @return {?}
         */
        StyleService.prototype.createStyle = /**
         * @param {?} options
         * @return {?}
         */
            function (options) {
                return this.parseStyle('style', options);
            };
        /**
         * @private
         * @param {?} key
         * @param {?} value
         * @return {?}
         */
        StyleService.prototype.parseStyle = /**
         * @private
         * @param {?} key
         * @param {?} value
         * @return {?}
         */
            function (key, value) {
                var _this = this;
                /** @type {?} */
                var styleOptions = {};
                /** @type {?} */
                var olCls = this.getOlCls(key);
                if (olCls && value instanceof Object) {
                    Object.keys(value).forEach(( /**
                     * @param {?} _key
                     * @return {?}
                     */function (_key) {
                        /** @type {?} */
                        var olKey = _this.getOlKey(_key);
                        styleOptions[olKey] = _this.parseStyle(_key, value[_key]);
                    }));
                    return new olCls(styleOptions);
                }
                else {
                    return value;
                }
            };
        /**
         * @private
         * @param {?} key
         * @return {?}
         */
        StyleService.prototype.getOlKey = /**
         * @private
         * @param {?} key
         * @return {?}
         */
            function (key) {
                /** @type {?} */
                var olKey = key.toLowerCase();
                switch (olKey) {
                    case 'circle':
                    case 'regularshape':
                    case 'icon':
                        olKey = 'image';
                        break;
                    default:
                        break;
                }
                return olKey;
            };
        /**
         * @private
         * @param {?} key
         * @return {?}
         */
        StyleService.prototype.getOlCls = /**
         * @private
         * @param {?} key
         * @return {?}
         */
            function (key) {
                /** @type {?} */
                var olCls = olstyle[key.charAt(0).toUpperCase() + key.slice(1)];
                if (key === 'regularshape') {
                    olCls = olstyle.RegularShape;
                }
                return olCls;
            };
        /**
         * @param {?} feature
         * @param {?} styleByAttribute
         * @return {?}
         */
        StyleService.prototype.createStyleByAttribute = /**
         * @param {?} feature
         * @param {?} styleByAttribute
         * @return {?}
         */
            function (feature, styleByAttribute) {
                /** @type {?} */
                var style;
                /** @type {?} */
                var type = styleByAttribute.type;
                /** @type {?} */
                var attribute = styleByAttribute.attribute;
                /** @type {?} */
                var data = styleByAttribute.data;
                /** @type {?} */
                var stroke = styleByAttribute.stroke;
                /** @type {?} */
                var width = styleByAttribute.width;
                /** @type {?} */
                var fill = styleByAttribute.fill;
                /** @type {?} */
                var radius = styleByAttribute.radius;
                /** @type {?} */
                var icon = styleByAttribute.icon;
                /** @type {?} */
                var scale = styleByAttribute.scale;
                /** @type {?} */
                var size = data.length;
                /** @type {?} */
                var label = styleByAttribute.label;
                /** @type {?} */
                var baseStyle = styleByAttribute.baseStyle;
                if (type === 'circle') {
                    for (var i = 0; i < size; i++) {
                        if (feature.get(attribute) === data[i]) {
                            if (icon) {
                                style = [
                                    new olstyle.Style({
                                        image: new olstyle.Icon({
                                            src: icon[i],
                                            scale: scale ? scale[i] : 1
                                        })
                                    })
                                ];
                                return style;
                            }
                            style = [
                                new olstyle.Style({
                                    image: new olstyle.Circle({
                                        radius: radius ? radius[i] : 4,
                                        stroke: new olstyle.Stroke({
                                            color: stroke ? stroke[i] : 'black'
                                        }),
                                        fill: new olstyle.Fill({
                                            color: fill ? fill[i] : 'black'
                                        })
                                    })
                                })
                            ];
                            return style;
                        }
                    }
                    if (!feature.getStyle()) {
                        style = [
                            new olstyle.Style({
                                image: new olstyle.Circle({
                                    radius: 4,
                                    stroke: new olstyle.Stroke({
                                        color: 'black'
                                    }),
                                    fill: new olstyle.Fill({
                                        color: '#bbbbf2'
                                    })
                                })
                            })
                        ];
                        return style;
                    }
                }
                else if (type === 'regular') {
                    for (var i = 0; i < size; i++) {
                        if (feature.get(attribute) === data[i]) {
                            style = [
                                new olstyle.Style({
                                    stroke: new olstyle.Stroke({
                                        color: stroke ? stroke[i] : 'black',
                                        width: width ? width[i] : 1
                                    }),
                                    fill: new olstyle.Fill({
                                        color: fill ? fill[i] : 'rgba(255,255,255,0.4)'
                                    }),
                                    text: new olstyle.Text({
                                        text: feature.get(label),
                                        stroke: new olstyle.Stroke({
                                            color: 'black'
                                        })
                                    })
                                })
                            ];
                            return style;
                        }
                    }
                    if (!feature.getStyle()) {
                        if (baseStyle) {
                            style = this.createStyle(baseStyle);
                            return style;
                        }
                        style = [
                            new olstyle.Style({
                                stroke: new olstyle.Stroke({
                                    color: 'black'
                                }),
                                fill: new olstyle.Fill({
                                    color: '#bbbbf2'
                                })
                            })
                        ];
                        return style;
                    }
                }
            };
        /**
         * @param {?} feature
         * @param {?} clusterParam
         * @return {?}
         */
        StyleService.prototype.createClusterStyle = /**
         * @param {?} feature
         * @param {?} clusterParam
         * @return {?}
         */
            function (feature, clusterParam) {
                /** @type {?} */
                var style;
                /** @type {?} */
                var range = clusterParam.clusterRange;
                /** @type {?} */
                var icon = clusterParam.clusterIcon;
                /** @type {?} */
                var scale = clusterParam.clusterScale;
                /** @type {?} */
                var size = feature.get('features').length;
                /** @type {?} */
                var color$$1;
                if (size !== 1) {
                    if (range) {
                        if (size >= range[1]) {
                            color$$1 = 'red';
                        }
                        else if (size < range[1] && size >= range[0]) {
                            color$$1 = 'orange';
                        }
                        else if (size < range[0]) {
                            color$$1 = 'green';
                        }
                    }
                    style = [
                        new olstyle.Style({
                            image: new olstyle.Circle({
                                radius: 2 * size + 3.4,
                                stroke: new olstyle.Stroke({
                                    color: 'black'
                                }),
                                fill: new olstyle.Fill({
                                    color: range ? color$$1 : 'blue'
                                })
                            }),
                            text: new olstyle.Text({
                                text: size.toString(),
                                fill: new olstyle.Fill({
                                    color: '#fff'
                                })
                            })
                        })
                    ];
                }
                else {
                    if (icon) {
                        style = [
                            new olstyle.Style({
                                image: new olstyle.Icon({
                                    src: icon,
                                    scale: scale
                                })
                            })
                        ];
                    }
                    else {
                        style = [
                            new olstyle.Style({
                                image: new olstyle.Circle({
                                    radius: 2 * size + 3.4,
                                    stroke: new olstyle.Stroke({
                                        color: 'black'
                                    }),
                                    fill: new olstyle.Fill({
                                        color: 'blue'
                                    })
                                })
                            })
                        ];
                    }
                }
                return style;
            };
        StyleService.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        StyleService.ctorParameters = function () { return []; };
        /** @nocollapse */ StyleService.ngInjectableDef = i0.defineInjectable({ factory: function StyleService_Factory() { return new StyleService(); }, token: StyleService, providedIn: "root" });
        return StyleService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Whether a layer is queryable
     * @param {?} layer Layer
     * @return {?} True if the layer s squeryable
     */
    function layerIsQueryable(layer) {
        /** @type {?} */
        var dataSource = ( /** @type {?} */(layer.dataSource));
        return dataSource.options.queryable === true;
    }
    /**
     * Whether an OL layer is queryable
     * @param {?} olLayer
     * @return {?} True if the ol layer is queryable
     */
    function olLayerIsQueryable(olLayer) {
        /** @type {?} */
        var layer = olLayer.get('_layer');
        return layer === undefined ? false : layerIsQueryable(layer);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var LayerItemComponent = /** @class */ (function () {
        function LayerItemComponent(cdRef) {
            this.cdRef = cdRef;
            this.showLegend$ = new rxjs.BehaviorSubject(false);
            this.inResolutionRange$ = new rxjs.BehaviorSubject(true);
            this.queryBadgeHidden$ = new rxjs.BehaviorSubject(true);
            this.toggleLegendOnVisibilityChange = false;
            this.expandLegendIfVisible = false;
            this.updateLegendOnResolutionChange = false;
            this.orderable = true;
            this.queryBadge = false;
        }
        Object.defineProperty(LayerItemComponent.prototype, "removable", {
            get: /**
             * @return {?}
             */ function () { return this.layer.options.removable !== false; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LayerItemComponent.prototype, "opacity", {
            get: /**
             * @return {?}
             */ function () { return this.layer.opacity * 100; },
            set: /**
             * @param {?} opacity
             * @return {?}
             */ function (opacity) { this.layer.opacity = opacity / 100; },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        LayerItemComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var legend = this.layer.dataSource.options.legend || {};
                /** @type {?} */
                var legendCollapsed = legend.collapsed === false ? false : true;
                if (this.layer.visible && this.expandLegendIfVisible) {
                    legendCollapsed = false;
                }
                this.toggleLegend(legendCollapsed);
                this.updateQueryBadge();
                /** @type {?} */
                var resolution$ = this.layer.map.viewController.resolution$;
                this.resolution$$ = resolution$.subscribe(( /**
                 * @param {?} resolution
                 * @return {?}
                 */function (resolution) {
                    _this.onResolutionChange(resolution);
                }));
                this.tooltipText = this.computeTooltip();
            };
        /**
         * @return {?}
         */
        LayerItemComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.resolution$$.unsubscribe();
            };
        /**
         * @param {?} collapsed
         * @return {?}
         */
        LayerItemComponent.prototype.toggleLegend = /**
         * @param {?} collapsed
         * @return {?}
         */
            function (collapsed) {
                this.showLegend$.next(!collapsed);
            };
        /**
         * @return {?}
         */
        LayerItemComponent.prototype.toggleVisibility = /**
         * @return {?}
         */
            function () {
                this.layer.visible = !this.layer.visible;
                if (this.toggleLegendOnVisibilityChange) {
                    this.toggleLegend(!this.layer.visible);
                }
                this.updateQueryBadge();
            };
        /**
         * @return {?}
         */
        LayerItemComponent.prototype.computeTooltip = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var layerOptions = this.layer.options;
                if (!layerOptions.tooltip) {
                    return this.layer.title;
                }
                /** @type {?} */
                var layerTooltip = layerOptions.tooltip;
                /** @type {?} */
                var layerMetadata = (( /** @type {?} */(layerOptions))).metadata;
                switch (layerOptions.tooltip.type) {
                    case TooltipType.TITLE:
                        return this.layer.title;
                    case TooltipType.ABSTRACT:
                        if (layerMetadata && layerMetadata.abstract) {
                            return layerMetadata.abstract;
                        }
                        else {
                            return this.layer.title;
                        }
                    case TooltipType.CUSTOM:
                        if (layerTooltip && layerTooltip.text) {
                            return layerTooltip.text;
                        }
                        else {
                            return this.layer.title;
                        }
                    default:
                        return this.layer.title;
                }
            };
        /**
         * @private
         * @param {?} resolution
         * @return {?}
         */
        LayerItemComponent.prototype.onResolutionChange = /**
         * @private
         * @param {?} resolution
         * @return {?}
         */
            function (resolution) {
                /** @type {?} */
                var inResolutionRange = this.layer.isInResolutionsRange;
                if (inResolutionRange === false && this.updateLegendOnResolutionChange === true) {
                    this.toggleLegend(true);
                }
                this.inResolutionRange$.next(inResolutionRange);
            };
        /**
         * @private
         * @return {?}
         */
        LayerItemComponent.prototype.updateQueryBadge = /**
         * @private
         * @return {?}
         */
            function () {
                /** @type {?} */
                var hidden = this.queryBadge === false ||
                    this.layer.visible === false ||
                    !layerIsQueryable(this.layer);
                this.queryBadgeHidden$.next(hidden);
            };
        LayerItemComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'igo-layer-item',
                        template: "<mat-list-item>\r\n  <mat-icon\r\n    class=\"igo-chevron\"\r\n    mat-list-avatar\r\n    igoCollapse\r\n    [target]=\"legend\"\r\n    [collapsed]=\"!(showLegend$ | async)\"\r\n    (toggle)=\"toggleLegend($event)\"\r\n    svgIcon=\"chevron-up\" >\r\n  </mat-icon>\r\n  <h4 matLine [matTooltip]=\"tooltipText\" matTooltipShowDelay=\"500\">{{layer.title}}</h4>\r\n\r\n  <button\r\n    mat-icon-button\r\n    [color]=\"layer.visible ? 'primary' : 'default'\"\r\n    collapsibleButton\r\n    tooltip-position=\"below\"\r\n    matTooltipShowDelay=\"500\"\r\n    [matTooltip]=\"layer.visible ?\r\n                  ('igo.geo.layer.hideLayer' | translate) :\r\n                  ('igo.geo.layer.showLayer' | translate)\"\r\n    (click)=\"toggleVisibility()\">\r\n    <mat-icon\r\n      matBadge=\"?\"\r\n      matBadgeColor=\"accent\"\r\n      matBadgeSize=\"small\"\r\n      matBadgePosition=\"after\"\r\n      [matBadgeHidden]=\"queryBadgeHidden$ | async\"\r\n      [ngClass]=\"{disabled: !(inResolutionRange$ | async)}\"\r\n      [svgIcon]=\"layer.visible ? 'eye' : 'eye-off'\">\r\n    </mat-icon>\r\n  </button>\r\n\r\n  <button\r\n    mat-icon-button\r\n    color=\"primary\"\r\n    igoCollapse\r\n    [target]=\"actions\"\r\n    [collapsed]=\"true\">\r\n    <mat-icon svgIcon=\"dots-horizontal\"></mat-icon>\r\n  </button>\r\n</mat-list-item>\r\n\r\n<div #actions class=\"igo-layer-actions-container\">\r\n  <div class=\"igo-col igo-col-100 igo-col-100-m\">\r\n    <mat-slider\r\n      id=\"opacity-slider\"\r\n      thumbLabel\r\n      tickInterval=\"5\"\r\n      step=\"5\"\r\n      [min]=\"0\"\r\n      [max]=\"100\"\r\n      [(ngModel)]=\"opacity\"\r\n      [matTooltip]=\"'igo.geo.layer.opacity' | translate\"\r\n      matTooltipShowDelay=\"500\"\r\n      tooltip-position=\"below\">\r\n    </mat-slider>\r\n  </div>\r\n\r\n  <div class=\"igo-col igo-col-100 igo-col-100-m\">\r\n    <div class=\"igo-layer-button-group\">\r\n      <button\r\n        color=\"primary\"\r\n        mat-icon-button\r\n        tooltip-position=\"below\"\r\n        matTooltipShowDelay=\"500\"\r\n        [matTooltip]=\"'igo.geo.layer.raiseLayer' | translate\"\r\n        [disabled]=\"!orderable\"\r\n        (click)=\"layer.map.raiseLayer(layer)\">\r\n        <mat-icon svgIcon=\"arrow-up\"></mat-icon>\r\n      </button>\r\n\r\n      <button\r\n        mat-icon-button\r\n        color=\"primary\"\r\n        tooltip-position=\"below\"\r\n        matTooltipShowDelay=\"500\"\r\n        [matTooltip]=\"'igo.geo.layer.lowerLayer' | translate\"\r\n        [disabled]=\"!orderable\"\r\n        (click)=\"layer.map.lowerLayer(layer)\">\r\n        <mat-icon svgIcon=\"arrow-down\"></mat-icon>\r\n      </button>\r\n\r\n      <button\r\n        *ngIf=\"removable === true\"\r\n        mat-icon-button\r\n        color=\"warn\"\r\n        tooltip-position=\"below\"\r\n        matTooltipShowDelay=\"500\"\r\n        [matTooltip]=\"'igo.geo.layer.removeLayer' | translate\"\r\n        (click)=\"layer.map.removeLayer(layer)\">\r\n        <mat-icon svgIcon=\"delete\"></mat-icon>\r\n      </button>\r\n      <ng-content select=\"[igoLayerItemToolbar]\"></ng-content>\r\n\r\n    </div>\r\n  </div>\r\n</div>\r\n\r\n<div #legend class=\"igo-layer-legend-container\">\r\n  <igo-layer-legend\r\n    *ngIf=\"showLegend$ | async\"\r\n    [layer]=\"layer\"\r\n    [updateLegendOnResolutionChange]=\"updateLegendOnResolutionChange\">\r\n  </igo-layer-legend>\r\n</div>\r\n",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        styles: [":host{overflow:hidden}.igo-layer-actions-container{width:100%;display:inline-block}.igo-layer-actions-container>div{text-align:center}.igo-layer-legend-container{padding-left:18px;width:calc(100% - 18px);display:inline-block}#opacity-slider{width:100%}.igo-layer-button-group{float:right;padding:0 3px}@media only screen and (max-width:450px),only screen and (max-height:450px){#opacity-slider{width:70%}.igo-layer-button-group{float:none}}mat-icon.disabled{color:rgba(0,0,0,.38)}.mat-badge-small .mat-badge-content{font-size:12px}"]
                    }] }
        ];
        /** @nocollapse */
        LayerItemComponent.ctorParameters = function () {
            return [
                { type: i0.ChangeDetectorRef }
            ];
        };
        LayerItemComponent.propDecorators = {
            layer: [{ type: i0.Input }],
            toggleLegendOnVisibilityChange: [{ type: i0.Input }],
            expandLegendIfVisible: [{ type: i0.Input }],
            updateLegendOnResolutionChange: [{ type: i0.Input }],
            orderable: [{ type: i0.Input }],
            queryBadge: [{ type: i0.Input }]
        };
        return LayerItemComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var LayerLegendComponent = /** @class */ (function () {
        function LayerLegendComponent(capabilitiesService) {
            this.capabilitiesService = capabilitiesService;
            this.updateLegendOnResolutionChange = false;
            /**
             * Observable of the legend items
             */
            this.legendItems$ = new rxjs.BehaviorSubject([]);
        }
        /**
         * On init, subscribe to the map's resolution and update the legend accordingly
         */
        /**
         * On init, subscribe to the map's resolution and update the legend accordingly
         * @return {?}
         */
        LayerLegendComponent.prototype.ngOnInit = /**
         * On init, subscribe to the map's resolution and update the legend accordingly
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.updateLegendOnResolutionChange === true) {
                    /** @type {?} */
                    var resolution$ = this.layer.map.viewController.resolution$;
                    this.resolution$$ = resolution$.subscribe(( /**
                     * @param {?} resolution
                     * @return {?}
                     */function (resolution) { return _this.onResolutionChange(resolution); }));
                }
                else {
                    this.updateLegend(undefined);
                }
            };
        /**
         * On destroy, unsubscribe to the map,s resolution
         */
        /**
         * On destroy, unsubscribe to the map,s resolution
         * @return {?}
         */
        LayerLegendComponent.prototype.ngOnDestroy = /**
         * On destroy, unsubscribe to the map,s resolution
         * @return {?}
         */
            function () {
                if (this.resolution$$ !== undefined) {
                    this.resolution$$.unsubscribe();
                }
            };
        /**
         * @param {?} layerLegend
         * @return {?}
         */
        LayerLegendComponent.prototype.computeItemTitle = /**
         * @param {?} layerLegend
         * @return {?}
         */
            function (layerLegend) {
                /** @type {?} */
                var layerOptions = ( /** @type {?} */(this.layer.dataSource.options));
                if (layerOptions.type !== 'wms') {
                    return rxjs.of(layerLegend.title);
                }
                /** @type {?} */
                var layers = layerOptions.params.layers.split(',');
                /** @type {?} */
                var localLayerOptions = JSON.parse(JSON.stringify(layerOptions));
                localLayerOptions.params.layers = layers.find(( /**
                 * @param {?} layer
                 * @return {?}
                 */function (layer) { return layer === layerLegend.title; }));
                return this.capabilitiesService
                    .getWMSOptions(localLayerOptions)
                    .pipe(operators.map(( /**
             * @param {?} wmsDataSourceOptions
             * @return {?}
             */function (wmsDataSourceOptions) {
                    return wmsDataSourceOptions._layerOptionsFromCapabilities.title;
                })));
            };
        /**
         * On resolution change, compute the effective scale level and update the
         * legend accordingly.
         * @param resolutione Map resolution
         */
        /**
         * On resolution change, compute the effective scale level and update the
         * legend accordingly.
         * @private
         * @param {?} resolution
         * @return {?}
         */
        LayerLegendComponent.prototype.onResolutionChange = /**
         * On resolution change, compute the effective scale level and update the
         * legend accordingly.
         * @private
         * @param {?} resolution
         * @return {?}
         */
            function (resolution) {
                /** @type {?} */
                var scale = this.layer.map.viewController.getScale();
                this.updateLegend(scale);
            };
        /**
         * Update the legend according the scale level
         * @param scale Map scale level
         */
        /**
         * Update the legend according the scale level
         * @private
         * @param {?} scale Map scale level
         * @return {?}
         */
        LayerLegendComponent.prototype.updateLegend = /**
         * Update the legend according the scale level
         * @private
         * @param {?} scale Map scale level
         * @return {?}
         */
            function (scale) {
                /** @type {?} */
                var legendItems = this.layer.dataSource.getLegend(scale);
                if (legendItems.length === 0 && this.legendItems$.value.length === 0) {
                    return;
                }
                this.legendItems$.next(legendItems);
            };
        LayerLegendComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'igo-layer-legend',
                        template: "<ng-container *ngIf=\"legendItems$ | async as items\">\r\n  <ng-container *ngIf=\"items.length; else noItems\">\r\n    <ng-container *ngFor=\"let item of items\">\r\n      <mat-list-item *ngIf=\"item.title\">\r\n        <mat-icon\r\n          id=\"legend-toggle\"\r\n          class=\"igo-chevron\"\r\n          mat-list-avatar\r\n          igoCollapse\r\n          [target]=\"legend\"\r\n          [collapsed]=\"false\"\r\n          svgIcon=\"chevron-up\">\r\n        </mat-icon>\r\n        <h4 matLine>{{computeItemTitle(item) | async}}</h4>\r\n      </mat-list-item>\r\n    \r\n      <div #legend class=\"igo-layer-legend\" [ngClass]=\"{'with-title': item.title}\">\r\n        <img\r\n          *ngIf=\"item.url\"\r\n          src=\"{{(item.url | secureImage) |\u00A0async}}\"\r\n          alt=\"{{'igo.geo.layer.loadingLegendText' | translate}}\">\r\n        <div\r\n          [ngStyle]=\"item.style\"\r\n          [innerHTML]=\"item.html\"\r\n          *ngIf=\"item.html\">\r\n        </div>\r\n      </div>\r\n    </ng-container>\r\n  </ng-container>\r\n\r\n  <ng-template #noItems>\r\n    <small>\r\n      {{'igo.geo.layer.noLegendText' | translate}}\r\n    </small>\r\n  </ng-template>\r\n\r\n</ng-container>\r\n",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        styles: [".igo-layer-legend.with-title{padding-left:18px}"]
                    }] }
        ];
        /** @nocollapse */
        LayerLegendComponent.ctorParameters = function () {
            return [
                { type: CapabilitiesService }
            ];
        };
        LayerLegendComponent.propDecorators = {
            updateLegendOnResolutionChange: [{ type: i0.Input }],
            layer: [{ type: i0.Input }]
        };
        return LayerLegendComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @enum {string} */
    var LayerListControlsEnum = {
        always: 'always',
        never: 'never',
        default: 'default',
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var LayerListService = /** @class */ (function () {
        function LayerListService() {
            this.sortedAlpha = false;
            this.onlyVisible = false;
            this.onlyInRange = false;
            this.keywordInitialized = false;
            this.sortedAlphaInitialized = false;
            this.onlyVisibleInitialized = false;
            this.onlyInRangeInitialized = false;
        }
        LayerListService.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        LayerListService.ctorParameters = function () { return []; };
        /** @nocollapse */ LayerListService.ngInjectableDef = i0.defineInjectable({ factory: function LayerListService_Factory() { return new LayerListService(); }, token: LayerListService, providedIn: "root" });
        return LayerListService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    // TODO: This class could use a clean up. Also, some methods could be moved ealsewhere
    var LayerListComponent = /** @class */ (function () {
        function LayerListComponent(cdRef, layerListService) {
            this.cdRef = cdRef;
            this.layerListService = layerListService;
            this.hasLayerNotVisible = false;
            this.hasLayerOutOfRange = false;
            this.orderable = true;
            this.thresholdToFilterAndSort = 5;
            this.layers$ = new rxjs.BehaviorSubject([]);
            this.change$ = new rxjs.ReplaySubject(1);
            this.showToolbar$ = new rxjs.BehaviorSubject(false);
            this.placeholder = '';
            this.floatLabel = 'auto';
            this.layerFilterAndSortOptions = {};
            this.excludeBaseLayers = false;
            this.toggleLegendOnVisibilityChange = false;
            this.expandLegendOfVisibleLayers = false;
            this.updateLegendOnResolutionChange = false;
            this.queryBadge = false;
        }
        Object.defineProperty(LayerListComponent.prototype, "layers", {
            get: /**
             * @return {?}
             */ function () { return this._layers; },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.setLayers(value);
                this.next();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LayerListComponent.prototype, "keyword", {
            get: /**
             * @return {?}
             */ function () { return this.layerListService.keyword; },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.layerListService.keyword = value;
                this.next();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LayerListComponent.prototype, "keywordInitialized", {
            get: /**
             * @return {?}
             */ function () { return this.layerListService.keywordInitialized; },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) { this.layerListService.keywordInitialized = value; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LayerListComponent.prototype, "onlyVisible", {
            get: /**
             * @return {?}
             */ function () { return this.layerListService.onlyVisible; },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.layerListService.onlyVisible = value;
                this.next();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LayerListComponent.prototype, "onlyVisibleInitialized", {
            get: /**
             * @return {?}
             */ function () { return this.layerListService.onlyVisibleInitialized; },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) { this.layerListService.onlyVisibleInitialized = value; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LayerListComponent.prototype, "onlyInRange", {
            get: /**
             * @return {?}
             */ function () { return this.layerListService.onlyInRange; },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.layerListService.onlyInRange = value;
                this.next();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LayerListComponent.prototype, "onlyInRangeInitialized", {
            get: /**
             * @return {?}
             */ function () { return this.layerListService.onlyInRangeInitialized; },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) { this.layerListService.onlyInRangeInitialized = value; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LayerListComponent.prototype, "sortedAlpha", {
            get: /**
             * @return {?}
             */ function () { return this.layerListService.sortedAlpha; },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.layerListService.sortedAlpha = value;
                this.next();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LayerListComponent.prototype, "sortedAlphaInitialized", {
            get: /**
             * @return {?}
             */ function () { return this.layerListService.sortedAlphaInitialized; },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) { this.layerListService.sortedAlphaInitialized = value; },
            enumerable: true,
            configurable: true
        });
        /**
         * Subscribe to the search term stream and trigger researches
         * @internal
         */
        /**
         * Subscribe to the search term stream and trigger researches
         * \@internal
         * @return {?}
         */
        LayerListComponent.prototype.ngOnInit = /**
         * Subscribe to the search term stream and trigger researches
         * \@internal
         * @return {?}
         */
            function () {
                var _this = this;
                this.change$$ = this.change$
                    .pipe(operators.debounce(( /**
             * @return {?}
             */function () {
                    return _this.layers.length === 0 ? rxjs.EMPTY : rxjs.timer(50);
                }))).subscribe(( /**
                 * @return {?}
                 */function () {
                    _this.showToolbar$.next(_this.computeShowToolbar());
                    _this.layers$.next(_this.computeLayers(_this.layers.slice(0)));
                }));
                this.initLayerFilterAndSortOptions();
            };
        /**
         * @return {?}
         */
        LayerListComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.change$$.unsubscribe();
            };
        /**
         * @return {?}
         */
        LayerListComponent.prototype.toggleOnlyVisible = /**
         * @return {?}
         */
            function () {
                this.onlyVisible = !this.onlyVisible;
            };
        /**
         * @return {?}
         */
        LayerListComponent.prototype.toggleOnlyInRange = /**
         * @return {?}
         */
            function () {
                this.onlyInRange = !this.onlyInRange;
            };
        /**
         * @param {?} sortAlpha
         * @return {?}
         */
        LayerListComponent.prototype.toggleSort = /**
         * @param {?} sortAlpha
         * @return {?}
         */
            function (sortAlpha) {
                this.sortedAlpha = sortAlpha;
            };
        /**
         * @return {?}
         */
        LayerListComponent.prototype.clearKeyword = /**
         * @return {?}
         */
            function () {
                this.keyword = undefined;
            };
        /**
         * @private
         * @return {?}
         */
        LayerListComponent.prototype.next = /**
         * @private
         * @return {?}
         */
            function () {
                this.change$.next();
            };
        /**
         * @private
         * @param {?} layers
         * @return {?}
         */
        LayerListComponent.prototype.computeLayers = /**
         * @private
         * @param {?} layers
         * @return {?}
         */
            function (layers) {
                /** @type {?} */
                var layersOut = this.filterLayers(layers);
                if (this.sortedAlpha) {
                    layersOut = this.sortLayersByTitle(layersOut);
                }
                else {
                    layersOut = this.sortLayersByZindex(layersOut);
                }
                return layersOut;
            };
        /**
         * @private
         * @param {?} layers
         * @return {?}
         */
        LayerListComponent.prototype.filterLayers = /**
         * @private
         * @param {?} layers
         * @return {?}
         */
            function (layers) {
                var _this = this;
                /** @type {?} */
                var keyword = this.keyword;
                if (this.layerFilterAndSortOptions.showToolbar === LayerListControlsEnum.never) {
                    return layers;
                }
                if (!keyword && !this.onlyInRange && !this.onlyVisible) {
                    return layers;
                }
                /** @type {?} */
                var keepLayerIds = layers.map(( /**
                 * @param {?} layer
                 * @return {?}
                 */function (layer) { return layer.id; }));
                layers.forEach(( /**
                 * @param {?} layer
                 * @return {?}
                 */function (layer) {
                    /** @type {?} */
                    var layerOptions = ( /** @type {?} */(layer.options)) || {};
                    /** @type {?} */
                    var dataSourceOptions = layer.dataSource.options || {};
                    /** @type {?} */
                    var metadata = layerOptions.metadata || ( /** @type {?} */({}));
                    /** @type {?} */
                    var keywords = metadata.keywordList || [];
                    /** @type {?} */
                    var layerKeywords = keywords.map(( /**
                     * @param {?} kw
                     * @return {?}
                     */function (kw) {
                        return kw.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
                    }));
                    if (keyword) {
                        /** @type {?} */
                        var localKeyword = keyword.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
                        /** @type {?} */
                        var layerTitle = layer.title.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
                        /** @type {?} */
                        var dataSourceType = dataSourceOptions.type || '';
                        /** @type {?} */
                        var keywordRegex_1 = new RegExp(localKeyword, 'gi');
                        /** @type {?} */
                        var keywordInList = layerKeywords.find(( /**
                         * @param {?} kw
                         * @return {?}
                         */function (kw) { return keywordRegex_1.test(kw); })) !== undefined;
                        if (!keywordRegex_1.test(layerTitle) &&
                            !(keyword.toLowerCase() === dataSourceType.toLowerCase()) &&
                            !keywordInList) {
                            /** @type {?} */
                            var index = keepLayerIds.indexOf(layer.id);
                            if (index > -1) {
                                keepLayerIds.splice(index, 1);
                            }
                        }
                    }
                    if (_this.onlyVisible && layer.visible === false) {
                        /** @type {?} */
                        var index = keepLayerIds.indexOf(layer.id);
                        if (index > -1) {
                            keepLayerIds.splice(index, 1);
                        }
                    }
                    if (_this.onlyInRange && layer.isInResolutionsRange === false) {
                        /** @type {?} */
                        var index = keepLayerIds.indexOf(layer.id);
                        if (index > -1) {
                            keepLayerIds.splice(index, 1);
                        }
                    }
                }));
                return layers.filter(( /**
                 * @param {?} layer
                 * @return {?}
                 */function (layer) { return keepLayerIds.indexOf(layer.id) !== -1; }));
            };
        /**
         * @private
         * @param {?} layers
         * @return {?}
         */
        LayerListComponent.prototype.sortLayersByZindex = /**
         * @private
         * @param {?} layers
         * @return {?}
         */
            function (layers) {
                return layers.sort(( /**
                 * @param {?} layer1
                 * @param {?} layer2
                 * @return {?}
                 */function (layer1, layer2) { return layer2.zIndex - layer1.zIndex; }));
            };
        /**
         * @private
         * @param {?} layers
         * @return {?}
         */
        LayerListComponent.prototype.sortLayersByTitle = /**
         * @private
         * @param {?} layers
         * @return {?}
         */
            function (layers) {
                return layers.sort(( /**
                 * @param {?} a
                 * @param {?} b
                 * @return {?}
                 */function (a, b) {
                    if (a.title < b.title) {
                        return -1;
                    }
                    if (a.title > b.title) {
                        return 1;
                    }
                    return 0;
                }));
            };
        /**
         * @private
         * @return {?}
         */
        LayerListComponent.prototype.computeOrderable = /**
         * @private
         * @return {?}
         */
            function () {
                if (this.onlyInRange || this.onlyVisible ||
                    this.sortedAlpha || this.keyword) {
                    return false;
                }
                return true;
            };
        /**
         * @private
         * @return {?}
         */
        LayerListComponent.prototype.computeShowToolbar = /**
         * @private
         * @return {?}
         */
            function () {
                switch (this.layerFilterAndSortOptions.showToolbar) {
                    case LayerListControlsEnum.always:
                        return true;
                    case LayerListControlsEnum.never:
                        return false;
                    default:
                        if (this.layers.length >= this.thresholdToFilterAndSort ||
                            this.keyword ||
                            this.onlyInRange ||
                            this.onlyVisible) {
                            return true;
                        }
                        return false;
                }
            };
        /**
         * @private
         * @return {?}
         */
        LayerListComponent.prototype.initLayerFilterAndSortOptions = /**
         * @private
         * @return {?}
         */
            function () {
                if (this.layerFilterAndSortOptions.toolbarThreshold) {
                    this.thresholdToFilterAndSort = this.layerFilterAndSortOptions.toolbarThreshold;
                }
                if (this.layerFilterAndSortOptions.keyword && !this.keywordInitialized) {
                    this.keyword = this.layerFilterAndSortOptions.keyword;
                    this.keywordInitialized = true;
                }
                if (this.layerFilterAndSortOptions.sortedAlpha && !this.sortedAlphaInitialized) {
                    this.sortedAlpha = this.layerFilterAndSortOptions.sortedAlpha;
                    this.sortedAlphaInitialized = true;
                }
                if (this.layerFilterAndSortOptions.onlyVisible && !this.onlyVisibleInitialized &&
                    this.hasLayerNotVisible) {
                    this.onlyVisible = this.layerFilterAndSortOptions.onlyVisible;
                    this.onlyVisibleInitialized = true;
                }
                if (this.layerFilterAndSortOptions.onlyInRange && !this.onlyInRangeInitialized &&
                    this.hasLayerOutOfRange) {
                    this.onlyInRange = this.layerFilterAndSortOptions.onlyInRange;
                    this.onlyInRangeInitialized = true;
                }
            };
        /**
         * @private
         * @param {?} layers
         * @return {?}
         */
        LayerListComponent.prototype.setLayers = /**
         * @private
         * @param {?} layers
         * @return {?}
         */
            function (layers) {
                this._layers = layers;
                this.orderable = this.computeOrderable();
                if (this.excludeBaseLayers) {
                    this.hasLayerNotVisible = layers.find(( /**
                     * @param {?} l
                     * @return {?}
                     */function (l) { return l.visible === false && !l.baseLayer; })) !== undefined;
                    this.hasLayerOutOfRange = layers.find(( /**
                     * @param {?} l
                     * @return {?}
                     */function (l) { return l.isInResolutionsRange === false && !l.baseLayer; })) !== undefined;
                }
                else {
                    this.hasLayerNotVisible = layers.find(( /**
                     * @param {?} l
                     * @return {?}
                     */function (l) { return l.visible === false; })) !== undefined;
                    this.hasLayerOutOfRange = layers.find(( /**
                     * @param {?} l
                     * @return {?}
                     */function (l) { return l.isInResolutionsRange === false; })) !== undefined;
                }
            };
        LayerListComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'igo-layer-list',
                        template: "<igo-list [navigation]=\"false\" [selection]=\"false\">\r\n  <mat-list-item *ngIf=\"showToolbar$ | async\">\r\n    <ng-container>\r\n      <mat-form-field class=\"inputFilter\" [floatLabel]=\"floatLabel\">\r\n        <input\r\n          matInput\r\n          [placeholder]=\"placeholder\"\r\n          [matTooltip]=\"'igo.geo.layer.subsetLayersListKeyword' | translate\"\r\n          matTooltipShowDelay=\"500\"\r\n          type=\"text\" [(ngModel)]=\"keyword\">\r\n        <button\r\n          mat-button\r\n          *ngIf=\"keyword\"\r\n          matSuffix\r\n          mat-icon-button\r\n          aria-label=\"Clear\"\r\n          color=\"warn\"\r\n          (click)=\"clearKeyword()\">\r\n          <mat-icon svgIcon=\"close\"></mat-icon>\r\n        </button>\r\n      </mat-form-field>\r\n      <button\r\n        *ngIf=\"!sortedAlpha\"\r\n        mat-icon-button\r\n        [matTooltip]=\"'igo.geo.layer.sortAlphabetically' | translate\"\r\n        matTooltipShowDelay=\"500\"\r\n        (click)=\"toggleSort(true)\">\r\n        <mat-icon color=\"primary\" svgIcon=\"sort-alphabetical\"></mat-icon>\r\n      </button>\r\n      <button\r\n        *ngIf=\"sortedAlpha\"\r\n        mat-icon-button\r\n        [matTooltip]=\"'igo.geo.layer.sortMapOrder' | translate\"\r\n        matTooltipShowDelay=\"500\"\r\n        (click)=\"toggleSort(false)\">\r\n        <mat-icon color=\"warn\" svgIcon=\"alert\"></mat-icon>\r\n      </button>\r\n      <button\r\n        mat-icon-button\r\n        [disabled]=\"!hasLayerNotVisible\"\r\n        [matTooltip]=\"onlyVisible ?\r\n        ('igo.geo.layer.resetLayersList' | translate) :\r\n        ('igo.geo.layer.subsetLayersListOnlyVisible' | translate)\"\r\n        matTooltipShowDelay=\"500\"\r\n        [color]=\"onlyVisible ? 'warn' : 'primary'\"\r\n        (click)=\"toggleOnlyVisible()\">\r\n        <mat-icon [svgIcon]=\"!onlyVisible ? 'eye' : 'alert'\"></mat-icon>\r\n      </button>\r\n      <button\r\n        mat-icon-button\r\n        [disabled]=\"!hasLayerOutOfRange\"\r\n        [matTooltip]=\"onlyInRange ?\r\n        ('igo.geo.layer.resetLayersList' | translate) :\r\n        ('igo.geo.layer.subsetLayersListOnlyInRange' | translate)\"\r\n        matTooltipShowDelay=\"500\"\r\n        [color]=\"onlyInRange ? 'warn' : 'primary'\"\r\n        (click)=\"toggleOnlyInRange()\">\r\n        <mat-icon [svgIcon]=\"!onlyInRange ? 'playlist-check' : 'alert'\"></mat-icon>\r\n      </button>\r\n    </ng-container>\r\n  </mat-list-item>\r\n\r\n  <ng-template ngFor let-layer [ngForOf]=\"layers$ | async\">\r\n    <igo-layer-item *ngIf=\"!(excludeBaseLayers && layer.baseLayer)\"\r\n        igoListItem\r\n        [layer]=\"layer\"\r\n        [orderable]=\"orderable\"\r\n        [queryBadge]=\"queryBadge\"\r\n        [expandLegendIfVisible]=\"expandLegendOfVisibleLayers\"\r\n        [updateLegendOnResolutionChange]=\"updateLegendOnResolutionChange\"\r\n        [toggleLegendOnVisibilityChange]=\"toggleLegendOnVisibilityChange\">\r\n\r\n        <ng-container igoLayerItemToolbar\r\n          [ngTemplateOutlet]=\"templateLayerToolbar\"\r\n          [ngTemplateOutletContext]=\"{layer: layer}\">\r\n        </ng-container>\r\n\r\n    </igo-layer-item>\r\n  </ng-template>\r\n</igo-list>\r\n",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        styles: ["mat-form-field.inputFilter{width:calc(100% - 100px);max-width:200px}"]
                    }] }
        ];
        /** @nocollapse */
        LayerListComponent.ctorParameters = function () {
            return [
                { type: i0.ChangeDetectorRef },
                { type: LayerListService }
            ];
        };
        LayerListComponent.propDecorators = {
            templateLayerToolbar: [{ type: i0.ContentChild, args: ['igoLayerItemToolbar',] }],
            layers: [{ type: i0.Input }],
            placeholder: [{ type: i0.Input }],
            floatLabel: [{ type: i0.Input }],
            layerFilterAndSortOptions: [{ type: i0.Input }],
            excludeBaseLayers: [{ type: i0.Input }],
            toggleLegendOnVisibilityChange: [{ type: i0.Input }],
            expandLegendOfVisibleLayers: [{ type: i0.Input }],
            updateLegendOnResolutionChange: [{ type: i0.Input }],
            queryBadge: [{ type: i0.Input }]
        };
        return LayerListComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * MapService
     *
     * This service tracks the IgoMap instance, if any.
     * Currently, only one map instance is supported
     * but support for multiple maps may be added in the future.
     * This will impact other services such as the OverlayService
     * because these maps won't be sharing overlayed features.
     */
    var MapService = /** @class */ (function () {
        function MapService() {
        }
        /**
         * @return {?}
         */
        MapService.prototype.getMap = /**
         * @return {?}
         */
            function () {
                return this.map;
            };
        /**
         * @param {?} map
         * @return {?}
         */
        MapService.prototype.setMap = /**
         * @param {?} map
         * @return {?}
         */
            function (map) {
                this.map = map;
            };
        MapService.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        MapService.ctorParameters = function () { return []; };
        /** @nocollapse */ MapService.ngInjectableDef = i0.defineInjectable({ factory: function MapService_Factory() { return new MapService(); }, token: MapService, providedIn: "root" });
        return MapService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var LayerListBindingDirective = /** @class */ (function () {
        function LayerListBindingDirective(component, mapService, layerListService, route) {
            this.mapService = mapService;
            this.layerListService = layerListService;
            this.route = route;
            this.component = component;
        }
        /**
         * @return {?}
         */
        LayerListBindingDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // Override input layers
                this.component.layers = [];
                this.layers$$ = this.mapService
                    .getMap()
                    .layers$.subscribe(( /**
             * @param {?} layers
             * @return {?}
             */function (layers) {
                    _this.component.layers = layers.filter(( /**
                     * @param {?} layer
                     * @return {?}
                     */function (layer) {
                        return layer.showInLayerList === true;
                    }));
                }));
            };
        /**
         * @return {?}
         */
        LayerListBindingDirective.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                this.initRoutes();
            };
        /**
         * @private
         * @return {?}
         */
        LayerListBindingDirective.prototype.initRoutes = /**
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.route &&
                    (this.route.options.llcKKey || this.route.options.llcAKey ||
                        this.route.options.llcVKey || this.route.options.llcVKey)) {
                    this.route.queryParams.subscribe(( /**
                     * @param {?} params
                     * @return {?}
                     */function (params) {
                        /** @type {?} */
                        var keywordFromUrl = params[( /** @type {?} */(_this.route.options.llcKKey))];
                        /** @type {?} */
                        var sortedAplhaFromUrl = params[( /** @type {?} */(_this.route.options.llcAKey))];
                        /** @type {?} */
                        var onlyVisibleFromUrl = params[( /** @type {?} */(_this.route.options.llcVKey))];
                        /** @type {?} */
                        var onlyInRangeFromUrl = params[( /** @type {?} */(_this.route.options.llcRKey))];
                        if (keywordFromUrl && !_this.layerListService.keywordInitialized) {
                            _this.layerListService.keyword = keywordFromUrl;
                            _this.layerListService.keywordInitialized = true;
                        }
                        if (sortedAplhaFromUrl && !_this.layerListService.sortedAlphaInitialized) {
                            _this.layerListService.sortedAlpha = sortedAplhaFromUrl === '1' ? true : false;
                            _this.layerListService.sortedAlphaInitialized = true;
                        }
                        if (onlyVisibleFromUrl &&
                            !_this.layerListService.onlyVisibleInitialized &&
                            _this.component.hasLayerNotVisible) {
                            _this.layerListService.onlyVisible = onlyVisibleFromUrl === '1' ? true : false;
                            _this.layerListService.onlyVisibleInitialized = true;
                        }
                        if (onlyInRangeFromUrl &&
                            !_this.layerListService.onlyInRangeInitialized &&
                            _this.component.hasLayerOutOfRange) {
                            _this.layerListService.onlyInRange = onlyInRangeFromUrl === '1' ? true : false;
                            _this.layerListService.onlyInRangeInitialized = true;
                        }
                    }));
                }
            };
        /**
         * @return {?}
         */
        LayerListBindingDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.layers$$.unsubscribe();
            };
        LayerListBindingDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[igoLayerListBinding]'
                    },] }
        ];
        /** @nocollapse */
        LayerListBindingDirective.ctorParameters = function () {
            return [
                { type: LayerListComponent, decorators: [{ type: i0.Self }] },
                { type: MapService },
                { type: LayerListService },
                { type: i1$1.RouteService, decorators: [{ type: i0.Optional }] }
            ];
        };
        return LayerListBindingDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Strategies or responsible of synchronizing a feature store and a layer.
     * A strategy can be shared among multiple stores. Sharing a strategy
     * is a good idea when multiple strategies would have on cancelling effect
     * on each other.
     *
     * At creation, strategy is inactive and needs to be manually activated.
     */
    var /**
     * Strategies or responsible of synchronizing a feature store and a layer.
     * A strategy can be shared among multiple stores. Sharing a strategy
     * is a good idea when multiple strategies would have on cancelling effect
     * on each other.
     *
     * At creation, strategy is inactive and needs to be manually activated.
     */ FeatureStoreStrategy = /** @class */ (function () {
        function FeatureStoreStrategy(options) {
            if (options === void 0) {
                options = {};
            }
            this.options = options;
            /**
             * Feature store
             * \@internal
             */
            this.stores = [];
            /**
             * Whether this strategy is active
             * \@internal
             */
            this.active = false;
            this.options = options;
        }
        /**
         * Whether this strategy is active
         */
        /**
         * Whether this strategy is active
         * @return {?}
         */
        FeatureStoreStrategy.prototype.isActive = /**
         * Whether this strategy is active
         * @return {?}
         */
            function () { return this.active; };
        /**
         * Activate the strategy. If it's already active, it'll be deactivated
         * and activated again.
         */
        /**
         * Activate the strategy. If it's already active, it'll be deactivated
         * and activated again.
         * @return {?}
         */
        FeatureStoreStrategy.prototype.activate = /**
         * Activate the strategy. If it's already active, it'll be deactivated
         * and activated again.
         * @return {?}
         */
            function () {
                if (this.active === true) {
                    this.doDeactivate();
                }
                this.active = true;
                this.doActivate();
            };
        /**
         * Activate the strategy. If it's already active, it'll be deactivated
         * and activated again.
         */
        /**
         * Activate the strategy. If it's already active, it'll be deactivated
         * and activated again.
         * @return {?}
         */
        FeatureStoreStrategy.prototype.deactivate = /**
         * Activate the strategy. If it's already active, it'll be deactivated
         * and activated again.
         * @return {?}
         */
            function () {
                this.active = false;
                this.doDeactivate();
            };
        /**
         * Bind this strategy to a store
         * @param store Feature store
         */
        /**
         * Bind this strategy to a store
         * @param {?} store Feature store
         * @return {?}
         */
        FeatureStoreStrategy.prototype.bindStore = /**
         * Bind this strategy to a store
         * @param {?} store Feature store
         * @return {?}
         */
            function (store) {
                if (this.stores.indexOf(store) < 0) {
                    this.stores.push(store);
                }
            };
        /**
         * Unbind this strategy from store
         * @param store Feature store
         */
        /**
         * Unbind this strategy from store
         * @param {?} store Feature store
         * @return {?}
         */
        FeatureStoreStrategy.prototype.unbindStore = /**
         * Unbind this strategy from store
         * @param {?} store Feature store
         * @return {?}
         */
            function (store) {
                /** @type {?} */
                var index = this.stores.indexOf(store);
                if (index >= 0) {
                    this.stores.splice(index, 1);
                }
            };
        /**
         * Do the stataegy activation
         * @internal
         */
        /**
         * Do the stataegy activation
         * \@internal
         * @protected
         * @return {?}
         */
        FeatureStoreStrategy.prototype.doActivate = /**
         * Do the stataegy activation
         * \@internal
         * @protected
         * @return {?}
         */
            function () { };
        /**
         * Do the strategy deactivation
         * @internal
         */
        /**
         * Do the strategy deactivation
         * \@internal
         * @protected
         * @return {?}
         */
        FeatureStoreStrategy.prototype.doDeactivate = /**
         * Do the strategy deactivation
         * \@internal
         * @protected
         * @return {?}
         */
            function () { };
        return FeatureStoreStrategy;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * This strategy loads a store's features into it's layer counterpart.
     * The store -> layer binding is a one-way binding. That means any entity
     * added to the store will be added to the layer but the opposite is false.
     *
     * Important: This strategy observes filtered entities, not raw entities. This
     * is not configurable yet.
     */
    var /**
     * This strategy loads a store's features into it's layer counterpart.
     * The store -> layer binding is a one-way binding. That means any entity
     * added to the store will be added to the layer but the opposite is false.
     *
     * Important: This strategy observes filtered entities, not raw entities. This
     * is not configurable yet.
     */ FeatureStoreLoadingStrategy = /** @class */ (function (_super) {
        __extends(FeatureStoreLoadingStrategy, _super);
        function FeatureStoreLoadingStrategy(options) {
            var _this = _super.call(this, options) || this;
            _this.options = options;
            /**
             * Subscription to the store's features
             */
            _this.stores$$ = new Map();
            return _this;
        }
        /**
         * Bind this strategy to a store and start watching for entities changes
         * @param store Feature store
         */
        /**
         * Bind this strategy to a store and start watching for entities changes
         * @param {?} store Feature store
         * @return {?}
         */
        FeatureStoreLoadingStrategy.prototype.bindStore = /**
         * Bind this strategy to a store and start watching for entities changes
         * @param {?} store Feature store
         * @return {?}
         */
            function (store) {
                _super.prototype.bindStore.call(this, store);
                if (this.isActive() === true) {
                    this.watchStore(store);
                }
            };
        /**
         * Unbind this strategy from a store and stop watching for entities changes
         * @param store Feature store
         */
        /**
         * Unbind this strategy from a store and stop watching for entities changes
         * @param {?} store Feature store
         * @return {?}
         */
        FeatureStoreLoadingStrategy.prototype.unbindStore = /**
         * Unbind this strategy from a store and stop watching for entities changes
         * @param {?} store Feature store
         * @return {?}
         */
            function (store) {
                _super.prototype.unbindStore.call(this, store);
                if (this.isActive() === true) {
                    this.unwatchStore(store);
                }
            };
        /**
         * Start watching all stores already bound to that strategy at once.
         * @internal
         */
        /**
         * Start watching all stores already bound to that strategy at once.
         * \@internal
         * @protected
         * @return {?}
         */
        FeatureStoreLoadingStrategy.prototype.doActivate = /**
         * Start watching all stores already bound to that strategy at once.
         * \@internal
         * @protected
         * @return {?}
         */
            function () {
                var _this = this;
                this.stores.forEach(( /**
                 * @param {?} store
                 * @return {?}
                 */function (store) { return _this.watchStore(store); }));
            };
        /**
         * Stop watching all stores bound to that strategy
         * @internal
         */
        /**
         * Stop watching all stores bound to that strategy
         * \@internal
         * @protected
         * @return {?}
         */
        FeatureStoreLoadingStrategy.prototype.doDeactivate = /**
         * Stop watching all stores bound to that strategy
         * \@internal
         * @protected
         * @return {?}
         */
            function () {
                this.unwatchAll();
            };
        /**
         * Watch for entities changes in a store.
         * Important: Never observe a store's sorted entities. It makes no sense
         * to display sorted entities (instead of unsorted) on a layer and it
         * would potentially result in a lot of useless computation.
         * @param store Feature store
         */
        /**
         * Watch for entities changes in a store.
         * Important: Never observe a store's sorted entities. It makes no sense
         * to display sorted entities (instead of unsorted) on a layer and it
         * would potentially result in a lot of useless computation.
         * @private
         * @param {?} store Feature store
         * @return {?}
         */
        FeatureStoreLoadingStrategy.prototype.watchStore = /**
         * Watch for entities changes in a store.
         * Important: Never observe a store's sorted entities. It makes no sense
         * to display sorted entities (instead of unsorted) on a layer and it
         * would potentially result in a lot of useless computation.
         * @private
         * @param {?} store Feature store
         * @return {?}
         */
            function (store) {
                var _this = this;
                if (this.stores$$.has(store)) {
                    return;
                }
                /** @type {?} */
                var subscription = store.view.all$()
                    .subscribe(( /**
             * @param {?} features
             * @return {?}
             */function (features) { return _this.onFeaturesChange(features, store); }));
                this.stores$$.set(store, subscription);
            };
        /**
         * Stop watching for entities changes in a store.
         * @param store Feature store
         */
        /**
         * Stop watching for entities changes in a store.
         * @private
         * @param {?} store Feature store
         * @return {?}
         */
        FeatureStoreLoadingStrategy.prototype.unwatchStore = /**
         * Stop watching for entities changes in a store.
         * @private
         * @param {?} store Feature store
         * @return {?}
         */
            function (store) {
                /** @type {?} */
                var subscription = this.stores$$.get(store);
                if (subscription !== undefined) {
                    subscription.unsubscribe();
                    this.stores$$.delete(store);
                }
            };
        /**
         * Stop watching for entities changes in all stores.
         */
        /**
         * Stop watching for entities changes in all stores.
         * @private
         * @return {?}
         */
        FeatureStoreLoadingStrategy.prototype.unwatchAll = /**
         * Stop watching for entities changes in all stores.
         * @private
         * @return {?}
         */
            function () {
                Array.from(this.stores$$.entries()).forEach(( /**
                 * @param {?} entries
                 * @return {?}
                 */function (entries) {
                    entries[1].unsubscribe();
                }));
                this.stores$$.clear();
            };
        /**
         * Load features into a layer or clear the layer if the array of features is empty.
         * @param features Store filtered features
         * @param store Feature store
         */
        /**
         * Load features into a layer or clear the layer if the array of features is empty.
         * @private
         * @param {?} features Store filtered features
         * @param {?} store Feature store
         * @return {?}
         */
        FeatureStoreLoadingStrategy.prototype.onFeaturesChange = /**
         * Load features into a layer or clear the layer if the array of features is empty.
         * @private
         * @param {?} features Store filtered features
         * @param {?} store Feature store
         * @return {?}
         */
            function (features, store) {
                if (features.length === 0) {
                    store.clearLayer();
                }
                else {
                    store.setLayerFeatures(features, this.selectMotion(store), this.options.viewScale, this.options.areaRatio, this.options.getFeatureId);
                }
            };
        /**
         * Selects the best motion
         * @param store A FeatureStore to apply the motion
         * @returns The motion selected
         */
        /**
         * Selects the best motion
         * @private
         * @param {?} store A FeatureStore to apply the motion
         * @return {?} The motion selected
         */
        FeatureStoreLoadingStrategy.prototype.selectMotion = /**
         * Selects the best motion
         * @private
         * @param {?} store A FeatureStore to apply the motion
         * @return {?} The motion selected
         */
            function (store) {
                if (this.options.motion !== undefined) {
                    return this.options.motion;
                }
                if (store.pristine === true) {
                    // If features have just been loaded into the store, move/zoom on them
                    return FeatureMotion.Default;
                }
                else if (store.count > store.view.count) {
                    // If features have been filtered, move/zoom on the remaining ones
                    return FeatureMotion.Default;
                }
                else {
                    // On insert, update or delete, do nothing
                    return FeatureMotion.None;
                }
            };
        return FeatureStoreLoadingStrategy;
    }(FeatureStoreStrategy));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * This strategy loads a layer's features into it's store counterpart.
     * The layer -> store binding is a one-way binding. That means any OL feature
     * added to the layer will be added to the store but the opposite is false.
     *
     * Important: In it's current state, this strategy is to meant to be combined
     * with a standard Loading strategy and it would probably cause recursion issues.
     */
    var /**
     * This strategy loads a layer's features into it's store counterpart.
     * The layer -> store binding is a one-way binding. That means any OL feature
     * added to the layer will be added to the store but the opposite is false.
     *
     * Important: In it's current state, this strategy is to meant to be combined
     * with a standard Loading strategy and it would probably cause recursion issues.
     */ FeatureStoreLoadingLayerStrategy = /** @class */ (function (_super) {
        __extends(FeatureStoreLoadingLayerStrategy, _super);
        function FeatureStoreLoadingLayerStrategy(options) {
            var _this = _super.call(this, options) || this;
            _this.options = options;
            /**
             * Subscription to the store's OL source changes
             */
            _this.stores$$ = new Map();
            return _this;
        }
        /**
         * Bind this strategy to a store and start watching for Ol source changes
         * @param store Feature store
         */
        /**
         * Bind this strategy to a store and start watching for Ol source changes
         * @param {?} store Feature store
         * @return {?}
         */
        FeatureStoreLoadingLayerStrategy.prototype.bindStore = /**
         * Bind this strategy to a store and start watching for Ol source changes
         * @param {?} store Feature store
         * @return {?}
         */
            function (store) {
                _super.prototype.bindStore.call(this, store);
                if (this.isActive() === true) {
                    this.watchStore(store);
                }
            };
        /**
         * Unbind this strategy from a store and stop watching for Ol source changes
         * @param store Feature store
         */
        /**
         * Unbind this strategy from a store and stop watching for Ol source changes
         * @param {?} store Feature store
         * @return {?}
         */
        FeatureStoreLoadingLayerStrategy.prototype.unbindStore = /**
         * Unbind this strategy from a store and stop watching for Ol source changes
         * @param {?} store Feature store
         * @return {?}
         */
            function (store) {
                _super.prototype.unbindStore.call(this, store);
                if (this.isActive() === true) {
                    this.unwatchStore(store);
                }
            };
        /**
         * Start watching all stores already bound to that strategy at once.
         * @internal
         */
        /**
         * Start watching all stores already bound to that strategy at once.
         * \@internal
         * @protected
         * @return {?}
         */
        FeatureStoreLoadingLayerStrategy.prototype.doActivate = /**
         * Start watching all stores already bound to that strategy at once.
         * \@internal
         * @protected
         * @return {?}
         */
            function () {
                var _this = this;
                this.stores.forEach(( /**
                 * @param {?} store
                 * @return {?}
                 */function (store) { return _this.watchStore(store); }));
            };
        /**
         * Stop watching all stores bound to that strategy
         * @internal
         */
        /**
         * Stop watching all stores bound to that strategy
         * \@internal
         * @protected
         * @return {?}
         */
        FeatureStoreLoadingLayerStrategy.prototype.doDeactivate = /**
         * Stop watching all stores bound to that strategy
         * \@internal
         * @protected
         * @return {?}
         */
            function () {
                this.unwatchAll();
            };
        /**
         * Watch for a store's  OL source changes
         * @param store Feature store
         */
        /**
         * Watch for a store's  OL source changes
         * @private
         * @param {?} store Feature store
         * @return {?}
         */
        FeatureStoreLoadingLayerStrategy.prototype.watchStore = /**
         * Watch for a store's  OL source changes
         * @private
         * @param {?} store Feature store
         * @return {?}
         */
            function (store) {
                var _this = this;
                if (this.stores$$.has(store)) {
                    return;
                }
                this.onSourceChanges(store);
                /** @type {?} */
                var olSource = store.layer.ol.getSource();
                olSource.on('change', ( /**
                 * @param {?} event
                 * @return {?}
                 */function (event) {
                    _this.onSourceChanges(store);
                }));
            };
        /**
         * Stop watching for a store's OL source changes
         * @param store Feature store
         */
        /**
         * Stop watching for a store's OL source changes
         * @private
         * @param {?} store Feature store
         * @return {?}
         */
        FeatureStoreLoadingLayerStrategy.prototype.unwatchStore = /**
         * Stop watching for a store's OL source changes
         * @private
         * @param {?} store Feature store
         * @return {?}
         */
            function (store) {
                /** @type {?} */
                var key = this.stores$$.get(store);
                if (key !== undefined) {
                    olobservable.unByKey(key);
                    this.stores$$.delete(store);
                }
            };
        /**
         * Stop watching for OL source changes in all stores.
         */
        /**
         * Stop watching for OL source changes in all stores.
         * @private
         * @return {?}
         */
        FeatureStoreLoadingLayerStrategy.prototype.unwatchAll = /**
         * Stop watching for OL source changes in all stores.
         * @private
         * @return {?}
         */
            function () {
                Array.from(this.stores$$.entries()).forEach(( /**
                 * @param {?} entries
                 * @return {?}
                 */function (entries) {
                    olobservable.unByKey(entries[1]);
                }));
                this.stores$$.clear();
            };
        /**
         * Load features from an OL source into a  store or clear the store if the source is empty
         * @param features Store filtered features
         * @param store Feature store
         */
        /**
         * Load features from an OL source into a  store or clear the store if the source is empty
         * @private
         * @param {?} store Feature store
         * @return {?}
         */
        FeatureStoreLoadingLayerStrategy.prototype.onSourceChanges = /**
         * Load features from an OL source into a  store or clear the store if the source is empty
         * @private
         * @param {?} store Feature store
         * @return {?}
         */
            function (store) {
                /** @type {?} */
                var olFeatures = store.layer.ol.getSource().getFeatures();
                if (olFeatures.length === 0) {
                    store.clear();
                }
                else {
                    store.setStoreOlFeatures(olFeatures);
                }
            };
        return FeatureStoreLoadingLayerStrategy;
    }(FeatureStoreStrategy));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * The class is a specialized version of an EntityStore that stores
     * features and the map layer to display them on. Synchronization
     * between the store and the layer is handled by strategies.
     * @template T
     */
    var /**
     * The class is a specialized version of an EntityStore that stores
     * features and the map layer to display them on. Synchronization
     * between the store and the layer is handled by strategies.
     * @template T
     */ FeatureStore = /** @class */ (function (_super) {
        __extends(FeatureStore, _super);
        function FeatureStore(entities, options) {
            var _this = _super.call(this, entities, options) || this;
            /**
             * Feature store strategies responsible of synchronizing the store
             * and the layer
             */
            _this.strategies = [];
            _this.map = options.map;
            return _this;
        }
        Object.defineProperty(FeatureStore.prototype, "source", {
            /**
             * The layer's data source
             */
            get: /**
             * The layer's data source
             * @return {?}
             */ function () {
                return this.layer ? ( /** @type {?} */(this.layer.dataSource)) : undefined;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Bind this store to a vector layer
         * @param layer Vector layer
         * @returns Feature store
         */
        /**
         * Bind this store to a vector layer
         * @param {?} layer Vector layer
         * @return {?} Feature store
         */
        FeatureStore.prototype.bindLayer = /**
         * Bind this store to a vector layer
         * @param {?} layer Vector layer
         * @return {?} Feature store
         */
            function (layer) {
                this.layer = layer;
                return this;
            };
        /**
         * Add a strategy to this store
         * @param strategy Feature store strategy
         * @returns Feature store
         */
        /**
         * Add a strategy to this store
         * @param {?} strategy Feature store strategy
         * @param {?=} activate
         * @return {?} Feature store
         */
        FeatureStore.prototype.addStrategy = /**
         * Add a strategy to this store
         * @param {?} strategy Feature store strategy
         * @param {?=} activate
         * @return {?} Feature store
         */
            function (strategy, activate) {
                if (activate === void 0) {
                    activate = false;
                }
                /** @type {?} */
                var existingStrategy = this.strategies.find(( /**
                 * @param {?} _strategy
                 * @return {?}
                 */function (_strategy) {
                    return strategy.constructor === _strategy.constructor;
                }));
                if (existingStrategy !== undefined) {
                    throw new Error('A strategy of this type already exists on that FeatureStore.');
                }
                this.strategies.push(strategy);
                strategy.bindStore(this);
                if (activate === true) {
                    strategy.activate();
                }
                return this;
            };
        /**
         * Remove a strategy from this store
         * @param strategy Feature store strategy
         * @returns Feature store
         */
        /**
         * Remove a strategy from this store
         * @param {?} strategy Feature store strategy
         * @return {?} Feature store
         */
        FeatureStore.prototype.removeStrategy = /**
         * Remove a strategy from this store
         * @param {?} strategy Feature store strategy
         * @return {?} Feature store
         */
            function (strategy) {
                /** @type {?} */
                var index = this.strategies.indexOf(strategy);
                if (index >= 0) {
                    this.strategies.splice(index, 1);
                    strategy.unbindStore(this);
                }
                return this;
            };
        /**
         * Return strategies of a given type
         * @param type Feature store strategy class
         * @returns Strategies
         */
        /**
         * Return strategies of a given type
         * @param {?} type Feature store strategy class
         * @return {?} Strategies
         */
        FeatureStore.prototype.getStrategyOfType = /**
         * Return strategies of a given type
         * @param {?} type Feature store strategy class
         * @return {?} Strategies
         */
            function (type) {
                return this.strategies.find(( /**
                 * @param {?} strategy
                 * @return {?}
                 */function (strategy) {
                    return strategy instanceof type;
                }));
            };
        /**
         * Activate strategies of a given type
         * @param type Feature store strategy class
         */
        /**
         * Activate strategies of a given type
         * @param {?} type Feature store strategy class
         * @return {?}
         */
        FeatureStore.prototype.activateStrategyOfType = /**
         * Activate strategies of a given type
         * @param {?} type Feature store strategy class
         * @return {?}
         */
            function (type) {
                /** @type {?} */
                var strategy = this.getStrategyOfType(type);
                if (strategy !== undefined) {
                    strategy.activate();
                }
            };
        /**
         * Deactivate strategies of a given type
         * @param type Feature store strategy class
         */
        /**
         * Deactivate strategies of a given type
         * @param {?} type Feature store strategy class
         * @return {?}
         */
        FeatureStore.prototype.deactivateStrategyOfType = /**
         * Deactivate strategies of a given type
         * @param {?} type Feature store strategy class
         * @return {?}
         */
            function (type) {
                /** @type {?} */
                var strategy = this.getStrategyOfType(type);
                if (strategy !== undefined) {
                    strategy.deactivate();
                }
            };
        /**
         * Set the layer's features and perform a motion to make them visible. Strategies
         * make extensive use of that method.
         * @param features Features
         * @param motion Optional: The type of motion to perform
         */
        /**
         * Set the layer's features and perform a motion to make them visible. Strategies
         * make extensive use of that method.
         * @param {?} features Features
         * @param {?=} motion Optional: The type of motion to perform
         * @param {?=} viewScale
         * @param {?=} areaRatio
         * @param {?=} getId
         * @return {?}
         */
        FeatureStore.prototype.setLayerFeatures = /**
         * Set the layer's features and perform a motion to make them visible. Strategies
         * make extensive use of that method.
         * @param {?} features Features
         * @param {?=} motion Optional: The type of motion to perform
         * @param {?=} viewScale
         * @param {?=} areaRatio
         * @param {?=} getId
         * @return {?}
         */
            function (features, motion, viewScale, areaRatio, getId) {
                var _this = this;
                if (motion === void 0) {
                    motion = FeatureMotion.Default;
                }
                getId = getId ? getId : common$1.getEntityId;
                this.checkLayer();
                /** @type {?} */
                var olFeatures = features
                    .map(( /**
             * @param {?} feature
             * @return {?}
             */function (feature) { return featureToOl(feature, _this.map.projection, getId); }));
                this.setLayerOlFeatures(olFeatures, motion, viewScale, areaRatio);
            };
        /**
         * Set the store's features from an array of OL features.
         * @param olFeatures Ol features
         */
        /**
         * Set the store's features from an array of OL features.
         * @param {?} olFeatures Ol features
         * @return {?}
         */
        FeatureStore.prototype.setStoreOlFeatures = /**
         * Set the store's features from an array of OL features.
         * @param {?} olFeatures Ol features
         * @return {?}
         */
            function (olFeatures) {
                var _this = this;
                this.checkLayer();
                /** @type {?} */
                var features = olFeatures.map(( /**
                 * @param {?} olFeature
                 * @return {?}
                 */function (olFeature) {
                    olFeature.set('_featureStore', _this, true);
                    return featureFromOl(olFeature, _this.layer.map.projection);
                }));
                this.load(( /** @type {?} */(features)));
            };
        /**
         * Remove all features from the layer
         */
        /**
         * Remove all features from the layer
         * @return {?}
         */
        FeatureStore.prototype.clearLayer = /**
         * Remove all features from the layer
         * @return {?}
         */
            function () {
                this.checkLayer();
                this.source.ol.clear();
            };
        /**
         * Check wether a layer is bound or not and throw an error if not.
         */
        /**
         * Check wether a layer is bound or not and throw an error if not.
         * @private
         * @return {?}
         */
        FeatureStore.prototype.checkLayer = /**
         * Check wether a layer is bound or not and throw an error if not.
         * @private
         * @return {?}
         */
            function () {
                if (this.layer === undefined) {
                    throw new Error('This FeatureStore is not bound to a layer.');
                }
            };
        /**
         * Set the layer's features and perform a motion to make them visible.
         * @param features Openlayers feature objects
         * @param motion Optional: The type of motion to perform
         */
        /**
         * Set the layer's features and perform a motion to make them visible.
         * @private
         * @param {?} olFeatures
         * @param {?=} motion Optional: The type of motion to perform
         * @param {?=} viewScale
         * @param {?=} areaRatio
         * @return {?}
         */
        FeatureStore.prototype.setLayerOlFeatures = /**
         * Set the layer's features and perform a motion to make them visible.
         * @private
         * @param {?} olFeatures
         * @param {?=} motion Optional: The type of motion to perform
         * @param {?=} viewScale
         * @param {?=} areaRatio
         * @return {?}
         */
            function (olFeatures, motion, viewScale, areaRatio) {
                if (motion === void 0) {
                    motion = FeatureMotion.Default;
                }
                /** @type {?} */
                var olFeaturesMap = new Map();
                olFeatures.forEach(( /**
                 * @param {?} olFeature
                 * @return {?}
                 */function (olFeature) {
                    olFeaturesMap.set(olFeature.getId(), olFeature);
                }));
                /** @type {?} */
                var olFeaturesToRemove = [];
                this.source.ol.forEachFeature(( /**
                 * @param {?} olFeature
                 * @return {?}
                 */function (olFeature) {
                    /** @type {?} */
                    var newOlFeature = olFeaturesMap.get(olFeature.getId());
                    if (newOlFeature === undefined) {
                        olFeaturesToRemove.push(olFeature);
                    }
                    else if (newOlFeature.get('_entityRevision') !== olFeature.get('_entityRevision')) {
                        olFeaturesToRemove.push(olFeature);
                    }
                    else {
                        olFeaturesMap.delete(newOlFeature.getId());
                    }
                }));
                /** @type {?} */
                var olFeaturesToAddIds = Array.from(olFeaturesMap.keys());
                /** @type {?} */
                var olFeaturesToAdd = olFeatures.filter(( /**
                 * @param {?} olFeature
                 * @return {?}
                 */function (olFeature) {
                    return olFeaturesToAddIds.indexOf(olFeature.getId()) >= 0;
                }));
                if (olFeaturesToRemove.length > 0) {
                    this.removeOlFeaturesFromLayer(olFeaturesToRemove);
                }
                if (olFeaturesToAdd.length > 0) {
                    this.addOlFeaturesToLayer(olFeaturesToAdd);
                }
                if (olFeaturesToAdd.length > 0) {
                    // If features are added, do a motion toward the newly added features
                    moveToOlFeatures(this.map, olFeaturesToAdd, motion, viewScale, areaRatio);
                }
                else if (olFeatures.length > 0) {
                    // Else, do a motion toward all the features
                    moveToOlFeatures(this.map, olFeatures, motion, viewScale, areaRatio);
                }
            };
        /**
         * Add features to the the layer
         * @param features Openlayers feature objects
         */
        /**
         * Add features to the the layer
         * @private
         * @param {?} olFeatures
         * @return {?}
         */
        FeatureStore.prototype.addOlFeaturesToLayer = /**
         * Add features to the the layer
         * @private
         * @param {?} olFeatures
         * @return {?}
         */
            function (olFeatures) {
                var _this = this;
                olFeatures.forEach(( /**
                 * @param {?} olFeature
                 * @return {?}
                 */function (olFeature) {
                    olFeature.set('_featureStore', _this, true);
                }));
                this.source.ol.addFeatures(olFeatures);
            };
        /**
         * Remove features from the the layer
         * @param features Openlayers feature objects
         */
        /**
         * Remove features from the the layer
         * @private
         * @param {?} olFeatures
         * @return {?}
         */
        FeatureStore.prototype.removeOlFeaturesFromLayer = /**
         * Remove features from the the layer
         * @private
         * @param {?} olFeatures
         * @return {?}
         */
            function (olFeatures) {
                var _this = this;
                olFeatures.forEach(( /**
                 * @param {?} olFeature
                 * @return {?}
                 */function (olFeature) {
                    _this.source.ol.removeFeature(olFeature);
                }));
            };
        return FeatureStore;
    }(common$1.EntityStore));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var OlDragSelectInteraction = /** @class */ (function (_super) {
        __extends(OlDragSelectInteraction, _super);
        function OlDragSelectInteraction(options) {
            return _super.call(this, options) || this;
        }
        return OlDragSelectInteraction;
    }(OlDragBoxInteraction));
    /**
     * This strategy synchronizes a store and a layer selected entities.
     * The store <-> layer binding is a two-way binding.
     *
     * In many cases, a single strategy bound to multiple stores
     * will yield better results that multiple strategies with each their
     * own store. In the latter scenario, a click on overlapping features
     * would trigger the strategy of each layer and they would cancel
     * each other as well as move the map view around needlessly.
     */
    var /**
     * This strategy synchronizes a store and a layer selected entities.
     * The store <-> layer binding is a two-way binding.
     *
     * In many cases, a single strategy bound to multiple stores
     * will yield better results that multiple strategies with each their
     * own store. In the latter scenario, a click on overlapping features
     * would trigger the strategy of each layer and they would cancel
     * each other as well as move the map view around needlessly.
     */ FeatureStoreSelectionStrategy = /** @class */ (function (_super) {
        __extends(FeatureStoreSelectionStrategy, _super);
        function FeatureStoreSelectionStrategy(options) {
            var _this = _super.call(this, options) || this;
            _this.options = options;
            _this.overlayStore = _this.createOverlayStore();
            return _this;
        }
        Object.defineProperty(FeatureStoreSelectionStrategy.prototype, "map", {
            /**
             * The map the layers belong to
             */
            get: /**
             * The map the layers belong to
             * @return {?}
             */ function () { return this.options.map; },
            enumerable: true,
            configurable: true
        });
        /**
         * Bind this strategy to a store and force this strategy's
         * reactivation to properly setup watchers.
         * @param store Feature store
         */
        /**
         * Bind this strategy to a store and force this strategy's
         * reactivation to properly setup watchers.
         * @param {?} store Feature store
         * @return {?}
         */
        FeatureStoreSelectionStrategy.prototype.bindStore = /**
         * Bind this strategy to a store and force this strategy's
         * reactivation to properly setup watchers.
         * @param {?} store Feature store
         * @return {?}
         */
            function (store) {
                _super.prototype.bindStore.call(this, store);
                if (this.isActive() === true) {
                    // Force reactivation
                    this.activate();
                }
            };
        /**
         * Unbind this strategy from a store and force this strategy's
         * reactivation to properly setup watchers.
         * @param store Feature store
         */
        /**
         * Unbind this strategy from a store and force this strategy's
         * reactivation to properly setup watchers.
         * @param {?} store Feature store
         * @return {?}
         */
        FeatureStoreSelectionStrategy.prototype.unbindStore = /**
         * Unbind this strategy from a store and force this strategy's
         * reactivation to properly setup watchers.
         * @param {?} store Feature store
         * @return {?}
         */
            function (store) {
                _super.prototype.unbindStore.call(this, store);
                if (this.isActive() === true) {
                    // Force reactivation
                    this.activate();
                }
            };
        /**
         * Unselect all entities, from all stores
         */
        /**
         * Unselect all entities, from all stores
         * @return {?}
         */
        FeatureStoreSelectionStrategy.prototype.unselectAll = /**
         * Unselect all entities, from all stores
         * @return {?}
         */
            function () {
                this.stores.forEach(( /**
                 * @param {?} store
                 * @return {?}
                 */function (store) {
                    store.state.updateAll({ selected: false });
                }));
            };
        /**
         * @return {?}
         */
        FeatureStoreSelectionStrategy.prototype.clear = /**
         * @return {?}
         */
            function () {
                this.overlayStore.source.ol.clear();
                this.overlayStore.clear();
            };
        /**
         * Add the overlay layer, setup the map click lsitener and
         * start watching for stores selection
         * @internal
         */
        /**
         * Add the overlay layer, setup the map click lsitener and
         * start watching for stores selection
         * \@internal
         * @protected
         * @return {?}
         */
        FeatureStoreSelectionStrategy.prototype.doActivate = /**
         * Add the overlay layer, setup the map click lsitener and
         * start watching for stores selection
         * \@internal
         * @protected
         * @return {?}
         */
            function () {
                this.addOverlayLayer();
                this.listenToMapClick();
                if (this.options.dragBox === true) {
                    this.addDragBoxInteraction();
                }
                this.watchAll();
            };
        /**
         * Remove the overlay layer, remove the map click lsitener and
         * stop watching for stores selection
         * @internal
         */
        /**
         * Remove the overlay layer, remove the map click lsitener and
         * stop watching for stores selection
         * \@internal
         * @protected
         * @return {?}
         */
        FeatureStoreSelectionStrategy.prototype.doDeactivate = /**
         * Remove the overlay layer, remove the map click lsitener and
         * stop watching for stores selection
         * \@internal
         * @protected
         * @return {?}
         */
            function () {
                this.unlistenToMapClick();
                this.removeDragBoxInteraction();
                this.unwatchAll();
                this.removeOverlayLayer();
            };
        /**
         * Create a single observable of all the stores. With a single observable,
         * features can be added all at once to the overlay layer and a single
         * motion can be performed. Multiple observable would have
         * a cancelling effect on each other.
         */
        /**
         * Create a single observable of all the stores. With a single observable,
         * features can be added all at once to the overlay layer and a single
         * motion can be performed. Multiple observable would have
         * a cancelling effect on each other.
         * @private
         * @return {?}
         */
        FeatureStoreSelectionStrategy.prototype.watchAll = /**
         * Create a single observable of all the stores. With a single observable,
         * features can be added all at once to the overlay layer and a single
         * motion can be performed. Multiple observable would have
         * a cancelling effect on each other.
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                this.unwatchAll();
                /** @type {?} */
                var stores$ = this.stores.map(( /**
                 * @param {?} store
                 * @return {?}
                 */function (store) {
                    return store.stateView.manyBy$(( /**
                     * @param {?} record
                     * @return {?}
                     */function (record) {
                        return record.state.selected === true;
                    })).pipe(operators.map(( /**
                     * @param {?} records
                     * @return {?}
                     */function (records) {
                        return records.map(( /**
                         * @param {?} record
                         * @return {?}
                         */function (record) { return record.entity; }));
                    })));
                }));
                this.stores$$ = rxjs.combineLatest.apply(void 0, __spread(stores$)).pipe(operators.debounceTime(25), operators.skip(1), // Skip intial selection
                operators.map(( /**
                 * @param {?} features
                 * @return {?}
                 */function (features) {
                    return features.reduce(( /**
                     * @param {?} a
                     * @param {?} b
                     * @return {?}
                     */function (a, b) { return a.concat(b); }));
                }))).subscribe(( /**
                 * @param {?} features
                 * @return {?}
                 */function (features) { return _this.onSelectFromStore(features); }));
            };
        /**
         * Stop watching for selection in all stores.
         */
        /**
         * Stop watching for selection in all stores.
         * @private
         * @return {?}
         */
        FeatureStoreSelectionStrategy.prototype.unwatchAll = /**
         * Stop watching for selection in all stores.
         * @private
         * @return {?}
         */
            function () {
                if (this.stores$$ !== undefined) {
                    this.stores$$.unsubscribe();
                }
            };
        /**
         * Add a 'singleclick' listener to the map that'll allow selecting
         * features by clicking on the map. The selection will be performed
         * only on the layers bound to this strategy.
         */
        /**
         * Add a 'singleclick' listener to the map that'll allow selecting
         * features by clicking on the map. The selection will be performed
         * only on the layers bound to this strategy.
         * @private
         * @return {?}
         */
        FeatureStoreSelectionStrategy.prototype.listenToMapClick = /**
         * Add a 'singleclick' listener to the map that'll allow selecting
         * features by clicking on the map. The selection will be performed
         * only on the layers bound to this strategy.
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                this.mapClickListener = this.map.ol.on('singleclick', ( /**
                 * @param {?} event
                 * @return {?}
                 */function (event) {
                    _this.onMapClick(event);
                }));
            };
        /**
         * Remove the map click listener
         */
        /**
         * Remove the map click listener
         * @private
         * @return {?}
         */
        FeatureStoreSelectionStrategy.prototype.unlistenToMapClick = /**
         * Remove the map click listener
         * @private
         * @return {?}
         */
            function () {
                if (this.mapClickListener !== undefined) {
                    this.map.ol.un(this.mapClickListener.type, this.mapClickListener.listener);
                }
            };
        /**
         * On map click, select feature at pixel
         * @param event OL MapBrowserPointerEvent
         */
        /**
         * On map click, select feature at pixel
         * @private
         * @param {?} event OL MapBrowserPointerEvent
         * @return {?}
         */
        FeatureStoreSelectionStrategy.prototype.onMapClick = /**
         * On map click, select feature at pixel
         * @private
         * @param {?} event OL MapBrowserPointerEvent
         * @return {?}
         */
            function (event) {
                var _this = this;
                /** @type {?} */
                var exclusive = !ctrlKeyDown(event);
                /** @type {?} */
                var reverse = !exclusive;
                /** @type {?} */
                var olFeatures = event.map.getFeaturesAtPixel(event.pixel, {
                    hitTolerance: this.options.hitTolerance || 0,
                    layerFilter: ( /**
                     * @param {?} olLayer
                     * @return {?}
                     */function (olLayer) {
                        /** @type {?} */
                        var storeOlLayer = _this.stores.find(( /**
                         * @param {?} store
                         * @return {?}
                         */function (store) {
                            return store.layer.ol === olLayer;
                        }));
                        return storeOlLayer !== undefined;
                    })
                });
                this.onSelectFromMap(olFeatures, exclusive, reverse);
            };
        /**
         * Add a drag box interaction and, on drag box end, select features
         */
        /**
         * Add a drag box interaction and, on drag box end, select features
         * @private
         * @return {?}
         */
        FeatureStoreSelectionStrategy.prototype.addDragBoxInteraction = /**
         * Add a drag box interaction and, on drag box end, select features
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                var e_1, _a;
                /** @type {?} */
                var olDragSelectInteraction;
                /** @type {?} */
                var olInteractions = this.map.ol.getInteractions().getArray();
                try {
                    // There can only be one dragbox interaction, so find the current one, if any
                    // Don't keep a reference to the current dragbox because we don't want
                    // to remove it when this startegy is deactivated
                    for (var olInteractions_1 = __values(olInteractions), olInteractions_1_1 = olInteractions_1.next(); !olInteractions_1_1.done; olInteractions_1_1 = olInteractions_1.next()) {
                        var olInteraction = olInteractions_1_1.value;
                        if (olInteraction instanceof OlDragSelectInteraction) {
                            olDragSelectInteraction = olInteraction;
                            break;
                        }
                    }
                }
                catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                }
                finally {
                    try {
                        if (olInteractions_1_1 && !olInteractions_1_1.done && (_a = olInteractions_1.return))
                            _a.call(olInteractions_1);
                    }
                    finally {
                        if (e_1)
                            throw e_1.error;
                    }
                }
                // If no drag box interaction is found, create a new one and add it to the map
                if (olDragSelectInteraction === undefined) {
                    olDragSelectInteraction = new OlDragSelectInteraction({
                        condition: ctrlKeyDown
                    });
                    this.map.ol.addInteraction(olDragSelectInteraction);
                    this.olDragSelectInteraction = olDragSelectInteraction;
                }
                this.olDragSelectInteractionEndKey = olDragSelectInteraction.on('boxend', ( /**
                 * @param {?} event
                 * @return {?}
                 */function (event) { return _this.onDragBoxEnd(event); }));
            };
        /**
         * Remove drag box interaction
         */
        /**
         * Remove drag box interaction
         * @private
         * @return {?}
         */
        FeatureStoreSelectionStrategy.prototype.removeDragBoxInteraction = /**
         * Remove drag box interaction
         * @private
         * @return {?}
         */
            function () {
                if (this.olDragSelectInteractionEndKey !== undefined) {
                    olobservable.unByKey(this.olDragSelectInteractionEndKey);
                }
                if (this.olDragSelectInteraction !== undefined) {
                    this.map.ol.removeInteraction(this.olDragSelectInteraction);
                }
                this.olDragSelectInteraction = undefined;
            };
        /**
         * On dragbox end, select features in drag box
         * @param event OL MapBrowserPointerEvent
         */
        /**
         * On dragbox end, select features in drag box
         * @private
         * @param {?} event OL MapBrowserPointerEvent
         * @return {?}
         */
        FeatureStoreSelectionStrategy.prototype.onDragBoxEnd = /**
         * On dragbox end, select features in drag box
         * @private
         * @param {?} event OL MapBrowserPointerEvent
         * @return {?}
         */
            function (event) {
                /** @type {?} */
                var exclusive = !ctrlKeyDown(event.mapBrowserEvent);
                /** @type {?} */
                var extent = event.target.getGeometry().getExtent();
                /** @type {?} */
                var olFeatures = this.stores.reduce(( /**
                 * @param {?} acc
                 * @param {?} store
                 * @return {?}
                 */function (acc, store) {
                    /** @type {?} */
                    var olSource = store.layer.ol.getSource();
                    acc.push.apply(acc, __spread(olSource.getFeaturesInExtent(extent)));
                    return acc;
                }), []);
                this.onSelectFromMap(olFeatures, exclusive, false);
            };
        /**
         * When features are selected from the store, add
         * them to this startegy's overlay layer (select on map)
         * @param features Store features
         */
        /**
         * When features are selected from the store, add
         * them to this startegy's overlay layer (select on map)
         * @private
         * @param {?} features Store features
         * @return {?}
         */
        FeatureStoreSelectionStrategy.prototype.onSelectFromStore = /**
         * When features are selected from the store, add
         * them to this startegy's overlay layer (select on map)
         * @private
         * @param {?} features Store features
         * @return {?}
         */
            function (features) {
                /** @type {?} */
                var motion = this.options ? this.options.motion : undefined;
                /** @type {?} */
                var olOverlayFeatures = this.overlayStore.layer.ol.getSource().getFeatures();
                /** @type {?} */
                var overlayFeaturesKeys = olOverlayFeatures.map(( /**
                 * @param {?} olFeature
                 * @return {?}
                 */function (olFeature) { return olFeature.getId(); }));
                /** @type {?} */
                var featuresKeys = features.map(this.overlayStore.getKey);
                /** @type {?} */
                var doMotion = overlayFeaturesKeys.length !== featuresKeys.length ||
                    !overlayFeaturesKeys.every(( /**
                     * @param {?} key
                     * @return {?}
                     */function (key) { return featuresKeys.indexOf(key) >= 0; }));
                this.overlayStore.setLayerFeatures(features, doMotion ? motion : FeatureMotion.None, this.options.viewScale, this.options.areaRatio, this.options.getFeatureId);
            };
        /**
         * When features are selected from the map, also select them
         * in their store.
         * @param olFeatures OL feature objects
         */
        /**
         * When features are selected from the map, also select them
         * in their store.
         * @private
         * @param {?} olFeatures OL feature objects
         * @param {?} exclusive
         * @param {?} reverse
         * @return {?}
         */
        FeatureStoreSelectionStrategy.prototype.onSelectFromMap = /**
         * When features are selected from the map, also select them
         * in their store.
         * @private
         * @param {?} olFeatures OL feature objects
         * @param {?} exclusive
         * @param {?} reverse
         * @return {?}
         */
            function (olFeatures, exclusive, reverse) {
                var _this = this;
                /** @type {?} */
                var groupedFeatures = this.groupFeaturesByStore(olFeatures);
                this.stores.forEach(( /**
                 * @param {?} store
                 * @return {?}
                 */function (store) {
                    /** @type {?} */
                    var features = groupedFeatures.get(store);
                    if (features === undefined && exclusive === true) {
                        _this.unselectAllFeaturesFromStore(store);
                    }
                    else if (features === undefined && exclusive === false) ;
                    else {
                        _this.selectFeaturesFromStore(store, features, exclusive, reverse);
                    }
                }));
            };
        /**
         * Select features in store
         * @param store: Feature store
         * @param features Features
         */
        /**
         * Select features in store
         * @private
         * @param {?} store
         * @param {?} features Features
         * @param {?} exclusive
         * @param {?} reverse
         * @return {?}
         */
        FeatureStoreSelectionStrategy.prototype.selectFeaturesFromStore = /**
         * Select features in store
         * @private
         * @param {?} store
         * @param {?} features Features
         * @param {?} exclusive
         * @param {?} reverse
         * @return {?}
         */
            function (store, features, exclusive, reverse) {
                if (reverse === true) {
                    store.state.reverseMany(features, ['selected']);
                }
                else {
                    store.state.updateMany(features, { selected: true }, exclusive);
                }
            };
        /**
         * Unselect all features from store
         * @param store: Feature store
         */
        /**
         * Unselect all features from store
         * @private
         * @param {?} store
         * @return {?}
         */
        FeatureStoreSelectionStrategy.prototype.unselectAllFeaturesFromStore = /**
         * Unselect all features from store
         * @private
         * @param {?} store
         * @return {?}
         */
            function (store) {
                store.state.updateAll({ selected: false });
            };
        /**
         * This method returns a store -> features mapping from a list
         * of OL selected features. OL features keep a reference to the store
         * they are from.
         * @param olFeatures: OL feature objects
         * @returns Store -> features mapping
         */
        /**
         * This method returns a store -> features mapping from a list
         * of OL selected features. OL features keep a reference to the store
         * they are from.
         * @private
         * @param {?} olFeatures
         * @return {?} Store -> features mapping
         */
        FeatureStoreSelectionStrategy.prototype.groupFeaturesByStore = /**
         * This method returns a store -> features mapping from a list
         * of OL selected features. OL features keep a reference to the store
         * they are from.
         * @private
         * @param {?} olFeatures
         * @return {?} Store -> features mapping
         */
            function (olFeatures) {
                /** @type {?} */
                var groupedFeatures = new Map();
                if (olFeatures === null || olFeatures === undefined) {
                    return groupedFeatures;
                }
                olFeatures.forEach(( /**
                 * @param {?} olFeature
                 * @return {?}
                 */function (olFeature) {
                    /** @type {?} */
                    var store = olFeature.get('_featureStore');
                    if (store === undefined) {
                        return;
                    }
                    /** @type {?} */
                    var features = groupedFeatures.get(store);
                    if (features === undefined) {
                        features = [];
                        groupedFeatures.set(store, features);
                    }
                    /** @type {?} */
                    var feature = store.get(olFeature.getId());
                    if (feature !== undefined) {
                        features.push(feature);
                    }
                }));
                return groupedFeatures;
            };
        /**
         * Create an overlay store that'll contain the selected features.
         * @returns Overlay store
         */
        /**
         * Create an overlay store that'll contain the selected features.
         * @private
         * @return {?} Overlay store
         */
        FeatureStoreSelectionStrategy.prototype.createOverlayStore = /**
         * Create an overlay store that'll contain the selected features.
         * @private
         * @return {?} Overlay store
         */
            function () {
                /** @type {?} */
                var overlayLayer = this.options.layer
                    ? this.options.layer
                    : this.createOverlayLayer();
                return new FeatureStore([], { map: this.map }).bindLayer(overlayLayer);
            };
        /**
         * Create an overlay store that'll contain the selected features.
         * @returns Overlay layer
         */
        /**
         * Create an overlay store that'll contain the selected features.
         * @private
         * @return {?} Overlay layer
         */
        FeatureStoreSelectionStrategy.prototype.createOverlayLayer = /**
         * Create an overlay store that'll contain the selected features.
         * @private
         * @return {?} Overlay layer
         */
            function () {
                return new VectorLayer({
                    zIndex: 300,
                    source: new FeatureDataSource(),
                    style: undefined,
                    showInLayerList: false,
                    exportable: false,
                    browsable: false
                });
            };
        /**
         * Add the overlay store's layer to the map to display the selected
         * features.
         */
        /**
         * Add the overlay store's layer to the map to display the selected
         * features.
         * @private
         * @return {?}
         */
        FeatureStoreSelectionStrategy.prototype.addOverlayLayer = /**
         * Add the overlay store's layer to the map to display the selected
         * features.
         * @private
         * @return {?}
         */
            function () {
                if (this.overlayStore.layer.map === undefined) {
                    this.map.addLayer(this.overlayStore.layer);
                }
            };
        /**
         * Remove the overlay layer from the map
         */
        /**
         * Remove the overlay layer from the map
         * @private
         * @return {?}
         */
        FeatureStoreSelectionStrategy.prototype.removeOverlayLayer = /**
         * Remove the overlay layer from the map
         * @private
         * @return {?}
         */
            function () {
                this.overlayStore.source.ol.clear();
                this.map.removeLayer(this.overlayStore.layer);
            };
        return FeatureStoreSelectionStrategy;
    }(FeatureStoreStrategy));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Create an Openlayers feature object out of a feature definition.
     * The output object has a reference to the feature id.
     * @param {?} feature Feature definition
     * @param {?} projectionOut Feature object projection
     * @param {?=} getId
     * @return {?} OpenLayers feature object
     */
    function featureToOl(feature, projectionOut, getId) {
        getId = getId ? getId : common$1.getEntityId;
        /** @type {?} */
        var olFormat = new OlGeoJSON();
        /** @type {?} */
        var olFeature = olFormat.readFeature(feature, {
            dataProjection: feature.projection,
            featureProjection: projectionOut
        });
        olFeature.setId(getId(feature));
        /** @type {?} */
        var title = common$1.getEntityTitle(feature);
        if (title !== undefined) {
            olFeature.set('_title', title, true);
        }
        if (feature.extent !== undefined) {
            olFeature.set('_extent', feature.extent, true);
        }
        if (feature.projection !== undefined) {
            olFeature.set('_projection', feature.projection, true);
        }
        if (feature.extent !== undefined) {
            olFeature.set('_extent', feature.extent, true);
        }
        /** @type {?} */
        var mapTitle = common$1.getEntityProperty(feature, 'meta.mapTitle');
        if (mapTitle !== undefined) {
            olFeature.set('_mapTitle', mapTitle, true);
        }
        olFeature.set('_entityRevision', common$1.getEntityRevision(feature), true);
        return olFeature;
    }
    /**
     * Create a feature object out of an OL feature
     * The output object has a reference to the feature id.
     * @param {?} olFeature OL Feature
     * @param {?} projectionIn OL feature projection
     * @param {?=} projectionOut Feature projection
     * @return {?} Feature
     */
    function featureFromOl(olFeature, projectionIn, projectionOut) {
        if (projectionOut === void 0) {
            projectionOut = 'EPSG:4326';
        }
        /** @type {?} */
        var olFormat = new OlGeoJSON();
        /** @type {?} */
        var keys = olFeature.getKeys().filter(( /**
         * @param {?} key
         * @return {?}
         */function (key) {
            return !key.startsWith('_') && key !== 'geometry';
        }));
        /** @type {?} */
        var properties = keys.reduce(( /**
         * @param {?} acc
         * @param {?} key
         * @return {?}
         */function (acc, key) {
            acc[key] = olFeature.get(key);
            return acc;
        }), {});
        /** @type {?} */
        var geometry = olFormat.writeGeometryObject(olFeature.getGeometry(), {
            dataProjection: projectionOut,
            featureProjection: projectionIn
        });
        /** @type {?} */
        var title = olFeature.get('_title');
        /** @type {?} */
        var mapTitle = olFeature.get('_mapTitle');
        /** @type {?} */
        var id = olFeature.getId();
        return {
            type: FEATURE,
            projection: projectionOut,
            extent: olFeature.get('_extent'),
            meta: {
                id: id,
                title: title ? title : (mapTitle ? mapTitle : id),
                mapTitle: mapTitle,
                revision: olFeature.getRevision()
            },
            properties: properties,
            geometry: geometry
        };
    }
    /**
     * Compute an OL feature extent in it's map projection
     * @param {?} map Map
     * @param {?} olFeature OL feature
     * @return {?} Extent in the map projection
     */
    function computeOlFeatureExtent(map, olFeature) {
        /** @type {?} */
        var olExtent = olextent.createEmpty();
        /** @type {?} */
        var olFeatureExtent = olFeature.get('_extent');
        /** @type {?} */
        var olFeatureProjection = olFeature.get('_projection');
        if (olFeatureExtent !== undefined && olFeatureProjection !== undefined) {
            olExtent = olproj.transformExtent(olFeatureExtent, olFeatureProjection, map.projection);
        }
        else {
            /** @type {?} */
            var olGeometry = olFeature.getGeometry();
            if (olGeometry !== null) {
                olExtent = olGeometry.getExtent();
            }
        }
        return olExtent;
    }
    /**
     * Compute a multiple OL features extent in their map projection
     * @param {?} map Map
     * @param {?} olFeatures OL features
     * @return {?} Extent in the map projection
     */
    function computeOlFeaturesExtent(map, olFeatures) {
        /** @type {?} */
        var extent = olextent.createEmpty();
        olFeatures.forEach(( /**
         * @param {?} olFeature
         * @return {?}
         */function (olFeature) {
            /** @type {?} */
            var featureExtent = computeOlFeatureExtent(map, olFeature);
            olextent.extend(extent, featureExtent);
        }));
        return extent;
    }
    /**
     * Scale an extent.
     * @param {?} extent Extent
     * @param {?} scale
     * @return {?} Scaled extent
     */
    function scaleExtent(extent, scale) {
        var _a = __read(olextent.getSize(extent), 2), width = _a[0], height = _a[1];
        return [
            scale[3] ? extent[0] - width * scale[3] : extent[0],
            scale[2] ? extent[1] - height * scale[2] : extent[1],
            scale[1] ? extent[2] + width * scale[1] : extent[2],
            scale[0] ? extent[3] + height * scale[0] : extent[3]
        ];
    }
    /**
     * Return true if features are out of view.
     * If features are too close to the edge, they are considered out of view.
     * We define the edge as 5% of the extent size.
     * @param {?} map Map
     * @param {?} featuresExtent The features's extent
     * @return {?} Return true if features are out of view
     */
    function featuresAreOutOfView(map, featuresExtent) {
        /** @type {?} */
        var mapExtent = map.getExtent();
        /** @type {?} */
        var edgeRatio = 0.05;
        /** @type {?} */
        var scale = [-1, -1, -1, -1].map(( /**
         * @param {?} x
         * @return {?}
         */function (x) { return x * edgeRatio; }));
        /** @type {?} */
        var viewExtent = scaleExtent(mapExtent, ( /** @type {?} */(scale)));
        return !olextent.containsExtent(viewExtent, featuresExtent);
    }
    /**
     * Return true if features are too deep into the view. This results
     * in features being too small.
     * Features are considered too small if their extent occupies less than
     * 1% of the map extent.
     * @param {?} map Map
     * @param {?} featuresExtent The features's extent
     * @param {?=} areaRatio The features extent to view extent acceptable ratio
     * @return {?} Return true if features are too deep in the view
     */
    function featuresAreTooDeepInView(map, featuresExtent, areaRatio) {
        // An area ratio of 0.004 means that the feature extent's width and height
        // should be about 1/16 of the map extent's width and height
        areaRatio = areaRatio ? areaRatio : 0.004;
        /** @type {?} */
        var mapExtent = map.getExtent();
        /** @type {?} */
        var mapExtentArea = olextent.getArea(mapExtent);
        /** @type {?} */
        var featuresExtentArea = olextent.getArea(featuresExtent);
        return featuresExtentArea / mapExtentArea < areaRatio;
    }
    /**
     * Fit view to include the features extent.
     * By default, this method will let the features occupy about 50% of the viewport.
     * @param {?} map Map
     * @param {?} olFeatures OL features
     * @param {?=} motion To motion to the new map view
     * @param {?=} scale If this is defined, the original view will be scaled
     *  by that factor before any logic is applied.
     * @param {?=} areaRatio
     * @return {?}
     */
    function moveToOlFeatures(map, olFeatures, motion, scale, areaRatio) {
        if (motion === void 0) {
            motion = FeatureMotion.Default;
        }
        /** @type {?} */
        var featuresExtent = computeOlFeaturesExtent(map, olFeatures);
        /** @type {?} */
        var viewExtent = featuresExtent;
        if (scale !== undefined) {
            viewExtent = scaleExtent(viewExtent, scale);
        }
        if (motion === FeatureMotion.Zoom) {
            map.viewController.zoomToExtent(viewExtent);
        }
        else if (motion === FeatureMotion.Move) {
            map.viewController.moveToExtent(viewExtent);
        }
        else if (motion === FeatureMotion.Default) {
            if (featuresAreOutOfView(map, featuresExtent) ||
                featuresAreTooDeepInView(map, featuresExtent, areaRatio)) {
                map.viewController.zoomToExtent(viewExtent);
            }
        }
    }
    /**
     * Hide an OL feature
     * @param {?} olFeature OL feature
     * @return {?}
     */
    function hideOlFeature(olFeature) {
        olFeature.setStyle(new olstyle.Style({}));
    }
    /**
     * Try to bind a layer to a store if none is bound already.
     * The layer will also be added to the store's map.
     * If no layer is given to that function, a basic one will be created.
     * @param {?} store The store to bind the layer
     * @param {?=} layer An optional VectorLayer
     * @return {?}
     */
    function tryBindStoreLayer(store, layer) {
        if (store.layer !== undefined) {
            if (store.layer.map === undefined) {
                store.map.addLayer(store.layer);
            }
            return;
        }
        layer = layer ? layer : new VectorLayer({
            source: new FeatureDataSource()
        });
        store.bindLayer(layer);
        if (store.layer.map === undefined) {
            store.map.addLayer(store.layer);
        }
    }
    /**
     * Try to add a loading strategy to a store and activate it.
     * If no strategy is given to that function, a basic one will be created.
     * @param {?} store The store to bind the loading strategy
     * @param {?=} strategy An optional loading strategy
     * @return {?}
     */
    function tryAddLoadingStrategy(store, strategy) {
        if (store.getStrategyOfType(FeatureStoreLoadingStrategy) !== undefined) {
            store.activateStrategyOfType(FeatureStoreLoadingStrategy);
            return;
        }
        strategy = strategy ? strategy : new FeatureStoreLoadingStrategy({});
        store.addStrategy(strategy);
        strategy.activate();
    }
    /**
     * Try to add a selection strategy to a store and activate it.
     * If no strategy is given to that function, a basic one will be created.
     * @param {?} store The store to bind the selection strategy
     * @param {?=} strategy
     * @return {?}
     */
    function tryAddSelectionStrategy(store, strategy) {
        if (store.getStrategyOfType(FeatureStoreSelectionStrategy) !== undefined) {
            store.activateStrategyOfType(FeatureStoreSelectionStrategy);
            return;
        }
        strategy = strategy ? strategy : new FeatureStoreSelectionStrategy({
            map: store.map
        });
        store.addStrategy(strategy);
        strategy.activate();
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Create an overlay layer and it's source
     * @return {?} Overlay layer
     */
    function createOverlayLayer() {
        /** @type {?} */
        var overlayDataSource = new FeatureDataSource();
        return new VectorLayer({
            title: 'Overlay',
            zIndex: 300,
            source: overlayDataSource,
            style: createOverlayLayerStyle()
        });
    }
    /**
     * Create an overlay style with markers for points and a basic stroke/fill
     * combination for lines and polygons
     * @return {?} Style function
     */
    function createOverlayLayerStyle() {
        /** @type {?} */
        var defaultStyle = createOverlayDefaultStyle();
        /** @type {?} */
        var markerStyle = createOverlayMarkerStyle();
        return ( /**
         * @param {?} olFeature
         * @return {?}
         */function (olFeature) {
            /** @type {?} */
            var geometryType = olFeature.getGeometry().getType();
            /** @type {?} */
            var style = geometryType === 'Point' ? markerStyle : defaultStyle;
            style.getText().setText(olFeature.get('_mapTitle'));
            return style;
        });
    }
    /**
     * Create a basic style for lines and polygons
     * @return {?} Style
     */
    function createOverlayDefaultStyle() {
        /** @type {?} */
        var stroke = new olstyle.Stroke({
            width: 2,
            color: [0, 161, 222, 1]
        });
        /** @type {?} */
        var fill = new olstyle.Stroke({
            color: [0, 161, 222, 0.15]
        });
        return new olstyle.Style({
            stroke: stroke,
            fill: fill,
            image: new olstyle.Circle({
                radius: 5,
                stroke: stroke,
                fill: fill
            }),
            text: new olstyle.Text({
                font: '12px Calibri,sans-serif',
                fill: new olstyle.Fill({ color: '#000' }),
                stroke: new olstyle.Stroke({ color: '#fff', width: 3 }),
                overflow: true
            })
        });
    }
    /**
     * Create a marker style for points
     * @param {?=} color
     * @return {?} Style
     */
    function createOverlayMarkerStyle(color$$1) {
        if (color$$1 === void 0) {
            color$$1 = 'blue';
        }
        /** @type {?} */
        var iconColor;
        switch (color$$1) {
            case 'blue':
            case 'red':
            case 'yellow':
            case 'green':
                iconColor = color$$1;
                break;
            default:
                iconColor = 'blue';
                break;
        }
        return new olstyle.Style({
            image: new olstyle.Icon({
                src: './assets/igo2/geo/icons/place_' + iconColor + '_36px.svg',
                imgSize: [36, 36],
                // for ie
                anchor: [0.5, 1]
            }),
            text: new olstyle.Text({
                font: '12px Calibri,sans-serif',
                fill: new olstyle.Fill({ color: '#000' }),
                stroke: new olstyle.Stroke({ color: '#fff', width: 3 }),
                overflow: true
            })
        });
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * This class is simply a shortcut for adding features to a map.
     * It does nothing more than a standard layer but it's shipped with
     * a defautl style based on the geometry type of the features it contains.
     * \@todo Enhance that by using a FeatureStore and strategies.
     */
    var /**
     * This class is simply a shortcut for adding features to a map.
     * It does nothing more than a standard layer but it's shipped with
     * a defautl style based on the geometry type of the features it contains.
     * \@todo Enhance that by using a FeatureStore and strategies.
     */ Overlay = /** @class */ (function () {
        function Overlay(map) {
            this.layer = createOverlayLayer();
            this.setMap(map);
        }
        Object.defineProperty(Overlay.prototype, "dataSource", {
            /**
             * Overlay layer's data source
             */
            get: /**
             * Overlay layer's data source
             * @return {?}
             */ function () {
                return ( /** @type {?} */(this.layer.dataSource));
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Bind this to a map and add the overlay layer to that map
         * @param map Map
         */
        /**
         * Bind this to a map and add the overlay layer to that map
         * @param {?} map Map
         * @return {?}
         */
        Overlay.prototype.setMap = /**
         * Bind this to a map and add the overlay layer to that map
         * @param {?} map Map
         * @return {?}
         */
            function (map) {
                if (map === undefined) {
                    if (this.map !== undefined) {
                        this.map.ol.removeLayer(this.layer.ol);
                    }
                }
                else {
                    map.ol.addLayer(this.layer.ol);
                }
                this.map = map;
            };
        /**
         * Set the overlay features and, optionally, move to them
         * @param features Features
         * @param motion Optional: Apply this motion to the map view
         */
        /**
         * Set the overlay features and, optionally, move to them
         * @param {?} features Features
         * @param {?=} motion Optional: Apply this motion to the map view
         * @return {?}
         */
        Overlay.prototype.setFeatures = /**
         * Set the overlay features and, optionally, move to them
         * @param {?} features Features
         * @param {?=} motion Optional: Apply this motion to the map view
         * @return {?}
         */
            function (features, motion) {
                if (motion === void 0) {
                    motion = FeatureMotion.Default;
                }
                this.clear();
                this.addFeatures(features, motion);
            };
        /**
         * Add a feature to the  overlay and, optionally, move to it
         * @param feature Feature
         * @param motion Optional: Apply this motion to the map view
         */
        /**
         * Add a feature to the  overlay and, optionally, move to it
         * @param {?} feature Feature
         * @param {?=} motion Optional: Apply this motion to the map view
         * @return {?}
         */
        Overlay.prototype.addFeature = /**
         * Add a feature to the  overlay and, optionally, move to it
         * @param {?} feature Feature
         * @param {?=} motion Optional: Apply this motion to the map view
         * @return {?}
         */
            function (feature, motion) {
                if (motion === void 0) {
                    motion = FeatureMotion.Default;
                }
                this.addFeatures([feature], motion);
            };
        /**
         * Add features to the  overlay and, optionally, move to them
         * @param features Features
         * @param motion Optional: Apply this motion to the map view
         */
        /**
         * Add features to the  overlay and, optionally, move to them
         * @param {?} features Features
         * @param {?=} motion Optional: Apply this motion to the map view
         * @return {?}
         */
        Overlay.prototype.addFeatures = /**
         * Add features to the  overlay and, optionally, move to them
         * @param {?} features Features
         * @param {?=} motion Optional: Apply this motion to the map view
         * @return {?}
         */
            function (features, motion) {
                var _this = this;
                if (motion === void 0) {
                    motion = FeatureMotion.Default;
                }
                /** @type {?} */
                var olFeatures = [];
                features.forEach(( /**
                 * @param {?} feature
                 * @return {?}
                 */function (feature) {
                    /** @type {?} */
                    var olFeature = featureToOl(feature, _this.map.projection);
                    /** @type {?} */
                    var olGeometry = olFeature.getGeometry();
                    if (olGeometry === null) {
                        return;
                    }
                    olFeatures.push(olFeature);
                }));
                this.addOlFeatures(olFeatures, motion);
            };
        /**
         * Add a OpenLayers feature to the  overlay and, optionally, move to it
         * @param olFeature OpenLayers Feature
         * @param motion Optional: Apply this motion to the map view
         */
        /**
         * Add a OpenLayers feature to the  overlay and, optionally, move to it
         * @param {?} olFeature OpenLayers Feature
         * @param {?=} motion Optional: Apply this motion to the map view
         * @return {?}
         */
        Overlay.prototype.addOlFeature = /**
         * Add a OpenLayers feature to the  overlay and, optionally, move to it
         * @param {?} olFeature OpenLayers Feature
         * @param {?=} motion Optional: Apply this motion to the map view
         * @return {?}
         */
            function (olFeature, motion) {
                if (motion === void 0) {
                    motion = FeatureMotion.Default;
                }
                this.addOlFeature([olFeature], motion);
            };
        /**
         * Add OpenLayers features to the overlay and, optionally, move to them
         * @param olFeatures OpenLayers Features
         * @param motion Optional: Apply this motion to the map view
         */
        /**
         * Add OpenLayers features to the overlay and, optionally, move to them
         * @param {?} olFeatures OpenLayers Features
         * @param {?=} motion Optional: Apply this motion to the map view
         * @return {?}
         */
        Overlay.prototype.addOlFeatures = /**
         * Add OpenLayers features to the overlay and, optionally, move to them
         * @param {?} olFeatures OpenLayers Features
         * @param {?=} motion Optional: Apply this motion to the map view
         * @return {?}
         */
            function (olFeatures, motion) {
                if (motion === void 0) {
                    motion = FeatureMotion.Default;
                }
                this.dataSource.ol.addFeatures(olFeatures);
                moveToOlFeatures(this.map, olFeatures, motion);
            };
        /**
         * Clear the overlay
         */
        /**
         * Clear the overlay
         * @return {?}
         */
        Overlay.prototype.clear = /**
         * Clear the overlay
         * @return {?}
         */
            function () {
                this.dataSource.ol.clear();
            };
        return Overlay;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var LayerWatcher = /** @class */ (function (_super) {
        __extends(LayerWatcher, _super);
        function LayerWatcher() {
            var _this = _super.call(this) || this;
            _this.loaded = 0;
            _this.loading = 0;
            _this.layers = [];
            _this.subscriptions = [];
            return _this;
        }
        /**
         * @return {?}
         */
        LayerWatcher.prototype.watch = /**
         * @return {?}
         */
            function () { };
        /**
         * @return {?}
         */
        LayerWatcher.prototype.unwatch = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.layers.forEach(( /**
                 * @param {?} layer
                 * @return {?}
                 */function (layer) { return _this.unwatchLayer(layer); }), this);
            };
        /**
         * @param {?} layer
         * @return {?}
         */
        LayerWatcher.prototype.watchLayer = /**
         * @param {?} layer
         * @return {?}
         */
            function (layer) {
                var _this = this;
                if (layer.status$ === undefined) {
                    return;
                }
                this.layers.push(layer);
                /** @type {?} */
                var layer$$ = layer.status$
                    .pipe(operators.distinctUntilChanged())
                    .subscribe(( /**
             * @param {?} status
             * @return {?}
             */function (status) {
                    if (status === utils.SubjectStatus.Working) {
                        _this.loading += 1;
                    }
                    else if (status === utils.SubjectStatus.Done) {
                        _this.loaded += 1;
                    }
                    if (_this.loaded >= _this.loading) {
                        _this.loading = _this.loaded = 0;
                        _this.status = utils.SubjectStatus.Done;
                    }
                    else if (_this.loading > 0) {
                        _this.status = utils.SubjectStatus.Working;
                    }
                }));
                this.subscriptions.push(layer$$);
            };
        /**
         * @param {?} layer
         * @return {?}
         */
        LayerWatcher.prototype.unwatchLayer = /**
         * @param {?} layer
         * @return {?}
         */
            function (layer) {
                /** @type {?} */
                var index = this.layers.indexOf(layer);
                if (index >= 0) {
                    /** @type {?} */
                    var status_1 = (( /** @type {?} */(layer))).watcher.status;
                    if ([utils.SubjectStatus.Working, utils.SubjectStatus.Waiting].indexOf(status_1) !== -1) {
                        this.loaded += 1;
                    }
                    this.subscriptions[index].unsubscribe();
                    this.subscriptions.splice(index, 1);
                    this.layers.splice(index, 1);
                    (( /** @type {?} */(layer))).watcher.unwatch();
                }
            };
        return LayerWatcher;
    }(utils.Watcher));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @enum {number} */
    var MapViewAction = {
        Move: 0,
        Zoom: 1,
    };
    MapViewAction[MapViewAction.Move] = 'Move';
    MapViewAction[MapViewAction.Zoom] = 'Zoom';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * This method extracts a coordinate tuple from a string.
     * @param {?} str Any string
     * @param {?} mapProjection string Map Projection
     * @return {?} object:
     *             lonLat: Coordinate,
     *             message: Message of error,
     *             radius: radius of the confience of coordinate,
     *             conf: confidence of the coordinate}
     */
    function stringToLonLat(str, mapProjection) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        /** @type {?} */
        var lonLat;
        /** @type {?} */
        var coordStr;
        /** @type {?} */
        var negativeLon;
        /** @type {?} */
        var degreesLon;
        /** @type {?} */
        var minutesLon;
        /** @type {?} */
        var secondsLon;
        /** @type {?} */
        var directionLon;
        /** @type {?} */
        var decimalLon;
        /** @type {?} */
        var negativeLat;
        /** @type {?} */
        var degreesLat;
        /** @type {?} */
        var minutesLat;
        /** @type {?} */
        var secondsLat;
        /** @type {?} */
        var directionLat;
        /** @type {?} */
        var decimalLat;
        /** @type {?} */
        var pattern;
        /** @type {?} */
        var timeZone;
        /** @type {?} */
        var radius;
        /** @type {?} */
        var conf;
        /** @type {?} */
        var lon;
        /** @type {?} */
        var lat;
        /** @type {?} */
        var projectionPattern = '(;[\\d]{4,6})';
        /** @type {?} */
        var toProjection = '4326';
        /** @type {?} */
        var projectionStr;
        /** @type {?} */
        var projectionRegex = new RegExp(projectionPattern, 'g');
        /** @type {?} */
        var lonlatCoord = '([-+])?([\\d]{1,3})([,.](\\d+))?';
        /** @type {?} */
        var lonLatPattern = lonlatCoord + "[\\s,.]\\s*" + lonlatCoord;
        /** @type {?} */
        var lonLatRegex = new RegExp("^" + lonLatPattern + "$", 'g');
        /** @type {?} */
        var dmsCoord = '([0-9]{1,2})[:|]?\\s*([0-9]{1,2})?[:|\'||]?\\s*([0-9]{1,2}(?:\.[0-9]+){0,1})?\\s*["||]?\\s*';
        /** @type {?} */
        var dmsCoordPattern = dmsCoord + "([N|S]),?\\s*" + dmsCoord + "([E|W])";
        /** @type {?} */
        var dmsRegex = new RegExp("^" + dmsCoordPattern, 'gi');
        /** @type {?} */
        var patternUtmMtm = '(UTM|MTM)\-?(\\d{1,2})[\\s,.]*(\\d+[\\s.,]?\\d+)[\\s,.]+(\\d+[\\s.,]?\\d+)';
        /** @type {?} */
        var utmMtmRegex = new RegExp("^" + patternUtmMtm, 'gi');
        /** @type {?} */
        var ddCoord = '([-+])?(\\d{1,3})[,.](\\d+)';
        /** @type {?} */
        var patternDd = ddCoord + "[,.]?\\s*" + ddCoord;
        /** @type {?} */
        var ddRegex = new RegExp("^" + patternDd, 'g');
        /** @type {?} */
        var dmdCoord = '([-+])?(\\d{1,3})[\\s,.]{1}(\\d{1,2})[\\s,.]{1}(\\d{1,2})[.,]?(\\d{1,5})?';
        /** @type {?} */
        var patternDmd = dmdCoord + "[,.]?\\s*" + dmdCoord;
        /** @type {?} */
        var dmdRegex = new RegExp("^" + patternDmd, 'g');
        // tslint:disable:max-line-length
        /** @type {?} */
        var patternBELL = 'LAT\\s*[\\s:]*\\s*([-+])?(\\d{1,2})[\\s.,]?(\\d+)?[\\s.,]?\\s*(\\d{1,2}([.,]\\d+)?)?\\s*(N|S|E|W)?\\s*LONG\\s*[\\s:]*\\s*([-+])?(\\d{1,3})[\\s.,]?(\\d+)?[\\s.,]?\\s*(\\d{1,2}([.,]\\d+)?)?\\s*(N|S|E|W)?\\s*UNC\\s*[\\s:]?\\s*(\\d+)\\s*CONF\\s*[\\s:]?\\s*(\\d{1,3})';
        /** @type {?} */
        var bellRegex = new RegExp("^" + patternBELL + "?", 'gi');
        /** @type {?} */
        var mmCoord = '([-+]?\\d+)[,.]?(\\d+)?';
        /** @type {?} */
        var mmPattern = mmCoord + "[\\s,.]\\s*" + mmCoord;
        /** @type {?} */
        var mmRegex = new RegExp("^" + mmPattern + "$", 'g');
        str = str.toLocaleUpperCase();
        // Extract projection
        if (projectionRegex.test(str)) {
            _a = __read(str.split(';'), 2), coordStr = _a[0], projectionStr = _a[1];
        }
        else {
            coordStr = str;
        }
        if (lonLatRegex.test(coordStr)) {
            _b = __read(coordStr.match(lonLatPattern), 9), negativeLon = _b[1], lon = _b[2], decimalLon = _b[4], negativeLat = _b[5], lat = _b[6], decimalLat = _b[8];
            lon = parseFloat((negativeLon ? negativeLon : '') + lon + '.' + decimalLon);
            lat = parseFloat((negativeLat ? negativeLat : '') + lat + '.' + decimalLat);
        }
        else if (dmsRegex.test(coordStr)) {
            _c = __read(coordStr.match(dmsCoordPattern), 9), degreesLon = _c[1], minutesLon = _c[2], secondsLon = _c[3], directionLon = _c[4], degreesLat = _c[5], minutesLat = _c[6], secondsLat = _c[7], directionLat = _c[8];
            lon = convertDMSToDD(parseFloat(degreesLon), parseFloat(minutesLon), parseFloat(secondsLon), directionLon);
            lat = convertDMSToDD(parseFloat(degreesLat), parseFloat(minutesLat), parseFloat(secondsLat), directionLat);
        }
        else if (utmMtmRegex.test(coordStr)) {
            _d = __read(coordStr.match(patternUtmMtm), 5), pattern = _d[1], timeZone = _d[2], lon = _d[3], lat = _d[4];
            /** @type {?} */
            var utm = '+proj=' + pattern + ' +zone=' + timeZone;
            /** @type {?} */
            var wgs84 = '+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs';
            _e = __read(proj4(utm.toLocaleLowerCase(), wgs84, [parseFloat(lon), parseFloat(lat)]), 2), lon = _e[0], lat = _e[1];
        }
        else if (dmdRegex.test(coordStr)) {
            _f = __read(coordStr.match(patternDmd), 11), negativeLon = _f[1], degreesLon = _f[2], minutesLon = _f[3], secondsLon = _f[4], decimalLon = _f[5], negativeLat = _f[6], degreesLat = _f[7], minutesLat = _f[8], secondsLat = _f[9], decimalLat = _f[10];
            lon = convertDMSToDD(parseFloat((negativeLon ? negativeLon : '') + degreesLon), parseFloat(minutesLon), parseFloat(secondsLon), directionLon);
            lat = convertDMSToDD(parseFloat((negativeLat ? negativeLat : '') + degreesLat), parseFloat(minutesLat), parseFloat(secondsLat), directionLat);
        }
        else if (ddRegex.test(coordStr)) {
            _g = __read(coordStr.match(patternDd), 7), negativeLon = _g[1], degreesLon = _g[2], decimalLon = _g[3], negativeLat = _g[4], degreesLat = _g[5], decimalLat = _g[6];
            lon = convertDMSToDD(parseFloat((negativeLon ? negativeLon : '') + degreesLon), parseFloat(minutesLon), parseFloat(secondsLon), directionLon);
            lat = convertDMSToDD(parseFloat((negativeLat ? negativeLat : '') + degreesLat), parseFloat(minutesLat), parseFloat(secondsLat), directionLat);
        }
        else if (bellRegex.test(coordStr)) {
            _h = __read(coordStr.match(patternBELL), 15), negativeLat = _h[1], degreesLat = _h[2], minutesLat = _h[3], secondsLat = _h[4], directionLat = _h[6], negativeLon = _h[7], degreesLon = _h[8], minutesLon = _h[9], secondsLon = _h[10], directionLon = _h[12], radius = _h[13], conf = _h[14];
            // Set default value for North America
            if (!directionLon) {
                directionLon = 'W';
            }
            // Check if real minutes or decimals
            if (minutesLon && minutesLon.length > 2) {
                lon = parseFloat((negativeLon ? negativeLon : '') + degreesLon + '.' + minutesLon);
            }
            else {
                lon = convertDMSToDD(parseFloat(degreesLon), parseFloat(minutesLon), parseFloat(secondsLon), directionLon);
            }
            if (minutesLat && minutesLat.length > 2) {
                lat = parseFloat((negativeLat ? negativeLat : '') + degreesLat + '.' + minutesLat);
            }
            else {
                lat = convertDMSToDD(parseFloat(degreesLat), parseFloat(minutesLat), parseFloat(secondsLat), directionLat);
            }
        }
        else if (mmRegex.test(coordStr)) {
            _j = __read(coordStr.match(mmPattern), 5), lon = _j[1], decimalLon = _j[2], lat = _j[3], decimalLat = _j[4];
            if (decimalLon) {
                lon = parseFloat(lon + '.' + decimalLon);
            }
            if (decimalLat) {
                lat = parseFloat(lat + '.' + decimalLat);
            }
        }
        else {
            return { lonLat: undefined, message: '', radius: undefined, conf: undefined };
        }
        // Set a negative coordinate for North America zone
        if (lon > 0 && lat > 0) {
            if (lon > lat) {
                lon = -lon;
            }
            else {
                lat = -lat;
            }
        }
        // Reverse coordinate to respect lonLat convention
        if (lon < lat) {
            lonLat = ( /** @type {?} */([lon, lat]));
        }
        else {
            lonLat = ( /** @type {?} */([lat, lon]));
        }
        // Reproject the coordinate if projection parameter have been set and coord is not 4326
        if ((projectionStr !== undefined && projectionStr !== toProjection) || (lonLat[0] > 180 || lonLat[0] < -180)) {
            /** @type {?} */
            var source = projectionStr ? 'EPSG:' + projectionStr : mapProjection;
            /** @type {?} */
            var dest = 'EPSG:' + toProjection;
            try {
                lonLat = olproj.transform(lonLat, source, dest);
            }
            catch (e) {
                return { lonLat: undefined, message: 'Projection ' + source + ' not supported', radius: undefined, conf: undefined };
            }
        }
        return { lonLat: lonLat, message: '', radius: radius ? parseInt(radius, 10) : undefined, conf: conf ? parseInt(conf, 10) : undefined };
    }
    /**
     * Convert degrees minutes seconds to dd
     * @param {?} degrees Degrees
     * @param {?} minutes Minutes
     * @param {?} seconds Seconds
     * @param {?} direction Direction
     * @return {?}
     */
    function convertDMSToDD(degrees, minutes, seconds, direction) {
        minutes = minutes || 0;
        seconds = seconds || 0;
        /** @type {?} */
        var dd = degrees + (minutes / 60) + (seconds / 3600);
        if (direction === 'S' || direction === 'W') {
            dd = -dd;
        } // Don't do anything for N or E
        return dd;
    }
    /**
     * Return true of two view states are equal.
     * @param {?} state1 View state
     * @param {?} state2 View state
     * @return {?} True if the view states are equal
     */
    function viewStatesAreEqual(state1, state2) {
        if (state1 === undefined || state2 === undefined) {
            return false;
        }
        /** @type {?} */
        var tolerance = 1 / 10000;
        return state1.zoom === state2.zoom &&
            Math.trunc(state1.center[0] / tolerance) === Math.trunc(state2.center[0] / tolerance) &&
            Math.trunc(state1.center[1] / tolerance) === Math.trunc(state2.center[1] / tolerance);
    }
    /**
     * Format the scale to a human readable text
     * @param {?} scale
     * @return {?} Human readable scale text
     */
    function formatScale(scale) {
        scale = Math.round(scale);
        if (scale < 10000) {
            return scale + '';
        }
        scale = Math.round(scale / 1000);
        if (scale < 1000) {
            return scale + 'K';
        }
        scale = Math.round(scale / 1000);
        return scale + 'M';
    }
    /**
     * Return the resolution from a scale denom
     * @param {?} scale Scale denom
     * @param {?=} dpi DPI
     * @return {?} Resolution
     */
    function getResolutionFromScale(scale, dpi) {
        if (dpi === void 0) {
            dpi = 72;
        }
        return scale / (39.37 * dpi);
    }
    /**
     * Return the resolution from a scale denom
     * @param {?} resolution
     * @param {?=} unit
     * @param {?=} dpi
     * @return {?} Resolution
     */
    function getScaleFromResolution(resolution, unit, dpi) {
        if (unit === void 0) {
            unit = 'm';
        }
        if (dpi === void 0) {
            dpi = 72;
        }
        return resolution * olproj.METERS_PER_UNIT[unit] * 39.37 * dpi;
    }
    /**
     * Returns true if the CTRL key is pushed during an Ol MapBrowserPointerEvent
     * @param {?} event OL MapBrowserPointerEvent
     * @return {?} Whether the CTRL key is pushed
     */
    function ctrlKeyDown(event) {
        /** @type {?} */
        var originalEvent = event.originalEvent;
        return (!originalEvent.altKey &&
            (has.MAC ? originalEvent.metaKey : originalEvent.ctrlKey) &&
            !originalEvent.shiftKey);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Base map controller
     */
    var /**
     * Base map controller
     */ MapController = /** @class */ (function () {
        function MapController() {
            /**
             * Array of observer keys
             */
            this.observerKeys = [];
        }
        /**
         * Return the OL map this controller is bound to
         * @returns OL Map
         */
        /**
         * Return the OL map this controller is bound to
         * @return {?} OL Map
         */
        MapController.prototype.getOlMap = /**
         * Return the OL map this controller is bound to
         * @return {?} OL Map
         */
            function () {
                return this.olMap;
            };
        /**
         * Add or remove this controller to/from a map.
         * @param map OL Map
         */
        /**
         * Add or remove this controller to/from a map.
         * @param {?} olMap
         * @return {?}
         */
        MapController.prototype.setOlMap = /**
         * Add or remove this controller to/from a map.
         * @param {?} olMap
         * @return {?}
         */
            function (olMap$$1) {
                if (olMap$$1 !== undefined && this.getOlMap() !== undefined) {
                    throw new Error('This controller is already bound to a map.');
                }
                if (olMap$$1 === undefined) {
                    this.teardownObservers();
                    this.olMap = olMap$$1;
                    return;
                }
                this.olMap = olMap$$1;
            };
        /**
         * Teardown any observers
         */
        /**
         * Teardown any observers
         * @return {?}
         */
        MapController.prototype.teardownObservers = /**
         * Teardown any observers
         * @return {?}
         */
            function () {
                this.observerKeys.forEach(( /**
                 * @param {?} key
                 * @return {?}
                 */function (key) { return olobservable.unByKey(key); }));
                this.observerKeys = [];
            };
        return MapController;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Controller to handle map view interactions
     */
    var /**
     * Controller to handle map view interactions
     */ MapViewController = /** @class */ (function (_super) {
        __extends(MapViewController, _super);
        function MapViewController(options) {
            var _this = _super.call(this) || this;
            _this.options = options;
            /**
             * Observable of the current resolution
             */
            _this.resolution$ = new rxjs.BehaviorSubject(undefined);
            /**
             * Observable of the current state
             */
            _this.state$ = new rxjs.BehaviorSubject(undefined);
            /**
             * Extent stream
             */
            _this.extent$ = new rxjs.Subject();
            /**
             * History of states
             */
            _this.states = [];
            /**
             * Current state index
             */
            _this.stateIndex = 0;
            return _this;
        }
        Object.defineProperty(MapViewController.prototype, "stateHistory", {
            /**
             * Whether the view controller should keep the view's state history
             */
            get: /**
             * Whether the view controller should keep the view's state history
             * @return {?}
             */ function () {
                return this.options ? this.options.stateHistory === true : false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapViewController.prototype, "olView", {
            /**
             * OL View
             */
            get: /**
             * OL View
             * @return {?}
             */ function () { return this.olMap.getView(); },
            enumerable: true,
            configurable: true
        });
        /**
         * Add or remove this controller to/from a map.
         * @param map OL Map
         */
        /**
         * Add or remove this controller to/from a map.
         * @param {?} olMap
         * @return {?}
         */
        MapViewController.prototype.setOlMap = /**
         * Add or remove this controller to/from a map.
         * @param {?} olMap
         * @return {?}
         */
            function (olMap$$1) {
                _super.prototype.setOlMap.call(this, olMap$$1);
                this.setupObservers();
            };
        /**
         * Observe move moveend and subscribe to the extent stream
         */
        /**
         * Observe move moveend and subscribe to the extent stream
         * @return {?}
         */
        MapViewController.prototype.setupObservers = /**
         * Observe move moveend and subscribe to the extent stream
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.stateHistory === true) {
                    this.observerKeys.push(this.olMap.on('moveend', ( /**
                     * @param {?} event
                     * @return {?}
                     */function (event) { return _this.onMoveEnd(event); })));
                }
                this.extent$$ = this.extent$
                    .pipe(operators.debounceTime(25))
                    .subscribe(( /**
             * @param {?} value
             * @return {?}
             */function (value) {
                    _this.setExtent(value.extent, value.action);
                }));
            };
        /**
         * Teardown any observers
         */
        /**
         * Teardown any observers
         * @return {?}
         */
        MapViewController.prototype.teardownObservers = /**
         * Teardown any observers
         * @return {?}
         */
            function () {
                _super.prototype.teardownObservers.call(this);
                if (this.extent$$ !== undefined) {
                    this.extent$$.unsubscribe();
                    this.extent$$ = undefined;
                }
            };
        /**
         * Get the view's OL projection
         * @returns OL projection
         */
        /**
         * Get the view's OL projection
         * @return {?} OL projection
         */
        MapViewController.prototype.getOlProjection = /**
         * Get the view's OL projection
         * @return {?} OL projection
         */
            function () {
                return this.olView.getProjection();
            };
        /**
         * Get the current map view center
         * @param projection Output projection
         * @returns Center
         */
        /**
         * Get the current map view center
         * @param {?=} projection Output projection
         * @return {?} Center
         */
        MapViewController.prototype.getCenter = /**
         * Get the current map view center
         * @param {?=} projection Output projection
         * @return {?} Center
         */
            function (projection) {
                /** @type {?} */
                var center = this.olView.getCenter();
                if (projection && center) {
                    center = olproj.transform(center, this.getOlProjection(), projection);
                }
                return center;
            };
        /**
         * Get the current view extent
         * @param projection Output projection
         * @returns Extent
         */
        /**
         * Get the current view extent
         * @param {?=} projection Output projection
         * @return {?} Extent
         */
        MapViewController.prototype.getExtent = /**
         * Get the current view extent
         * @param {?=} projection Output projection
         * @return {?} Extent
         */
            function (projection) {
                /** @type {?} */
                var extent = this.olView.calculateExtent(this.olMap.getSize());
                if (projection && extent) {
                    extent = olproj.transformExtent(extent, this.getOlProjection(), projection);
                }
                return extent;
            };
        /**
         * Get the current scale
         * @param dpi Dot per inches
         * @returns View scale
         */
        /**
         * Get the current scale
         * @param {?=} dpi Dot per inches
         * @return {?} View scale
         */
        MapViewController.prototype.getScale = /**
         * Get the current scale
         * @param {?=} dpi Dot per inches
         * @return {?} View scale
         */
            function (dpi) {
                if (dpi === void 0) {
                    dpi = 72;
                }
                return getScaleFromResolution(this.getResolution(), this.getOlProjection().getUnits(), dpi);
            };
        /**
         * Get the current resolution
         * @returns Projection denominator
         */
        /**
         * Get the current resolution
         * @return {?} Projection denominator
         */
        MapViewController.prototype.getResolution = /**
         * Get the current resolution
         * @return {?} Projection denominator
         */
            function () {
                return this.olView.getResolution();
            };
        /**
         * Get the current zoom level
         * @returns Zoom level
         */
        /**
         * Get the current zoom level
         * @return {?} Zoom level
         */
        MapViewController.prototype.getZoom = /**
         * Get the current zoom level
         * @return {?} Zoom level
         */
            function () {
                return Math.round(this.olView.getZoom());
            };
        /**
         * Zoom in
         */
        /**
         * Zoom in
         * @return {?}
         */
        MapViewController.prototype.zoomIn = /**
         * Zoom in
         * @return {?}
         */
            function () {
                this.zoomTo(this.olView.getZoom() + 1);
            };
        /**
         * Zoom out
         */
        /**
         * Zoom out
         * @return {?}
         */
        MapViewController.prototype.zoomOut = /**
         * Zoom out
         * @return {?}
         */
            function () {
                this.zoomTo(this.olView.getZoom() - 1);
            };
        /**
         * Zoom to specific zoom level
         * @param zoom Zoom level
         */
        /**
         * Zoom to specific zoom level
         * @param {?} zoom Zoom level
         * @return {?}
         */
        MapViewController.prototype.zoomTo = /**
         * Zoom to specific zoom level
         * @param {?} zoom Zoom level
         * @return {?}
         */
            function (zoom) {
                this.olView.animate({
                    zoom: zoom,
                    duration: 250,
                    easing: oleasing.easeOut
                });
            };
        /**
         * Move to extent after a short delay (100ms) unless
         * a new movement gets registered in the meantime.
         * @param extent Extent to move to
         */
        /**
         * Move to extent after a short delay (100ms) unless
         * a new movement gets registered in the meantime.
         * @param {?} extent Extent to move to
         * @return {?}
         */
        MapViewController.prototype.moveToExtent = /**
         * Move to extent after a short delay (100ms) unless
         * a new movement gets registered in the meantime.
         * @param {?} extent Extent to move to
         * @return {?}
         */
            function (extent) {
                this.extent$.next({ extent: extent, action: MapViewAction.Move });
            };
        /**
         * Zoom to extent after a short delay (100ms) unless
         * a new movement gets registered in the meantime.
         * @param extent Extent to zoom to
         */
        /**
         * Zoom to extent after a short delay (100ms) unless
         * a new movement gets registered in the meantime.
         * @param {?} extent Extent to zoom to
         * @return {?}
         */
        MapViewController.prototype.zoomToExtent = /**
         * Zoom to extent after a short delay (100ms) unless
         * a new movement gets registered in the meantime.
         * @param {?} extent Extent to zoom to
         * @return {?}
         */
            function (extent) {
                this.extent$.next({ extent: extent, action: MapViewAction.Zoom });
            };
        /**
         * Return the current view rotation
         * @returns Rotation angle in degrees
         */
        /**
         * Return the current view rotation
         * @return {?} Rotation angle in degrees
         */
        MapViewController.prototype.getRotation = /**
         * Return the current view rotation
         * @return {?} Rotation angle in degrees
         */
            function () {
                return this.olView.getRotation();
            };
        /**
         * Reset the view rotation to 0
         */
        /**
         * Reset the view rotation to 0
         * @return {?}
         */
        MapViewController.prototype.resetRotation = /**
         * Reset the view rotation to 0
         * @return {?}
         */
            function () {
                this.olView.animate({ rotation: 0 });
            };
        /**
         * Whether the view has a previous state
         * @returns True if the view has a previous state
         */
        /**
         * Whether the view has a previous state
         * @return {?} True if the view has a previous state
         */
        MapViewController.prototype.hasPreviousState = /**
         * Whether the view has a previous state
         * @return {?} True if the view has a previous state
         */
            function () {
                return this.states.length > 1 && this.stateIndex > 0;
            };
        /**
         * Whether the view has a next state
         * @returns True if the view has a next state
         */
        /**
         * Whether the view has a next state
         * @return {?} True if the view has a next state
         */
        MapViewController.prototype.hasNextState = /**
         * Whether the view has a next state
         * @return {?} True if the view has a next state
         */
            function () {
                return this.states.length > 1 && this.stateIndex < this.states.length - 1;
            };
        /**
         * Restore the previous view state
         */
        /**
         * Restore the previous view state
         * @return {?}
         */
        MapViewController.prototype.previousState = /**
         * Restore the previous view state
         * @return {?}
         */
            function () {
                if (this.hasPreviousState()) {
                    this.setStateIndex(this.stateIndex - 1);
                }
            };
        /**
         * Restore the next view state
         */
        /**
         * Restore the next view state
         * @return {?}
         */
        MapViewController.prototype.nextState = /**
         * Restore the next view state
         * @return {?}
         */
            function () {
                if (this.hasNextState()) {
                    this.setStateIndex(this.stateIndex + 1);
                }
            };
        /**
         * Clear the state history
         */
        /**
         * Clear the state history
         * @return {?}
         */
        MapViewController.prototype.clearStateHistory = /**
         * Clear the state history
         * @return {?}
         */
            function () {
                this.states = [];
                this.stateIndex = 0;
            };
        /**
         * Update the the view to it's intial state
         */
        /**
         * Update the the view to it's intial state
         * @return {?}
         */
        MapViewController.prototype.setInitialState = /**
         * Update the the view to it's intial state
         * @return {?}
         */
            function () {
                if (this.states.length > 0) {
                    this.setStateIndex(0);
                }
            };
        /**
         * Move to the extent retrieved from the stream
         * @param extent Extent
         * @param action Either zoom or move
         */
        /**
         * Move to the extent retrieved from the stream
         * @private
         * @param {?} extent Extent
         * @param {?} action Either zoom or move
         * @return {?}
         */
        MapViewController.prototype.setExtent = /**
         * Move to the extent retrieved from the stream
         * @private
         * @param {?} extent Extent
         * @param {?} action Either zoom or move
         * @return {?}
         */
            function (extent, action) {
                /** @type {?} */
                var olView$$1 = this.olView;
                if (action === MapViewAction.Zoom) {
                    olView$$1.fit(extent, { maxZoom: 17 });
                }
                else if (action === MapViewAction.Move) {
                    olView$$1.fit(extent, { maxZoom: olView$$1.getZoom() });
                }
            };
        /**
         * Set the view state index
         * @param index State index
         */
        /**
         * Set the view state index
         * @private
         * @param {?} index State index
         * @return {?}
         */
        MapViewController.prototype.setStateIndex = /**
         * Set the view state index
         * @private
         * @param {?} index State index
         * @return {?}
         */
            function (index) {
                this.stateIndex = index;
                this.setState(this.states[index]);
            };
        /**
         * Set the view state
         * @param state View state
         */
        /**
         * Set the view state
         * @private
         * @param {?} state View state
         * @return {?}
         */
        MapViewController.prototype.setState = /**
         * Set the view state
         * @private
         * @param {?} state View state
         * @return {?}
         */
            function (state) {
                this.olView.animate({
                    resolution: state.resolution,
                    center: state.center,
                    duration: 0
                });
            };
        /**
         * On move end, get the view state and record it.
         * @param event Map event
         */
        /**
         * On move end, get the view state and record it.
         * @private
         * @param {?} event Map event
         * @return {?}
         */
        MapViewController.prototype.onMoveEnd = /**
         * On move end, get the view state and record it.
         * @private
         * @param {?} event Map event
         * @return {?}
         */
            function (event) {
                /** @type {?} */
                var resolution = this.getResolution();
                if (this.resolution$.value !== resolution) {
                    this.resolution$.next(resolution);
                }
                /** @type {?} */
                var state = {
                    resolution: resolution,
                    center: this.getCenter(),
                    zoom: this.getZoom()
                };
                if (this.stateHistory === true) {
                    /** @type {?} */
                    var stateIndex = this.stateIndex;
                    /** @type {?} */
                    var stateAtIndex = this.states.length === 0 ? undefined : this.states[stateIndex];
                    if (!viewStatesAreEqual(state, stateAtIndex)) {
                        this.states = this.states.slice(0, stateIndex + 1).concat([state]);
                        this.stateIndex = this.states.length - 1;
                    }
                }
                this.state$.next(state);
            };
        return MapViewController;
    }(MapController));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    // TODO: This class is messy. Clearly define it's scope and the map browser's.
    // Move some stuff into controllers.
    var  
    // TODO: This class is messy. Clearly define it's scope and the map browser's.
    // Move some stuff into controllers.
    IgoMap = /** @class */ (function () {
        function IgoMap(options) {
            this.layers$ = new rxjs.BehaviorSubject([]);
            this.geolocation$ = new rxjs.BehaviorSubject(undefined);
            this.defaultOptions = {
                controls: { attribution: false }
            };
            this.options = Object.assign({}, this.defaultOptions, options);
            this.layerWatcher = new LayerWatcher();
            this.status$ = this.layerWatcher.status$;
            olproj4.register(proj4);
            this.init();
        }
        Object.defineProperty(IgoMap.prototype, "layers", {
            get: /**
             * @return {?}
             */ function () {
                return this.layers$.value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgoMap.prototype, "projection", {
            get: /**
             * @return {?}
             */ function () {
                return this.viewController.getOlProjection().getCode();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        IgoMap.prototype.init = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var controls = [];
                if (this.options.controls) {
                    if (this.options.controls.attribution) {
                        /** @type {?} */
                        var attributionOpt = ( /** @type {?} */((this.options.controls.attribution === true
                            ? {}
                            : this.options.controls.attribution)));
                        controls.push(new olAttribution(attributionOpt));
                    }
                    if (this.options.controls.scaleLine) {
                        /** @type {?} */
                        var scaleLineOpt = ( /** @type {?} */((this.options.controls.scaleLine === true
                            ? {}
                            : this.options.controls.scaleLine)));
                        controls.push(new olControlScaleLine(scaleLineOpt));
                    }
                }
                /** @type {?} */
                var interactions = {};
                if (this.options.interactions === false) {
                    interactions = {
                        altShiftDragRotate: false,
                        doubleClickZoom: false,
                        keyboard: false,
                        mouseWheelZoom: false,
                        shiftDragZoom: false,
                        dragPan: false,
                        pinchRotate: false,
                        pinchZoom: false
                    };
                }
                this.ol = new olMap({
                    interactions: olinteraction.defaults(interactions),
                    controls: controls
                });
                this.setView(this.options.view || {});
                this.viewController = new MapViewController({
                    stateHistory: true
                });
                this.viewController.setOlMap(this.ol);
                this.overlay = new Overlay(this);
            };
        /**
         * @param {?} id
         * @return {?}
         */
        IgoMap.prototype.setTarget = /**
         * @param {?} id
         * @return {?}
         */
            function (id) {
                this.ol.setTarget(id);
                if (id !== undefined) {
                    this.layerWatcher.subscribe(( /**
                     * @return {?}
                     */function () { }), null);
                }
                else {
                    this.layerWatcher.unsubscribe();
                }
            };
        /**
         * @param {?} options
         * @return {?}
         */
        IgoMap.prototype.updateView = /**
         * @param {?} options
         * @return {?}
         */
            function (options) {
                /** @type {?} */
                var currentView = this.ol.getView();
                /** @type {?} */
                var viewOptions = Object.assign({
                    zoom: currentView.getZoom()
                }, currentView.getProperties());
                this.setView(Object.assign(viewOptions, options));
            };
        /**
         * Set the map view
         * @param options Map view options
         */
        /**
         * Set the map view
         * @param {?} options Map view options
         * @return {?}
         */
        IgoMap.prototype.setView = /**
         * Set the map view
         * @param {?} options Map view options
         * @return {?}
         */
            function (options) {
                if (this.viewController !== undefined) {
                    this.viewController.clearStateHistory();
                }
                /** @type {?} */
                var view = new olView(options);
                this.ol.setView(view);
                this.unsubscribeGeolocate();
                if (options) {
                    if (options.center) {
                        /** @type {?} */
                        var projection = view.getProjection().getCode();
                        /** @type {?} */
                        var center = olproj.fromLonLat(options.center, projection);
                        view.setCenter(center);
                    }
                    if (options.geolocate) {
                        this.geolocate(true);
                    }
                }
            };
        // TODO: Move to ViewController and update every place it's used
        // TODO: Move to ViewController and update every place it's used
        /**
         * @param {?=} projection
         * @return {?}
         */
        IgoMap.prototype.getCenter =
            // TODO: Move to ViewController and update every place it's used
            /**
             * @param {?=} projection
             * @return {?}
             */
            function (projection) {
                return this.viewController.getCenter();
            };
        // TODO: Move to ViewController and update every place it's used
        // TODO: Move to ViewController and update every place it's used
        /**
         * @param {?=} projection
         * @return {?}
         */
        IgoMap.prototype.getExtent =
            // TODO: Move to ViewController and update every place it's used
            /**
             * @param {?=} projection
             * @return {?}
             */
            function (projection) {
                return this.viewController.getExtent();
            };
        // TODO: Move to ViewController and update every place it's used
        // TODO: Move to ViewController and update every place it's used
        /**
         * @return {?}
         */
        IgoMap.prototype.getZoom =
            // TODO: Move to ViewController and update every place it's used
            /**
             * @return {?}
             */
            function () {
                return this.viewController.getZoom();
            };
        /**
         * @param {?} baseLayer
         * @return {?}
         */
        IgoMap.prototype.changeBaseLayer = /**
         * @param {?} baseLayer
         * @return {?}
         */
            function (baseLayer) {
                var e_1, _a;
                if (!baseLayer) {
                    return;
                }
                try {
                    for (var _b = __values(this.getBaseLayers()), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var bl = _c.value;
                        bl.visible = false;
                    }
                }
                catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return))
                            _a.call(_b);
                    }
                    finally {
                        if (e_1)
                            throw e_1.error;
                    }
                }
                baseLayer.visible = true;
            };
        /**
         * @return {?}
         */
        IgoMap.prototype.getBaseLayers = /**
         * @return {?}
         */
            function () {
                return this.layers.filter(( /**
                 * @param {?} layer
                 * @return {?}
                 */function (layer) { return layer.baseLayer === true; }));
            };
        /**
         * @param {?} id
         * @return {?}
         */
        IgoMap.prototype.getLayerById = /**
         * @param {?} id
         * @return {?}
         */
            function (id) {
                return this.layers.find(( /**
                 * @param {?} layer
                 * @return {?}
                 */function (layer) { return layer.id && layer.id === id; }));
            };
        /**
         * @param {?} alias
         * @return {?}
         */
        IgoMap.prototype.getLayerByAlias = /**
         * @param {?} alias
         * @return {?}
         */
            function (alias) {
                return this.layers.find(( /**
                 * @param {?} layer
                 * @return {?}
                 */function (layer) { return layer.alias && layer.alias === alias; }));
            };
        /**
         * Add a single layer
         * @param layer Layer to add
         * @param push DEPRECATED
         */
        /**
         * Add a single layer
         * @param {?} layer Layer to add
         * @param {?=} push DEPRECATED
         * @return {?}
         */
        IgoMap.prototype.addLayer = /**
         * Add a single layer
         * @param {?} layer Layer to add
         * @param {?=} push DEPRECATED
         * @return {?}
         */
            function (layer, push) {
                if (push === void 0) {
                    push = true;
                }
                this.addLayers([layer]);
            };
        /**
         * Add many layers
         * @param layers Layers to add
         * @param push DEPRECATED
         */
        /**
         * Add many layers
         * @param {?} layers Layers to add
         * @param {?=} push DEPRECATED
         * @return {?}
         */
        IgoMap.prototype.addLayers = /**
         * Add many layers
         * @param {?} layers Layers to add
         * @param {?=} push DEPRECATED
         * @return {?}
         */
            function (layers, push) {
                var _this = this;
                if (push === void 0) {
                    push = true;
                }
                /** @type {?} */
                var addedLayers = layers
                    .map(( /**
             * @param {?} layer
             * @return {?}
             */function (layer) { return _this.doAddLayer(layer); }))
                    .filter(( /**
             * @param {?} layer
             * @return {?}
             */function (layer) { return layer !== undefined; }));
                this.setLayers([].concat(this.layers, addedLayers));
            };
        /**
         * Remove a single layer
         * @param layer Layer to remove
         */
        /**
         * Remove a single layer
         * @param {?} layer Layer to remove
         * @return {?}
         */
        IgoMap.prototype.removeLayer = /**
         * Remove a single layer
         * @param {?} layer Layer to remove
         * @return {?}
         */
            function (layer) {
                this.removeLayers([layer]);
            };
        /**
         * Remove many layers
         * @param layers Layers to remove
         */
        /**
         * Remove many layers
         * @param {?} layers Layers to remove
         * @return {?}
         */
        IgoMap.prototype.removeLayers = /**
         * Remove many layers
         * @param {?} layers Layers to remove
         * @return {?}
         */
            function (layers) {
                var _this = this;
                /** @type {?} */
                var newLayers = this.layers$.value.slice(0);
                /** @type {?} */
                var layersToRemove = [];
                layers.forEach(( /**
                 * @param {?} layer
                 * @return {?}
                 */function (layer) {
                    /** @type {?} */
                    var index = _this.getLayerIndex(layer);
                    if (index >= 0) {
                        layersToRemove.push(layer);
                        newLayers.splice(index, 1);
                    }
                }));
                layersToRemove.forEach(( /**
                 * @param {?} layer
                 * @return {?}
                 */function (layer) { return _this.doRemoveLayer(layer); }));
                this.setLayers(newLayers);
            };
        /**
         * Remove all layers
         */
        /**
         * Remove all layers
         * @return {?}
         */
        IgoMap.prototype.removeAllLayers = /**
         * Remove all layers
         * @return {?}
         */
            function () {
                var _this = this;
                this.layers.forEach(( /**
                 * @param {?} layer
                 * @return {?}
                 */function (layer) { return _this.doRemoveLayer(layer); }));
                this.layers$.next([]);
            };
        /**
         * @param {?} layer
         * @return {?}
         */
        IgoMap.prototype.raiseLayer = /**
         * @param {?} layer
         * @return {?}
         */
            function (layer) {
                /** @type {?} */
                var index = this.getLayerIndex(layer);
                if (index > 0) {
                    this.moveLayer(layer, index, index - 1);
                }
            };
        /**
         * @param {?} layer
         * @return {?}
         */
        IgoMap.prototype.lowerLayer = /**
         * @param {?} layer
         * @return {?}
         */
            function (layer) {
                /** @type {?} */
                var index = this.getLayerIndex(layer);
                if (index < this.layers.length - 1) {
                    this.moveLayer(layer, index, index + 1);
                }
            };
        /**
         * @param {?} layer
         * @param {?} from
         * @param {?} to
         * @return {?}
         */
        IgoMap.prototype.moveLayer = /**
         * @param {?} layer
         * @param {?} from
         * @param {?} to
         * @return {?}
         */
            function (layer, from, to) {
                /** @type {?} */
                var layerTo = this.layers[to];
                /** @type {?} */
                var zIndexTo = layerTo.zIndex;
                /** @type {?} */
                var zIndexFrom = layer.zIndex;
                layer.zIndex = zIndexTo;
                layerTo.zIndex = zIndexFrom;
                this.layers[to] = layer;
                this.layers[from] = layerTo;
                this.layers$.next(this.layers.slice(0));
            };
        /**
         * Add a layer to the OL map and start watching. If the layer is already
         * added to this map, make it visible but don't add it one again.
         * @param layer Layer
         * @returns The layer added, if any
         */
        /**
         * Add a layer to the OL map and start watching. If the layer is already
         * added to this map, make it visible but don't add it one again.
         * @private
         * @param {?} layer Layer
         * @return {?} The layer added, if any
         */
        IgoMap.prototype.doAddLayer = /**
         * Add a layer to the OL map and start watching. If the layer is already
         * added to this map, make it visible but don't add it one again.
         * @private
         * @param {?} layer Layer
         * @return {?} The layer added, if any
         */
            function (layer) {
                if (layer.baseLayer && layer.visible) {
                    this.changeBaseLayer(layer);
                }
                /** @type {?} */
                var existingLayer = this.getLayerById(layer.id);
                if (existingLayer !== undefined) {
                    existingLayer.visible = true;
                    return;
                }
                if (layer.zIndex === undefined || layer.zIndex === 0) {
                    /** @type {?} */
                    var offset = layer.baseLayer ? 1 : 10;
                    layer.zIndex = this.layers.length + offset;
                }
                layer.setMap(this);
                this.layerWatcher.watchLayer(layer);
                this.ol.addLayer(layer.ol);
                return layer;
            };
        /**
         * Remove a layer from the OL map and stop watching
         * @param layer Layer
         */
        /**
         * Remove a layer from the OL map and stop watching
         * @private
         * @param {?} layer Layer
         * @return {?}
         */
        IgoMap.prototype.doRemoveLayer = /**
         * Remove a layer from the OL map and stop watching
         * @private
         * @param {?} layer Layer
         * @return {?}
         */
            function (layer) {
                this.layerWatcher.unwatchLayer(layer);
                this.ol.removeLayer(layer.ol);
                layer.setMap(undefined);
            };
        /**
         * Update the layers observable
         * @param layers Layers
         */
        /**
         * Update the layers observable
         * @private
         * @param {?} layers Layers
         * @return {?}
         */
        IgoMap.prototype.setLayers = /**
         * Update the layers observable
         * @private
         * @param {?} layers Layers
         * @return {?}
         */
            function (layers) {
                this.layers$.next(this.sortLayersByZIndex(layers).slice(0));
            };
        /**
         * Sort layers by descending zIndex
         * @param layers Array of layers
         * @returns The original array, sorted by zIndex
         */
        /**
         * Sort layers by descending zIndex
         * @private
         * @param {?} layers Array of layers
         * @return {?} The original array, sorted by zIndex
         */
        IgoMap.prototype.sortLayersByZIndex = /**
         * Sort layers by descending zIndex
         * @private
         * @param {?} layers Array of layers
         * @return {?} The original array, sorted by zIndex
         */
            function (layers) {
                // Sort by descending zIndex
                return layers.sort(( /**
                 * @param {?} layer1
                 * @param {?} layer2
                 * @return {?}
                 */function (layer1, layer2) { return layer2.zIndex - layer1.zIndex; }));
            };
        /**
         * Get layer index in the map's inenr array of layers
         * @param layer Layer
         * @returns The layer index
         */
        /**
         * Get layer index in the map's inenr array of layers
         * @private
         * @param {?} layer Layer
         * @return {?} The layer index
         */
        IgoMap.prototype.getLayerIndex = /**
         * Get layer index in the map's inenr array of layers
         * @private
         * @param {?} layer Layer
         * @return {?} The layer index
         */
            function (layer) {
                return this.layers.findIndex(( /**
                 * @param {?} _layer
                 * @return {?}
                 */function (_layer) { return _layer === layer; }));
            };
        // TODO: Create a GeolocationController with everything below
        // TODO: Create a GeolocationController with everything below
        /**
         * @param {?=} track
         * @return {?}
         */
        IgoMap.prototype.geolocate =
            // TODO: Create a GeolocationController with everything below
            /**
             * @param {?=} track
             * @return {?}
             */
            function (track) {
                var _this = this;
                if (track === void 0) {
                    track = false;
                }
                /** @type {?} */
                var first = true;
                if (this.geolocation$$) {
                    track = this.geolocation.getTracking();
                    this.unsubscribeGeolocate();
                }
                this.startGeolocation();
                this.geolocation$$ = this.geolocation$.subscribe(( /**
                 * @param {?} geolocation
                 * @return {?}
                 */function (geolocation) {
                    if (!geolocation) {
                        return;
                    }
                    /** @type {?} */
                    var accuracy = geolocation.getAccuracy();
                    if (accuracy < 10000) {
                        /** @type {?} */
                        var geometry = geolocation.getAccuracyGeometry();
                        /** @type {?} */
                        var extent = geometry.getExtent();
                        if (_this.geolocationFeature &&
                            _this.overlay.dataSource.ol.getFeatureById(_this.geolocationFeature.getId())) {
                            _this.overlay.dataSource.ol.removeFeature(_this.geolocationFeature);
                        }
                        _this.geolocationFeature = new OlFeature({ geometry: geometry });
                        _this.geolocationFeature.setId('geolocationFeature');
                        _this.overlay.addFeature(_this.geolocationFeature);
                        if (first) {
                            _this.viewController.zoomToExtent(extent);
                        }
                    }
                    else if (first) {
                        /** @type {?} */
                        var view = _this.ol.getView();
                        /** @type {?} */
                        var coordinates = geolocation.getPosition();
                        view.setCenter(coordinates);
                        view.setZoom(14);
                    }
                    if (track) {
                        _this.unsubscribeGeolocate();
                    }
                    first = false;
                }));
            };
        /**
         * @return {?}
         */
        IgoMap.prototype.unsubscribeGeolocate = /**
         * @return {?}
         */
            function () {
                this.stopGeolocation();
                if (this.geolocation$$) {
                    this.geolocation$$.unsubscribe();
                    this.geolocation$$ = undefined;
                }
            };
        /**
         * @private
         * @return {?}
         */
        IgoMap.prototype.startGeolocation = /**
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                if (!this.geolocation) {
                    this.geolocation = new olGeolocation({
                        projection: this.projection,
                        tracking: true
                    });
                    this.geolocation.on('change', ( /**
                     * @param {?} evt
                     * @return {?}
                     */function (evt) {
                        _this.geolocation$.next(_this.geolocation);
                    }));
                }
                else {
                    this.geolocation.setTracking(true);
                }
            };
        /**
         * @private
         * @return {?}
         */
        IgoMap.prototype.stopGeolocation = /**
         * @private
         * @return {?}
         */
            function () {
                if (this.geolocation) {
                    this.geolocation.setTracking(false);
                }
            };
        return IgoMap;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MapBrowserComponent = /** @class */ (function () {
        function MapBrowserComponent(activityService) {
            this.activityService = activityService;
            this.id = "igo-map-target-" + new Date().getTime();
        }
        Object.defineProperty(MapBrowserComponent.prototype, "view", {
            get: /**
             * @return {?}
             */ function () { return this._view; },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._view = value;
                if (this.map !== undefined) {
                    this.map.updateView(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MapBrowserComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.status$$ = this.map.status$.subscribe(( /**
                 * @param {?} status
                 * @return {?}
                 */function (status) {
                    return _this.handleStatusChange(status);
                }));
            };
        /**
         * @return {?}
         */
        MapBrowserComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                this.map.setTarget(this.id);
            };
        /**
         * @return {?}
         */
        MapBrowserComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.map.setTarget(undefined);
                this.activityService.unregister(this.activityId);
                this.status$$.unsubscribe();
            };
        /**
         * @private
         * @param {?} status
         * @return {?}
         */
        MapBrowserComponent.prototype.handleStatusChange = /**
         * @private
         * @param {?} status
         * @return {?}
         */
            function (status) {
                if (status === utils.SubjectStatus.Working && this.activityId === undefined) {
                    this.activityId = this.activityService.register();
                }
                else if (status === utils.SubjectStatus.Done && this.activityId !== undefined) {
                    this.activityService.unregister(this.activityId);
                    this.activityId = undefined;
                }
            };
        MapBrowserComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'igo-map-browser',
                        template: "<div [id]=\"id\" class=\"igo-map-browser-target\"></div>\r\n<ng-content></ng-content>\r\n",
                        styles: [":host{position:relative;display:block}.igo-map-browser-target,:host{width:100%;height:100%}:host>>>igo-zoom-button{position:absolute;bottom:5px;right:5px}:host>>>igo-geolocate-button{position:absolute;bottom:95px;right:5px}:host>>>igo-rotation-button{position:absolute;top:calc(40px + 5px + 5px);right:5px}:host>>>igo-user-button{position:absolute;bottom:5px;right:calc(5px + 50px)}:host>>>igo-baselayers-switcher{position:absolute;bottom:5px;left:5px}:host.igo-attribution-offset>>>.ol-attribution{left:90px;width:calc(100% - 200px)}@media only screen and (max-width:450px),only screen and (max-height:450px){:host>>>igo-zoom-button{display:none}:host>>>igo-geolocate-button{bottom:5px}:host>>>igo-rotation-button{top:calc(40px + 5px + 5px)}:host>>>igo-user-button{right:calc(5px + 90px)}:host.igo-attribution-offset>>>.ol-attribution{left:50px}}:host>>>.ol-attribution{left:5px;bottom:5px;text-align:left;padding:0;margin-right:90px;background-color:rgba(255,255,255,0);width:calc(100% - 100px)}:host>>>.ol-attribution.ol-logo-only{height:inherit}:host>>>.ol-attribution.ol-collapsed{background:0 0}:host>>>.ol-attribution.ol-collapsed button{-webkit-transform:none;transform:none}:host>>>.ol-attribution button{-webkit-transform:rotate(180deg);transform:rotate(180deg);background-color:#fff;cursor:pointer}:host>>>.ol-scale-line-inner{color:#000;border-color:#000}:host>>>.ol-scale-line{background-color:rgba(255,255,255,0);bottom:4px;-webkit-transform:translate(-50%);transform:translate(-50%);left:50%}:host>>>canvas{display:block}"]
                    }] }
        ];
        /** @nocollapse */
        MapBrowserComponent.ctorParameters = function () {
            return [
                { type: i1$1.ActivityService }
            ];
        };
        MapBrowserComponent.propDecorators = {
            map: [{ type: i0.Input }],
            view: [{ type: i0.Input }]
        };
        return MapBrowserComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MapOfflineDirective = /** @class */ (function () {
        function MapOfflineDirective(component, networkService) {
            this.networkService = networkService;
            this.component = component;
        }
        Object.defineProperty(MapOfflineDirective.prototype, "map", {
            get: /**
             * @return {?}
             */ function () {
                return this.component.map;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MapOfflineDirective.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.networkService.currentState().subscribe(( /**
                 * @param {?} state
                 * @return {?}
                 */function (state) {
                    console.log(state);
                    _this.state = state;
                    _this.changeLayer();
                }));
                this.map.layers$.subscribe(( /**
                 * @param {?} layers
                 * @return {?}
                 */function (layers) {
                    _this.changeLayer();
                }));
            };
        /**
         * @private
         * @return {?}
         */
        MapOfflineDirective.prototype.changeLayer = /**
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var sourceOptions;
                /** @type {?} */
                var layerList = this.map.layers$.value;
                layerList.forEach(( /**
                 * @param {?} layer
                 * @return {?}
                 */function (layer) {
                    if (layer.options.sourceOptions.type === 'mvt') {
                        sourceOptions = (( /** @type {?} */(layer.options.sourceOptions)));
                        layer.ol.getSource().clear();
                    }
                    else if (layer.options.sourceOptions.type === 'xyz') {
                        sourceOptions = (( /** @type {?} */(layer.options.sourceOptions)));
                    }
                    else if (layer.options.sourceOptions.type === 'vector') {
                        sourceOptions = (( /** @type {?} */(layer.options.sourceOptions)));
                    }
                    else {
                        return;
                    }
                    if (sourceOptions.pathOffline &&
                        _this.state.connection === false) {
                        if (sourceOptions.excludeAttributeOffline) {
                            sourceOptions.excludeAttributeBackUp = sourceOptions.excludeAttribute;
                            sourceOptions.excludeAttribute = sourceOptions.excludeAttributeOffline;
                        }
                        layer.ol.getSource().setUrl(sourceOptions.pathOffline);
                    }
                    else if (sourceOptions.pathOffline &&
                        _this.state.connection === true) {
                        if (sourceOptions.excludeAttributeBackUp) {
                            sourceOptions.excludeAttribute = sourceOptions.excludeAttributeBackUp;
                        }
                        layer.ol.getSource().setUrl(sourceOptions.url);
                    }
                }));
            };
        MapOfflineDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[igoMapOffline]'
                    },] }
        ];
        /** @nocollapse */
        MapOfflineDirective.ctorParameters = function () {
            return [
                { type: MapBrowserComponent },
                { type: i1$1.NetworkService }
            ];
        };
        return MapOfflineDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * When injected, this service automatically registers and
     * projection defined in the application config. A custom projection
     * needs to be registered to be usable by OL.
     */
    var ProjectionService = /** @class */ (function () {
        function ProjectionService(config) {
            var _this = this;
            this.config = config;
            /** @type {?} */
            var projections = this.config.getConfig('projections') || [];
            projections.forEach(( /**
             * @param {?} projection
             * @return {?}
             */function (projection) {
                _this.registerProjection(projection);
            }));
        }
        /**
         * Define a proj4 projection and register it in OL
         * @param projection Projection
         */
        /**
         * Define a proj4 projection and register it in OL
         * @param {?} projection Projection
         * @return {?}
         */
        ProjectionService.prototype.registerProjection = /**
         * Define a proj4 projection and register it in OL
         * @param {?} projection Projection
         * @return {?}
         */
            function (projection) {
                proj4.defs(projection.code, projection.def);
                olproj4.register(proj4);
                olproj.get(projection.code).setExtent(projection.extent);
            };
        ProjectionService.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        ProjectionService.ctorParameters = function () {
            return [
                { type: i1$1.ConfigService }
            ];
        };
        /** @nocollapse */ ProjectionService.ngInjectableDef = i0.defineInjectable({ factory: function ProjectionService_Factory() { return new ProjectionService(i0.inject(i1$1.ConfigService)); }, token: ProjectionService, providedIn: "root" });
        return ProjectionService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var ZoomButtonComponent = /** @class */ (function () {
        function ZoomButtonComponent() {
        }
        Object.defineProperty(ZoomButtonComponent.prototype, "zoom", {
            get: /**
             * @return {?}
             */ function () { return this.map.viewController.getZoom(); },
            enumerable: true,
            configurable: true
        });
        ZoomButtonComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'igo-zoom-button',
                        template: "<div class=\"igo-zoom-button-container\">\r\n  <button\r\n    mat-icon-button\r\n    [matTooltip]=\"'igo.geo.mapButtons.zoomIn' | translate: {zoom: zoom + 1}\"\r\n    matTooltipPosition=\"left\"\r\n    [color]=\"color\"\r\n    (click)=\"map.viewController.zoomIn()\">\r\n    <mat-icon svgIcon=\"plus\"></mat-icon>\r\n  </button>\r\n\r\n  <button\r\n    mat-icon-button\r\n    [matTooltip]=\"'igo.geo.mapButtons.zoomOut' | translate: {zoom: zoom - 1}\"\r\n    matTooltipPosition=\"left\"\r\n    [color]=\"color\"\r\n    (click)=\"map.viewController.zoomOut()\">\r\n    <mat-icon svgIcon=\"minus\"></mat-icon>\r\n  </button>\r\n</div>\r\n",
                        styles: [".igo-zoom-button-container{width:40px}.igo-zoom-button-container button{background-color:#fff}.igo-zoom-button-container button:hover{background-color:#efefef}.igo-zoom-button-container button:first-child{margin-bottom:2px}:host>>>button .mat-button-ripple-round,button{border-radius:0}"]
                    }] }
        ];
        /** @nocollapse */
        ZoomButtonComponent.ctorParameters = function () { return []; };
        ZoomButtonComponent.propDecorators = {
            map: [{ type: i0.Input }],
            color: [{ type: i0.Input }]
        };
        return ZoomButtonComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var GeolocateButtonComponent = /** @class */ (function () {
        function GeolocateButtonComponent() {
        }
        Object.defineProperty(GeolocateButtonComponent.prototype, "map", {
            get: /**
             * @return {?}
             */ function () {
                return this._map;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._map = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeolocateButtonComponent.prototype, "color", {
            get: /**
             * @return {?}
             */ function () {
                return this._color;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._color = value;
            },
            enumerable: true,
            configurable: true
        });
        GeolocateButtonComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'igo-geolocate-button',
                        template: "<div class=\"igo-geolocate-button-container\">\r\n  <button\r\n    mat-icon-button\r\n    [matTooltip]=\"'igo.geo.mapButtons.geolocate' | translate\"\r\n    matTooltipPosition=\"left\"\r\n    [color]=\"color\"\r\n    (click)=\"map.geolocate()\">\r\n    <mat-icon svgIcon=\"crosshairs-gps\"></mat-icon>\r\n  </button>\r\n</div>\r\n",
                        styles: [".igo-geolocate-button-container{width:40px;background-color:#fff}.igo-geolocate-button-container:hover{background-color:#efefef}:host>>>button .mat-button-ripple-round,button{border-radius:0}"]
                    }] }
        ];
        /** @nocollapse */
        GeolocateButtonComponent.ctorParameters = function () { return []; };
        GeolocateButtonComponent.propDecorators = {
            map: [{ type: i0.Input }],
            color: [{ type: i0.Input }]
        };
        return GeolocateButtonComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @return {?}
     */
    function baseLayersSwitcherSlideInOut() {
        return animations.trigger('baseLayerSwitcherState', [
            animations.state('collapseIcon', animations.style({
                height: '40px',
                width: '40px',
                overflow: 'hidden'
            })),
            animations.state('collapseMap', animations.style({
                height: '85px',
                overflow: 'hidden'
            })),
            animations.state('expand', animations.style({
                overflow: 'hidden'
            })),
            animations.transition('collapse => expand', animations.animate('200ms')),
            animations.transition('expand => collapse', animations.animate('200ms'))
        ]);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var BaseLayersSwitcherComponent = /** @class */ (function () {
        function BaseLayersSwitcherComponent(mediaService) {
            this.mediaService = mediaService;
            this._baseLayers = [];
            this.expand = false;
            this.showButton = true;
            /** @type {?} */
            var media = this.mediaService.media$.value;
            if (media === i1$1.Media.Mobile && this.useStaticIcon === undefined) {
                this.useStaticIcon = true;
            }
        }
        Object.defineProperty(BaseLayersSwitcherComponent.prototype, "map", {
            get: /**
             * @return {?}
             */ function () {
                return this._map;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._map = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseLayersSwitcherComponent.prototype, "useStaticIcon", {
            get: /**
             * @return {?}
             */ function () {
                return this._useStaticIcon;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._useStaticIcon = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        BaseLayersSwitcherComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.layers$$ = this.map.layers$.subscribe(( /**
                 * @param {?} arrayLayers
                 * @return {?}
                 */function (arrayLayers) {
                    _this._baseLayers = arrayLayers.filter(( /**
                     * @param {?} l
                     * @return {?}
                     */function (l) { return l.baseLayer; }));
                }));
            };
        /**
         * @return {?}
         */
        BaseLayersSwitcherComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.layers$$.unsubscribe();
            };
        /**
         * @return {?}
         */
        BaseLayersSwitcherComponent.prototype.collapseOrExpand = /**
         * @return {?}
         */
            function () {
                if (this.baseLayers.length > 1 || this.useStaticIcon) {
                    this.expand = !this.expand;
                }
                else {
                    this.expand = false;
                }
            };
        Object.defineProperty(BaseLayersSwitcherComponent.prototype, "baseLayers", {
            get: /**
             * @return {?}
             */ function () {
                /** @type {?} */
                var mapResolution = this.map.viewController.getResolution();
                /** @type {?} */
                var bl = this._baseLayers.filter(( /**
                 * @param {?} l
                 * @return {?}
                 */function (l) {
                    return ((!l.options.maxResolution ||
                        mapResolution <= l.options.maxResolution) &&
                        (!l.options.minResolution || mapResolution >= l.options.minResolution));
                }));
                /** @type {?} */
                var blHidden = bl.filter(( /**
                 * @param {?} l
                 * @return {?}
                 */function (l) { return !l.visible; }));
                return blHidden.length + 1 === bl.length ? blHidden : bl;
            },
            enumerable: true,
            configurable: true
        });
        BaseLayersSwitcherComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'igo-baselayers-switcher',
                        template: "<div *ngIf=\"baseLayers.length > 0\"\r\n     class=\"igo-baselayers-switcher-container\"\r\n     [ngClass]=\"{'container-expand': expand}\"\r\n     [@baseLayerSwitcherState]=\"expand ? 'expand' : useStaticIcon ? 'collapseIcon' : 'collapseMap'\"\r\n     (@baseLayerSwitcherState.start)=\"showButton=false\"\r\n     (@baseLayerSwitcherState.done)=\"showButton=true\"\r\n     (click)=\"collapseOrExpand()\">\r\n\r\n     <div *ngIf=\"useStaticIcon && !expand && showButton\" class=\"igo-baselayers-switcher-button-container\">\r\n       <button\r\n         mat-icon-button\r\n         [matTooltip]=\"'igo.geo.mapButtons.baselayerSwitcher' | translate\"\r\n         matTooltipPosition=\"right\"\r\n         color=\"primary\">\r\n         <mat-icon svgIcon=\"photo-library\"></mat-icon>\r\n       </button>\r\n     </div>\r\n\r\n     <igo-mini-basemap *ngFor=\"let baseLayer of baseLayers; let i = index\"\r\n       [map]=\"map\"\r\n       [baseLayer]=\"baseLayer\"\r\n       [display]=\"expand || (i === 0 && !useStaticIcon)\"\r\n       [disabled]=\"!expand && baseLayers.length > 1\">\r\n     </igo-mini-basemap>\r\n\r\n    <div class=\"more-baselayers\">\r\n      <mat-icon class=\"material-icons mat-icon mat-list-avatar\" color=\"primary\" svgIcon=\"menu-down\"></mat-icon>\r\n    </div>\r\n\r\n</div>\r\n",
                        animations: [baseLayersSwitcherSlideInOut()],
                        styles: [".igo-baselayers-switcher-container{height:auto;position:relative}.container-expand{overflow:hidden;border-width:0}.more-baselayers{width:80px;height:20px;background-color:#fff;text-align:center;cursor:pointer}.more-baselayers:hover{background-color:#efefef}.igo-baselayers-switcher-button-container{width:40px;background-color:#fff}.igo-baselayers-switcher-button-container:hover{background-color:#efefef}:host>>>button .mat-button-ripple-round,button{border-radius:0}"]
                    }] }
        ];
        /** @nocollapse */
        BaseLayersSwitcherComponent.ctorParameters = function () {
            return [
                { type: i1$1.MediaService }
            ];
        };
        BaseLayersSwitcherComponent.propDecorators = {
            map: [{ type: i0.Input }],
            useStaticIcon: [{ type: i0.Input }]
        };
        return BaseLayersSwitcherComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MiniBaseMapComponent = /** @class */ (function () {
        function MiniBaseMapComponent(layerService) {
            this.layerService = layerService;
            this.basemap = new IgoMap({
                controls: {},
                interactions: false
            });
        }
        Object.defineProperty(MiniBaseMapComponent.prototype, "map", {
            get: /**
             * @return {?}
             */ function () {
                return this._map;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._map = value;
                this.handleMoveEnd();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MiniBaseMapComponent.prototype, "baseLayer", {
            get: /**
             * @return {?}
             */ function () {
                return this._baseLayer;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._baseLayer = value;
                this.handleBaseLayerChanged(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MiniBaseMapComponent.prototype, "disabled", {
            get: /**
             * @return {?}
             */ function () {
                return this._disabled;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._disabled = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MiniBaseMapComponent.prototype, "display", {
            get: /**
             * @return {?}
             */ function () {
                return this._display;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._display = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MiniBaseMapComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.map.ol.on('moveend', ( /**
                 * @return {?}
                 */function () { return _this.handleMoveEnd(); }));
                this.handleMoveEnd();
            };
        /**
         * @return {?}
         */
        MiniBaseMapComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.map.ol.un('moveend', ( /**
                 * @return {?}
                 */function () { return _this.handleMoveEnd(); }));
            };
        /**
         * @param {?} baseLayer
         * @return {?}
         */
        MiniBaseMapComponent.prototype.changeBaseLayer = /**
         * @param {?} baseLayer
         * @return {?}
         */
            function (baseLayer) {
                if (this.disabled) {
                    return;
                }
                this.map.changeBaseLayer(baseLayer);
            };
        /**
         * @private
         * @return {?}
         */
        MiniBaseMapComponent.prototype.handleMoveEnd = /**
         * @private
         * @return {?}
         */
            function () {
                this.basemap.ol.setView(this.map.ol.getView());
            };
        /**
         * @private
         * @param {?} baselayer
         * @return {?}
         */
        MiniBaseMapComponent.prototype.handleBaseLayerChanged = /**
         * @private
         * @param {?} baselayer
         * @return {?}
         */
            function (baselayer) {
                this.basemap.removeAllLayers();
                /** @type {?} */
                var options = Object.assign(Object.create(baselayer.options), baselayer.options);
                options.visible = true;
                /** @type {?} */
                var layer = this.layerService.createLayer(options);
                this.basemap.addLayer(layer);
            };
        MiniBaseMapComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'igo-mini-basemap',
                        template: "<div class=\"igo-mini-basemap-container\">\r\n\r\n  <div *ngIf=\"display\" (click)=\"changeBaseLayer(baseLayer)\">\r\n    <igo-map-browser [map]=\"basemap\"></igo-map-browser>\r\n    <div class='igo-mini-basemap-title'>{{baseLayer.title}}</div>\r\n  </div>\r\n\r\n</div>\r\n",
                        styles: [".igo-mini-basemap-container{width:calc(40px * 2);height:calc(40px * 2);background-color:rgba(255,255,255,.01);border:2px solid #fff;box-shadow:0 1px 4px rgba(0,0,0,.3);cursor:pointer;margin-top:5px}.igo-mini-basemap-container:hover .igo-mini-basemap-title{color:#000;text-shadow:0 0 5px #fff}.igo-mini-basemap-container>div{width:100%;height:100%}.igo-mini-basemap-title{position:relative;top:-76px;height:76px;width:76px;text-align:center;vertical-align:bottom;color:#fff;text-shadow:0 0 5px #000;white-space:normal;display:flex;align-items:flex-end;justify-content:center}"]
                    }] }
        ];
        /** @nocollapse */
        MiniBaseMapComponent.ctorParameters = function () {
            return [
                { type: LayerService }
            ];
        };
        MiniBaseMapComponent.propDecorators = {
            map: [{ type: i0.Input }],
            baseLayer: [{ type: i0.Input }],
            disabled: [{ type: i0.Input }],
            display: [{ type: i0.Input }]
        };
        return MiniBaseMapComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var RotationButtonComponent = /** @class */ (function () {
        function RotationButtonComponent() {
        }
        Object.defineProperty(RotationButtonComponent.prototype, "map", {
            get: /**
             * @return {?}
             */ function () {
                return this._map;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._map = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RotationButtonComponent.prototype, "showIfNoRotation", {
            get: /**
             * @return {?}
             */ function () {
                return this._showIfNoRotation;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._showIfNoRotation = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RotationButtonComponent.prototype, "color", {
            get: /**
             * @return {?}
             */ function () {
                return this._color;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._color = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RotationButtonComponent.prototype, "rotated", {
            get: /**
             * @return {?}
             */ function () {
                return this.map.viewController.getRotation() !== 0;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} radians
         * @return {?}
         */
        RotationButtonComponent.prototype.rotationStyle = /**
         * @param {?} radians
         * @return {?}
         */
            function (radians) {
                /** @type {?} */
                var rotation = 'rotate(' + radians + 'rad)';
                return {
                    transform: rotation
                };
            };
        RotationButtonComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'igo-rotation-button',
                        template: "<div *ngIf=\"rotated && !showIfNoRotation\" class=\"igo-rotation-button-container\"\r\n  [matTooltip]=\"rotated ? ('igo.geo.mapButtons.resetRotation' | translate): ('igo.geo.mapButtons.tipRotation' | translate)\"\r\n  matTooltipPosition=\"left\">\r\n  <button mat-icon-button matTooltipPosition=\"left\" [color]=\"color\" [disabled]=\"!rotated\"\r\n    (click)=\"map.viewController.resetRotation()\">\r\n    <mat-icon [ngStyle]=\"rotationStyle(map.viewController.getRotation())\" svgIcon=\"navigation\">\r\n    </mat-icon>\r\n  </button>\r\n</div>\r\n\r\n<div *ngIf=\"showIfNoRotation\" class=\"igo-rotation-button-container\"\r\n  [matTooltip]=\"rotated ? ('igo.geo.mapButtons.resetRotation' | translate): ('igo.geo.mapButtons.tipRotation' | translate)\"\r\n  matTooltipPosition=\"left\">\r\n  <button mat-icon-button matTooltipPosition=\"left\" [color]=\"color\" [disabled]=\"!rotated\"\r\n    (click)=\"map.viewController.resetRotation()\">\r\n    <mat-icon [ngStyle]=\"rotationStyle(map.viewController.getRotation())\" svgIcon=\"navigation\">\r\n    </mat-icon>\r\n  </button>\r\n</div>",
                        styles: [".igo-rotation-button-container{width:40px;background-color:#fff}.igo-rotation-button-container:hover{background-color:#efefef}:host>>>button .mat-button-ripple-round,button{border-radius:0}@media only screen and (max-width:450px),only screen and (max-height:450px){:host>>>button .mat-button-ripple-round:disabled,button:disabled{display:none}}"]
                    }] }
        ];
        /** @nocollapse */
        RotationButtonComponent.ctorParameters = function () { return []; };
        RotationButtonComponent.propDecorators = {
            map: [{ type: i0.Input }],
            showIfNoRotation: [{ type: i0.Input }],
            color: [{ type: i0.Input }]
        };
        return RotationButtonComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var EsriStyleGenerator = /** @class */ (function () {
        function EsriStyleGenerator() {
            this._converters = {};
            this._converters.esriPMS = EsriStyleGenerator._convertEsriPMS;
            this._converters.esriSFS = EsriStyleGenerator._convertEsriSFS;
            this._converters.esriSLS = EsriStyleGenerator._convertEsriSLS;
            this._converters.esriSMS = EsriStyleGenerator._convertEsriSMS;
            this._converters.esriTS = EsriStyleGenerator._convertEsriTS;
            this._renderers = {};
            this._renderers.uniqueValue = this._renderUniqueValue;
            this._renderers.simple = this._renderSimple;
            this._renderers.classBreaks = this._renderClassBreaks;
        }
        /**
         * @param {?} point
         * @return {?}
         */
        EsriStyleGenerator._convertPointToPixel = /**
         * @param {?} point
         * @return {?}
         */
            function (point) {
                return point / 0.75;
            };
        /**
         * @param {?} color
         * @return {?}
         */
        EsriStyleGenerator._transformColor = /**
         * @param {?} color
         * @return {?}
         */
            function (color$$1) {
                // alpha channel is different, runs from 0-255 but in ol3 from 0-1
                return [color$$1[0], color$$1[1], color$$1[2], color$$1[3] / 255];
            };
        /**
         * @param {?} scale
         * @param {?} units
         * @return {?}
         */
        EsriStyleGenerator._getResolutionForScale = /**
         * @param {?} scale
         * @param {?} units
         * @return {?}
         */
            function (scale, units) {
                /** @type {?} */
                var dpi = 25.4 / 0.28;
                /** @type {?} */
                var mpu = olproj.METERS_PER_UNIT[units];
                /** @type {?} */
                var inchesPerMeter = 39.37;
                return parseFloat(scale) / (mpu * inchesPerMeter * dpi);
            };
        /* convert an Esri Text Symbol */
        /* convert an Esri Text Symbol */
        /**
         * @param {?} symbol
         * @return {?}
         */
        EsriStyleGenerator._convertEsriTS = /* convert an Esri Text Symbol */
            /**
             * @param {?} symbol
             * @return {?}
             */
            function (symbol) {
                /** @type {?} */
                var rotation = EsriStyleGenerator._transformAngle(symbol.angle);
                /** @type {?} */
                var text = symbol.text !== undefined ? symbol.text : undefined;
                return new olstyle.Style({
                    text: new olstyle.Text({
                        fill: new olstyle.Fill({
                            color: EsriStyleGenerator._transformColor(symbol.color)
                        }),
                        font: symbol.font.style +
                            ' ' +
                            symbol.font.weight +
                            ' ' +
                            symbol.font.size +
                            ' px ' +
                            symbol.font.family,
                        textBaseline: symbol.verticalAlignment,
                        textAlign: symbol.horizontalAlignment,
                        offsetX: EsriStyleGenerator._convertPointToPixel(symbol.xoffset),
                        offsetY: EsriStyleGenerator._convertPointToPixel(symbol.yoffset),
                        rotation: rotation,
                        text: text
                    })
                });
            };
        /* convert an Esri Picture Marker Symbol */
        /* convert an Esri Picture Marker Symbol */
        /**
         * @param {?} symbol
         * @return {?}
         */
        EsriStyleGenerator._convertEsriPMS = /* convert an Esri Picture Marker Symbol */
            /**
             * @param {?} symbol
             * @return {?}
             */
            function (symbol) {
                /** @type {?} */
                var src = 'data:' + symbol.contentType + ';base64, ' + symbol.imageData;
                /** @type {?} */
                var rotation = EsriStyleGenerator._transformAngle(symbol.angle);
                return new olstyle.Style({
                    image: new olstyle.Icon({
                        src: src,
                        rotation: rotation
                    })
                });
            };
        /* convert an Esri Simple Fill Symbol */
        /* convert an Esri Simple Fill Symbol */
        /**
         * @param {?} symbol
         * @return {?}
         */
        EsriStyleGenerator._convertEsriSFS = /* convert an Esri Simple Fill Symbol */
            /**
             * @param {?} symbol
             * @return {?}
             */
            function (symbol) {
                // there is no support in openlayers currently for fill patterns, so style is not interpreted
                /** @type {?} */
                var fill = new olstyle.Fill({
                    color: EsriStyleGenerator._transformColor(symbol.color)
                });
                /** @type {?} */
                var stroke = symbol.outline
                    ? EsriStyleGenerator._convertOutline(symbol.outline)
                    : undefined;
                return new olstyle.Style({
                    fill: fill,
                    stroke: stroke
                });
            };
        /**
         * @param {?} outline
         * @return {?}
         */
        EsriStyleGenerator._convertOutline = /**
         * @param {?} outline
         * @return {?}
         */
            function (outline) {
                /** @type {?} */
                var lineDash;
                /** @type {?} */
                var color$$1 = EsriStyleGenerator._transformColor(outline.color);
                if (outline.style === 'esriSLSDash') {
                    lineDash = [5];
                }
                else if (outline.style === 'esriSLSDashDot') {
                    lineDash = [5, 5, 1, 2];
                }
                else if (outline.style === 'esriSLSDashDotDot') {
                    lineDash = [5, 5, 1, 2, 1, 2];
                }
                else if (outline.style === 'esriSLSDot') {
                    lineDash = [1, 2];
                }
                else if (outline.style === 'esriSLSNull') {
                    // line not visible, make color fully transparent
                    color$$1[3] = 0;
                }
                return new olstyle.Stroke({
                    color: color$$1,
                    lineDash: lineDash,
                    width: EsriStyleGenerator._convertPointToPixel(outline.width)
                });
            };
        /* convert an Esri Simple Line Symbol */
        /* convert an Esri Simple Line Symbol */
        /**
         * @param {?} symbol
         * @return {?}
         */
        EsriStyleGenerator._convertEsriSLS = /* convert an Esri Simple Line Symbol */
            /**
             * @param {?} symbol
             * @return {?}
             */
            function (symbol) {
                return new olstyle.Style({
                    stroke: EsriStyleGenerator._convertOutline(symbol)
                });
            };
        /**
         * @param {?} angle
         * @return {?}
         */
        EsriStyleGenerator._transformAngle = /**
         * @param {?} angle
         * @return {?}
         */
            function (angle) {
                if (angle === 0 || angle === undefined) {
                    return undefined;
                }
                /** @type {?} */
                var normalRad = (angle * Math.PI) / 180;
                /** @type {?} */
                var ol3Rad = -normalRad + Math.PI / 2;
                if (ol3Rad < 0) {
                    return 2 * Math.PI + ol3Rad;
                }
                else {
                    return ol3Rad;
                }
            };
        /* convert an Esri Simple Marker Symbol */
        /* convert an Esri Simple Marker Symbol */
        /**
         * @param {?} symbol
         * @return {?}
         */
        EsriStyleGenerator._convertEsriSMS = /* convert an Esri Simple Marker Symbol */
            /**
             * @param {?} symbol
             * @return {?}
             */
            function (symbol) {
                /** @type {?} */
                var fill = new olstyle.Fill({
                    color: EsriStyleGenerator._transformColor(symbol.color)
                });
                /** @type {?} */
                var stroke = symbol.outline
                    ? EsriStyleGenerator._convertOutline(symbol.outline)
                    : undefined;
                /** @type {?} */
                var radius = EsriStyleGenerator._convertPointToPixel(symbol.size) / 2;
                /** @type {?} */
                var rotation = EsriStyleGenerator._transformAngle(symbol.angle);
                if (symbol.style === 'esriSMSCircle') {
                    return new olstyle.Style({
                        image: new olstyle.Circle({
                            radius: radius,
                            fill: fill,
                            stroke: stroke
                        })
                    });
                }
                else if (symbol.style === 'esriSMSCross') {
                    return new olstyle.Style({
                        image: new olstyle.RegularShape({
                            fill: fill,
                            stroke: stroke,
                            points: 4,
                            radius: radius,
                            radius2: 0,
                            angle: 0,
                            rotation: rotation
                        })
                    });
                }
                else if (symbol.style === 'esriSMSDiamond') {
                    return new olstyle.Style({
                        image: new olstyle.RegularShape({
                            fill: fill,
                            stroke: stroke,
                            points: 4,
                            radius: radius,
                            rotation: rotation
                        })
                    });
                }
                else if (symbol.style === 'esriSMSSquare') {
                    return new olstyle.Style({
                        image: new olstyle.RegularShape({
                            fill: fill,
                            stroke: stroke,
                            points: 4,
                            radius: radius,
                            angle: Math.PI / 4,
                            rotation: rotation
                        })
                    });
                }
                else if (symbol.style === 'esriSMSX') {
                    return new olstyle.Style({
                        image: new olstyle.RegularShape({
                            fill: fill,
                            stroke: stroke,
                            points: 4,
                            radius: radius,
                            radius2: 0,
                            angle: Math.PI / 4,
                            rotation: rotation
                        })
                    });
                }
                else if (symbol.style === 'esriSMSTriangle') {
                    return new olstyle.Style({
                        image: new olstyle.RegularShape({
                            fill: fill,
                            stroke: stroke,
                            points: 3,
                            radius: radius,
                            angle: 0,
                            rotation: rotation
                        })
                    });
                }
            };
        /**
         * @param {?} labelingInfo
         * @param {?} mapUnits
         * @return {?}
         */
        EsriStyleGenerator.prototype._convertLabelingInfo = /**
         * @param {?} labelingInfo
         * @param {?} mapUnits
         * @return {?}
         */
            function (labelingInfo, mapUnits) {
                /** @type {?} */
                var styles = [];
                for (var i = 0, ii = labelingInfo.length; i < ii; ++i) {
                    /** @type {?} */
                    var labelExpression = labelingInfo[i].labelExpression;
                    // only limited support for label expressions
                    /** @type {?} */
                    var field = labelExpression.substr(labelExpression.indexOf('[') + 1, labelExpression.indexOf(']') - 1);
                    /** @type {?} */
                    var symbol = labelingInfo[i].symbol;
                    /** @type {?} */
                    var maxScale = labelingInfo[i].maxScale;
                    /** @type {?} */
                    var minScale = labelingInfo[i].minScale;
                    /** @type {?} */
                    var minResolution = null;
                    if (maxScale !== 0) {
                        minResolution = EsriStyleGenerator._getResolutionForScale(maxScale, mapUnits);
                    }
                    /** @type {?} */
                    var maxResolution = null;
                    if (minScale !== 0) {
                        maxResolution = EsriStyleGenerator._getResolutionForScale(minScale, mapUnits);
                    }
                    /** @type {?} */
                    var style = this._converters[symbol.type].call(this, symbol);
                    styles.push((( /**
                     * @return {?}
                     */function () {
                        return ( /**
                         * @param {?} feature
                         * @param {?} resolution
                         * @return {?}
                         */function (feature, resolution) {
                            /** @type {?} */
                            var visible = true;
                            if (this.minResolution !== null && this.maxResolution !== null) {
                                visible =
                                    resolution < this.maxResolution &&
                                        resolution >= this.minResolution;
                            }
                            else if (this.minResolution !== null) {
                                visible = resolution >= this.minResolution;
                            }
                            else if (this.maxResolution !== null) {
                                visible = resolution < this.maxResolution;
                            }
                            if (visible) {
                                /** @type {?} */
                                var value = feature.get(this.field);
                                this.style.getText().setText(value);
                                return [this.style];
                            }
                        });
                    }))().bind({
                        minResolution: minResolution,
                        maxResolution: maxResolution,
                        field: field,
                        style: style
                    }));
                }
                return styles;
            };
        /**
         * @param {?} renderer
         * @return {?}
         */
        EsriStyleGenerator.prototype._renderSimple = /**
         * @param {?} renderer
         * @return {?}
         */
            function (renderer) {
                /** @type {?} */
                var style = this._converters[renderer.symbol.type].call(this, renderer.symbol);
                return (( /**
                 * @return {?}
                 */function () {
                    return ( /**
                     * @return {?}
                     */function () {
                        return [style];
                    });
                }))();
            };
        /**
         * @param {?} renderer
         * @return {?}
         */
        EsriStyleGenerator.prototype._renderClassBreaks = /**
         * @param {?} renderer
         * @return {?}
         */
            function (renderer) {
                /** @type {?} */
                var defaultSymbol = renderer.defaultSymbol;
                /** @type {?} */
                var defaultStyle = this._converters[defaultSymbol.type].call(this, defaultSymbol);
                /** @type {?} */
                var field = renderer.field;
                /** @type {?} */
                var classes = [];
                for (var i = 0, ii = renderer.classBreakInfos.length; i < ii; ++i) {
                    /** @type {?} */
                    var classBreakInfo = renderer.classBreakInfos[i];
                    /** @type {?} */
                    var min = void 0;
                    if (classBreakInfo.classMinValue === null ||
                        classBreakInfo.classMinValue === undefined) {
                        if (i === 0) {
                            min = renderer.minValue;
                        }
                        else {
                            min = renderer.classBreakInfos[i - 1].classMaxValue;
                        }
                    }
                    else {
                        min = classBreakInfo.classMinValue;
                    }
                    /** @type {?} */
                    var max = classBreakInfo.classMaxValue;
                    /** @type {?} */
                    var symbol = classBreakInfo.symbol;
                    /** @type {?} */
                    var style = this._converters[symbol.type].call(this, symbol);
                    classes.push({ min: min, max: max, style: style });
                }
                return (( /**
                 * @return {?}
                 */function () {
                    return ( /**
                     * @param {?} feature
                     * @return {?}
                     */function (feature) {
                        /** @type {?} */
                        var value = feature.get(field);
                        for (var i = 0, ii = classes.length; i < ii; ++i) {
                            /** @type {?} */
                            var condition = void 0;
                            if (i === 0) {
                                condition = value >= classes[i].min && value <= classes[i].max;
                            }
                            else {
                                condition = value > classes[i].min && value <= classes[i].max;
                            }
                            if (condition) {
                                return [classes[i].style];
                            }
                        }
                        return [defaultStyle];
                    });
                }))();
            };
        /**
         * @param {?} renderer
         * @return {?}
         */
        EsriStyleGenerator.prototype._renderUniqueValue = /**
         * @param {?} renderer
         * @return {?}
         */
            function (renderer) {
                /** @type {?} */
                var defaultSymbol = renderer.defaultSymbol;
                /** @type {?} */
                var defaultStyle = [];
                if (defaultSymbol) {
                    defaultStyle = [
                        this._converters[defaultSymbol.type].call(this, defaultSymbol)
                    ];
                }
                /** @type {?} */
                var field = renderer.field1;
                /** @type {?} */
                var infos = renderer.uniqueValueInfos;
                /** @type {?} */
                var me = this;
                return (( /**
                 * @return {?}
                 */function () {
                    /** @type {?} */
                    var hash = {};
                    for (var i = 0, ii = infos.length; i < ii; ++i) {
                        /** @type {?} */
                        var info = infos[i];
                        /** @type {?} */
                        var symbol = info.symbol;
                        hash[info.value] = [me._converters[symbol.type].call(me, symbol)];
                    }
                    return ( /**
                     * @param {?} feature
                     * @return {?}
                     */function (feature) {
                        /** @type {?} */
                        var style = hash[feature.get(field)];
                        return style ? style : defaultStyle;
                    });
                }))();
            };
        /**
         * @param {?} layerInfo
         * @param {?} mapUnits
         * @return {?}
         */
        EsriStyleGenerator.prototype.generateStyle = /**
         * @param {?} layerInfo
         * @param {?} mapUnits
         * @return {?}
         */
            function (layerInfo, mapUnits) {
                /** @type {?} */
                var drawingInfo = layerInfo.drawingInfo;
                /** @type {?} */
                var styleFunctions = [];
                /** @type {?} */
                var drawingInfoStyle = this._renderers[drawingInfo.renderer.type].call(this, drawingInfo.renderer);
                if (drawingInfoStyle !== undefined) {
                    styleFunctions.push(drawingInfoStyle);
                }
                if (layerInfo.labelingInfo) {
                    /** @type {?} */
                    var labelingInfoStyleFunctions = this._convertLabelingInfo(layerInfo.labelingInfo, mapUnits);
                    styleFunctions = styleFunctions.concat(labelingInfoStyleFunctions);
                }
                if (styleFunctions.length === 1) {
                    return styleFunctions[0];
                }
                else {
                    return (( /**
                     * @return {?}
                     */function () {
                        return ( /**
                         * @param {?} feature
                         * @param {?} resolution
                         * @return {?}
                         */function (feature, resolution) {
                            /** @type {?} */
                            var styles = [];
                            for (var i = 0, ii = styleFunctions.length; i < ii; ++i) {
                                /** @type {?} */
                                var result = styleFunctions[i].call(null, feature, resolution);
                                if (result) {
                                    styles = styles.concat(result);
                                }
                            }
                            return styles;
                        });
                    }))();
                }
            };
        return EsriStyleGenerator;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var CapabilitiesService = /** @class */ (function () {
        function CapabilitiesService(http) {
            this.http = http;
            this.capabilitiesStore = [];
            this.parsers = {
                wms: new olformat.WMSCapabilities(),
                wmts: new olformat.WMTSCapabilities()
            };
        }
        /**
         * @param {?} baseOptions
         * @return {?}
         */
        CapabilitiesService.prototype.getWMSOptions = /**
         * @param {?} baseOptions
         * @return {?}
         */
            function (baseOptions) {
                var _this = this;
                /** @type {?} */
                var url = baseOptions.url;
                /** @type {?} */
                var version = (( /** @type {?} */(baseOptions.params))).version;
                return this.getCapabilities('wms', url, version).pipe(operators.map(( /**
                 * @param {?} capabilities
                 * @return {?}
                 */function (capabilities) {
                    return _this.parseWMSOptions(baseOptions, capabilities);
                })));
            };
        /**
         * @param {?} baseOptions
         * @return {?}
         */
        CapabilitiesService.prototype.getWMTSOptions = /**
         * @param {?} baseOptions
         * @return {?}
         */
            function (baseOptions) {
                var _this = this;
                /** @type {?} */
                var url = baseOptions.url;
                /** @type {?} */
                var version = baseOptions.version;
                /** @type {?} */
                var options = this.getCapabilities('wmts', url, version).pipe(operators.map(( /**
                 * @param {?} capabilities
                 * @return {?}
                 */function (capabilities) {
                    return _this.parseWMTSOptions(baseOptions, capabilities);
                })));
                return options;
            };
        /**
         * @param {?} baseOptions
         * @return {?}
         */
        CapabilitiesService.prototype.getCartoOptions = /**
         * @param {?} baseOptions
         * @return {?}
         */
            function (baseOptions) {
                var _this = this;
                /** @type {?} */
                var baseUrl = 'https://' +
                    baseOptions.account +
                    '.carto.com/api/v2/viz/' +
                    baseOptions.mapId +
                    '/viz.json';
                return this.http
                    .jsonp(baseUrl, 'callback')
                    .pipe(operators.map(( /**
             * @param {?} cartoOptions
             * @return {?}
             */function (cartoOptions) {
                    return _this.parseCartoOptions(baseOptions, cartoOptions);
                })));
            };
        /**
         * @param {?} baseOptions
         * @return {?}
         */
        CapabilitiesService.prototype.getArcgisOptions = /**
         * @param {?} baseOptions
         * @return {?}
         */
            function (baseOptions) {
                var _this = this;
                /** @type {?} */
                var baseUrl = baseOptions.url + '/' + baseOptions.layer + '?f=json';
                /** @type {?} */
                var modifiedUrl = baseOptions.url.replace('FeatureServer', 'MapServer');
                /** @type {?} */
                var legendUrl = modifiedUrl + '/legend?f=json';
                /** @type {?} */
                var arcgisOptions = this.http.get(baseUrl);
                /** @type {?} */
                var legend = this.http.get(legendUrl).pipe(operators.map(( /**
                 * @param {?} res
                 * @return {?}
                 */function (res) { return res; })), operators.catchError(( /**
                 * @param {?} err
                 * @return {?}
                 */function (err) {
                    console.log('No legend associated with this Feature Service');
                    return rxjs.of(err);
                })));
                return rxjs.forkJoin([arcgisOptions, legend]).pipe(operators.map(( /**
                 * @param {?} res
                 * @return {?}
                 */function (res) {
                    return _this.parseArcgisOptions(baseOptions, res[0], res[1]);
                })));
            };
        /**
         * @param {?} baseOptions
         * @return {?}
         */
        CapabilitiesService.prototype.getTileArcgisOptions = /**
         * @param {?} baseOptions
         * @return {?}
         */
            function (baseOptions) {
                var _this = this;
                /** @type {?} */
                var baseUrl = baseOptions.url + '/' + baseOptions.layer + '?f=json';
                /** @type {?} */
                var legendUrl = baseOptions.url + '/legend?f=json';
                /** @type {?} */
                var arcgisOptions = this.http.get(baseUrl);
                /** @type {?} */
                var legendInfo = this.http.get(legendUrl);
                return rxjs.forkJoin([arcgisOptions, legendInfo]).pipe(operators.map(( /**
                 * @param {?} res
                 * @return {?}
                 */function (res) {
                    return _this.parseTileArcgisOptions(baseOptions, res[0], res[1]);
                })));
            };
        /**
         * @param {?} service
         * @param {?} baseUrl
         * @param {?=} version
         * @return {?}
         */
        CapabilitiesService.prototype.getCapabilities = /**
         * @param {?} service
         * @param {?} baseUrl
         * @param {?=} version
         * @return {?}
         */
            function (service, baseUrl, version) {
                var _this = this;
                /** @type {?} */
                var params = new i1.HttpParams({
                    fromObject: {
                        request: 'GetCapabilities',
                        service: service,
                        version: version || '1.3.0'
                    }
                });
                /** @type {?} */
                var request = this.http.get(baseUrl, {
                    params: params,
                    responseType: 'text'
                });
                return request.pipe(operators.map(( /**
                 * @param {?} res
                 * @return {?}
                 */function (res) {
                    /** @type {?} */
                    var capabilities = _this.parsers[service].read(res);
                    return capabilities;
                })));
            };
        /**
         * @private
         * @param {?} baseOptions
         * @param {?} capabilities
         * @return {?}
         */
        CapabilitiesService.prototype.parseWMSOptions = /**
         * @private
         * @param {?} baseOptions
         * @param {?} capabilities
         * @return {?}
         */
            function (baseOptions, capabilities) {
                /** @type {?} */
                var layers = (( /** @type {?} */(baseOptions.params))).layers;
                /** @type {?} */
                var layer = this.findDataSourceInCapabilities(capabilities.Capability.Layer, layers);
                if (!layer) {
                    return baseOptions;
                }
                /** @type {?} */
                var metadata = layer.DataURL ? layer.DataURL[0] : undefined;
                /** @type {?} */
                var abstract = layer.Abstract ? layer.Abstract : undefined;
                /** @type {?} */
                var keywordList = layer.KeywordList ? layer.KeywordList : undefined;
                /** @type {?} */
                var queryable = layer.queryable;
                /** @type {?} */
                var timeFilter = this.getTimeFilter(layer);
                /** @type {?} */
                var timeFilterable = timeFilter && Object.keys(timeFilter).length > 0;
                /** @type {?} */
                var options = utils.ObjectUtils.removeUndefined({
                    _layerOptionsFromCapabilities: {
                        title: layer.Title,
                        maxResolution: getResolutionFromScale(layer.MaxScaleDenominator) || Infinity,
                        minResolution: getResolutionFromScale(layer.MinScaleDenominator) || 0,
                        metadata: {
                            url: metadata ? metadata.OnlineResource : undefined,
                            extern: metadata ? true : undefined,
                            abstract: abstract,
                            keywordList: keywordList
                        }
                    },
                    queryable: queryable,
                    timeFilter: timeFilterable ? timeFilter : undefined,
                    timeFilterable: timeFilterable ? true : undefined
                });
                return utils.ObjectUtils.mergeDeep(options, baseOptions);
            };
        /**
         * @private
         * @param {?} baseOptions
         * @param {?} capabilities
         * @return {?}
         */
        CapabilitiesService.prototype.parseWMTSOptions = /**
         * @private
         * @param {?} baseOptions
         * @param {?} capabilities
         * @return {?}
         */
            function (baseOptions, capabilities) {
                /** @type {?} */
                var options = WMTS_js.optionsFromCapabilities(capabilities, baseOptions);
                return Object.assign(options, baseOptions);
            };
        /**
         * @private
         * @param {?} baseOptions
         * @param {?} cartoOptions
         * @return {?}
         */
        CapabilitiesService.prototype.parseCartoOptions = /**
         * @private
         * @param {?} baseOptions
         * @param {?} cartoOptions
         * @return {?}
         */
            function (baseOptions, cartoOptions) {
                /** @type {?} */
                var layers = [];
                /** @type {?} */
                var params = cartoOptions.layers[1].options.layer_definition;
                params.layers.forEach(( /**
                 * @param {?} element
                 * @return {?}
                 */function (element) {
                    layers.push({
                        type: element.type.toLowerCase(),
                        options: element.options,
                        legend: element.legend
                    });
                }));
                /** @type {?} */
                var options = utils.ObjectUtils.removeUndefined({
                    config: {
                        version: params.version,
                        layers: layers
                    }
                });
                return utils.ObjectUtils.mergeDeep(options, baseOptions);
            };
        /**
         * @private
         * @param {?} baseOptions
         * @param {?} arcgisOptions
         * @param {?=} legend
         * @return {?}
         */
        CapabilitiesService.prototype.parseArcgisOptions = /**
         * @private
         * @param {?} baseOptions
         * @param {?} arcgisOptions
         * @param {?=} legend
         * @return {?}
         */
            function (baseOptions, arcgisOptions, legend) {
                /** @type {?} */
                var legendInfo = legend.layers ? legend : undefined;
                /** @type {?} */
                var styleGenerator = new EsriStyleGenerator();
                /** @type {?} */
                var units = arcgisOptions.units === 'esriMeters' ? 'm' : 'degrees';
                /** @type {?} */
                var style = styleGenerator.generateStyle(arcgisOptions, units);
                /** @type {?} */
                var attributions = new olAttribution({
                    html: arcgisOptions.copyrightText
                });
                /** @type {?} */
                var timeExtent;
                /** @type {?} */
                var timeFilter;
                if (arcgisOptions.timeInfo) {
                    /** @type {?} */
                    var time = arcgisOptions.timeInfo.timeExtent;
                    timeExtent = time[0] + ',' + time[1];
                    /** @type {?} */
                    var min = new Date();
                    min.setTime(time[0]);
                    /** @type {?} */
                    var max = new Date();
                    max.setTime(time[1]);
                    timeFilter = {
                        min: min.toUTCString(),
                        max: max.toUTCString(),
                        range: true,
                        type: 'datetime',
                        style: 'calendar'
                    };
                }
                /** @type {?} */
                var params = Object.assign({}, {
                    legendInfo: legendInfo,
                    style: style,
                    timeFilter: timeFilter,
                    timeExtent: timeExtent,
                    attributions: attributions
                });
                /** @type {?} */
                var options = utils.ObjectUtils.removeUndefined({
                    params: params
                });
                return utils.ObjectUtils.mergeDeep(options, baseOptions);
            };
        /**
         * @private
         * @param {?} baseOptions
         * @param {?} arcgisOptions
         * @param {?} legend
         * @return {?}
         */
        CapabilitiesService.prototype.parseTileArcgisOptions = /**
         * @private
         * @param {?} baseOptions
         * @param {?} arcgisOptions
         * @param {?} legend
         * @return {?}
         */
            function (baseOptions, arcgisOptions, legend) {
                /** @type {?} */
                var legendInfo = legend.layers ? legend : undefined;
                /** @type {?} */
                var attributions = new olAttribution({
                    html: arcgisOptions.copyrightText
                });
                /** @type {?} */
                var timeExtent;
                /** @type {?} */
                var timeFilter;
                if (arcgisOptions.timeInfo) {
                    /** @type {?} */
                    var time = arcgisOptions.timeInfo.timeExtent;
                    timeExtent = time[0] + ',' + time[1];
                    /** @type {?} */
                    var min = new Date();
                    min.setTime(time[0]);
                    /** @type {?} */
                    var max = new Date();
                    max.setTime(time[1]);
                    timeFilter = {
                        min: min.toUTCString(),
                        max: max.toUTCString(),
                        range: true,
                        type: 'datetime',
                        style: 'calendar'
                    };
                }
                /** @type {?} */
                var params = Object.assign({}, {
                    layers: 'show:' + baseOptions.layer,
                    time: timeExtent
                });
                /** @type {?} */
                var options = utils.ObjectUtils.removeUndefined({
                    params: params,
                    legendInfo: legendInfo,
                    timeFilter: timeFilter,
                    attributions: attributions
                });
                return utils.ObjectUtils.mergeDeep(options, baseOptions);
            };
        /**
         * @private
         * @param {?} layerArray
         * @param {?} name
         * @return {?}
         */
        CapabilitiesService.prototype.findDataSourceInCapabilities = /**
         * @private
         * @param {?} layerArray
         * @param {?} name
         * @return {?}
         */
            function (layerArray, name) {
                var _this = this;
                if (Array.isArray(layerArray)) {
                    /** @type {?} */
                    var layer_1;
                    layerArray.find(( /**
                     * @param {?} value
                     * @return {?}
                     */function (value) {
                        layer_1 = _this.findDataSourceInCapabilities(value, name);
                        return layer_1 !== undefined;
                    }), this);
                    return layer_1;
                }
                else if (layerArray.Layer) {
                    return this.findDataSourceInCapabilities(layerArray.Layer, name);
                }
                else {
                    if (layerArray.Name && layerArray.Name === name) {
                        return layerArray;
                    }
                    return undefined;
                }
            };
        /**
         * @param {?} layer
         * @return {?}
         */
        CapabilitiesService.prototype.getTimeFilter = /**
         * @param {?} layer
         * @return {?}
         */
            function (layer) {
                /** @type {?} */
                var dimension;
                if (layer.Dimension) {
                    /** @type {?} */
                    var timeFilter = {};
                    dimension = layer.Dimension[0];
                    if (dimension.values) {
                        /** @type {?} */
                        var minMaxDim = dimension.values.split('/');
                        timeFilter.min = minMaxDim[0] !== undefined ? minMaxDim[0] : undefined;
                        timeFilter.max = minMaxDim[1] !== undefined ? minMaxDim[1] : undefined;
                        timeFilter.step = minMaxDim[2] !== undefined ? minMaxDim[2] : undefined;
                    }
                    if (dimension.default) {
                        timeFilter.value = dimension.default;
                    }
                    return timeFilter;
                }
            };
        CapabilitiesService.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        CapabilitiesService.ctorParameters = function () {
            return [
                { type: i1.HttpClient }
            ];
        };
        /** @nocollapse */ CapabilitiesService.ngInjectableDef = i0.defineInjectable({ factory: function CapabilitiesService_Factory() { return new CapabilitiesService(i0.inject(i1.HttpClient)); }, token: CapabilitiesService, providedIn: "root" });
        __decorate([
            ngxCacheable.Cacheable(),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [String, String, String]),
            __metadata("design:returntype", rxjs.Observable)
        ], CapabilitiesService.prototype, "getCapabilities", null);
        return CapabilitiesService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var DataSourceService = /** @class */ (function () {
        function DataSourceService(capabilitiesService, wfsDataSourceService) {
            this.capabilitiesService = capabilitiesService;
            this.wfsDataSourceService = wfsDataSourceService;
            this.datasources$ = new rxjs.BehaviorSubject([]);
        }
        /**
         * @param {?} context
         * @return {?}
         */
        DataSourceService.prototype.createAsyncDataSource = /**
         * @param {?} context
         * @return {?}
         */
            function (context) {
                if (!context.type) {
                    console.error(context);
                    throw new Error('Datasource needs a type');
                }
                /** @type {?} */
                var dataSource;
                switch (context.type.toLowerCase()) {
                    case 'osm':
                        dataSource = this.createOSMDataSource(( /** @type {?} */(context)));
                        break;
                    case 'vector':
                        dataSource = this.createFeatureDataSource(( /** @type {?} */(context)));
                        break;
                    case 'wfs':
                        dataSource = this.createWFSDataSource(( /** @type {?} */(context)));
                        break;
                    case 'wms':
                        dataSource = this.createWMSDataSource(( /** @type {?} */(context)));
                        break;
                    case 'wmts':
                        dataSource = this.createWMTSDataSource(( /** @type {?} */(context)));
                        break;
                    case 'xyz':
                        dataSource = this.createXYZDataSource(( /** @type {?} */(context)));
                        break;
                    case 'carto':
                        dataSource = this.createCartoDataSource(( /** @type {?} */(context)));
                        break;
                    case 'arcgisrest':
                        dataSource = this.createArcGISRestDataSource(( /** @type {?} */(context)));
                        break;
                    case 'websocket':
                        dataSource = this.createWebSocketDataSource(( /** @type {?} */(context)));
                        break;
                    case 'mvt':
                        dataSource = this.createMVTDataSource(( /** @type {?} */(context)));
                        break;
                    case 'tilearcgisrest':
                        dataSource = this.createTileArcGISRestDataSource(( /** @type {?} */(context)));
                        break;
                    case 'cluster':
                        dataSource = this.createClusterDataSource(( /** @type {?} */(context)));
                        break;
                    default:
                        console.error(context);
                        throw new Error('Invalid datasource type');
                }
                this.datasources$.next(this.datasources$.value.concat([dataSource]));
                return dataSource;
            };
        /**
         * @private
         * @param {?} context
         * @return {?}
         */
        DataSourceService.prototype.createOSMDataSource = /**
         * @private
         * @param {?} context
         * @return {?}
         */
            function (context) {
                return new rxjs.Observable(( /**
                 * @param {?} d
                 * @return {?}
                 */function (d) { return d.next(new OSMDataSource(context)); }));
            };
        /**
         * @private
         * @param {?} context
         * @return {?}
         */
        DataSourceService.prototype.createFeatureDataSource = /**
         * @private
         * @param {?} context
         * @return {?}
         */
            function (context) {
                return new rxjs.Observable(( /**
                 * @param {?} d
                 * @return {?}
                 */function (d) { return d.next(new FeatureDataSource(context)); }));
            };
        /**
         * @private
         * @param {?} context
         * @return {?}
         */
        DataSourceService.prototype.createWebSocketDataSource = /**
         * @private
         * @param {?} context
         * @return {?}
         */
            function (context) {
                return new rxjs.Observable(( /**
                 * @param {?} d
                 * @return {?}
                 */function (d) { return d.next(new WebSocketDataSource(context)); }));
            };
        /**
         * @private
         * @param {?} context
         * @return {?}
         */
        DataSourceService.prototype.createWFSDataSource = /**
         * @private
         * @param {?} context
         * @return {?}
         */
            function (context) {
                var _this = this;
                return new rxjs.Observable(( /**
                 * @param {?} d
                 * @return {?}
                 */function (d) {
                    return d.next(new WFSDataSource(context, _this.wfsDataSourceService));
                }));
            };
        /**
         * @private
         * @param {?} context
         * @return {?}
         */
        DataSourceService.prototype.createWMSDataSource = /**
         * @private
         * @param {?} context
         * @return {?}
         */
            function (context) {
                var _this = this;
                if (context.optionsFromCapabilities) {
                    return this.capabilitiesService
                        .getWMSOptions(context)
                        .pipe(operators.map(( /**
                 * @param {?} options
                 * @return {?}
                 */function (options) {
                        return new WMSDataSource(options, _this.wfsDataSourceService);
                    })));
                }
                return new rxjs.Observable(( /**
                 * @param {?} d
                 * @return {?}
                 */function (d) {
                    return d.next(new WMSDataSource(context, _this.wfsDataSourceService));
                }));
            };
        /**
         * @private
         * @param {?} context
         * @return {?}
         */
        DataSourceService.prototype.createWMTSDataSource = /**
         * @private
         * @param {?} context
         * @return {?}
         */
            function (context) {
                if (context.optionsFromCapabilities) {
                    return this.capabilitiesService
                        .getWMTSOptions(context)
                        .pipe(operators.map(( /**
                 * @param {?} options
                 * @return {?}
                 */function (options) { return new WMTSDataSource(options); })));
                }
                return new rxjs.Observable(( /**
                 * @param {?} d
                 * @return {?}
                 */function (d) { return d.next(new WMTSDataSource(context)); }));
            };
        /**
         * @private
         * @param {?} context
         * @return {?}
         */
        DataSourceService.prototype.createXYZDataSource = /**
         * @private
         * @param {?} context
         * @return {?}
         */
            function (context) {
                return new rxjs.Observable(( /**
                 * @param {?} d
                 * @return {?}
                 */function (d) { return d.next(new XYZDataSource(context)); }));
            };
        /**
         * @private
         * @param {?} context
         * @return {?}
         */
        DataSourceService.prototype.createCartoDataSource = /**
         * @private
         * @param {?} context
         * @return {?}
         */
            function (context) {
                if (context.mapId) {
                    return this.capabilitiesService
                        .getCartoOptions(context)
                        .pipe(operators.map(( /**
                 * @param {?} options
                 * @return {?}
                 */function (options) { return new CartoDataSource(options); })));
                }
                return new rxjs.Observable(( /**
                 * @param {?} d
                 * @return {?}
                 */function (d) { return d.next(new CartoDataSource(context)); }));
            };
        /**
         * @private
         * @param {?} context
         * @return {?}
         */
        DataSourceService.prototype.createArcGISRestDataSource = /**
         * @private
         * @param {?} context
         * @return {?}
         */
            function (context) {
                return this.capabilitiesService
                    .getArcgisOptions(context)
                    .pipe(operators.map(( /**
             * @param {?} options
             * @return {?}
             */function (options) {
                    return new ArcGISRestDataSource(options);
                })));
            };
        /**
         * @private
         * @param {?} context
         * @return {?}
         */
        DataSourceService.prototype.createTileArcGISRestDataSource = /**
         * @private
         * @param {?} context
         * @return {?}
         */
            function (context) {
                return this.capabilitiesService
                    .getTileArcgisOptions(context)
                    .pipe(operators.map(( /**
             * @param {?} options
             * @return {?}
             */function (options) {
                    return new TileArcGISRestDataSource(options);
                })));
            };
        /**
         * @private
         * @param {?} context
         * @return {?}
         */
        DataSourceService.prototype.createMVTDataSource = /**
         * @private
         * @param {?} context
         * @return {?}
         */
            function (context) {
                return new rxjs.Observable(( /**
                 * @param {?} d
                 * @return {?}
                 */function (d) { return d.next(new MVTDataSource(context)); }));
            };
        /**
         * @private
         * @param {?} context
         * @return {?}
         */
        DataSourceService.prototype.createClusterDataSource = /**
         * @private
         * @param {?} context
         * @return {?}
         */
            function (context) {
                return new rxjs.Observable(( /**
                 * @param {?} d
                 * @return {?}
                 */function (d) { return d.next(new ClusterDataSource(context)); }));
            };
        DataSourceService.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        DataSourceService.ctorParameters = function () {
            return [
                { type: CapabilitiesService },
                { type: WFSService }
            ];
        };
        /** @nocollapse */ DataSourceService.ngInjectableDef = i0.defineInjectable({ factory: function DataSourceService_Factory() { return new DataSourceService(i0.inject(CapabilitiesService), i0.inject(WFSService)); }, token: DataSourceService, providedIn: "root" });
        return DataSourceService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var LayerService = /** @class */ (function () {
        function LayerService(styleService, dataSourceService, config) {
            this.styleService = styleService;
            this.dataSourceService = dataSourceService;
            this.config = config;
            if (this.config) {
                this.tokenKey = this.config.getConfig('auth.tokenKey');
            }
        }
        /**
         * @param {?} layerOptions
         * @return {?}
         */
        LayerService.prototype.createLayer = /**
         * @param {?} layerOptions
         * @return {?}
         */
            function (layerOptions) {
                if (!layerOptions.source) {
                    return;
                }
                if (layerOptions.source.options &&
                    layerOptions.source.options.optionsFromCapabilities) {
                    layerOptions = utils.ObjectUtils.mergeDeep((( /** @type {?} */(layerOptions.source.options)))._layerOptionsFromCapabilities ||
                        {}, layerOptions || {});
                }
                /** @type {?} */
                var layer;
                switch (layerOptions.source.constructor) {
                    case OSMDataSource:
                    case WMTSDataSource:
                    case XYZDataSource:
                    case CartoDataSource:
                    case TileArcGISRestDataSource:
                        layer = this.createTileLayer(( /** @type {?} */(layerOptions)));
                        break;
                    case FeatureDataSource:
                    case WFSDataSource:
                    case ArcGISRestDataSource:
                    case WebSocketDataSource:
                    case ClusterDataSource:
                        layer = this.createVectorLayer(( /** @type {?} */(layerOptions)));
                        break;
                    case WMSDataSource:
                        layer = this.createImageLayer(( /** @type {?} */(layerOptions)));
                        break;
                    case MVTDataSource:
                        layer = this.createVectorTileLayer(( /** @type {?} */(layerOptions)));
                        break;
                    default:
                        break;
                }
                return layer;
            };
        /**
         * @param {?} layerOptions
         * @return {?}
         */
        LayerService.prototype.createAsyncLayer = /**
         * @param {?} layerOptions
         * @return {?}
         */
            function (layerOptions) {
                var _this = this;
                if (layerOptions.source) {
                    return new rxjs.Observable(( /**
                     * @param {?} d
                     * @return {?}
                     */function (d) { return d.next(_this.createLayer(layerOptions)); }));
                }
                return this.dataSourceService
                    .createAsyncDataSource(layerOptions.sourceOptions)
                    .pipe(operators.map(( /**
             * @param {?} source
             * @return {?}
             */function (source) {
                    layerOptions.source = source;
                    return _this.createLayer(layerOptions);
                })));
            };
        /**
         * @private
         * @param {?} layerOptions
         * @return {?}
         */
        LayerService.prototype.createImageLayer = /**
         * @private
         * @param {?} layerOptions
         * @return {?}
         */
            function (layerOptions) {
                if (this.tokenKey) {
                    layerOptions.token = localStorage.getItem(this.tokenKey);
                }
                return new ImageLayer(layerOptions);
            };
        /**
         * @private
         * @param {?} layerOptions
         * @return {?}
         */
        LayerService.prototype.createTileLayer = /**
         * @private
         * @param {?} layerOptions
         * @return {?}
         */
            function (layerOptions) {
                return new TileLayer(layerOptions);
            };
        /**
         * @private
         * @param {?} layerOptions
         * @return {?}
         */
        LayerService.prototype.createVectorLayer = /**
         * @private
         * @param {?} layerOptions
         * @return {?}
         */
            function (layerOptions) {
                /** @type {?} */
                var style;
                if (layerOptions.style !== undefined) {
                    style = this.styleService.createStyle(layerOptions.style);
                }
                if (layerOptions.source instanceof ArcGISRestDataSource) {
                    /** @type {?} */
                    var source = ( /** @type {?} */(layerOptions.source));
                    style = source.options.params.style;
                }
                else if (layerOptions.styleByAttribute) {
                    /** @type {?} */
                    var serviceStyle_1 = this.styleService;
                    layerOptions.style = ( /**
                     * @param {?} feature
                     * @return {?}
                     */function (feature) {
                        return serviceStyle_1.createStyleByAttribute(feature, layerOptions.styleByAttribute);
                    });
                    return new VectorLayer(layerOptions);
                }
                if (layerOptions.source instanceof ClusterDataSource) {
                    /** @type {?} */
                    var serviceStyle_2 = this.styleService;
                    layerOptions.style = ( /**
                     * @param {?} feature
                     * @return {?}
                     */function (feature) {
                        return serviceStyle_2.createClusterStyle(feature, layerOptions.clusterParam);
                    });
                    return new VectorLayer(layerOptions);
                }
                /** @type {?} */
                var layerOptionsOl = Object.assign({}, layerOptions, {
                    style: style
                });
                return new VectorLayer(layerOptionsOl);
            };
        /**
         * @private
         * @param {?} layerOptions
         * @return {?}
         */
        LayerService.prototype.createVectorTileLayer = /**
         * @private
         * @param {?} layerOptions
         * @return {?}
         */
            function (layerOptions) {
                /** @type {?} */
                var style;
                if (layerOptions.style !== undefined) {
                    style = this.styleService.createStyle(layerOptions.style);
                }
                if (layerOptions.styleByAttribute) {
                    /** @type {?} */
                    var serviceStyle_3 = this.styleService;
                    layerOptions.style = ( /**
                     * @param {?} feature
                     * @return {?}
                     */function (feature) {
                        return serviceStyle_3.createStyleByAttribute(feature, layerOptions.styleByAttribute);
                    });
                    return new VectorTileLayer(layerOptions);
                }
                /** @type {?} */
                var layerOptionsOl = Object.assign({}, layerOptions, {
                    style: style
                });
                return new VectorTileLayer(layerOptionsOl);
            };
        LayerService.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        LayerService.ctorParameters = function () {
            return [
                { type: StyleService },
                { type: DataSourceService },
                { type: i1$1.ConfigService, decorators: [{ type: i0.Optional }] }
            ];
        };
        /** @nocollapse */ LayerService.ngInjectableDef = i0.defineInjectable({ factory: function LayerService_Factory() { return new LayerService(i0.inject(StyleService), i0.inject(DataSourceService), i0.inject(i1$1.ConfigService, 8)); }, token: LayerService, providedIn: "root" });
        return LayerService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @enum {string} */
    var CatalogItemType = {
        Layer: 'layer',
        Group: 'group',
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var QueryService = /** @class */ (function () {
        function QueryService(http) {
            this.http = http;
            this.queryEnabled = true;
        }
        /**
         * @param {?} layers
         * @param {?} options
         * @return {?}
         */
        QueryService.prototype.query = /**
         * @param {?} layers
         * @param {?} options
         * @return {?}
         */
            function (layers, options) {
                var _this = this;
                return layers
                    .filter(( /**
             * @param {?} layer
             * @return {?}
             */function (layer) { return layer.visible && layer.isInResolutionsRange; }))
                    .map(( /**
             * @param {?} layer
             * @return {?}
             */function (layer) { return _this.queryLayer(layer, options); }));
            };
        /**
         * @param {?} layer
         * @param {?} options
         * @return {?}
         */
        QueryService.prototype.queryLayer = /**
         * @param {?} layer
         * @param {?} options
         * @return {?}
         */
            function (layer, options) {
                var _this = this;
                /** @type {?} */
                var url = this.getQueryUrl(layer.dataSource, options);
                if (!url) {
                    return rxjs.of([]);
                }
                if ((( /** @type {?} */(layer.dataSource))).options.queryFormat === QueryFormat.HTMLGML2) {
                    /** @type {?} */
                    var urlGml = this.getQueryUrl(layer.dataSource, options, true);
                    return this.http.get(urlGml, { responseType: 'text' })
                        .pipe(operators.mergeMap(( /**
                 * @param {?} gmlRes
                 * @return {?}
                 */function (gmlRes) {
                        /** @type {?} */
                        var imposedGeom = _this.mergeGML(gmlRes, url);
                        return _this.http.get(url, { responseType: 'text' })
                            .pipe(operators.map((( /**
                     * @param {?} res
                     * @return {?}
                     */function (res) { return _this.extractData(res, layer, options, url, imposedGeom); }))));
                    })));
                }
                /** @type {?} */
                var request = this.http.get(url, { responseType: 'text' });
                return request.pipe(operators.map(( /**
                 * @param {?} res
                 * @return {?}
                 */function (res) { return _this.extractData(res, layer, options, url); })));
            };
        /**
         * @private
         * @param {?} gmlRes
         * @param {?} url
         * @return {?}
         */
        QueryService.prototype.mergeGML = /**
         * @private
         * @param {?} gmlRes
         * @param {?} url
         * @return {?}
         */
            function (gmlRes, url) {
                /** @type {?} */
                var parser = new olFormatGML2();
                /** @type {?} */
                var features = parser.readFeatures(gmlRes);
                // Handle non standard GML output (MapServer)
                if (features.length === 0) {
                    parser = new olformat.WMSGetFeatureInfo();
                    features = parser.readFeatures(gmlRes);
                }
                /** @type {?} */
                var olmline = new olgeom.MultiLineString([]);
                /** @type {?} */
                var pts;
                /** @type {?} */
                var ptsArray = [];
                /** @type {?} */
                var olmpoly = new olgeom.MultiPolygon([]);
                /** @type {?} */
                var firstFeatureType;
                /** @type {?} */
                var nbFeatures = features.length;
                // Check if geometry intersect bbox
                // for geoserver getfeatureinfo response in data projection, not call projection
                /** @type {?} */
                var searchParams = this.getQueryParams(url.toLowerCase());
                /** @type {?} */
                var bboxRaw = searchParams.bbox;
                /** @type {?} */
                var bbox = bboxRaw.split(',');
                /** @type {?} */
                var bboxExtent = olextent.createEmpty();
                olextent.extend(bboxExtent, bbox);
                /** @type {?} */
                var outBboxExtent = false;
                features.map(( /**
                 * @param {?} feature
                 * @return {?}
                 */function (feature) {
                    /*  if (!feature.getGeometry().simplify(100).intersectsExtent(bboxExtent)) {
                            outBboxExtent = true;
                            // TODO: Check to project the geometry?
                          }*/
                    /** @type {?} */
                    var featureGeometryCoordinates = feature.getGeometry().getCoordinates();
                    /** @type {?} */
                    var featureGeometryType = feature.getGeometry().getType();
                    if (!firstFeatureType && !outBboxExtent) {
                        firstFeatureType = featureGeometryType;
                    }
                    {
                        switch (featureGeometryType) {
                            case 'Point':
                                if (nbFeatures === 1) {
                                    pts = new olgeom.Point(featureGeometryCoordinates, 'XY');
                                }
                                else {
                                    ptsArray.push(featureGeometryCoordinates);
                                }
                                break;
                            case 'LineString':
                                olmline.appendLineString(new olgeom.LineString(featureGeometryCoordinates, 'XY'));
                                break;
                            case 'Polygon':
                                olmpoly.appendPolygon(new olgeom.Polygon(featureGeometryCoordinates, 'XY'));
                                break;
                            case 'MultiPolygon':
                                olmpoly = new olgeom.MultiPolygon(featureGeometryCoordinates, 'XY');
                                break;
                            default:
                                return;
                        }
                    }
                }));
                /** @type {?} */
                var olmpts;
                if (ptsArray.length === 0 && pts) {
                    olmpts = {
                        type: pts.getType(),
                        coordinates: pts.getCoordinates()
                    };
                }
                else {
                    olmpts = {
                        type: 'Polygon',
                        coordinates: [this.convexHull(ptsArray)]
                    };
                }
                switch (firstFeatureType) {
                    case 'LineString':
                        return {
                            type: olmline.getType(),
                            coordinates: olmline.getCoordinates()
                        };
                    case 'Point':
                        return olmpts;
                    case 'Polygon':
                        return {
                            type: olmpoly.getType(),
                            coordinates: olmpoly.getCoordinates()
                        };
                    case 'MultiPolygon':
                        return {
                            type: olmpoly.getType(),
                            coordinates: olmpoly.getCoordinates()
                        };
                    default:
                        return;
                }
            };
        /**
         * @param {?} a
         * @param {?} b
         * @param {?} o
         * @return {?}
         */
        QueryService.prototype.cross = /**
         * @param {?} a
         * @param {?} b
         * @param {?} o
         * @return {?}
         */
            function (a, b, o) {
                return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);
            };
        /**
         * @param points An array of [X, Y] coordinates
         * This method is use instead of turf.js convexHull because Turf needs at least 3 point to make a hull.
         * https://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain#JavaScript
         */
        /**
         * @param {?} points An array of [X, Y] coordinates
         * This method is use instead of turf.js convexHull because Turf needs at least 3 point to make a hull.
         * https://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain#JavaScript
         * @return {?}
         */
        QueryService.prototype.convexHull = /**
         * @param {?} points An array of [X, Y] coordinates
         * This method is use instead of turf.js convexHull because Turf needs at least 3 point to make a hull.
         * https://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain#JavaScript
         * @return {?}
         */
            function (points) {
                var e_1, _a;
                points.sort(( /**
                 * @param {?} a
                 * @param {?} b
                 * @return {?}
                 */function (a, b) {
                    return a[0] === b[0] ? a[1] - b[1] : a[0] - b[0];
                }));
                /** @type {?} */
                var lower = [];
                try {
                    for (var points_1 = __values(points), points_1_1 = points_1.next(); !points_1_1.done; points_1_1 = points_1.next()) {
                        var point = points_1_1.value;
                        while (lower.length >= 2 && this.cross(lower[lower.length - 2], lower[lower.length - 1], point) <= 0) {
                            lower.pop();
                        }
                        lower.push(point);
                    }
                }
                catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                }
                finally {
                    try {
                        if (points_1_1 && !points_1_1.done && (_a = points_1.return))
                            _a.call(points_1);
                    }
                    finally {
                        if (e_1)
                            throw e_1.error;
                    }
                }
                /** @type {?} */
                var upper = [];
                for (var i = points.length - 1; i >= 0; i--) {
                    while (upper.length >= 2 && this.cross(upper[upper.length - 2], upper[upper.length - 1], points[i]) <= 0) {
                        upper.pop();
                    }
                    upper.push(points[i]);
                }
                upper.pop();
                lower.pop();
                return lower.concat(upper);
            };
        /**
         * @private
         * @param {?} res
         * @param {?} layer
         * @param {?} options
         * @param {?} url
         * @param {?=} imposedGeometry
         * @return {?}
         */
        QueryService.prototype.extractData = /**
         * @private
         * @param {?} res
         * @param {?} layer
         * @param {?} options
         * @param {?} url
         * @param {?=} imposedGeometry
         * @return {?}
         */
            function (res, layer, options, url, imposedGeometry) {
                /** @type {?} */
                var queryDataSource = ( /** @type {?} */(layer.dataSource));
                /** @type {?} */
                var allowedFieldsAndAlias;
                if (layer.options &&
                    layer.options.sourceOptions &&
                    layer.options.sourceOptions.sourceFields &&
                    layer.options.sourceOptions.sourceFields.length >= 1) {
                    allowedFieldsAndAlias = {};
                    layer.options.sourceOptions.sourceFields.forEach(( /**
                     * @param {?} sourceField
                     * @return {?}
                     */function (sourceField) {
                        /** @type {?} */
                        var alias = sourceField.alias ? sourceField.alias : sourceField.name;
                        allowedFieldsAndAlias[sourceField.name] = alias;
                    }));
                }
                /** @type {?} */
                var features = [];
                switch (queryDataSource.options.queryFormat) {
                    case QueryFormat.GML3:
                        features = this.extractGML3Data(res, layer.zIndex, allowedFieldsAndAlias);
                        break;
                    case QueryFormat.JSON:
                    case QueryFormat.GEOJSON:
                        features = this.extractGeoJSONData(res);
                        break;
                    case QueryFormat.ESRIJSON:
                        features = this.extractEsriJSONData(res, layer.zIndex);
                        break;
                    case QueryFormat.TEXT:
                        features = this.extractTextData(res);
                        break;
                    case QueryFormat.HTML:
                        features = this.extractHtmlData(res, queryDataSource.queryHtmlTarget, url);
                        break;
                    case QueryFormat.HTMLGML2:
                        features = this.extractHtmlData(res, queryDataSource.queryHtmlTarget, url, imposedGeometry);
                        break;
                    case QueryFormat.GML2:
                    default:
                        features = this.extractGML2Data(res, layer, allowedFieldsAndAlias);
                        break;
                }
                return features.map(( /**
                 * @param {?} feature
                 * @param {?} index
                 * @return {?}
                 */function (feature, index) {
                    /** @type {?} */
                    var title = feature.properties[queryDataSource.queryTitle];
                    if (!title && features.length > 1) {
                        title = layer.title + " (" + (index + 1) + ")";
                    }
                    else if (!title) {
                        title = layer.title;
                    }
                    /** @type {?} */
                    var meta = Object.assign({}, feature.meta || {}, {
                        id: utils.uuid(),
                        title: title,
                        mapTitle: title,
                        sourceTitle: layer.title,
                        order: 1000 - layer.zIndex
                    });
                    return Object.assign(feature, {
                        meta: meta,
                        projection: queryDataSource.options.type === 'carto'
                            ? 'EPSG:4326'
                            : options.projection
                    });
                }));
            };
        /**
         * @private
         * @param {?} res
         * @param {?} zIndex
         * @param {?=} allowedFieldsAndAlias
         * @return {?}
         */
        QueryService.prototype.extractGML2Data = /**
         * @private
         * @param {?} res
         * @param {?} zIndex
         * @param {?=} allowedFieldsAndAlias
         * @return {?}
         */
            function (res, zIndex, allowedFieldsAndAlias) {
                var _this = this;
                /** @type {?} */
                var parser = new olFormatGML2();
                /** @type {?} */
                var features = parser.readFeatures(res);
                // Handle non standard GML output (MapServer)
                if (features.length === 0) {
                    parser = new olformat.WMSGetFeatureInfo();
                    features = parser.readFeatures(res);
                }
                return features.map(( /**
                 * @param {?} feature
                 * @return {?}
                 */function (feature) {
                    return _this.featureToResult(feature, zIndex, allowedFieldsAndAlias);
                }));
            };
        /**
         * @private
         * @param {?} res
         * @param {?} zIndex
         * @param {?=} allowedFieldsAndAlias
         * @return {?}
         */
        QueryService.prototype.extractGML3Data = /**
         * @private
         * @param {?} res
         * @param {?} zIndex
         * @param {?=} allowedFieldsAndAlias
         * @return {?}
         */
            function (res, zIndex, allowedFieldsAndAlias) {
                var _this = this;
                /** @type {?} */
                var parser = new olFormatGML3();
                /** @type {?} */
                var features = parser.readFeatures(res);
                return features.map(( /**
                 * @param {?} feature
                 * @return {?}
                 */function (feature) {
                    return _this.featureToResult(feature, zIndex, allowedFieldsAndAlias);
                }));
            };
        /**
         * @private
         * @param {?} res
         * @return {?}
         */
        QueryService.prototype.extractGeoJSONData = /**
         * @private
         * @param {?} res
         * @return {?}
         */
            function (res) {
                /** @type {?} */
                var features = [];
                try {
                    features = JSON.parse(res).features;
                }
                catch (e) {
                    console.warn('query.service: Unable to parse geojson', '\n', res);
                }
                return features;
            };
        /**
         * @private
         * @param {?} res
         * @param {?} zIndex
         * @return {?}
         */
        QueryService.prototype.extractEsriJSONData = /**
         * @private
         * @param {?} res
         * @param {?} zIndex
         * @return {?}
         */
            function (res, zIndex) {
                var _this = this;
                /** @type {?} */
                var parser = new olFormatEsriJSON();
                /** @type {?} */
                var features = parser.readFeatures(res);
                return features.map(( /**
                 * @param {?} feature
                 * @return {?}
                 */function (feature) { return _this.featureToResult(feature, zIndex); }));
            };
        /**
         * @private
         * @param {?} res
         * @return {?}
         */
        QueryService.prototype.extractTextData = /**
         * @private
         * @param {?} res
         * @return {?}
         */
            function (res) {
                // TODO
                return [];
            };
        /**
         * @private
         * @param {?} res
         * @param {?} htmlTarget
         * @param {?} url
         * @param {?=} imposedGeometry
         * @return {?}
         */
        QueryService.prototype.extractHtmlData = /**
         * @private
         * @param {?} res
         * @param {?} htmlTarget
         * @param {?} url
         * @param {?=} imposedGeometry
         * @return {?}
         */
            function (res, htmlTarget, url, imposedGeometry) {
                // _blank , iframe or undefined
                /** @type {?} */
                var searchParams = this.getQueryParams(url.toLowerCase());
                /** @type {?} */
                var bboxRaw = searchParams.bbox;
                /** @type {?} */
                var width = parseInt(searchParams.width, 10);
                /** @type {?} */
                var height = parseInt(searchParams.height, 10);
                /** @type {?} */
                var xPosition = parseInt(searchParams.i || searchParams.x, 10);
                /** @type {?} */
                var yPosition = parseInt(searchParams.j || searchParams.y, 10);
                /** @type {?} */
                var projection = searchParams.crs || searchParams.srs || 'EPSG:3857';
                /** @type {?} */
                var bbox = bboxRaw.split(',');
                /** @type {?} */
                var threshold = (Math.abs(parseFloat(bbox[0])) - Math.abs(parseFloat(bbox[2]))) * 0.05;
                // for context in degree (EPSG:4326,4269...)
                if (Math.abs(parseFloat(bbox[0])) < 180) {
                    threshold = 0.045;
                }
                /** @type {?} */
                var clickx = parseFloat(bbox[0]) +
                    (Math.abs(parseFloat(bbox[0]) - parseFloat(bbox[2])) * xPosition) /
                        width -
                    threshold;
                /** @type {?} */
                var clicky = parseFloat(bbox[1]) +
                    (Math.abs(parseFloat(bbox[1]) - parseFloat(bbox[3])) * yPosition) /
                        height -
                    threshold;
                /** @type {?} */
                var clickx1 = clickx + threshold * 2;
                /** @type {?} */
                var clicky1 = clicky + threshold * 2;
                /** @type {?} */
                var wktPoly = 'POLYGON((' +
                    clickx +
                    ' ' +
                    clicky +
                    ', ' +
                    clickx +
                    ' ' +
                    clicky1 +
                    ', ' +
                    clickx1 +
                    ' ' +
                    clicky1 +
                    ', ' +
                    clickx1 +
                    ' ' +
                    clicky +
                    ', ' +
                    clickx +
                    ' ' +
                    clicky +
                    '))';
                /** @type {?} */
                var format = new olformat.WKT();
                /** @type {?} */
                var tenPercentWidthGeom = format.readFeature(wktPoly);
                /** @type {?} */
                var f = ( /** @type {?} */(tenPercentWidthGeom.getGeometry()));
                if (htmlTarget !== QueryHtmlTarget.BLANK &&
                    htmlTarget !== QueryHtmlTarget.IFRAME) {
                    htmlTarget = QueryHtmlTarget.IFRAME;
                }
                /** @type {?} */
                var bodyTagStart = res.toLowerCase().indexOf('<body>');
                /** @type {?} */
                var bodyTagEnd = res.toLowerCase().lastIndexOf('</body>') + 7;
                // replace \r \n  and ' ' with '' to validate if the body is really empty.
                /** @type {?} */
                var body = res.slice(bodyTagStart, bodyTagEnd).replace(/(\r|\n|\s)/g, '');
                if (body === '<body></body>' || res === '') {
                    return [];
                }
                return [
                    {
                        type: FEATURE,
                        projection: projection,
                        properties: { target: htmlTarget, body: res, url: url },
                        geometry: imposedGeometry || { type: f.getType(), coordinates: f.getCoordinates() }
                    }
                ];
            };
        /**
         * @private
         * @param {?} url
         * @return {?}
         */
        QueryService.prototype.getQueryParams = /**
         * @private
         * @param {?} url
         * @return {?}
         */
            function (url) {
                /** @type {?} */
                var queryString = url.split('?');
                if (!queryString[1]) {
                    return;
                }
                /** @type {?} */
                var pairs = queryString[1].split('&');
                /** @type {?} */
                var result = {};
                pairs.forEach(( /**
                 * @param {?} pair
                 * @return {?}
                 */function (pair) {
                    pair = pair.split('=');
                    result[pair[0]] = decodeURIComponent(pair[1] || '');
                }));
                return result;
            };
        /**
         * @private
         * @param {?} featureOL
         * @param {?} zIndex
         * @param {?=} allowedFieldsAndAlias
         * @return {?}
         */
        QueryService.prototype.featureToResult = /**
         * @private
         * @param {?} featureOL
         * @param {?} zIndex
         * @param {?=} allowedFieldsAndAlias
         * @return {?}
         */
            function (featureOL, zIndex, allowedFieldsAndAlias) {
                /** @type {?} */
                var featureGeometry = ( /** @type {?} */(featureOL.getGeometry()));
                /** @type {?} */
                var properties = Object.assign({}, featureOL.getProperties());
                delete properties.geometry;
                delete properties.boundedBy;
                delete properties.shape;
                delete properties.SHAPE;
                delete properties.the_geom;
                /** @type {?} */
                var geometry;
                if (featureGeometry !== undefined) {
                    geometry = {
                        type: featureGeometry.getType(),
                        coordinates: featureGeometry.getCoordinates()
                    };
                }
                return {
                    type: FEATURE,
                    projection: undefined,
                    properties: properties,
                    geometry: geometry,
                    meta: {
                        id: utils.uuid(),
                        order: 1000 - zIndex,
                        alias: allowedFieldsAndAlias
                    }
                };
            };
        /**
         * @private
         * @param {?} datasource
         * @param {?} options
         * @param {?=} forceGML2
         * @return {?}
         */
        QueryService.prototype.getQueryUrl = /**
         * @private
         * @param {?} datasource
         * @param {?} options
         * @param {?=} forceGML2
         * @return {?}
         */
            function (datasource, options, forceGML2) {
                if (forceGML2 === void 0) {
                    forceGML2 = false;
                }
                /** @type {?} */
                var url;
                switch (datasource.constructor) {
                    case WMSDataSource:
                        /** @type {?} */
                        var wmsDatasource = ( /** @type {?} */(datasource));
                        /** @type {?} */
                        var WMSGetFeatureInfoOptions = {
                            INFO_FORMAT: wmsDatasource.params.info_format ||
                                this.getMimeInfoFormat(datasource.options.queryFormat),
                            QUERY_LAYERS: wmsDatasource.params.layers,
                            FEATURE_COUNT: wmsDatasource.params.feature_count || '5'
                        };
                        if (forceGML2) {
                            WMSGetFeatureInfoOptions.INFO_FORMAT =
                                this.getMimeInfoFormat(QueryFormat.GML2);
                        }
                        url = wmsDatasource.ol.getGetFeatureInfoUrl(options.coordinates, options.resolution, options.projection, WMSGetFeatureInfoOptions);
                        if (wmsDatasource.params.version !== '1.3.0') {
                            url = url.replace('&I=', '&X=');
                            url = url.replace('&J=', '&Y=');
                        }
                        break;
                    case CartoDataSource:
                        /** @type {?} */
                        var cartoDatasource = ( /** @type {?} */(datasource));
                        /** @type {?} */
                        var baseUrl = 'https://' +
                            cartoDatasource.options.account +
                            '.carto.com/api/v2/sql?';
                        /** @type {?} */
                        var format = 'format=GeoJSON';
                        /** @type {?} */
                        var sql = '&q=' + cartoDatasource.options.config.layers[0].options.sql;
                        /** @type {?} */
                        var clause = ' WHERE ST_Intersects(the_geom_webmercator,ST_BUFFER(ST_SetSRID(ST_POINT(';
                        /** @type {?} */
                        var meters = cartoDatasource.options.queryPrecision
                            ? cartoDatasource.options.queryPrecision
                            : '1000';
                        /** @type {?} */
                        var coordinates = options.coordinates[0] +
                            ',' +
                            options.coordinates[1] +
                            '),3857),' +
                            meters +
                            '))';
                        url = "" + baseUrl + format + sql + clause + coordinates;
                        break;
                    case TileArcGISRestDataSource:
                        /** @type {?} */
                        var tileArcGISRestDatasource = ( /** @type {?} */(datasource));
                        /** @type {?} */
                        var extent = olextent.boundingExtent([options.coordinates]);
                        if (tileArcGISRestDatasource.options.queryPrecision) {
                            extent = olextent.buffer(extent, tileArcGISRestDatasource.options.queryPrecision);
                        }
                        /** @type {?} */
                        var serviceUrl = tileArcGISRestDatasource.options.url +
                            '/' +
                            tileArcGISRestDatasource.options.layer +
                            '/query/';
                        /** @type {?} */
                        var geometry = encodeURIComponent('{"xmin":' +
                            extent[0] +
                            ',"ymin":' +
                            extent[1] +
                            ',"xmax":' +
                            extent[2] +
                            ',"ymax":' +
                            extent[3] +
                            ',"spatialReference":{"wkid":102100}}');
                        /** @type {?} */
                        var params = [
                            'f=json',
                            "geometry=" + geometry,
                            'geometryType=esriGeometryEnvelope',
                            'inSR=102100',
                            'spatialRel=esriSpatialRelIntersects',
                            'outFields=*',
                            'returnGeometry=true',
                            'outSR=102100'
                        ];
                        url = serviceUrl + "?" + params.join('&');
                        break;
                    default:
                        break;
                }
                return url;
            };
        /**
         * @private
         * @param {?} queryFormat
         * @return {?}
         */
        QueryService.prototype.getMimeInfoFormat = /**
         * @private
         * @param {?} queryFormat
         * @return {?}
         */
            function (queryFormat) {
                /** @type {?} */
                var mime;
                switch (queryFormat) {
                    case QueryFormat.GML2:
                        mime = 'application/vnd.ogc.gml';
                        break;
                    case QueryFormat.GML3:
                        mime = 'application/vnd.ogc.gml/3.1.1';
                        break;
                    case QueryFormat.JSON:
                        mime = 'application/json';
                        break;
                    case QueryFormat.GEOJSON:
                        mime = 'application/geojson';
                        break;
                    case QueryFormat.TEXT:
                        mime = 'text/plain';
                        break;
                    case QueryFormat.HTML:
                        mime = 'text/html';
                        break;
                    case QueryFormat.HTMLGML2:
                        mime = 'text/html';
                        break;
                    default:
                        mime = 'application/vnd.ogc.gml';
                        break;
                }
                return mime;
            };
        QueryService.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        QueryService.ctorParameters = function () {
            return [
                { type: i1.HttpClient }
            ];
        };
        /** @nocollapse */ QueryService.ngInjectableDef = i0.defineInjectable({ factory: function QueryService_Factory() { return new QueryService(i0.inject(i1.HttpClient)); }, token: QueryService, providedIn: "root" });
        return QueryService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * This directive makes a map queryable with a click of with a drag box.
     * By default, all layers are queryable but this cna ben controlled at
     * the layer level.
     */
    var QueryDirective = /** @class */ (function () {
        function QueryDirective(component, queryService) {
            this.component = component;
            this.queryService = queryService;
            /**
             * Subscriptions to ongoing queries
             */
            this.queries$$ = [];
            /**
             * Whter to query features or not
             */
            this.queryFeatures = false;
            /**
             * Feature query hit tolerance
             */
            this.queryFeaturesHitTolerance = 0;
            /**
             * Whether all query should complete before emitting an event
             */
            this.waitForAllQueries = true;
            /**
             * Event emitted when a query (or all queries) complete
             */
            this.query = new i0.EventEmitter();
        }
        Object.defineProperty(QueryDirective.prototype, "map", {
            /**
             * IGO map
             * @internal
             */
            get: /**
             * IGO map
             * \@internal
             * @return {?}
             */ function () {
                return ( /** @type {?} */((( /** @type {?} */(this.component.map)))));
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Start listening to click and drag box events
         * @internal
         */
        /**
         * Start listening to click and drag box events
         * \@internal
         * @return {?}
         */
        QueryDirective.prototype.ngAfterViewInit = /**
         * Start listening to click and drag box events
         * \@internal
         * @return {?}
         */
            function () {
                this.listenToMapClick();
            };
        /**
         * Stop listening to click and drag box events and cancel ongoind requests
         * @internal
         */
        /**
         * Stop listening to click and drag box events and cancel ongoind requests
         * \@internal
         * @return {?}
         */
        QueryDirective.prototype.ngOnDestroy = /**
         * Stop listening to click and drag box events and cancel ongoind requests
         * \@internal
         * @return {?}
         */
            function () {
                this.cancelOngoingQueries();
                this.unlistenToMapClick();
            };
        /**
         * On map click, issue queries
         */
        /**
         * On map click, issue queries
         * @private
         * @return {?}
         */
        QueryDirective.prototype.listenToMapClick = /**
         * On map click, issue queries
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                this.mapClickListener = this.map.ol.on('singleclick', ( /**
                 * @param {?} event
                 * @return {?}
                 */function (event) { return _this.onMapEvent(event); }));
            };
        /**
         * Stop listenig for map clicks
         */
        /**
         * Stop listenig for map clicks
         * @private
         * @return {?}
         */
        QueryDirective.prototype.unlistenToMapClick = /**
         * Stop listenig for map clicks
         * @private
         * @return {?}
         */
            function () {
                this.map.ol.un(this.mapClickListener.type, this.mapClickListener.listener);
                this.mapClickListener = undefined;
            };
        /**
         * Issue queries from a map event and emit events with the results
         * @param event OL map browser pointer event
         */
        /**
         * Issue queries from a map event and emit events with the results
         * @private
         * @param {?} event OL map browser pointer event
         * @return {?}
         */
        QueryDirective.prototype.onMapEvent = /**
         * Issue queries from a map event and emit events with the results
         * @private
         * @param {?} event OL map browser pointer event
         * @return {?}
         */
            function (event) {
                var _this = this;
                this.cancelOngoingQueries();
                if (!this.queryService.queryEnabled) {
                    return;
                }
                /** @type {?} */
                var queries$ = [];
                if (this.queryFeatures) {
                    queries$.push(this.doQueryFeatures(event));
                }
                /** @type {?} */
                var resolution = this.map.ol.getView().getResolution();
                /** @type {?} */
                var queryLayers = this.map.layers.filter(layerIsQueryable);
                queries$.push.apply(queries$, __spread(this.queryService.query(queryLayers, {
                    coordinates: event.coordinate,
                    projection: this.map.projection,
                    resolution: resolution
                })));
                if (queries$.length === 0) {
                    return;
                }
                if (this.waitForAllQueries) {
                    this.queries$$.push(rxjs.zip.apply(void 0, __spread(queries$)).subscribe(( /**
                     * @param {?} results
                     * @return {?}
                     */function (results) {
                        /** @type {?} */
                        var features = [].concat.apply([], __spread(results));
                        _this.query.emit({ features: features, event: event });
                    })));
                }
                else {
                    this.queries$$ = queries$.map(( /**
                     * @param {?} query$
                     * @return {?}
                     */function (query$) {
                        return query$.subscribe(( /**
                         * @param {?} features
                         * @return {?}
                         */function (features) {
                            _this.query.emit({ features: features, event: event });
                        }));
                    }));
                }
            };
        /**
         * Query features already present on the map
         * @param event OL map browser pointer event
         */
        /**
         * Query features already present on the map
         * @private
         * @param {?} event OL map browser pointer event
         * @return {?}
         */
        QueryDirective.prototype.doQueryFeatures = /**
         * Query features already present on the map
         * @private
         * @param {?} event OL map browser pointer event
         * @return {?}
         */
            function (event) {
                var _this = this;
                /** @type {?} */
                var olFeatures = event.map.getFeaturesAtPixel(event.pixel, {
                    hitTolerance: this.queryFeaturesHitTolerance || 0,
                    layerFilter: this.queryFeaturesCondition ? this.queryFeaturesCondition : olLayerIsQueryable
                });
                /** @type {?} */
                var features = (olFeatures || []).map(( /**
                 * @param {?} olFeature
                 * @return {?}
                 */function (olFeature) {
                    return featureFromOl(olFeature, _this.map.projection);
                }));
                return rxjs.of(features);
            };
        /**
         * Cancel ongoing requests, if any
         */
        /**
         * Cancel ongoing requests, if any
         * @private
         * @return {?}
         */
        QueryDirective.prototype.cancelOngoingQueries = /**
         * Cancel ongoing requests, if any
         * @private
         * @return {?}
         */
            function () {
                this.queries$$.forEach(( /**
                 * @param {?} sub
                 * @return {?}
                 */function (sub) { return sub.unsubscribe(); }));
                this.queries$$ = [];
            };
        QueryDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[igoQuery]'
                    },] }
        ];
        /** @nocollapse */
        QueryDirective.ctorParameters = function () {
            return [
                { type: MapBrowserComponent, decorators: [{ type: i0.Self }] },
                { type: QueryService }
            ];
        };
        QueryDirective.propDecorators = {
            queryFeatures: [{ type: i0.Input }],
            queryFeaturesHitTolerance: [{ type: i0.Input }],
            queryFeaturesCondition: [{ type: i0.Input }],
            waitForAllQueries: [{ type: i0.Input }],
            query: [{ type: i0.Output }]
        };
        return QueryDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Base search source class
     */
    var SearchSource = /** @class */ (function () {
        function SearchSource(options) {
            var _this = this;
            this.options = Object.assign({}, this.getDefaultOptions(), options);
            // Set Default Params from Settings
            this.settings.forEach(( /**
             * @param {?} setting
             * @return {?}
             */function (setting) {
                _this.setParamFromSetting(setting);
            }));
        }
        /**
         * Get search source's id
         * @returns Search source's id
         */
        /**
         * Get search source's id
         * @return {?} Search source's id
         */
        SearchSource.prototype.getId = /**
         * Get search source's id
         * @return {?} Search source's id
         */
            function () {
                throw new Error('You have to implement the method "getId".');
            };
        /**
         * Get search source's default options
         * @returns Search source default options
         */
        /**
         * Get search source's default options
         * @protected
         * @return {?} Search source default options
         */
        SearchSource.prototype.getDefaultOptions = /**
         * Get search source's default options
         * @protected
         * @return {?} Search source default options
         */
            function () {
                throw new Error('You have to implement the method "getDefaultOptions".');
            };
        Object.defineProperty(SearchSource.prototype, "title", {
            /**
             * Search source's title
             */
            get: /**
             * Search source's title
             * @return {?}
             */ function () {
                return this.options.title;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchSource.prototype, "available", {
            /**
             * Whether the search source is available
             */
            get: /**
             * Whether the search source is available
             * @return {?}
             */ function () {
                return this.options.available !== false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchSource.prototype, "enabled", {
            get: /**
             * @return {?}
             */ function () {
                return this.available && this.options.enabled !== false;
            },
            /**
             * Whether the search source is enabled
             */
            set: /**
             * Whether the search source is enabled
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.options.enabled = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchSource.prototype, "searchUrl", {
            /**
             * Search url
             */
            get: /**
             * Search url
             * @return {?}
             */ function () {
                return this.options.searchUrl;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchSource.prototype, "params", {
            /**
             * Search query params
             */
            get: /**
             * Search query params
             * @return {?}
             */ function () {
                return this.options.params === undefined ? {} : this.options.params;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchSource.prototype, "settings", {
            /**
             * Search settings
             */
            get: /**
             * Search settings
             * @return {?}
             */ function () {
                return this.options.settings === undefined ? [] : this.options.settings;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Set params from selected settings
         */
        /**
         * Set params from selected settings
         * @param {?} setting
         * @return {?}
         */
        SearchSource.prototype.setParamFromSetting = /**
         * Set params from selected settings
         * @param {?} setting
         * @return {?}
         */
            function (setting) {
                var _this = this;
                var _a;
                switch (setting.type) {
                    case 'radiobutton':
                        setting.values.forEach(( /**
                         * @param {?} conf
                         * @return {?}
                         */function (conf) {
                            var _a;
                            if (conf.enabled) {
                                _this.options.params = Object.assign((_this.options.params || {}), (_a = {}, _a[setting.name] = conf.value, _a));
                            }
                        }));
                        break;
                    case 'checkbox':
                        /** @type {?} */
                        var confValue_1 = '';
                        setting.values.forEach(( /**
                         * @param {?} conf
                         * @return {?}
                         */function (conf) {
                            if (conf.enabled) {
                                confValue_1 += conf.value + ',';
                            }
                        }));
                        confValue_1 = confValue_1.slice(0, -1);
                        this.options.params = Object.assign((this.options.params || {}), (_a = {}, _a[setting.name] = confValue_1, _a));
                        break;
                }
            };
        Object.defineProperty(SearchSource.prototype, "displayOrder", {
            /**
             * Search results display order
             */
            get: /**
             * Search results display order
             * @return {?}
             */ function () {
                return this.options.order === undefined ? 99 : this.options.order;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Check if hashtag is valid
         * @param hashtag hashtag from query
         * @param completeMatch boolean
         */
        /**
         * Check if hashtag is valid
         * @param {?} searchSourceSetting
         * @param {?} hashtag hashtag from query
         * @param {?=} completeMatch boolean
         * @return {?}
         */
        SearchSource.prototype.hashtagValid = /**
         * Check if hashtag is valid
         * @param {?} searchSourceSetting
         * @param {?} hashtag hashtag from query
         * @param {?=} completeMatch boolean
         * @return {?}
         */
            function (searchSourceSetting, hashtag, completeMatch) {
                if (completeMatch === void 0) {
                    completeMatch = false;
                }
                /** @type {?} */
                var hashtagIsValid = false;
                searchSourceSetting.values.forEach(( /**
                 * @param {?} conf
                 * @return {?}
                 */function (conf) {
                    /** @type {?} */
                    var re = new RegExp('' + hashtag.substring(1) + '', 'g');
                    if (typeof conf.value === 'string') {
                        if ((completeMatch && conf.value === hashtag.substring(1)) ||
                            (!completeMatch && conf.value.match(re))) {
                            hashtagIsValid = true;
                        }
                    }
                }));
                return hashtagIsValid;
            };
        /**
         * @param {?} search
         * @return {?}
         */
        SearchSource.prototype.getSettingsValues = /**
         * @param {?} search
         * @return {?}
         */
            function (search) {
                return this.getDefaultOptions().settings.find(( /**
                 * @param {?} value
                 * @return {?}
                 */function (value) {
                    return value.name === search;
                }));
            };
        /**
         * Search source ID
         * \@internal
         */
        SearchSource.id = '';
        /**
         * Search source type
         * \@internal
         */
        SearchSource.type = '';
        return SearchSource;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Map search source. For now it has no search capability. All it does
     * is act as a placeholder for the map query results' "search source".
     */
    var QuerySearchSource = /** @class */ (function (_super) {
        __extends(QuerySearchSource, _super);
        function QuerySearchSource(options) {
            return _super.call(this, options) || this;
        }
        /**
         * @return {?}
         */
        QuerySearchSource.prototype.getId = /**
         * @return {?}
         */
            function () {
                return QuerySearchSource.id;
            };
        /**
         * @protected
         * @return {?}
         */
        QuerySearchSource.prototype.getDefaultOptions = /**
         * @protected
         * @return {?}
         */
            function () {
                return {
                    title: 'Carte'
                };
            };
        QuerySearchSource.id = 'map';
        QuerySearchSource.type = FEATURE;
        QuerySearchSource.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        QuerySearchSource.ctorParameters = function () {
            return [
                { type: undefined, decorators: [{ type: i0.Inject, args: ['options',] }] }
            ];
        };
        return QuerySearchSource;
    }(SearchSource));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var CatalogService = /** @class */ (function () {
        function CatalogService(http, config, languageService, capabilitiesService) {
            this.http = http;
            this.config = config;
            this.languageService = languageService;
            this.capabilitiesService = capabilitiesService;
        }
        /**
         * @return {?}
         */
        CatalogService.prototype.loadCatalogs = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var contextConfig = this.config.getConfig('context') || {};
                /** @type {?} */
                var catalogConfig = this.config.getConfig('catalog') || {};
                /** @type {?} */
                var apiUrl = catalogConfig.url || contextConfig.url;
                /** @type {?} */
                var catalogsFromConfig = catalogConfig.sources || [];
                if (apiUrl === undefined) {
                    return rxjs.of(catalogsFromConfig);
                }
                /** @type {?} */
                var observables$ = [];
                // Base layers catalog
                if (catalogConfig.baseLayers) {
                    /** @type {?} */
                    var translate = this.languageService.translate;
                    /** @type {?} */
                    var title = translate.instant('igo.geo.catalog.baseLayers');
                    /** @type {?} */
                    var baseLayersCatalog = {
                        id: 'catalog.baselayers',
                        title: title,
                        url: apiUrl + "/baselayers",
                        type: 'baselayers'
                    };
                    observables$.push(rxjs.of(baseLayersCatalog));
                }
                // Catalogs from API
                /** @type {?} */
                var catalogsFromApi$ = this.http
                    .get(apiUrl + "/catalogs")
                    .pipe(operators.catchError(( /**
             * @param {?} response
             * @return {?}
             */function (response) { return rxjs.EMPTY; })));
                observables$.push(catalogsFromApi$);
                // Catalogs from config
                if (catalogsFromConfig.length > 0) {
                    observables$.push(rxjs.of(catalogsFromConfig));
                }
                return ( /** @type {?} */(rxjs.concat.apply(void 0, __spread(observables$))));
            };
        /**
         * @param {?} catalog
         * @return {?}
         */
        CatalogService.prototype.loadCatalogItems = /**
         * @param {?} catalog
         * @return {?}
         */
            function (catalog) {
                if (catalog.type === 'baselayers') {
                    return this.loadCatalogBaseLayerItems(catalog);
                }
                else if (catalog.type === 'wmts') {
                    return this.loadCatalogWMTSLayerItems(catalog);
                }
                return this.loadCatalogWMSLayerItems(catalog);
            };
        /**
         * @private
         * @param {?} catalog
         * @return {?}
         */
        CatalogService.prototype.loadCatalogBaseLayerItems = /**
         * @private
         * @param {?} catalog
         * @return {?}
         */
            function (catalog) {
                // TODO: I'm not sure this works
                return this.getCatalogBaseLayersOptions(catalog)
                    .pipe(operators.map(( /**
             * @param {?} layersOptions
             * @return {?}
             */function (layersOptions) {
                    /** @type {?} */
                    var items = layersOptions.map(( /**
                     * @param {?} layerOptions
                     * @return {?}
                     */function (layerOptions) {
                        return ( /** @type {?} */({
                            id: generateIdFromSourceOptions(layerOptions.sourceOptions),
                            title: layerOptions.title,
                            type: CatalogItemType.Layer,
                            options: layerOptions
                        }));
                    }));
                    return [{
                            id: 'catalog.group.baselayers',
                            type: CatalogItemType.Group,
                            title: catalog.title,
                            items: items
                        }];
                })));
            };
        /**
         * @private
         * @param {?} catalog
         * @return {?}
         */
        CatalogService.prototype.getCatalogBaseLayersOptions = /**
         * @private
         * @param {?} catalog
         * @return {?}
         */
            function (catalog) {
                return this.http.get(catalog.url);
            };
        /**
         * @private
         * @param {?} catalog
         * @return {?}
         */
        CatalogService.prototype.loadCatalogWMSLayerItems = /**
         * @private
         * @param {?} catalog
         * @return {?}
         */
            function (catalog) {
                var _this = this;
                return this.getCatalogWMSCapabilities(catalog)
                    .pipe(operators.map(( /**
             * @param {?} capabilities
             * @return {?}
             */function (capabilities) {
                    /** @type {?} */
                    var items = [];
                    _this.includeRecursiveItems(catalog, capabilities.Capability.Layer, items);
                    return items;
                })));
            };
        /**
         * @private
         * @param {?} catalog
         * @return {?}
         */
        CatalogService.prototype.loadCatalogWMTSLayerItems = /**
         * @private
         * @param {?} catalog
         * @return {?}
         */
            function (catalog) {
                var _this = this;
                return this.getCatalogWMTSCapabilities(catalog)
                    .pipe(operators.map(( /**
             * @param {?} capabilities
             * @return {?}
             */function (capabilities) { return _this.getWMTSItems(catalog, capabilities); })));
            };
        /**
         * @private
         * @param {?} catalog
         * @return {?}
         */
        CatalogService.prototype.getCatalogWMSCapabilities = /**
         * @private
         * @param {?} catalog
         * @return {?}
         */
            function (catalog) {
                return this.capabilitiesService.getCapabilities('wms', catalog.url, catalog.version);
            };
        /**
         * @private
         * @param {?} catalog
         * @return {?}
         */
        CatalogService.prototype.getCatalogWMTSCapabilities = /**
         * @private
         * @param {?} catalog
         * @return {?}
         */
            function (catalog) {
                return this.capabilitiesService.getCapabilities('wmts', catalog.url, catalog.version);
            };
        /**
         * @private
         * @param {?} catalog
         * @param {?} layerList
         * @param {?} items
         * @return {?}
         */
        CatalogService.prototype.includeRecursiveItems = /**
         * @private
         * @param {?} catalog
         * @param {?} layerList
         * @param {?} items
         * @return {?}
         */
            function (catalog, layerList, items) {
                var _this = this;
                var e_1, _a;
                // Dig all levels until last level (layer object are not defined on last level)
                /** @type {?} */
                var regexes = (catalog.regFilters || []).map(( /**
                 * @param {?} pattern
                 * @return {?}
                 */function (pattern) { return new RegExp(pattern); }));
                /** @type {?} */
                var catalogQueryParams = catalog.queryParams || {};
                /** @type {?} */
                var catalogSourceOptions = catalog.sourceOptions || {};
                var _loop_1 = function (group) {
                    if (group.Layer !== undefined) {
                        // recursive, check next level
                        this_1.includeRecursiveItems(catalog, group, items);
                        return "continue";
                    }
                    /** @type {?} */
                    var catalogTooltipType = this_1.retrieveTooltipType(catalog);
                    /** @type {?} */
                    var layersQueryFormat = this_1.findCatalogInfoFormat(catalog);
                    // TODO: Slice that into multiple methods
                    // Define object of group layer
                    /** @type {?} */
                    var groupItem = {
                        id: "catalog.group." + layerList.Name,
                        type: CatalogItemType.Group,
                        title: layerList.Title,
                        items: layerList.Layer.reduce(( /**
                         * @param {?} layers
                         * @param {?} layer
                         * @return {?}
                         */function (layers, layer) {
                            /** @type {?} */
                            var configuredQueryFormat = _this.retriveLayerInfoFormat(layer.Name, layersQueryFormat);
                            if (_this.testLayerRegexes(layer.Name, regexes) === false) {
                                return layers;
                            }
                            /** @type {?} */
                            var metadata = layer.DataURL ? layer.DataURL[0] : undefined;
                            /** @type {?} */
                            var abstract = layer.Abstract ? layer.Abstract : undefined;
                            /** @type {?} */
                            var keywordList = layer.KeywordList ? layer.KeywordList : undefined;
                            /** @type {?} */
                            var timeFilter = _this.capabilitiesService.getTimeFilter(layer);
                            /** @type {?} */
                            var timeFilterable = timeFilter && Object.keys(timeFilter).length > 0 ? true : false;
                            /** @type {?} */
                            var params = Object.assign({}, catalogQueryParams, {
                                layers: layer.Name,
                                feature_count: catalog.count
                            });
                            /** @type {?} */
                            var baseSourceOptions = {
                                type: 'wms',
                                url: catalog.url,
                                crossOrigin: catalog.setCrossOriginAnonymous ? 'anonymous' : undefined,
                                timeFilter: __assign({}, timeFilter, catalog.timeFilter),
                                timeFilterable: timeFilterable ? true : false,
                                queryable: layer.queryable,
                                queryFormat: configuredQueryFormat,
                                queryHtmlTarget: catalog.queryHtmlTarget || QueryHtmlTarget.IFRAME
                            };
                            /** @type {?} */
                            var sourceOptions = ( /** @type {?} */(Object.assign({}, baseSourceOptions, catalogSourceOptions, { params: params })));
                            layers.push({
                                id: generateIdFromSourceOptions(sourceOptions),
                                type: CatalogItemType.Layer,
                                title: layer.Title,
                                options: {
                                    title: layer.Title,
                                    maxResolution: getResolutionFromScale(layer.MaxScaleDenominator) || Infinity,
                                    minResolution: getResolutionFromScale(layer.MinScaleDenominator) || 0,
                                    metadata: {
                                        url: metadata ? metadata.OnlineResource : undefined,
                                        extern: metadata ? true : undefined,
                                        abstract: abstract,
                                        keywordList: keywordList
                                    },
                                    tooltip: ( /** @type {?} */({ type: catalogTooltipType })),
                                    sourceOptions: sourceOptions
                                }
                            });
                            return layers;
                        }), [])
                    };
                    if (groupItem.items.length !== 0) {
                        items.push(groupItem);
                    }
                    return "break";
                };
                var this_1 = this;
                try {
                    for (var _b = __values(layerList.Layer), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var group = _c.value;
                        var state_1 = _loop_1(group);
                        if (state_1 === "break")
                            break;
                    }
                }
                catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return))
                            _a.call(_b);
                    }
                    finally {
                        if (e_1)
                            throw e_1.error;
                    }
                }
            };
        /**
         * @private
         * @param {?} catalog
         * @param {?} capabilities
         * @return {?}
         */
        CatalogService.prototype.getWMTSItems = /**
         * @private
         * @param {?} catalog
         * @param {?} capabilities
         * @return {?}
         */
            function (catalog, capabilities) {
                var _this = this;
                /** @type {?} */
                var layers = capabilities.Contents.Layer;
                /** @type {?} */
                var regexes = (catalog.regFilters || []).map(( /**
                 * @param {?} pattern
                 * @return {?}
                 */function (pattern) { return new RegExp(pattern); }));
                /** @type {?} */
                var catalogQueryParams = catalog.queryParams || {};
                /** @type {?} */
                var catalogSourceOptions = catalog.sourceOptions || {};
                return layers.map(( /**
                 * @param {?} layer
                 * @return {?}
                 */function (layer) {
                    if (_this.testLayerRegexes(layer.Identifier, regexes) === false) {
                        return undefined;
                    }
                    /** @type {?} */
                    var params = Object.assign({}, catalogQueryParams, {
                        version: '1.0.0'
                    });
                    /** @type {?} */
                    var baseSourceOptions = ( /** @type {?} */({
                        type: 'wmts',
                        url: catalog.url,
                        crossOrigin: catalog.setCrossOriginAnonymous ? 'anonymous' : undefined,
                        layer: layer.Identifier,
                        matrixSet: catalog.matrixSet,
                        optionsFromCapabilities: true,
                        requestEncoding: catalog.requestEncoding || 'KVP',
                        style: 'default'
                    }));
                    /** @type {?} */
                    var sourceOptions = ( /** @type {?} */(Object.assign({}, baseSourceOptions, catalogSourceOptions, { params: params })));
                    return {
                        id: generateIdFromSourceOptions(sourceOptions),
                        type: CatalogItemType.Layer,
                        title: layer.Title,
                        options: {
                            title: layer.Title,
                            sourceOptions: sourceOptions
                        }
                    };
                }))
                    .filter(( /**
             * @param {?} item
             * @return {?}
             */function (item) { return item !== undefined; }));
            };
        /**
         * @private
         * @param {?} layerName
         * @param {?} regexes
         * @return {?}
         */
        CatalogService.prototype.testLayerRegexes = /**
         * @private
         * @param {?} layerName
         * @param {?} regexes
         * @return {?}
         */
            function (layerName, regexes) {
                if (regexes.length === 0) {
                    return true;
                }
                return regexes.find(( /**
                 * @param {?} regex
                 * @return {?}
                 */function (regex) { return regex.test(layerName); })) !== undefined;
            };
        /**
         * @private
         * @param {?} layerNameFromCatalog
         * @param {?} layersQueryFormat
         * @return {?}
         */
        CatalogService.prototype.retriveLayerInfoFormat = /**
         * @private
         * @param {?} layerNameFromCatalog
         * @param {?} layersQueryFormat
         * @return {?}
         */
            function (layerNameFromCatalog, layersQueryFormat) {
                /** @type {?} */
                var currentLayerInfoFormat = layersQueryFormat.find(( /**
                 * @param {?} f
                 * @return {?}
                 */function (f) { return f.layer === layerNameFromCatalog; }));
                /** @type {?} */
                var baseInfoFormat = layersQueryFormat.find(( /**
                 * @param {?} f
                 * @return {?}
                 */function (f) { return f.layer === '*'; }));
                /** @type {?} */
                var queryFormat;
                if (currentLayerInfoFormat) {
                    queryFormat = currentLayerInfoFormat.queryFormat;
                }
                else if (baseInfoFormat) {
                    queryFormat = baseInfoFormat.queryFormat;
                }
                return queryFormat;
            };
        /**
         * @private
         * @param {?} catalog
         * @return {?}
         */
        CatalogService.prototype.retrieveTooltipType = /**
         * @private
         * @param {?} catalog
         * @return {?}
         */
            function (catalog) {
                if (!catalog.tooltipType) {
                    return TooltipType.TITLE;
                }
                return catalog.tooltipType;
            };
        /**
         * @private
         * @param {?} catalog
         * @return {?}
         */
        CatalogService.prototype.findCatalogInfoFormat = /**
         * @private
         * @param {?} catalog
         * @return {?}
         */
            function (catalog) {
                /** @type {?} */
                var layersQueryFormat = [];
                if (!catalog.queryFormat) {
                    return layersQueryFormat;
                }
                Object.keys(catalog.queryFormat).forEach(( /**
                 * @param {?} configuredInfoFormat
                 * @return {?}
                 */function (configuredInfoFormat) {
                    if (catalog.queryFormat[configuredInfoFormat] instanceof Array) {
                        catalog.queryFormat[configuredInfoFormat].forEach(( /**
                         * @param {?} layerName
                         * @return {?}
                         */function (layerName) {
                            if (!layersQueryFormat.find(( /**
                             * @param {?} specific
                             * @return {?}
                             */function (specific) { return specific.layer === layerName; }))) {
                                layersQueryFormat.push({ layer: layerName, queryFormat: ( /** @type {?} */(configuredInfoFormat)) });
                            }
                        }));
                    }
                    else {
                        if (!layersQueryFormat.find(( /**
                         * @param {?} specific
                         * @return {?}
                         */function (specific) { return specific.layer === catalog.queryFormat[configuredInfoFormat]; }))) {
                            layersQueryFormat.push({ layer: catalog.queryFormat[configuredInfoFormat], queryFormat: ( /** @type {?} */(configuredInfoFormat)) });
                        }
                    }
                }));
                return layersQueryFormat;
            };
        CatalogService.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        CatalogService.ctorParameters = function () {
            return [
                { type: i1.HttpClient },
                { type: i1$1.ConfigService },
                { type: i1$1.LanguageService },
                { type: CapabilitiesService }
            ];
        };
        /** @nocollapse */ CatalogService.ngInjectableDef = i0.defineInjectable({ factory: function CatalogService_Factory() { return new CatalogService(i0.inject(i1.HttpClient), i0.inject(i1$1.ConfigService), i0.inject(i1$1.LanguageService), i0.inject(CapabilitiesService)); }, token: CatalogService, providedIn: "root" });
        return CatalogService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Component to browse a catalog's groups and layers and display them on a map.
     */
    var CatalogBrowserComponent = /** @class */ (function () {
        function CatalogBrowserComponent(layerService, cdRef) {
            this.layerService = layerService;
            this.cdRef = cdRef;
            /**
             * Whether a group can be toggled when it's collapsed
             */
            this.toggleCollapsedGroup = true;
        }
        /**
         * @internal
         */
        /**
         * \@internal
         * @return {?}
         */
        CatalogBrowserComponent.prototype.ngOnInit = /**
         * \@internal
         * @return {?}
         */
            function () {
                /** @type {?} */
                var currentItems = this.map.layers.map(( /**
                 * @param {?} layer
                 * @return {?}
                 */function (layer) {
                    return {
                        id: layer.id,
                        title: layer.title,
                        type: CatalogItemType.Layer
                    };
                }));
                this.store.state.updateMany(currentItems, { added: true }, true);
                if (this.catalog && this.catalog.sortDirection !== undefined) {
                    this.store.view.sort({
                        direction: this.catalog.sortDirection,
                        valueAccessor: ( /**
                         * @param {?} item
                         * @return {?}
                         */function (item) { return item.title; })
                    });
                }
                this.watcher = new common$1.EntityStoreWatcher(this.store, this.cdRef);
            };
        /**
         * @return {?}
         */
        CatalogBrowserComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.watcher.destroy();
            };
        /**
         * @internal
         */
        /**
         * \@internal
         * @param {?} item
         * @return {?}
         */
        CatalogBrowserComponent.prototype.isGroup = /**
         * \@internal
         * @param {?} item
         * @return {?}
         */
            function (item) {
                return item.type === CatalogItemType.Group;
            };
        /**
         * @internal
         */
        /**
         * \@internal
         * @param {?} item
         * @return {?}
         */
        CatalogBrowserComponent.prototype.isLayer = /**
         * \@internal
         * @param {?} item
         * @return {?}
         */
            function (item) {
                return item.type === CatalogItemType.Layer;
            };
        /**
         * When a layer is added or removed, add or remove it from the map
         * @internal
         * @param event Layer added event
         */
        /**
         * When a layer is added or removed, add or remove it from the map
         * \@internal
         * @param {?} event Layer added event
         * @return {?}
         */
        CatalogBrowserComponent.prototype.onLayerAddedChange = /**
         * When a layer is added or removed, add or remove it from the map
         * \@internal
         * @param {?} event Layer added event
         * @return {?}
         */
            function (event) {
                /** @type {?} */
                var layer = event.layer;
                this.store.state.update(layer, { added: event.added }, false);
                event.added ? this.addLayerToMap(layer) : this.removeLayerFromMap(layer);
            };
        /**
         * When a froup is added or removed, add or remove it from the map
         * @internal
         * @param event Group added event
         */
        /**
         * When a froup is added or removed, add or remove it from the map
         * \@internal
         * @param {?} event Group added event
         * @return {?}
         */
        CatalogBrowserComponent.prototype.onGroupAddedChange = /**
         * When a froup is added or removed, add or remove it from the map
         * \@internal
         * @param {?} event Group added event
         * @return {?}
         */
            function (event) {
                /** @type {?} */
                var group = event.group;
                this.store.state.update(group, { added: event.added }, false);
                event.added ? this.addGroupToMap(group) : this.removeGroupFromMap(group);
            };
        /**
         * Add layer to map
         * @param layer Catalog layer
         */
        /**
         * Add layer to map
         * @private
         * @param {?} layer Catalog layer
         * @return {?}
         */
        CatalogBrowserComponent.prototype.addLayerToMap = /**
         * Add layer to map
         * @private
         * @param {?} layer Catalog layer
         * @return {?}
         */
            function (layer) {
                this.addLayersToMap([layer]);
            };
        /**
         * Remove layer from map
         * @param layer Catalog layer
         */
        /**
         * Remove layer from map
         * @private
         * @param {?} layer Catalog layer
         * @return {?}
         */
        CatalogBrowserComponent.prototype.removeLayerFromMap = /**
         * Remove layer from map
         * @private
         * @param {?} layer Catalog layer
         * @return {?}
         */
            function (layer) {
                this.removeLayersFromMap([layer]);
            };
        /**
         * Add multiple layers to map
         * @param layers Catalog layers
         */
        /**
         * Add multiple layers to map
         * @private
         * @param {?} layers Catalog layers
         * @return {?}
         */
        CatalogBrowserComponent.prototype.addLayersToMap = /**
         * Add multiple layers to map
         * @private
         * @param {?} layers Catalog layers
         * @return {?}
         */
            function (layers) {
                var _this = this;
                /** @type {?} */
                var layers$ = layers.map(( /**
                 * @param {?} layer
                 * @return {?}
                 */function (layer) {
                    return _this.layerService.createAsyncLayer(layer.options);
                }));
                rxjs.zip.apply(void 0, __spread(layers$)).subscribe(( /**
                 * @param {?} oLayers
                 * @return {?}
                 */function (oLayers) {
                    _this.store.state.updateMany(layers, { added: true });
                    _this.map.addLayers(oLayers);
                }));
            };
        /**
         * Remove multiple layers from map
         * @param layers Catalog layers
         */
        /**
         * Remove multiple layers from map
         * @private
         * @param {?} layers Catalog layers
         * @return {?}
         */
        CatalogBrowserComponent.prototype.removeLayersFromMap = /**
         * Remove multiple layers from map
         * @private
         * @param {?} layers Catalog layers
         * @return {?}
         */
            function (layers) {
                var _this = this;
                layers.forEach(( /**
                 * @param {?} layer
                 * @return {?}
                 */function (layer) {
                    _this.store.state.update(layer, { added: false });
                    /** @type {?} */
                    var oLayer = _this.map.getLayerById(layer.id);
                    if (oLayer !== undefined) {
                        _this.map.removeLayer(oLayer);
                    }
                }));
            };
        /**
         * Add all the layers of a group to map
         * @param group Catalog group
         */
        /**
         * Add all the layers of a group to map
         * @private
         * @param {?} group Catalog group
         * @return {?}
         */
        CatalogBrowserComponent.prototype.addGroupToMap = /**
         * Add all the layers of a group to map
         * @private
         * @param {?} group Catalog group
         * @return {?}
         */
            function (group) {
                var _this = this;
                /** @type {?} */
                var layers = group.items.filter(( /**
                 * @param {?} item
                 * @return {?}
                 */function (item) {
                    /** @type {?} */
                    var added = _this.store.state.get(item).added || false;
                    return _this.isLayer(item) && added === false;
                }));
                this.addLayersToMap(( /** @type {?} */(layers)));
            };
        /**
         * Remove all the layers of a groufrom map
         * @param group Catalog group
         */
        /**
         * Remove all the layers of a groufrom map
         * @private
         * @param {?} group Catalog group
         * @return {?}
         */
        CatalogBrowserComponent.prototype.removeGroupFromMap = /**
         * Remove all the layers of a groufrom map
         * @private
         * @param {?} group Catalog group
         * @return {?}
         */
            function (group) {
                var _this = this;
                /** @type {?} */
                var layers = group.items.filter(( /**
                 * @param {?} item
                 * @return {?}
                 */function (item) {
                    /** @type {?} */
                    var added = _this.store.state.get(item).added || false;
                    return _this.isLayer(item) && added === true;
                }));
                this.removeLayersFromMap(( /** @type {?} */(layers)));
            };
        CatalogBrowserComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'igo-catalog-browser',
                        template: "<igo-list [navigation]=\"false\" [selection]=\"false\">\r\n  <ng-template ngFor let-item [ngForOf]=\"store.view.all$() | async\">\r\n    <ng-container *ngIf=\"isGroup(item)\">\r\n      <igo-catalog-browser-group\r\n        [catalog]=\"catalog\"\r\n        [group]=\"item\"\r\n        [state]=\"store.state\"\r\n        [toggleCollapsed]=\"toggleCollapsedGroup\"\r\n        (addedChange)=\"onGroupAddedChange($event)\"\r\n        (layerAddedChange)=\"onLayerAddedChange($event)\">\r\n      </igo-catalog-browser-group>\r\n    </ng-container>\r\n\r\n    <ng-container *ngIf=\"isLayer(item)\">\r\n      <igo-catalog-browser-layer\r\n        igoListItem\r\n        [layer]=\"item\"\r\n        [added]=\"store.state.get(item).added\"\r\n        [disabled]=\"store.state.get(item).added\"\r\n        (addedChange)=\"onLayerAddedChange($event)\">\r\n      </igo-catalog-browser-layer>\r\n    </ng-container>\r\n  </ng-template>\r\n</igo-list>\r\n",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        CatalogBrowserComponent.ctorParameters = function () {
            return [
                { type: LayerService },
                { type: i0.ChangeDetectorRef }
            ];
        };
        CatalogBrowserComponent.propDecorators = {
            catalog: [{ type: i0.Input }],
            store: [{ type: i0.Input }],
            map: [{ type: i0.Input }],
            toggleCollapsedGroup: [{ type: i0.Input }]
        };
        return CatalogBrowserComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Catalog browser layer item
     */
    var CatalogBrowserLayerComponent = /** @class */ (function () {
        function CatalogBrowserLayerComponent() {
            /**
             * Event emitted when the add/remove button is clicked
             */
            this.addedChange = new i0.EventEmitter();
        }
        Object.defineProperty(CatalogBrowserLayerComponent.prototype, "title", {
            /**
             * @internal
             */
            get: /**
             * \@internal
             * @return {?}
             */ function () { return common$1.getEntityTitle(this.layer); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CatalogBrowserLayerComponent.prototype, "icon", {
            /**
             * @internal
             */
            get: /**
             * \@internal
             * @return {?}
             */ function () { return common$1.getEntityIcon(this.layer) || 'layers'; },
            enumerable: true,
            configurable: true
        });
        /**
         * On toggle button click, emit the added change event
         * @internal
         */
        /**
         * On toggle button click, emit the added change event
         * \@internal
         * @return {?}
         */
        CatalogBrowserLayerComponent.prototype.onToggleClick = /**
         * On toggle button click, emit the added change event
         * \@internal
         * @return {?}
         */
            function () {
                this.added ? this.remove() : this.add();
            };
        /**
         * Emit added change event with added = true
         */
        /**
         * Emit added change event with added = true
         * @private
         * @return {?}
         */
        CatalogBrowserLayerComponent.prototype.add = /**
         * Emit added change event with added = true
         * @private
         * @return {?}
         */
            function () {
                this.added = true;
                this.addedChange.emit({ added: true, layer: this.layer });
            };
        /**
         * Emit added change event with added = false
         */
        /**
         * Emit added change event with added = false
         * @private
         * @return {?}
         */
        CatalogBrowserLayerComponent.prototype.remove = /**
         * Emit added change event with added = false
         * @private
         * @return {?}
         */
            function () {
                this.added = false;
                this.addedChange.emit({ added: false, layer: this.layer });
            };
        CatalogBrowserLayerComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'igo-catalog-browser-layer',
                        template: "<mat-list-item>\r\n  <mat-icon mat-list-avatar svgIcon=\"{{icon}}\"></mat-icon>\r\n  <h4 mat-line>{{title}}</h4>\r\n\r\n  <igo-metadata-button [layer]=\"layer\"></igo-metadata-button>\r\n\r\n  <button\r\n    mat-icon-button\r\n    tooltip-position=\"below\"\r\n    matTooltipShowDelay=\"500\"\r\n    [matTooltip]=\"(added ? 'igo.geo.catalog.layer.removeFromMap' : 'igo.geo.catalog.layer.addToMap') | translate\"\r\n    [color]=\"added ? 'warn' : ''\"\r\n    (click)=\"onToggleClick()\">\r\n    <mat-icon [svgIcon]=\"added ? 'delete' : 'plus'\"></mat-icon>\r\n  </button>\r\n\r\n</mat-list-item>\r\n",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        CatalogBrowserLayerComponent.ctorParameters = function () { return []; };
        CatalogBrowserLayerComponent.propDecorators = {
            layer: [{ type: i0.Input }],
            added: [{ type: i0.Input }],
            addedChange: [{ type: i0.Output }]
        };
        return CatalogBrowserLayerComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Catalog browser group item
     */
    var CatalogBrowserGroupComponent = /** @class */ (function () {
        function CatalogBrowserGroupComponent() {
            /**
             * Group's items store
             * \@internal
             */
            this.store = new common$1.EntityStore([]);
            /**
             * Whether all the layers of the group are added
             * \@internal
             */
            this.added$ = new rxjs.BehaviorSubject(false);
            /**
             * Whether the toggle button is disabled
             * \@internal
             */
            this.disabled$ = new rxjs.BehaviorSubject(false);
            /**
             * Whether the group is collapsed
             */
            this.collapsed = true;
            /**
             * Whether the group can be toggled when it's collapsed
             */
            this.toggleCollapsed = true;
            /**
             * Event emitted when the add/remove button of the group is clicked
             */
            this.addedChange = new i0.EventEmitter();
            /**
             * Event emitted when the add/remove button of a layer is clicked
             */
            this.layerAddedChange = new i0.EventEmitter();
        }
        Object.defineProperty(CatalogBrowserGroupComponent.prototype, "title", {
            /**
             * @internal
             */
            get: /**
             * \@internal
             * @return {?}
             */ function () {
                return this.group.title;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @internal
         */
        /**
         * \@internal
         * @return {?}
         */
        CatalogBrowserGroupComponent.prototype.ngOnInit = /**
         * \@internal
         * @return {?}
         */
            function () {
                this.store.load(this.group.items);
                this.evaluateAdded();
                this.evaluateDisabled(this.collapsed);
                if (this.catalog && this.catalog.sortDirection !== undefined) {
                    this.store.view.sort({
                        direction: this.catalog.sortDirection,
                        valueAccessor: ( /**
                         * @param {?} item
                         * @return {?}
                         */function (item) { return item.title; })
                    });
                }
            };
        /**
         * @return {?}
         */
        CatalogBrowserGroupComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.store.destroy();
            };
        /**
         * @internal
         */
        /**
         * \@internal
         * @param {?} item
         * @return {?}
         */
        CatalogBrowserGroupComponent.prototype.isGroup = /**
         * \@internal
         * @param {?} item
         * @return {?}
         */
            function (item) {
                return item.type === CatalogItemType.Group;
            };
        /**
         * @internal
         */
        /**
         * \@internal
         * @param {?} item
         * @return {?}
         */
        CatalogBrowserGroupComponent.prototype.isLayer = /**
         * \@internal
         * @param {?} item
         * @return {?}
         */
            function (item) {
                return item.type === CatalogItemType.Layer;
            };
        /**
         * On toggle button click, emit the added change event
         * @internal
         */
        /**
         * On toggle button click, emit the added change event
         * \@internal
         * @return {?}
         */
        CatalogBrowserGroupComponent.prototype.onToggleClick = /**
         * On toggle button click, emit the added change event
         * \@internal
         * @return {?}
         */
            function () {
                this.added$.value ? this.remove() : this.add();
            };
        /**
         * On toggle button click, emit the added change event
         * @internal
         */
        /**
         * On toggle button click, emit the added change event
         * \@internal
         * @param {?} collapsed
         * @return {?}
         */
        CatalogBrowserGroupComponent.prototype.onToggleCollapsed = /**
         * On toggle button click, emit the added change event
         * \@internal
         * @param {?} collapsed
         * @return {?}
         */
            function (collapsed) {
                this.evaluateDisabled(collapsed);
            };
        /**
         * When a layer is added or removed, evaluate if all the layers of the group
         * are now added or removed. If so, consider that the group itself is added
         * or removed.
         * @internal
         * @param event Layer added change event
         */
        /**
         * When a layer is added or removed, evaluate if all the layers of the group
         * are now added or removed. If so, consider that the group itself is added
         * or removed.
         * \@internal
         * @param {?} event Layer added change event
         * @return {?}
         */
        CatalogBrowserGroupComponent.prototype.onLayerAddedChange = /**
         * When a layer is added or removed, evaluate if all the layers of the group
         * are now added or removed. If so, consider that the group itself is added
         * or removed.
         * \@internal
         * @param {?} event Layer added change event
         * @return {?}
         */
            function (event) {
                this.layerAddedChange.emit(event);
                this.tryToggleGroup(event);
            };
        /**
         * Emit added change event with added = true
         */
        /**
         * Emit added change event with added = true
         * @private
         * @return {?}
         */
        CatalogBrowserGroupComponent.prototype.add = /**
         * Emit added change event with added = true
         * @private
         * @return {?}
         */
            function () {
                this.added$.next(true);
                this.addedChange.emit({
                    added: true,
                    group: this.group
                });
            };
        /**
         * Emit added change event with added = true
         */
        /**
         * Emit added change event with added = true
         * @private
         * @return {?}
         */
        CatalogBrowserGroupComponent.prototype.remove = /**
         * Emit added change event with added = true
         * @private
         * @return {?}
         */
            function () {
                this.added$.next(false);
                this.addedChange.emit({
                    added: false,
                    group: this.group
                });
            };
        /**
         * If all the layers of the group added or removed, add or remove the group itself.
         * @param event The last layer added change event to occur
         */
        /**
         * If all the layers of the group added or removed, add or remove the group itself.
         * @private
         * @param {?} event The last layer added change event to occur
         * @return {?}
         */
        CatalogBrowserGroupComponent.prototype.tryToggleGroup = /**
         * If all the layers of the group added or removed, add or remove the group itself.
         * @private
         * @param {?} event The last layer added change event to occur
         * @return {?}
         */
            function (event) {
                var _this = this;
                /** @type {?} */
                var added = event.added;
                /** @type {?} */
                var layer = event.layer;
                /** @type {?} */
                var layersAdded = this.store.view
                    .all()
                    .filter(( /**
             * @param {?} item
             * @return {?}
             */function (item) { return item.id !== layer.id; }))
                    .map(( /**
             * @param {?} item
             * @return {?}
             */function (item) { return _this.state.get(item).added || false; }));
                if (layersAdded.every(( /**
                 * @param {?} value
                 * @return {?}
                 */function (value) { return value === added; }))) {
                    added ? this.add() : this.remove();
                }
                else if (this.added$.value === true) {
                    this.added$.next(false);
                }
            };
        /**
         * @private
         * @return {?}
         */
        CatalogBrowserGroupComponent.prototype.evaluateAdded = /**
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var added = this.store.all().every(( /**
                 * @param {?} item
                 * @return {?}
                 */function (item) {
                    return (_this.state.get(item).added || false) === true;
                }));
                this.added$.next(added);
            };
        /**
         * @private
         * @param {?} collapsed
         * @return {?}
         */
        CatalogBrowserGroupComponent.prototype.evaluateDisabled = /**
         * @private
         * @param {?} collapsed
         * @return {?}
         */
            function (collapsed) {
                /** @type {?} */
                var disabled = false;
                if (this.toggleCollapsed === false) {
                    disabled = collapsed;
                }
                this.disabled$.next(disabled);
            };
        CatalogBrowserGroupComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'igo-catalog-browser-group',
                        template: "<mat-list-item>\r\n  <mat-icon\r\n    mat-list-avatar\r\n    svgIcon=\"chevron-up\"\r\n    igoCollapse\r\n    class=\"igo-chevron\"\r\n    [target]=\"items\"\r\n    [collapsed]=\"collapsed\"\r\n    (toggle)=\"onToggleCollapsed($event)\">\r\n  </mat-icon>\r\n\r\n  <h4 matLine>{{title}}</h4>\r\n\r\n  <ng-container *ngIf=\"added$ | async; else notadded\">\r\n    <button\r\n      mat-icon-button\r\n      tooltip-position=\"below\"\r\n      matTooltipShowDelay=\"500\"\r\n      [matTooltip]=\"'igo.geo.catalog.group.removeFromMap' | translate\"\r\n      color=\"warn\"\r\n      [disabled]=\"disabled$ | async\"\r\n      (click)=\"onToggleClick()\">\r\n      <mat-icon svgIcon=\"delete\"></mat-icon>\r\n    </button>\r\n  </ng-container>\r\n\r\n  <ng-template #notadded>\r\n    <button\r\n      mat-icon-button\r\n      tooltip-position=\"below\"\r\n      matTooltipShowDelay=\"500\"\r\n      [matTooltip]=\"'igo.geo.catalog.group.addToMap' | translate\"\r\n      [disabled]=\"disabled$ | async\"\r\n      (click)=\"onToggleClick()\">\r\n      <mat-icon svgIcon=\"plus\"></mat-icon>\r\n    </button>\r\n  </ng-template>\r\n</mat-list-item>\r\n\r\n<div #items>\r\n  <ng-template ngFor let-item [ngForOf]=\"store.view.all$() | async\">\r\n    <ng-container *ngIf=\"isGroup(item)\"></ng-container>\r\n    <ng-container *ngIf=\"isLayer(item)\">\r\n      <igo-catalog-browser-layer\r\n        igoListItem\r\n        [layer]=\"item\"\r\n        [added]=\"state.get(item).added\"\r\n        [disabled]=\"state.get(item).added\"\r\n        (addedChange)=\"onLayerAddedChange($event)\">\r\n      </igo-catalog-browser-layer>\r\n    </ng-container>\r\n  </ng-template>\r\n</div>\r\n",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        CatalogBrowserGroupComponent.propDecorators = {
            catalog: [{ type: i0.Input }],
            group: [{ type: i0.Input }],
            collapsed: [{ type: i0.Input }],
            toggleCollapsed: [{ type: i0.Input }],
            state: [{ type: i0.Input }],
            addedChange: [{ type: i0.Output }],
            layerAddedChange: [{ type: i0.Output }]
        };
        return CatalogBrowserGroupComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @ignore
     */
    var IgoCatalogBrowserModule = /** @class */ (function () {
        function IgoCatalogBrowserModule() {
        }
        IgoCatalogBrowserModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            material.MatButtonModule,
                            material.MatIconModule,
                            material.MatListModule,
                            material.MatTooltipModule,
                            i1$1.IgoLanguageModule,
                            common$1.IgoListModule,
                            common$1.IgoCollapsibleModule,
                            IgoMetadataModule
                        ],
                        exports: [
                            CatalogBrowserComponent
                        ],
                        declarations: [
                            CatalogBrowserComponent,
                            CatalogBrowserGroupComponent,
                            CatalogBrowserLayerComponent
                        ]
                    },] }
        ];
        return IgoCatalogBrowserModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Component to browse a list of available catalogs
     */
    var CatalogLibaryComponent = /** @class */ (function () {
        function CatalogLibaryComponent() {
            /**
             * Event emitted a catalog is selected or unselected
             */
            this.catalogSelectChange = new i0.EventEmitter();
        }
        /**
         * @internal
         */
        /**
         * \@internal
         * @return {?}
         */
        CatalogLibaryComponent.prototype.ngOnInit = /**
         * \@internal
         * @return {?}
         */
            function () {
                this.store.state.clear();
            };
        /**
         * When a catalog is selected, update it's state in the store
         * and emit the catalog select change event
         * @internal
         */
        /**
         * When a catalog is selected, update it's state in the store
         * and emit the catalog select change event
         * \@internal
         * @param {?} catalog
         * @return {?}
         */
        CatalogLibaryComponent.prototype.onCatalogSelect = /**
         * When a catalog is selected, update it's state in the store
         * and emit the catalog select change event
         * \@internal
         * @param {?} catalog
         * @return {?}
         */
            function (catalog) {
                this.store.state.update(catalog, {
                    selected: true,
                    focused: true
                }, true);
                this.catalogSelectChange.emit({ selected: true, catalog: catalog });
            };
        CatalogLibaryComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'igo-catalog-library',
                        template: "<igo-list [navigation]=\"false\">\r\n  <ng-template ngFor let-catalog [ngForOf]=\"store.view.all$() | async\">\r\n    <igo-catalog-library-item\r\n      igoListItem\r\n      color=\"accent\"\r\n      [map]=\"map\"\r\n      [catalog]=\"catalog\"\r\n      (select)=\"onCatalogSelect(catalog)\">\r\n    </igo-catalog-library-item>\r\n  </ng-template>\r\n</igo-list>\r\n",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        CatalogLibaryComponent.propDecorators = {
            store: [{ type: i0.Input }],
            map: [{ type: i0.Input }],
            catalogSelectChange: [{ type: i0.Output }]
        };
        return CatalogLibaryComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Catalog library item
     */
    var CatalogLibaryItemComponent = /** @class */ (function () {
        function CatalogLibaryItemComponent() {
        }
        Object.defineProperty(CatalogLibaryItemComponent.prototype, "title", {
            /**
             * @internal
             */
            get: /**
             * \@internal
             * @return {?}
             */ function () { return common$1.getEntityTitle(this.catalog); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CatalogLibaryItemComponent.prototype, "icon", {
            /**
             * @internal
             */
            get: /**
             * \@internal
             * @return {?}
             */ function () { return common$1.getEntityIcon(this.catalog) || 'image-multiple'; },
            enumerable: true,
            configurable: true
        });
        CatalogLibaryItemComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'igo-catalog-library-item',
                        template: "<mat-list-item>\r\n  <mat-icon mat-list-avatar svgIcon=\"{{icon}}\"></mat-icon>\r\n  <h4 mat-line>{{title}}</h4>\r\n</mat-list-item>\r\n",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        CatalogLibaryItemComponent.propDecorators = {
            catalog: [{ type: i0.Input }],
            map: [{ type: i0.Input }]
        };
        return CatalogLibaryItemComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @ignore
     */
    var IgoCatalogLibraryModule = /** @class */ (function () {
        function IgoCatalogLibraryModule() {
        }
        IgoCatalogLibraryModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            material.MatIconModule,
                            material.MatListModule,
                            material.MatTooltipModule,
                            common$1.IgoListModule
                        ],
                        exports: [
                            CatalogLibaryComponent
                        ],
                        declarations: [
                            CatalogLibaryComponent,
                            CatalogLibaryItemComponent
                        ]
                    },] }
        ];
        return IgoCatalogLibraryModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var IgoCatalogModule = /** @class */ (function () {
        function IgoCatalogModule() {
        }
        IgoCatalogModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            material.MatIconModule,
                            material.MatListModule,
                            material.MatTooltipModule,
                            common$1.IgoListModule,
                            common$1.IgoCollapsibleModule
                        ],
                        exports: [
                            IgoCatalogBrowserModule,
                            IgoCatalogLibraryModule
                        ],
                        declarations: []
                    },] }
        ];
        return IgoCatalogModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var IgoDataSourceModule = /** @class */ (function () {
        function IgoDataSourceModule() {
        }
        /**
         * @return {?}
         */
        IgoDataSourceModule.forRoot = /**
         * @return {?}
         */
            function () {
                return {
                    ngModule: IgoDataSourceModule,
                    providers: []
                };
            };
        IgoDataSourceModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [],
                        exports: [],
                        declarations: []
                    },] }
        ];
        return IgoDataSourceModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var FilterableDataSourcePipe = /** @class */ (function () {
        function FilterableDataSourcePipe() {
        }
        /**
         * @param {?} value
         * @param {?} arg
         * @return {?}
         */
        FilterableDataSourcePipe.prototype.transform = /**
         * @param {?} value
         * @param {?} arg
         * @return {?}
         */
            function (value, arg) {
                var _this = this;
                /** @type {?} */
                var layers;
                if (arg === 'time') {
                    layers = value.filter(( /**
                     * @param {?} layer
                     * @return {?}
                     */function (layer) {
                        /** @type {?} */
                        var datasource = ( /** @type {?} */(layer.dataSource));
                        return (_this.isTimeFilterable(datasource) &&
                            datasource.options.timeFilter !== undefined &&
                            Object.keys(datasource.options.timeFilter).length);
                    }));
                }
                if (arg === 'ogc') {
                    layers = value.filter(( /**
                     * @param {?} layer
                     * @return {?}
                     */function (layer) {
                        /** @type {?} */
                        var datasource = ( /** @type {?} */(layer.dataSource));
                        return _this.isOgcFilterable(datasource);
                    }));
                }
                return layers;
            };
        /**
         * @private
         * @param {?} dataSource
         * @return {?}
         */
        FilterableDataSourcePipe.prototype.isTimeFilterable = /**
         * @private
         * @param {?} dataSource
         * @return {?}
         */
            function (dataSource) {
                if (dataSource.options.type !== 'wms') {
                    return false;
                }
                return dataSource.options.timeFilterable;
            };
        /**
         * @private
         * @param {?} dataSource
         * @return {?}
         */
        FilterableDataSourcePipe.prototype.isOgcFilterable = /**
         * @private
         * @param {?} dataSource
         * @return {?}
         */
            function (dataSource) {
                if (dataSource.options.ogcFilters &&
                    dataSource.options.ogcFilters.enabled) {
                    return true;
                }
                return false;
            };
        FilterableDataSourcePipe.decorators = [
            { type: i0.Pipe, args: [{
                        name: 'filterableDataSource'
                    },] }
        ];
        return FilterableDataSourcePipe;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TimeFilterService = /** @class */ (function () {
        function TimeFilterService() {
        }
        /**
         * @param {?} datasource
         * @param {?} date
         * @return {?}
         */
        TimeFilterService.prototype.filterByDate = /**
         * @param {?} datasource
         * @param {?} date
         * @return {?}
         */
            function (datasource, date) {
                /** @type {?} */
                var time;
                /** @type {?} */
                var newdateform;
                /** @type {?} */
                var newdateformStart;
                /** @type {?} */
                var newdateformEnd;
                if (Array.isArray(date)) {
                    /** @type {?} */
                    var dates = [];
                    if (date[0]) {
                        newdateformStart = this.reformatDateTime(date[0]);
                        dates.push(date[0]);
                    }
                    if (date[1]) {
                        newdateformEnd = this.reformatDateTime(date[1]);
                        dates.push(date[1]);
                    }
                    if (dates.length === 2 && newdateformStart !== newdateformEnd) {
                        if (datasource instanceof TileArcGISRestDataSource) {
                            time = newdateformStart + ',' + newdateformEnd;
                        }
                        else {
                            time = newdateformStart + '/' + newdateformEnd;
                        }
                    }
                    if (newdateformStart === newdateformEnd) {
                        time = newdateformStart;
                    }
                }
                else if (date) {
                    newdateform = this.reformatDateTime(date);
                    time = newdateform;
                }
                /** @type {?} */
                var params = { time: time };
                datasource.ol.updateParams(params);
            };
        /**
         * @param {?} datasource
         * @param {?} year
         * @return {?}
         */
        TimeFilterService.prototype.filterByYear = /**
         * @param {?} datasource
         * @param {?} year
         * @return {?}
         */
            function (datasource, year) {
                /** @type {?} */
                var time;
                /** @type {?} */
                var newdateformStart;
                /** @type {?} */
                var newdateformEnd;
                if (Array.isArray(year)) {
                    /** @type {?} */
                    var years = [];
                    if (year[0]) {
                        newdateformStart = year[0];
                        years.push(year[0]);
                    }
                    if (year[1]) {
                        newdateformEnd = year[1];
                        years.push(year[1]);
                    }
                    if (years.length === 2 && newdateformStart !== newdateformEnd) {
                        if (datasource instanceof TileArcGISRestDataSource) {
                            time = newdateformStart + ',' + newdateformEnd;
                        }
                        else {
                            time = newdateformStart + '/' + newdateformEnd;
                        }
                    }
                    if (newdateformStart === newdateformEnd) {
                        time = newdateformStart;
                    }
                }
                else if (year) {
                    time = year;
                }
                /** @type {?} */
                var params = { time: time };
                datasource.ol.updateParams(params);
            };
        /**
         * @private
         * @param {?} value
         * @return {?}
         */
        TimeFilterService.prototype.reformatDateTime = /**
         * @private
         * @param {?} value
         * @return {?}
         */
            function (value) {
                /** @type {?} */
                var year = value.getFullYear();
                /** @type {?} */
                var month = value.getMonth() + 1;
                /** @type {?} */
                var day = value.getUTCDate();
                /** @type {?} */
                var hour = value.getUTCHours();
                /** @type {?} */
                var minute = value.getUTCMinutes();
                if (Number(month) < 10) {
                    month = '0' + month;
                }
                if (Number(day) < 10) {
                    day = '0' + day;
                }
                if (Number(hour) < 10) {
                    hour = '0' + hour;
                }
                if (Number(minute) < 10) {
                    minute = '0' + minute;
                }
                return year + '-' + month + '-' + day + 'T' + hour + ':' + minute + ':00Z';
            };
        TimeFilterService.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        TimeFilterService.ctorParameters = function () { return []; };
        return TimeFilterService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @enum {string} */
    var OgcFilterOperatorType = {
        BasicNumericOperator: 'BasicNumericOperator',
        Basic: 'Basic',
        BasicAndSpatial: 'BasicAndSpatial',
        Spatial: 'Spatial',
        All: 'All',
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var OGCFilterService = /** @class */ (function () {
        function OGCFilterService() {
        }
        /**
         * @param {?} wmsDatasource
         * @param {?} filterString
         * @return {?}
         */
        OGCFilterService.prototype.filterByOgc = /**
         * @param {?} wmsDatasource
         * @param {?} filterString
         * @return {?}
         */
            function (wmsDatasource, filterString) {
                /** @type {?} */
                var appliedFilter = new OgcFilterWriter().formatProcessedOgcFilter(filterString, wmsDatasource.options.params.layers);
                wmsDatasource.ol.updateParams({ filter: appliedFilter });
            };
        /**
         * @param {?} wfsDatasource
         * @return {?}
         */
        OGCFilterService.prototype.setOgcWFSFiltersOptions = /**
         * @param {?} wfsDatasource
         * @return {?}
         */
            function (wfsDatasource) {
                /** @type {?} */
                var options = wfsDatasource.options;
                /** @type {?} */
                var ogcFilterWriter = new OgcFilterWriter();
                if (options.ogcFilters.enabled && options.ogcFilters.filters) {
                    options.ogcFilters.filters = ogcFilterWriter.checkIgoFiltersProperties(options.ogcFilters.filters, options.paramsWFS.fieldNameGeometry, true);
                    if (!options.ogcFilters.interfaceOgcFilters) {
                        options.ogcFilters.interfaceOgcFilters = ogcFilterWriter.defineInterfaceFilterSequence(options.ogcFilters.filters, options.paramsWFS.fieldNameGeometry);
                    }
                }
            };
        /**
         * @param {?} wmsDatasource
         * @return {?}
         */
        OGCFilterService.prototype.setOgcWMSFiltersOptions = /**
         * @param {?} wmsDatasource
         * @return {?}
         */
            function (wmsDatasource) {
                /** @type {?} */
                var options = wmsDatasource.options;
                /** @type {?} */
                var ogcFilterWriter = new OgcFilterWriter();
                if (options.ogcFilters.enabled && options.ogcFilters.filters) {
                    options.ogcFilters.filters = ogcFilterWriter.checkIgoFiltersProperties(options.ogcFilters.filters, options.fieldNameGeometry, true);
                    if (!options.ogcFilters.interfaceOgcFilters) {
                        options.ogcFilters.interfaceOgcFilters = ogcFilterWriter.defineInterfaceFilterSequence(
                        // With some wms server, this param must be set to make spatials call.
                        options.ogcFilters.filters, options.fieldNameGeometry);
                    }
                    this.filterByOgc(( /** @type {?} */(wmsDatasource)), ogcFilterWriter.buildFilter(options.ogcFilters.filters));
                    options.filtered = true;
                }
                else {
                    options.ogcFilters.filters = undefined;
                    options.ogcFilters.interfaceOgcFilters = [];
                    options.filtered = false;
                }
            };
        OGCFilterService.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        OGCFilterService.ctorParameters = function () { return []; };
        return OGCFilterService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var DownloadService = /** @class */ (function () {
        function DownloadService(messageService, languageService) {
            this.messageService = messageService;
            this.languageService = languageService;
        }
        /**
         * @param {?} layer
         * @return {?}
         */
        DownloadService.prototype.open = /**
         * @param {?} layer
         * @return {?}
         */
            function (layer) {
                /** @type {?} */
                var translate = this.languageService.translate;
                /** @type {?} */
                var title = translate.instant('igo.geo.download.title');
                this.messageService.success(translate.instant('igo.geo.download.start'), title);
                /** @type {?} */
                var DSOptions = layer.dataSource.options;
                if (Object.keys(DSOptions.download).length > 0) {
                    if (DSOptions.download.dynamicUrl &&
                        DSOptions.download.url === undefined) {
                        /** @type {?} */
                        var wfsOptions = void 0;
                        if ((( /** @type {?} */(layer.dataSource.options))).paramsWFS &&
                            Object.keys((( /** @type {?} */(layer.dataSource.options))).paramsWFS).length > 0) {
                            wfsOptions = (( /** @type {?} */(layer.dataSource.options))).paramsWFS;
                        }
                        else {
                            wfsOptions = (( /** @type {?} */(layer.dataSource.options))).params;
                        }
                        /** @type {?} */
                        var outputFormatDownload = wfsOptions.outputFormatDownload === undefined
                            ? 'outputformat=' + wfsOptions.outputFormat
                            : 'outputformat=' + wfsOptions.outputFormatDownload;
                        /** @type {?} */
                        var baseurl = DSOptions.download.dynamicUrl
                            .replace(/&?outputformat=[^&]*/gi, '')
                            .replace(/&?filter=[^&]*/gi, '')
                            .replace(/&?bbox=[^&]*/gi, '');
                        /** @type {?} */
                        var ogcFilters = (( /** @type {?} */(layer.dataSource.options))).ogcFilters;
                        /** @type {?} */
                        var filterQueryString = void 0;
                        filterQueryString = new OgcFilterWriter()
                            .handleOgcFiltersAppliedValue(layer.dataSource.options, ogcFilters.geometryName);
                        if (!filterQueryString) {
                            // Prevent getting all the features for empty filter
                            filterQueryString = new OgcFilterWriter().buildFilter(undefined, layer.map.getExtent(), new olProjection({ code: layer.map.projection }), ogcFilters.geometryName);
                        }
                        else {
                            filterQueryString = 'filter=' + filterQueryString;
                        }
                        window.open(baseurl + "&" + filterQueryString + "&" + outputFormatDownload, '_blank');
                    }
                    else if (DSOptions.download) {
                        window.open(DSOptions.download.url, '_blank');
                    }
                }
            };
        DownloadService.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        DownloadService.ctorParameters = function () {
            return [
                { type: i1$1.MessageService },
                { type: i1$1.LanguageService }
            ];
        };
        /** @nocollapse */ DownloadService.ngInjectableDef = i0.defineInjectable({ factory: function DownloadService_Factory() { return new DownloadService(i0.inject(i1$1.MessageService), i0.inject(i1$1.LanguageService)); }, token: DownloadService, providedIn: "root" });
        return DownloadService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var DownloadButtonComponent = /** @class */ (function () {
        function DownloadButtonComponent(downloadService) {
            this.downloadService = downloadService;
            this._color = 'primary';
        }
        Object.defineProperty(DownloadButtonComponent.prototype, "layer", {
            get: /**
             * @return {?}
             */ function () {
                return this._layer;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._layer = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DownloadButtonComponent.prototype, "color", {
            get: /**
             * @return {?}
             */ function () {
                return this._color;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._color = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} layer
         * @return {?}
         */
        DownloadButtonComponent.prototype.openDownload = /**
         * @param {?} layer
         * @return {?}
         */
            function (layer) {
                this.downloadService.open(layer);
            };
        Object.defineProperty(DownloadButtonComponent.prototype, "options", {
            get: /**
             * @return {?}
             */ function () {
                if (!this.layer) {
                    return;
                }
                return this.layer.dataSource.options;
            },
            enumerable: true,
            configurable: true
        });
        DownloadButtonComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'igo-download-button',
                        template: "<button\r\n  *ngIf=\"options && options.download && (options.download['dynamicUrl'] || options.download['url']) \"\r\n  mat-icon-button\r\n  tooltip-position=\"below\"\r\n  matTooltipShowDelay=\"500\"\r\n  [matTooltip]=\"'igo.geo.download.action' | translate\"\r\n  [color]=\"color\"\r\n  (click)=\"openDownload(layer)\">\r\n  <mat-icon svgIcon=\"download\"></mat-icon>\r\n</button>\r\n",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        styles: [""]
                    }] }
        ];
        /** @nocollapse */
        DownloadButtonComponent.ctorParameters = function () {
            return [
                { type: DownloadService }
            ];
        };
        DownloadButtonComponent.propDecorators = {
            layer: [{ type: i0.Input }],
            color: [{ type: i0.Input }]
        };
        return DownloadButtonComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var IgoDownloadModule = /** @class */ (function () {
        function IgoDownloadModule() {
        }
        /**
         * @return {?}
         */
        IgoDownloadModule.forRoot = /**
         * @return {?}
         */
            function () {
                return {
                    ngModule: IgoDownloadModule
                };
            };
        IgoDownloadModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            material.MatIconModule,
                            material.MatButtonModule,
                            material.MatTooltipModule,
                            i1$1.IgoLanguageModule
                        ],
                        exports: [DownloadButtonComponent],
                        declarations: [DownloadButtonComponent]
                    },] }
        ];
        return IgoDownloadModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var FeatureDetailsComponent = /** @class */ (function () {
        function FeatureDetailsComponent(cdRef, sanitizer) {
            this.cdRef = cdRef;
            this.sanitizer = sanitizer;
        }
        Object.defineProperty(FeatureDetailsComponent.prototype, "feature", {
            get: /**
             * @return {?}
             */ function () {
                return this._feature;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._feature = value;
                this.cdRef.detectChanges();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FeatureDetailsComponent.prototype, "title", {
            /**
             * @internal
             */
            get: /**
             * \@internal
             * @return {?}
             */ function () {
                return common$1.getEntityTitle(this.feature);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FeatureDetailsComponent.prototype, "icon", {
            /**
             * @internal
             */
            get: /**
             * \@internal
             * @return {?}
             */ function () {
                return common$1.getEntityIcon(this.feature) || 'link';
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} value
         * @return {?}
         */
        FeatureDetailsComponent.prototype.htmlSanitizer = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                return this.sanitizer.bypassSecurityTrustResourceUrl(value);
            };
        /**
         * @param {?} value
         * @return {?}
         */
        FeatureDetailsComponent.prototype.isObject = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                return typeof value === 'object';
            };
        /**
         * @param {?} value
         * @return {?}
         */
        FeatureDetailsComponent.prototype.isUrl = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (typeof value === 'string') {
                    return (value.slice(0, 8) === 'https://' || value.slice(0, 7) === 'http://');
                }
                else {
                    return false;
                }
            };
        /**
         * @param {?} feature
         * @return {?}
         */
        FeatureDetailsComponent.prototype.filterFeatureProperties = /**
         * @param {?} feature
         * @return {?}
         */
            function (feature) {
                /** @type {?} */
                var allowedFieldsAndAlias = feature.meta ? feature.meta.alias : undefined;
                /** @type {?} */
                var properties = Object.assign({}, feature.properties);
                if (allowedFieldsAndAlias) {
                    Object.keys(properties).forEach(( /**
                     * @param {?} property
                     * @return {?}
                     */function (property) {
                        if (Object.keys(allowedFieldsAndAlias).indexOf(property) === -1) {
                            delete properties[property];
                        }
                        else {
                            properties[allowedFieldsAndAlias[property]] = properties[property];
                            if (allowedFieldsAndAlias[property] !== property) {
                                delete properties[property];
                            }
                        }
                    }));
                    return properties;
                }
                else {
                    return feature.properties;
                }
            };
        FeatureDetailsComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'igo-feature-details',
                        template: "<table class=\"igo-striped\" *ngIf=\"feature && isObject(feature.properties) && feature.properties.target !== 'iframe'\">\r\n  <tbody>\r\n    <tr *ngFor=\"let property of filterFeatureProperties(feature) | keyvalue\">\r\n\r\n      <td *ngIf=\"feature.properties.target === '_blank' && property.key === 'url'\">\r\n        <mat-icon mat-list-avatar svgIcon=\"{{icon}}\"></mat-icon>\r\n      </td>\r\n\r\n      <td *ngIf=\"feature.properties.target === '_blank' && property.key === 'url'\">\r\n        <a href=\"{{property.value}}\" target='_blank'> {{ 'igo.geo.targetHtmlUrl' | translate }} {{title}}</a>\r\n      </td>\r\n\r\n      <td *ngIf=\"feature.properties.target === undefined\">\r\n        {{property.key }}\r\n      </td>\r\n\r\n      <td *ngIf=\"feature.properties.target === undefined && !isObject(property.value) && !isUrl(property.value)\" [innerHTML]=property.value>\r\n      </td>\r\n\r\n      <td *ngIf=\"feature.properties.target === undefined && !isObject(property.value) && isUrl(property.value)\">\r\n        <a href=\"{{property.value}}\" target='_blank'>{{ 'igo.geo.targetHtmlUrl' | translate }} </a>\r\n      </td>\r\n\r\n      <td *ngIf=\"feature.properties.target === undefined && isObject(property.value)\" [innerHTML]=\"property.value | json\">\r\n      </td>\r\n\r\n    </tr>\r\n  </tbody>\r\n</table>\r\n<iframe *ngIf=\"feature && isObject(feature.properties) && feature.properties.target === 'iframe'\" [src]='htmlSanitizer(feature.properties.url)'></iframe>\r\n",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        styles: ["table{width:100%;white-space:nowrap}table td{padding:5px}iframe{height:calc(100% - 4px);width:100%;border:0}"]
                    }] }
        ];
        /** @nocollapse */
        FeatureDetailsComponent.ctorParameters = function () {
            return [
                { type: i0.ChangeDetectorRef },
                { type: platformBrowser.DomSanitizer }
            ];
        };
        FeatureDetailsComponent.propDecorators = {
            feature: [{ type: i0.Input }]
        };
        return FeatureDetailsComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @ignore
     */
    var IgoFeatureDetailsModule = /** @class */ (function () {
        function IgoFeatureDetailsModule() {
        }
        IgoFeatureDetailsModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            material.MatIconModule,
                            i1$1.IgoLanguageModule,
                            common$1.IgoKeyValueModule
                        ],
                        exports: [FeatureDetailsComponent],
                        declarations: [FeatureDetailsComponent]
                    },] }
        ];
        return IgoFeatureDetailsModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * A configurable form, optionnally bound to a feature.
     * This component creates an entity form and, on submit,
     * returns a feature made out of the submitted data. It also
     * does things like managing the feature visibility while it's being updated
     * as well as disabling the selection of another feature.
     */
    var FeatureFormComponent = /** @class */ (function () {
        function FeatureFormComponent() {
            this.feature$ = new rxjs.BehaviorSubject(undefined);
            /**
             * Event emitted when the form is submitted
             */
            this.submitForm = new i0.EventEmitter();
        }
        /**
         * @param {?} changes
         * @return {?}
         */
        FeatureFormComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                /** @type {?} */
                var store = changes.store;
                if (store && store.currentValue !== store.previousValue) {
                    this.setStore(store.currentValue);
                }
                /** @type {?} */
                var feature = changes.feature;
                if (feature && feature.currentValue !== feature.previousValue) {
                    this.feature$.next(feature.currentValue);
                }
            };
        /**
         * Show the original feature and reactivate the selection
         * @internal
         */
        /**
         * Show the original feature and reactivate the selection
         * \@internal
         * @return {?}
         */
        FeatureFormComponent.prototype.ngOnDestroy = /**
         * Show the original feature and reactivate the selection
         * \@internal
         * @return {?}
         */
            function () {
                this.setStore(undefined);
            };
        /**
         * Transform the form data to a feature and emit an event
         * @param event Form submit event
         * @internal
         */
        /**
         * Transform the form data to a feature and emit an event
         * \@internal
         * @param {?} data
         * @return {?}
         */
        FeatureFormComponent.prototype.onSubmit = /**
         * Transform the form data to a feature and emit an event
         * \@internal
         * @param {?} data
         * @return {?}
         */
            function (data) {
                /** @type {?} */
                var feature = this.formDataToFeature(data);
                this.submitForm.emit(feature);
            };
        /**
         * Transform the form data to a feature
         * @param data Form data
         * @returns A feature
         */
        /**
         * Transform the form data to a feature
         * @private
         * @param {?} data Form data
         * @return {?} A feature
         */
        FeatureFormComponent.prototype.formDataToFeature = /**
         * Transform the form data to a feature
         * @private
         * @param {?} data Form data
         * @return {?} A feature
         */
            function (data) {
                /** @type {?} */
                var properties = {};
                /** @type {?} */
                var meta = {};
                if (this.feature === undefined) {
                    (( /** @type {?} */(meta))).id = utils.uuid();
                }
                else {
                    Object.assign(properties, this.feature.properties);
                    Object.assign(meta, this.feature.meta, {
                        revision: common$1.getEntityRevision(this.feature) + 1
                    });
                }
                /** @type {?} */
                var propertyPrefix = 'properties.';
                Object.entries(data).forEach(( /**
                 * @param {?} entry
                 * @return {?}
                 */function (entry) {
                    var _a = __read(entry, 2), key = _a[0], value = _a[1];
                    if (key.startsWith(propertyPrefix)) {
                        /** @type {?} */
                        var property = key.substr(propertyPrefix.length);
                        properties[property] = value;
                    }
                }));
                /** @type {?} */
                var geometry = data.geometry;
                if (geometry === undefined && this.feature !== undefined) {
                    geometry = this.feature.geometry;
                }
                return {
                    meta: ( /** @type {?} */(meta)),
                    type: FEATURE,
                    geometry: geometry,
                    projection: 'EPSG:4326',
                    properties: properties
                };
            };
        /**
         * @private
         * @param {?} store
         * @return {?}
         */
        FeatureFormComponent.prototype.setStore = /**
         * @private
         * @param {?} store
         * @return {?}
         */
            function (store) {
                if (this.store !== undefined) {
                    this.activateStoreSelection(this.store);
                }
                if (store !== undefined) {
                    this.deactivateStoreSelection(store);
                }
                this.store = store;
            };
        /**
         * Deactivate feature selection from the store and from the map
         */
        /**
         * Deactivate feature selection from the store and from the map
         * @private
         * @param {?} store
         * @return {?}
         */
        FeatureFormComponent.prototype.deactivateStoreSelection = /**
         * Deactivate feature selection from the store and from the map
         * @private
         * @param {?} store
         * @return {?}
         */
            function (store) {
                /** @type {?} */
                var selectionStrategy = store.getStrategyOfType(FeatureStoreSelectionStrategy);
                if (selectionStrategy !== undefined) {
                    selectionStrategy.deactivate();
                    (( /** @type {?} */(selectionStrategy))).unselectAll();
                }
            };
        /**
         * Reactivate feature selection from the store and from the map
         */
        /**
         * Reactivate feature selection from the store and from the map
         * @private
         * @param {?} store
         * @return {?}
         */
        FeatureFormComponent.prototype.activateStoreSelection = /**
         * Reactivate feature selection from the store and from the map
         * @private
         * @param {?} store
         * @return {?}
         */
            function (store) {
                // TODO: maybe we should recativate the strategies only if they
                // were active in the first place
                store.activateStrategyOfType(FeatureStoreSelectionStrategy);
            };
        FeatureFormComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'igo-feature-form',
                        template: "\r\n<igo-form\r\n  [form]=\"form\"\r\n  [formData]=\"feature$ | async\"\r\n  (submitForm)=\"onSubmit($event)\">\r\n\r\n  <ng-content></ng-content>\r\n  \r\n  <ng-content select=\"[formButtons]\" formButtons></ng-content>\r\n  \r\n</igo-form>\r\n",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        styles: [":host{display:block}igo-form{height:100%}"]
                    }] }
        ];
        /** @nocollapse */
        FeatureFormComponent.ctorParameters = function () { return []; };
        FeatureFormComponent.propDecorators = {
            form: [{ type: i0.Input }],
            feature: [{ type: i0.Input }],
            store: [{ type: i0.Input }],
            submitForm: [{ type: i0.Output }]
        };
        return FeatureFormComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @ignore
     */
    var IgoFeatureFormModule = /** @class */ (function () {
        function IgoFeatureFormModule() {
        }
        IgoFeatureFormModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            common$1.IgoFormModule
                        ],
                        exports: [
                            common$1.IgoFormModule,
                            FeatureFormComponent
                        ],
                        declarations: [
                            FeatureFormComponent
                        ]
                    },] }
        ];
        return IgoFeatureFormModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var IgoFeatureModule = /** @class */ (function () {
        function IgoFeatureModule() {
        }
        IgoFeatureModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            common.CommonModule
                        ],
                        exports: [
                            IgoFeatureDetailsModule,
                            IgoFeatureFormModule
                        ],
                        declarations: [],
                        providers: []
                    },] }
        ];
        return IgoFeatureModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TimeFilterFormComponent = /** @class */ (function () {
        function TimeFilterFormComponent() {
            this.listYears = [];
            this.startListYears = [];
            this.endListYears = [];
            this.playIcon = 'play_circle_filled';
            this.change = new i0.EventEmitter();
            this.yearChange = new i0.EventEmitter();
        }
        Object.defineProperty(TimeFilterFormComponent.prototype, "options", {
            get: /**
             * @return {?}
             */ function () {
                return this._options;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._options = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TimeFilterFormComponent.prototype, "currentValue", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value) {
                    if (this.type !== 'year') {
                        /** @type {?} */
                        var valueArray = value.split('/');
                        if (valueArray.length > 0) {
                            /** @type {?} */
                            var startDate = new Date(valueArray[0]);
                            /** @type {?} */
                            var endDate = new Date(valueArray[1]);
                            if (!isNaN(startDate.valueOf())) {
                                this.startDate = startDate;
                            }
                            if (!isNaN(endDate.valueOf())) {
                                this.endDate = endDate;
                            }
                        }
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TimeFilterFormComponent.prototype, "type", {
            get: /**
             * @return {?}
             */ function () {
                return this.options.type === undefined ? 'date' : this.options.type;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TimeFilterFormComponent.prototype, "isRange", {
            get: /**
             * @return {?}
             */ function () {
                return this.options.range === undefined || this.options.style === 'slider'
                    ? false
                    : this.options.range;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TimeFilterFormComponent.prototype, "style", {
            get: /**
             * @return {?}
             */ function () {
                return this.options.style === undefined ? 'slider' : this.options.style;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TimeFilterFormComponent.prototype, "step", {
            get: /**
             * @return {?}
             */ function () {
                /** @type {?} */
                var step = 10800000;
                if (this.options.step === undefined) {
                    switch (this.type) {
                        case 'date':
                        case 'datetime':
                            step = 10800000;
                            break;
                        case 'time':
                            step = 3600000;
                            break;
                        case 'year':
                            step = 31536000000;
                            break;
                        default:
                            step = 10800000;
                    }
                }
                else {
                    step = this.getStepDefinition(this.options.step);
                }
                return step;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TimeFilterFormComponent.prototype, "timeInterval", {
            get: /**
             * @return {?}
             */ function () {
                return this.options.timeInterval === undefined
                    ? 2000
                    : this.options.timeInterval;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TimeFilterFormComponent.prototype, "min", {
            get: /**
             * @return {?}
             */ function () {
                return this.options.min === undefined
                    ? undefined
                    : new Date(this.options.min);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TimeFilterFormComponent.prototype, "max", {
            get: /**
             * @return {?}
             */ function () {
                return this.options.max === undefined
                    ? undefined
                    : new Date(this.options.max);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TimeFilterFormComponent.prototype, "is", {
            get: /**
             * @return {?}
             */ function () {
                return this.options.range === undefined ? false : this.options.range;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        TimeFilterFormComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                if (this.startDate === undefined) {
                    /** @type {?} */
                    var utcmin = new Date(this.min);
                    this.startDate = new Date(utcmin.getTime() + utcmin.getTimezoneOffset() * 60000);
                }
                if (this.endDate === undefined) {
                    /** @type {?} */
                    var utcmax = new Date(this.max);
                    this.endDate = new Date(utcmax.getTime() + utcmax.getTimezoneOffset() * 60000);
                }
                if (this.startYear === undefined) {
                    this.startYear = new Date(this.startDate).getFullYear();
                    this.initStartYear = this.startYear;
                }
                if (this.endYear === undefined) {
                    this.endYear = new Date(this.endDate).getFullYear();
                    this.initEndYear = this.endYear;
                }
                if (!this.isRange) {
                    for (var i = this.startYear; i <= this.endYear + 1; i++) {
                        this.listYears.push(i);
                    }
                }
                else {
                    for (var i = this.startYear; i < this.endYear; i++) {
                        this.startListYears.push(i);
                    }
                    for (var i = this.startYear + 1; i <= this.endYear; i++) {
                        this.endListYears.push(i);
                    }
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        TimeFilterFormComponent.prototype.handleDateChange = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.setupDateOutput();
                this.applyTypeChange();
                // Only if is range, use 2 dates to make the range
                if (this.isRange) {
                    this.change.emit([this.startDate, this.endDate]);
                }
                else {
                    this.change.emit(this.startDate);
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        TimeFilterFormComponent.prototype.handleYearChange = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this.isRange) {
                    this.endListYears = [];
                    for (var i = this.startYear + 1; i <= this.initEndYear; i++) {
                        this.endListYears.push(i);
                    }
                    this.startListYears = [];
                    for (var i = this.initStartYear + 1; i < this.endYear; i++) {
                        this.startListYears.push(i);
                    }
                    this.yearChange.emit([this.startYear, this.endYear]);
                }
                else {
                    this.yearChange.emit(this.year);
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        TimeFilterFormComponent.prototype.handleListYearChange = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.handleYearChange([this.startYear, this.endYear]);
            };
        /**
         * @param {?} event
         * @return {?}
         */
        TimeFilterFormComponent.prototype.handleListYearStartChange = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.change.emit([this.startDate, this.endDate]);
            };
        /**
         * @param {?} date
         * @return {?}
         */
        TimeFilterFormComponent.prototype.dateToNumber = /**
         * @param {?} date
         * @return {?}
         */
            function (date) {
                /** @type {?} */
                var newDate;
                if (date) {
                    newDate = new Date(date);
                }
                else {
                    newDate = new Date(this.min);
                }
                return newDate.getTime();
            };
        /**
         * @param {?} label
         * @return {?}
         */
        TimeFilterFormComponent.prototype.setSliderThumbLabel = /**
         * @param {?} label
         * @return {?}
         */
            function (label) {
                /** @type {?} */
                var thumbLabel = this.findThumbLabel(this.mySlider._elementRef.nativeElement.childNodes);
                if (thumbLabel) {
                    thumbLabel.textContent = label;
                }
            };
        /**
         * @param {?} test
         * @return {?}
         */
        TimeFilterFormComponent.prototype.findThumbLabel = /**
         * @param {?} test
         * @return {?}
         */
            function (test) {
                var _this = this;
                /** @type {?} */
                var thumbLabel;
                test.forEach(( /**
                 * @param {?} value
                 * @return {?}
                 */function (value) {
                    if (value.className === 'mat-slider-thumb-label-text') {
                        thumbLabel = value;
                    }
                    if (value.children.length > 0 && !thumbLabel) {
                        thumbLabel = _this.findThumbLabel(value.childNodes);
                    }
                }), this);
                return thumbLabel;
            };
        /**
         * @param {?} event
         * @return {?}
         */
        TimeFilterFormComponent.prototype.playFilter = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this.interval) {
                    this.stopFilter();
                }
                else {
                    this.playIcon = 'pause_circle_filled';
                    this.interval = setInterval(( /**
                     * @param {?} that
                     * @return {?}
                     */function (that) {
                        /** @type {?} */
                        var newMinDateNumber;
                        /** @type {?} */
                        var maxDateNumber = new Date(that.max);
                        newMinDateNumber =
                            that.date === undefined ? that.min.getTime() : that.date.getTime();
                        newMinDateNumber += that.mySlider.step;
                        that.date = new Date(newMinDateNumber);
                        if (newMinDateNumber > maxDateNumber.getTime()) {
                            that.stopFilter();
                        }
                        that.handleDateChange({ value: that.date, date: that.date });
                    }), this.timeInterval, this);
                }
            };
        /**
         * @return {?}
         */
        TimeFilterFormComponent.prototype.stopFilter = /**
         * @return {?}
         */
            function () {
                if (this.interval) {
                    clearInterval(this.interval);
                }
                this.interval = undefined;
                this.playIcon = 'play_circle_filled';
            };
        /**
         * @param {?} event
         * @return {?}
         */
        TimeFilterFormComponent.prototype.handleSliderDateChange = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.date = new Date(event.value);
                this.setSliderThumbLabel(this.handleSliderTooltip());
                this.handleDateChange(event);
            };
        /**
         * @return {?}
         */
        TimeFilterFormComponent.prototype.handleSliderValue = /**
         * @return {?}
         */
            function () {
                if (this.options.current === true || !this.min) {
                    /** @type {?} */
                    var currentDate = new Date();
                    this.date = this.getRoundedDate(currentDate);
                }
                return this.date === undefined ? this.min.getTime() : this.date.getTime();
            };
        /**
         * @return {?}
         */
        TimeFilterFormComponent.prototype.handleSliderTooltip = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var label;
                switch (this.type) {
                    case 'date':
                        label =
                            this.date === undefined
                                ? this.min.toDateString()
                                : this.date.toDateString();
                        break;
                    case 'time':
                        label =
                            this.date === undefined
                                ? this.min.toTimeString()
                                : this.date.toTimeString();
                        break;
                    // datetime
                    default:
                        label =
                            this.date === undefined
                                ? this.min.toUTCString()
                                : this.date.toUTCString();
                        break;
                }
                return label;
            };
        /**
         * @return {?}
         */
        TimeFilterFormComponent.prototype.setupDateOutput = /**
         * @return {?}
         */
            function () {
                if (this.style === 'slider') {
                    this.startDate = new Date(this.date);
                    this.startDate.setSeconds(-(this.step / 1000));
                    this.endDate = new Date(this.startDate);
                    this.endDate.setSeconds(this.step / 1000);
                }
                else if (!this.isRange && !!this.date) {
                    this.endDate = new Date(this.date);
                    this.startDate = new Date(this.date);
                }
                else if (this.isRange && (!!this.date || !this.date)) {
                    this.startDate =
                        this.startDate === undefined ? new Date(this.min) : this.startDate;
                    this.endDate =
                        this.endDate === undefined ? new Date(this.max) : this.endDate;
                }
                else if (!this.date) {
                    this.startDate =
                        this.startDate === undefined ? new Date(this.min) : this.startDate;
                    this.endDate =
                        this.endDate === undefined ? new Date(this.max) : this.endDate;
                }
            };
        /**
         * @return {?}
         */
        TimeFilterFormComponent.prototype.applyTypeChange = /**
         * @return {?}
         */
            function () {
                switch (this.type) {
                    case 'date':
                        if (this.startDate !== undefined || this.endDate !== undefined) {
                            this.startDate.setHours(0);
                            this.startDate.setMinutes(0);
                            this.startDate.setSeconds(0);
                            this.endDate.setHours(23);
                            this.endDate.setMinutes(59);
                            this.endDate.setSeconds(59);
                        }
                        break;
                    case 'time':
                        if (this.style === 'calendar') {
                            if (this.startDate.getDay() !== this.min.getDay()) {
                                /** @type {?} */
                                var selectedHour = this.startDate.getHours();
                                /** @type {?} */
                                var selectedMinute = this.startDate.getMinutes();
                                this.startDate = this.min;
                                this.startDate.setHours(selectedHour);
                                this.startDate.setMinutes(selectedMinute);
                            }
                            if (this.endDate.getDay() !== this.min.getDay()) {
                                /** @type {?} */
                                var selectedHour = this.endDate.getHours();
                                /** @type {?} */
                                var selectedMinute = this.endDate.getMinutes();
                                this.endDate = this.min;
                                this.endDate.setHours(selectedHour);
                                this.endDate.setMinutes(selectedMinute);
                            }
                        }
                        if (!this.isRange && this.step > 60 * 60 * 1000) {
                            this.startDate.setMinutes(0);
                            this.startDate.setSeconds(0);
                            this.endDate.setMinutes(59);
                            this.endDate.setSeconds(59);
                        }
                        break;
                    // datetime
                    default:
                    // do nothing
                }
            };
        /**
         * @return {?}
         */
        TimeFilterFormComponent.prototype.getRangeMinDate = /**
         * @return {?}
         */
            function () {
                return this.startDate === undefined ? this.min : this.startDate;
            };
        /**
         * @return {?}
         */
        TimeFilterFormComponent.prototype.getRangeMaxDate = /**
         * @return {?}
         */
            function () {
                return this.endDate === undefined ? this.max : this.endDate;
            };
        /**
         * Round date at a certain time, 10 minutes by Default
         * @param date - Date to Round
         * @param atMinute - round to closest 'atMinute' minute, rounded 10 by default
         * @return the rounded date
         */
        /**
         * Round date at a certain time, 10 minutes by Default
         * @param {?} date - Date to Round
         * @param {?=} atMinute - round to closest 'atMinute' minute, rounded 10 by default
         * @return {?} the rounded date
         */
        TimeFilterFormComponent.prototype.getRoundedDate = /**
         * Round date at a certain time, 10 minutes by Default
         * @param {?} date - Date to Round
         * @param {?=} atMinute - round to closest 'atMinute' minute, rounded 10 by default
         * @return {?} the rounded date
         */
            function (date, atMinute) {
                if (atMinute === void 0) {
                    atMinute = 10;
                }
                /** @type {?} */
                var coeff = 1000 * 60 * atMinute;
                return new Date(Math.round(date.getTime() / coeff) * coeff);
            };
        /**
         * Get the step (period) definition from the layer dimension tag
         * @param step The step as ISO 8601 example: PT10M for 10 Minutes
         * @return the duration in milliseconds
         */
        /**
         * Get the step (period) definition from the layer dimension tag
         * @param {?} step The step as ISO 8601 example: PT10M for 10 Minutes
         * @return {?} the duration in milliseconds
         */
        TimeFilterFormComponent.prototype.getStepDefinition = /**
         * Get the step (period) definition from the layer dimension tag
         * @param {?} step The step as ISO 8601 example: PT10M for 10 Minutes
         * @return {?} the duration in milliseconds
         */
            function (step) {
                return moment.duration(step).asMilliseconds();
            };
        TimeFilterFormComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'igo-time-filter-form',
                        template: "<!-- <div *ngIf=\"style === 'calendar' && type !=='year'\">\r\n  <div *ngIf=\"!isRange\" class=\"igo-col igo-col-100 igo-col-100-m\">\r\n    <mat-form-field>\r\n      <mat-datetimepicker-toggle [for]=\"datetimePicker\" matSuffix></mat-datetimepicker-toggle>\r\n      <mat-datetimepicker #datetimePicker type=\"{{type}}\" openOnFocus=\"true\" timeInterval=\"5\"></mat-datetimepicker>\r\n      <input matInput autocomplete=\"false\"\r\n        placeholder=\"{{'igo.geo.timeFilter.date' | translate}}\"\r\n        [matDatetimepicker]=\"datetimePicker\"\r\n        [(ngModel)]=\"date\"\r\n        [min]=\"min\"\r\n        [max]=\"max\"\r\n        readonly=\"readonly\"\r\n        (dateChange)=\"handleDateChange($event)\">\r\n    </mat-form-field>\r\n\r\n  </div>\r\n\r\n  <div *ngIf=\"isRange\">\r\n    <div class=\"igo-col igo-col-100\">\r\n      <mat-form-field>\r\n        <mat-datetimepicker-toggle [for]=\"minDatetimePicker\" matSuffix></mat-datetimepicker-toggle>\r\n        <mat-datetimepicker #minDatetimePicker type=\"{{type}}\" openOnFocus=\"true\" timeInterval=\"5\"></mat-datetimepicker>\r\n        <input matInput autocomplete=\"false\"\r\n          placeholder=\"{{'igo.geo.timeFilter.startDate' | translate}}\"\r\n          [matDatetimepicker]=\"minDatetimePicker\"\r\n          [(ngModel)]=\"startDate\"\r\n          [min]=\"min\"\r\n          [max]=\"getRangeMaxDate()\"\r\n          readonly=\"readonly\"\r\n          (input)=\"startDate\"\r\n          (dateChange)=\"handleDateChange($event)\">\r\n      </mat-form-field>\r\n    </div>\r\n\r\n    <div class=\"igo-col igo-col-100\">\r\n      <mat-form-field>\r\n        <mat-datetimepicker-toggle [for]=\"maxDatetimePicker\" matSuffix></mat-datetimepicker-toggle>\r\n        <mat-datetimepicker #maxDatetimePicker type=\"{{type}}\" openOnFocus=\"true\" timeInterval=\"5\"></mat-datetimepicker>\r\n        <input matInput autocomplete=\"false\"\r\n          placeholder=\"{{'igo.geo.timeFilter.endDate' | translate}}\"\r\n          [matDatetimepicker]=\"maxDatetimePicker\"\r\n          [(ngModel)]=\"endDate\"\r\n          [min]=\"getRangeMinDate()\"\r\n          [max]=\"max\"\r\n          readonly=\"readonly\"\r\n          (dateChange)=\"handleDateChange($event)\">\r\n      </mat-form-field>\r\n    </div>\r\n  </div>\r\n</div>\r\n\r\n<div *ngIf=\"style === 'calendar' && type ==='year'\">\r\n\r\n  <div *ngIf=\"!isRange\" class=\"igo-col igo-col-100 igo-col-100-m\">\r\n        <mat-form-field>\r\n            <mat-select placeholder=\"{{'igo.geo.timeFilter.date' | translate}}\" [(ngModel)]=\"year\" (selectionChange)=\"handleYearChange($event)\">\r\n                  <mat-option [value]=\"year\" *ngFor=\"let year of listYears\">{{year}}</mat-option>\r\n            </mat-select>\r\n        </mat-form-field>\r\n  </div>\r\n\r\n  <div *ngIf=\"isRange\">\r\n    <div class=\"igo-col igo-col-100\">\r\n        <mat-form-field>\r\n            <mat-select placeholder=\"{{'igo.geo.timeFilter.startDate' | translate}}\" [(ngModel)]=\"startYear\" (selectionChange)=\"handleYearChange($event)\">\r\n              <mat-option [value]=\"startYear\" *ngFor=\"let startYear of startListYears\">{{startYear}}</mat-option>\r\n            </mat-select>\r\n      </mat-form-field>\r\n    </div>\r\n\r\n    <div class=\"igo-col igo-col-100\">\r\n    <mat-form-field>\r\n        <mat-select placeholder=\"{{'igo.geo.timeFilter.endDate' | translate}}\" [(ngModel)]=\"endYear\" (selectionChange)=\"handleYearChange($event)\">\r\n              <mat-option [value]=\"endYear\" *ngFor=\"let endYear of endListYears\">{{endYear}}</mat-option>\r\n        </mat-select>\r\n      </mat-form-field>\r\n    </div>\r\n  </div>\r\n\r\n</div>\r\n\r\n\r\n  <br>\r\n\r\n\r\n<div *ngIf=\"style === 'slider'\" class=\"igo-col igo-col-100 igo-col-100-m\">\r\n  <mat-slider\r\n      id=\"time-slider\"\r\n      tickInterval=\"auto\"\r\n      step=\"{{step}}\"\r\n      [min]=\"dateToNumber(min)\"\r\n      [max]=\"dateToNumber(max)\"\r\n      [value]=\"handleSliderValue()\"\r\n      thumbLabel\r\n      (input)=\"handleSliderDateChange($event)\"\r\n      (selectionChange)=\"handleSliderDateChange($event)\">\r\n  </mat-slider>\r\n  <p class=\"date-below\">{{handleSliderTooltip()}}</p>\r\n  <button mat-icon-button color=\"primary\" (click)=\"playFilter($event)\">\r\n   <mat-icon svgIcon=\"{{playIcon}}\"></mat-icon>\r\n  </button>\r\n</div> -->\r\n",
                        styles: [".igo-layer-filters-container{padding-left:5px}mat-slider>>>div.mat-slider-thumb-label{width:32px;height:32px;margin:0 auto}mat-slider>>>span.mat-slider-thumb-label-text{font-size:8px}#time-slider{width:70%;margin:0 auto}@media only screen and (max-width:450px),only screen and (max-height:450px){#time-slider{width:60%;margin:0 auto}}#playFilterIcon{font-size:32px;cursor:pointer}.date-below{margin:0}mat-form-field{text-align:center}"]
                    }] }
        ];
        /** @nocollapse */
        TimeFilterFormComponent.ctorParameters = function () { return []; };
        TimeFilterFormComponent.propDecorators = {
            options: [{ type: i0.Input }],
            currentValue: [{ type: i0.Input }],
            change: [{ type: i0.Output }],
            yearChange: [{ type: i0.Output }],
            mySlider: [{ type: i0.ViewChild, args: [material.MatSlider,] }]
        };
        return TimeFilterFormComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TimeFilterItemComponent = /** @class */ (function () {
        function TimeFilterItemComponent(timeFilterService) {
            this.timeFilterService = timeFilterService;
        }
        Object.defineProperty(TimeFilterItemComponent.prototype, "layer", {
            get: /**
             * @return {?}
             */ function () {
                return this._layer;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._layer = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TimeFilterItemComponent.prototype, "datasource", {
            get: /**
             * @return {?}
             */ function () {
                return ( /** @type {?} */(this.layer.dataSource));
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} year
         * @return {?}
         */
        TimeFilterItemComponent.prototype.handleYearChange = /**
         * @param {?} year
         * @return {?}
         */
            function (year) {
                this.timeFilterService.filterByYear(this.datasource, year);
            };
        /**
         * @param {?} date
         * @return {?}
         */
        TimeFilterItemComponent.prototype.handleDateChange = /**
         * @param {?} date
         * @return {?}
         */
            function (date) {
                this.timeFilterService.filterByDate(this.datasource, date);
            };
        TimeFilterItemComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'igo-time-filter-item',
                        template: "<mat-list-item>\r\n  <mat-icon\r\n    class=\"igo-chevron\"\r\n    mat-list-avatar\r\n    igoCollapse\r\n    [target]=\"filters\"\r\n    [collapsed]=\"false\"\r\n    svgIcon=\"chevron-up\" >\r\n  </mat-icon>\r\n  <h4 matLine>{{layer.title}}</h4>\r\n</mat-list-item>\r\n\r\n<div #filters class=\"igo-datasource-filters-container\">\r\n  <igo-time-filter-form\r\n    [options]=\"datasource.options.timeFilter\"\r\n    [currentValue]=\"datasource.options.params.time\"\r\n    (change)=\"handleDateChange($event)\"\r\n    (yearChange)=\"handleYearChange($event)\">\r\n  </igo-time-filter-form>\r\n</div>\r\n",
                        styles: [":host{overflow:hidden}.igo-datasource-filters-container{text-align:center;width:100%;display:inline-block}"]
                    }] }
        ];
        /** @nocollapse */
        TimeFilterItemComponent.ctorParameters = function () {
            return [
                { type: TimeFilterService }
            ];
        };
        TimeFilterItemComponent.propDecorators = {
            layer: [{ type: i0.Input }]
        };
        return TimeFilterItemComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TimeFilterListComponent = /** @class */ (function () {
        function TimeFilterListComponent(cdRef) {
            this.cdRef = cdRef;
            this._layers = [];
        }
        Object.defineProperty(TimeFilterListComponent.prototype, "layers", {
            get: /**
             * @return {?}
             */ function () {
                return this._layers;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._layers = value;
                this.cdRef.detectChanges();
            },
            enumerable: true,
            configurable: true
        });
        TimeFilterListComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'igo-time-filter-list',
                        template: "<igo-list [navigation]=\"false\" [selection]=\"false\">\r\n  <ng-template ngFor let-layer [ngForOf]=\"layers | filterableDataSource: 'time'\">\r\n    <igo-time-filter-item igoListItem [layer]=\"layer\"></igo-time-filter-item>\r\n  </ng-template>\r\n</igo-list>\r\n",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        TimeFilterListComponent.ctorParameters = function () {
            return [
                { type: i0.ChangeDetectorRef }
            ];
        };
        TimeFilterListComponent.propDecorators = {
            layers: [{ type: i0.Input }]
        };
        return TimeFilterListComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TimeFilterListBindingDirective = /** @class */ (function () {
        function TimeFilterListBindingDirective(component, mapService) {
            this.mapService = mapService;
            this.component = component;
        }
        /**
         * @return {?}
         */
        TimeFilterListBindingDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // Override input layers
                this.component.layers = [];
                this.layers$$ = this.mapService.getMap().layers$.subscribe(( /**
                 * @param {?} layers
                 * @return {?}
                 */function (layers) {
                    _this.component.layers = layers;
                }));
            };
        /**
         * @return {?}
         */
        TimeFilterListBindingDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.layers$$.unsubscribe();
            };
        TimeFilterListBindingDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[igoTimeFilterListBinding]'
                    },] }
        ];
        /** @nocollapse */
        TimeFilterListBindingDirective.ctorParameters = function () {
            return [
                { type: TimeFilterListComponent, decorators: [{ type: i0.Self }] },
                { type: MapService }
            ];
        };
        return TimeFilterListBindingDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var WktService = /** @class */ (function () {
        function WktService() {
        }
        /**
         * @param {?} wkt
         * @param {?} wktProj
         * @param {?=} featureProj
         * @return {?}
         */
        WktService.prototype.wktToFeature = /**
         * @param {?} wkt
         * @param {?} wktProj
         * @param {?=} featureProj
         * @return {?}
         */
            function (wkt, wktProj, featureProj) {
                if (featureProj === void 0) {
                    featureProj = 'EPSG:3857';
                }
                return new olWKT().readFeature(wkt, {
                    dataProjection: wktProj,
                    featureProjection: featureProj
                });
            };
        /**
         * @param {?} epsgTO
         * @param {?} extent
         * @param {?} extentProj
         * @return {?}
         */
        WktService.prototype.extentToWkt = /**
         * @param {?} epsgTO
         * @param {?} extent
         * @param {?} extentProj
         * @return {?}
         */
            function (epsgTO, extent, extentProj) {
                /** @type {?} */
                var currentExtent = olproj.transformExtent(extent, extentProj, epsgTO);
                currentExtent = this.roundCoordinateArray(currentExtent, epsgTO, 0);
                /** @type {?} */
                var wktPoly = "POLYGON((\n      " + extent[0] + " " + extent[1] + ",\n      " + extent[0] + " " + extent[3] + ",\n      " + extent[2] + " " + extent[3] + ",\n      " + extent[2] + " " + extent[1] + ",\n      " + extent[0] + " " + extent[1] + "))";
                /** @type {?} */
                var wktLine = "LINESTRING(\n      " + extent[0] + " " + extent[1] + ",\n      " + extent[0] + " " + extent[3] + ",\n      " + extent[2] + " " + extent[3] + ",\n      " + extent[2] + " " + extent[1] + ",\n      " + extent[0] + " " + extent[1] + ")";
                /** @type {?} */
                var wktMultiPoints = "MULTIPOINT(\n        " + extent[0] + " " + extent[1] + ",\n        " + extent[0] + " " + extent[3] + ",\n        " + extent[2] + " " + extent[3] + ",\n        " + extent[2] + " " + extent[1] + ")";
                return {
                    wktPoly: wktPoly,
                    wktLine: wktLine,
                    wktMultiPoints: wktMultiPoints
                };
            };
        /**
         * @private
         * @param {?} coordinateArray
         * @param {?} projection
         * @param {?=} decimal
         * @return {?}
         */
        WktService.prototype.roundCoordinateArray = /**
         * @private
         * @param {?} coordinateArray
         * @param {?} projection
         * @param {?=} decimal
         * @return {?}
         */
            function (coordinateArray, projection, decimal) {
                if (decimal === void 0) {
                    decimal = 0;
                }
                /** @type {?} */
                var lproj = olproj.get(projection);
                /** @type {?} */
                var units = lproj.getUnits();
                /** @type {?} */
                var olUnits = ['ft', 'm', 'us-ft'];
                if (olUnits.indexOf(units) !== -1) {
                    coordinateArray = this.roundArray(coordinateArray, decimal);
                }
                return coordinateArray;
            };
        /**
         * @private
         * @param {?} array
         * @param {?=} decimal
         * @return {?}
         */
        WktService.prototype.roundArray = /**
         * @private
         * @param {?} array
         * @param {?=} decimal
         * @return {?}
         */
            function (array, decimal) {
                if (decimal === void 0) {
                    decimal = 0;
                }
                /** @type {?} */
                var x = 0;
                while (x < array.length) {
                    array[x] = array[x].toFixed(decimal);
                    x++;
                }
                return array;
            };
        /**
         * @param {?} snrc
         * @param {?=} epsgTO
         * @return {?}
         */
        WktService.prototype.snrcToWkt = /**
         * @param {?} snrc
         * @param {?=} epsgTO
         * @return {?}
         */
            function (snrc, epsgTO) {
                if (epsgTO === void 0) {
                    epsgTO = 'EPSG:3857';
                }
                snrc = snrc.toLowerCase();
                /** @type {?} */
                var wktPoly;
                /** @type {?} */
                var ew = {
                    1: { from: -56, to: -64 },
                    2: { from: -64, to: -72 },
                    3: { from: -72, to: -80 },
                    4: { from: -80, to: -88 },
                    5: { from: -88, to: -96 },
                    6: { from: -96, to: -104 },
                    7: { from: -104, to: -112 },
                    8: { from: -112, to: -120 },
                    9: { from: -120, to: -128 },
                    10: { from: -128, to: -136 }
                };
                /** @type {?} */
                var sn = {
                    1: { from: 44, to: 48 },
                    2: { from: 48, to: 52 },
                    3: { from: 52, to: 56 },
                    4: { from: 56, to: 60 },
                    5: { from: 60, to: 64 },
                    6: { from: 64, to: 68 },
                    7: { from: 68, to: 72 },
                    8: { from: 72, to: 76 },
                    9: { from: 76, to: -128 }
                };
                /** @type {?} */
                var snrc250kIndex = [
                    ['m', 'n', 'o', 'p'],
                    ['l', 'k', 'j', 'i'],
                    ['e', 'f', 'g', 'h'],
                    ['d', 'c', 'b', 'a']
                ];
                /** @type {?} */
                var snrc50kIndex = [
                    ['13', '14', '15', '16'],
                    ['12', '11', '10', '09'],
                    ['05', '06', '07', '08'],
                    ['04', '03', '02', '01']
                ];
                /** @type {?} */
                var checkSNRC50k = /\d{2,3}[a-p][0,1][0-9]/gi;
                /** @type {?} */
                var checkSNRC250k = /\d{2,3}[a-p]/gi;
                /** @type {?} */
                var checkSNRC1m = /\d{2,3}/gi;
                /** @type {?} */
                var snrc1m = false;
                /** @type {?} */
                var snrc250k = false;
                /** @type {?} */
                var snrc50k = false;
                if (checkSNRC50k.test(snrc)) {
                    snrc50k = true;
                }
                else {
                    if (checkSNRC250k.test(snrc)) {
                        snrc250k = true;
                    }
                    else {
                        if (checkSNRC1m.test(snrc)) {
                            snrc1m = true;
                        }
                    }
                }
                if (snrc1m) {
                    snrc += 'a01';
                }
                else if (snrc250k) {
                    snrc += '01';
                }
                if (/\d{2,3}[a-p][0,1][0-9]/gi.test(snrc)) {
                    /** @type {?} */
                    var regex1m = /(?=[a-p])/gi;
                    /** @type {?} */
                    var ar1m = snrc.split(regex1m);
                    /** @type {?} */
                    var part1m = ar1m[0];
                    /** @type {?} */
                    var part250k_1 = ar1m[1][0];
                    /** @type {?} */
                    var part50k_1 = ar1m[1].split(part250k_1)[1];
                    /** @type {?} */
                    var separator = 1;
                    if (part1m.length === 3) {
                        separator = 2;
                    }
                    /** @type {?} */
                    var partEW = part1m.substring(0, separator);
                    /** @type {?} */
                    var partSN = part1m.substring(separator);
                    /** @type {?} */
                    var unit1mEW = 8;
                    /** @type {?} */
                    var unit1mSN = 4;
                    /** @type {?} */
                    var unit250kEW = 2;
                    /** @type {?} */
                    var unit250kSN = 1;
                    /** @type {?} */
                    var unit50kEW = 0.5;
                    /** @type {?} */
                    var unit50kSN = 0.25;
                    /** @type {?} */
                    var index250kEW_1 = 0;
                    /** @type {?} */
                    var index250kSN_1 = 0;
                    /** @type {?} */
                    var index50kEW_1 = 0;
                    /** @type {?} */
                    var index50kSN_1 = 0;
                    snrc250kIndex.forEach(( /**
                     * @param {?} element
                     * @return {?}
                     */function (element) {
                        if (element.indexOf(part250k_1) !== -1) {
                            index250kSN_1 = snrc250kIndex.indexOf(element);
                            index250kEW_1 = element.indexOf(part250k_1);
                        }
                    }));
                    snrc50kIndex.forEach(( /**
                     * @param {?} element
                     * @return {?}
                     */function (element) {
                        if (element.indexOf(part50k_1) !== -1) {
                            index50kSN_1 = snrc50kIndex.indexOf(element);
                            index50kEW_1 = element.indexOf(part50k_1);
                        }
                    }));
                    /** @type {?} */
                    var increment250kEW = 0;
                    /** @type {?} */
                    var increment250kSN = 0;
                    /** @type {?} */
                    var increment50kEW = 0;
                    /** @type {?} */
                    var increment50kSN = 0;
                    /** @type {?} */
                    var unitPerTypeEW = unit1mEW;
                    /** @type {?} */
                    var unitPerTypeSN = unit1mSN;
                    if (snrc250k) {
                        increment250kEW = index250kEW_1 * unit250kEW;
                        increment250kSN = index250kSN_1 * unit250kSN;
                        increment50kEW = 0;
                        increment50kSN = 0;
                        unitPerTypeEW = unit250kEW;
                        unitPerTypeSN = unit250kSN;
                    }
                    else if (snrc50k) {
                        increment250kEW = index250kEW_1 * unit250kEW;
                        increment250kSN = index250kSN_1 * unit250kSN;
                        increment50kEW = index50kEW_1 * unit50kEW;
                        increment50kSN = index50kSN_1 * unit50kSN;
                        unitPerTypeEW = unit50kEW;
                        unitPerTypeSN = unit50kSN;
                    }
                    /** @type {?} */
                    var coord = {
                        ul: [
                            ew[partEW].to + increment250kEW + increment50kEW,
                            sn[partSN].to - increment250kSN - increment50kSN
                        ]
                    };
                    coord.lr = [
                        coord.ul[0] + unitPerTypeEW,
                        coord.ul[1] - unitPerTypeSN
                    ];
                    coord.ur = [coord.ul[0], coord.ul[1] - unitPerTypeSN];
                    coord.ll = [coord.ul[0] + unitPerTypeEW, coord.ul[1]];
                    coord.ul = olproj.transform([coord.ul[0], coord.ul[1]], 'EPSG:4326', epsgTO);
                    coord.lr = olproj.transform([coord.lr[0], coord.lr[1]], 'EPSG:4326', epsgTO);
                    coord.ur = olproj.transform([coord.ur[0], coord.ur[1]], 'EPSG:4326', epsgTO);
                    coord.ll = olproj.transform([coord.ll[0], coord.ll[1]], 'EPSG:4326', epsgTO);
                    // Rounded coordinate to shorten url in get
                    coord.ul = this.roundCoordinateArray(coord.ul, epsgTO, 0);
                    coord.lr = this.roundCoordinateArray(coord.lr, epsgTO, 0);
                    coord.ur = this.roundCoordinateArray(coord.ur, epsgTO, 0);
                    coord.ll = this.roundCoordinateArray(coord.ll, epsgTO, 0);
                    wktPoly =
                        'POLYGON((' +
                            [
                                coord.ul.join(' '),
                                coord.ur.join(' '),
                                coord.lr.join(' '),
                                coord.ll.join(' '),
                                coord.ul.join(' ')
                            ].join(',') +
                            '))';
                    /** @type {?} */
                    var wktLine = 'LINESTRING(' +
                        [
                            coord.ul.join(' '),
                            coord.ur.join(' '),
                            coord.lr.join(' '),
                            coord.ll.join(' '),
                            coord.ul.join(' ')
                        ].join(',') +
                        ')';
                    /** @type {?} */
                    var wktMultiPoints = 'MULTIPOINT(' +
                        [
                            coord.ul.join(' '),
                            coord.ur.join(' '),
                            coord.lr.join(' '),
                            coord.ll.join(' ')
                        ].join(',') +
                        ')';
                    return {
                        wktPoly: wktPoly,
                        wktLine: wktLine,
                        wktMultiPoints: wktMultiPoints
                    };
                }
            };
        WktService.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        WktService.ctorParameters = function () { return []; };
        /** @nocollapse */ WktService.ngInjectableDef = i0.defineInjectable({ factory: function WktService_Factory() { return new WktService(); }, token: WktService, providedIn: "root" });
        return WktService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var OgcFilterFormComponent = /** @class */ (function () {
        function OgcFilterFormComponent(wktService) {
            this.wktService = wktService;
            this.value = '';
            this.color = 'primary';
            this.snrc = '';
            this.baseOverlayName = 'ogcFilterOverlay_';
            // TODO: Filter permitted operator based on wfscapabilities
            // Need to work on regex on XML capabilities because
            // comaparison operator's name varies between WFS servers...
            // Ex: IsNull vs PropertyIsNull vs IsNil ...
            this.ogcFilterOperators = new OgcFilterWriter().operators;
            this.igoSpatialSelectors = [
                {
                    type: 'fixedExtent'
                },
                {
                    type: 'snrc'
                }
            ];
            // TODO: selectFeature & drawFeature
        }
        Object.defineProperty(OgcFilterFormComponent.prototype, "activeFilters", {
            get: /**
             * @return {?}
             */ function () {
                this.updateField();
                return this.datasource.options.ogcFilters.interfaceOgcFilters.filter(( /**
                 * @param {?} f
                 * @return {?}
                 */function (f) { return f.active === true; }));
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        OgcFilterFormComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.computeAllowedOperators();
            };
        /**
         * @return {?}
         */
        OgcFilterFormComponent.prototype.computeAllowedOperators = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var allowedOperators = this.datasource.options.ogcFilters.allowedOperatorsType;
                /** @type {?} */
                var effectiveOperators = {};
                if (!allowedOperators) {
                    allowedOperators = OgcFilterOperatorType.BasicAndSpatial;
                }
                switch (allowedOperators.toLowerCase()) {
                    case 'all':
                        effectiveOperators = this.ogcFilterOperators;
                        break;
                    case 'spatial':
                        effectiveOperators = {
                            Intersects: { spatial: true, fieldRestrict: [] },
                            Within: { spatial: true, fieldRestrict: [] },
                        };
                        break;
                    case 'basicandspatial':
                        effectiveOperators = {
                            PropertyIsEqualTo: { spatial: false, fieldRestrict: [] },
                            PropertyIsNotEqualTo: { spatial: false, fieldRestrict: [] },
                            Intersects: { spatial: true, fieldRestrict: [] },
                            Within: { spatial: true, fieldRestrict: [] },
                        };
                        break;
                    case 'basic':
                        effectiveOperators = {
                            PropertyIsEqualTo: { spatial: false, fieldRestrict: [] },
                            PropertyIsNotEqualTo: { spatial: false, fieldRestrict: [] }
                        };
                        break;
                    case 'basicnumeric':
                        effectiveOperators = {
                            PropertyIsEqualTo: { spatial: false, fieldRestrict: [] },
                            PropertyIsNotEqualTo: { spatial: false, fieldRestrict: [] },
                            PropertyIsGreaterThan: { spatial: false, fieldRestrict: ['number'] },
                            PropertyIsGreaterThanOrEqualTo: { spatial: false, fieldRestrict: ['number'] },
                            PropertyIsLessThan: { spatial: false, fieldRestrict: ['number'] },
                            PropertyIsLessThanOrEqualTo: { spatial: false, fieldRestrict: ['number'] },
                        };
                        break;
                    default:
                        effectiveOperators = {
                            PropertyIsEqualTo: { spatial: false, fieldRestrict: [] },
                            PropertyIsNotEqualTo: { spatial: false, fieldRestrict: [] },
                            Intersects: { spatial: true, fieldRestrict: [] },
                            Within: { spatial: true, fieldRestrict: [] },
                        };
                }
                this.ogcFilterOperators = effectiveOperators;
            };
        /**
         * @return {?}
         */
        OgcFilterFormComponent.prototype.updateField = /**
         * @return {?}
         */
            function () {
                var _this = this;
                if (!this.datasource.options.sourceFields) {
                    return;
                }
                this.fields = this.datasource.options.sourceFields
                    .filter(( /**
             * @param {?} sf
             * @return {?}
             */function (sf) { return (sf.excludeFromOgcFilters === undefined || !sf.excludeFromOgcFilters); }));
                this.fields.filter(( /**
                 * @param {?} f
                 * @return {?}
                 */function (f) { return f.name === _this.currentFilter.propertyName; }))
                    .forEach(( /**
             * @param {?} element
             * @return {?}
             */function (element) {
                    _this.values = element.values !== undefined ? element.values.sort() : [];
                }));
            };
        /**
         * @param {?} event
         * @param {?} filter
         * @param {?} property
         * @return {?}
         */
        OgcFilterFormComponent.prototype.toggleFilterState = /**
         * @param {?} event
         * @param {?} filter
         * @param {?} property
         * @return {?}
         */
            function (event, filter, property) {
                this.updateField();
                if (event.checked) {
                    this.datasource.options.ogcFilters.interfaceOgcFilters
                        .filter(( /**
                 * @param {?} f
                 * @return {?}
                 */function (f) { return f.filterid === filter.filterid; }))
                        .forEach(( /**
                 * @param {?} element
                 * @return {?}
                 */function (element) {
                        element[property] = true;
                    }));
                }
                else {
                    this.removeOverlayByID(filter.filterid);
                    this.datasource.options.ogcFilters.interfaceOgcFilters
                        .filter(( /**
                 * @param {?} f
                 * @return {?}
                 */function (f) { return f.filterid === filter.filterid; }))
                        .forEach(( /**
                 * @param {?} element
                 * @return {?}
                 */function (element) {
                        element[property] = false;
                    }));
                }
                this.refreshFilters();
            };
        /**
         * @param {?} filter
         * @return {?}
         */
        OgcFilterFormComponent.prototype.deleteFilter = /**
         * @param {?} filter
         * @return {?}
         */
            function (filter) {
                /** @type {?} */
                var ogcFilters = this.datasource.options.ogcFilters;
                ogcFilters.interfaceOgcFilters = ogcFilters.interfaceOgcFilters.filter(( /**
                 * @param {?} f
                 * @return {?}
                 */function (f) { return f.filterid !== filter.filterid; }));
                this.removeOverlayByID(filter.filterid);
                this.refreshFilters();
            };
        /**
         * @param {?} filter
         * @param {?} property
         * @param {?} value
         * @return {?}
         */
        OgcFilterFormComponent.prototype.changeNumericProperty = /**
         * @param {?} filter
         * @param {?} property
         * @param {?} value
         * @return {?}
         */
            function (filter, property, value) {
                this.changeProperty(filter, property, parseFloat(value));
                this.refreshFilters();
            };
        /**
         * @private
         * @param {?} id
         * @return {?}
         */
        OgcFilterFormComponent.prototype.removeOverlayByID = /**
         * @private
         * @param {?} id
         * @return {?}
         */
            function (id) {
                /** @type {?} */
                var overlayId = this.baseOverlayName + id;
                if (this.map.overlay.dataSource.ol.getFeatureById(overlayId)) {
                    this.map.overlay.dataSource.ol.removeFeature(this.map.overlay.dataSource.ol.getFeatureById(overlayId));
                }
            };
        /**
         * @param {?} filter
         * @return {?}
         */
        OgcFilterFormComponent.prototype.changeOperator = /**
         * @param {?} filter
         * @return {?}
         */
            function (filter) {
                if (this.ogcFilterOperators[filter.operator].spatial === false) {
                    this.removeOverlayByID(filter.filterid);
                }
                this.refreshFilters();
            };
        /**
         * @param {?} filter
         * @param {?} property
         * @param {?} value
         * @return {?}
         */
        OgcFilterFormComponent.prototype.changeProperty = /**
         * @param {?} filter
         * @param {?} property
         * @param {?} value
         * @return {?}
         */
            function (filter, property, value) {
                this.datasource.options.ogcFilters.interfaceOgcFilters
                    .filter(( /**
             * @param {?} f
             * @return {?}
             */function (f) { return f.filterid === filter.filterid; }))
                    .forEach(( /**
             * @param {?} element
             * @return {?}
             */function (element) {
                    element[property] = value;
                }));
                this.refreshFilters();
            };
        /**
         * @param {?} filter
         * @param {?=} value
         * @return {?}
         */
        OgcFilterFormComponent.prototype.changeGeometry = /**
         * @param {?} filter
         * @param {?=} value
         * @return {?}
         */
            function (filter, value) {
                var _this = this;
                /** @type {?} */
                var checkSNRC50k = /\d{2,3}[a-l][0,1][0-9]/gi;
                /** @type {?} */
                var checkSNRC250k = /\d{2,3}[a-p]/gi;
                /** @type {?} */
                var checkSNRC1m = /\d{2,3}/gi;
                /** @type {?} */
                var mapProjection = this.map.projection;
                this.removeOverlayByID(filter.filterid);
                this.datasource.options.ogcFilters.interfaceOgcFilters
                    .filter(( /**
             * @param {?} f
             * @return {?}
             */function (f) { return f.filterid === filter.filterid; }))
                    .forEach(( /**
             * @param {?} element
             * @return {?}
             */function (element) {
                    /** @type {?} */
                    var wktPoly;
                    if (filter.igoSpatialSelector === 'snrc') {
                        if (value === '' && _this.snrc !== '') {
                            wktPoly = _this.wktService.snrcToWkt(_this.snrc).wktPoly;
                            element.wkt_geometry = wktPoly;
                        }
                        else if (value !== '' &&
                            (checkSNRC1m.test(value) ||
                                checkSNRC250k.test(value) ||
                                checkSNRC50k.test(value))) {
                            wktPoly = _this.wktService.snrcToWkt(value).wktPoly;
                            element.wkt_geometry = wktPoly;
                        }
                    }
                    else if (filter.igoSpatialSelector === 'fixedExtent') {
                        wktPoly = _this.wktService.extentToWkt(mapProjection, _this.map.getExtent(), mapProjection).wktPoly;
                        element.wkt_geometry = wktPoly;
                    }
                }));
                this.refreshFilters();
            };
        OgcFilterFormComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'igo-ogc-filter-form',
                        template: "<mat-list-item>\r\n\r\n  <div class=\"igo-col igo-col-90 igo-col-100-m\">\r\n    <mat-select class=\"logical\" [disabled]=\"!currentFilter.active\" (selectionChange)=\"refreshFilters()\" [(ngModel)]=\"currentFilter.parentLogical\"\r\n      *ngIf=\"activeFilters.indexOf(currentFilter) !== 0 && currentFilter.active===true\">\r\n      <mat-option value=\"And\">{{'igo.geo.operators.And' | translate}}</mat-option>\r\n      <mat-option value=\"Or\">{{'igo.geo.operators.Or' | translate}}</mat-option>\r\n    </mat-select>\r\n  </div>\r\n  <!-- NON SPATIAL -->\r\n  <div class=\"igo-col igo-col-90 igo-col-100-m\" *ngIf=\"(currentFilter.operator !== 'Intersects' && currentFilter.operator !== 'Contains' && currentFilter.operator !== 'Within')\">\r\n    <span *ngIf=\"fields && fields.length > 0 && fields[0].name !== ''\">\r\n      <mat-select [disabled]=\"!currentFilter.active\" *ngIf=\"['Contains','Intersects','Within'].indexOf(currentFilter.operator) === -1\"\r\n        [(ngModel)]=\"currentFilter.propertyName\" tooltip-position=\"below\" matTooltipShowDelay=\"500\" [matTooltip]=\"'igo.geo.sourceFields.selectField' | translate\"\r\n        (selectionChange)=\"updateField()\">\r\n        <mat-option *ngFor=\"let field of fields\" [value]=\"field.name\">{{field.alias}}</mat-option>\r\n      </mat-select>\r\n    </span>\r\n    <span *ngIf=\"fields && fields.length === 1 && fields[0].name === ''\">\r\n      <mat-form-field>\r\n        <input [disabled]=\"!currentFilter.active\" matInput #fieldPerUser (keyup)=\"changeProperty(currentFilter,'propertyName',fieldPerUser.value)\"\r\n          (blur)=\"changeProperty(currentFilter,'propertyName',fieldPerUser.value)\" [(ngModel)]=\"currentFilter.propertyName\">\r\n\r\n        <button mat-button *ngIf=\"currentFilter.propertyName\" matSuffix mat-icon-button aria-label=\"Clear\" (click)=\"currentFilter.propertyName=''\">\r\n          <mat-icon svgIcon=\"close\"></mat-icon>\r\n        </button>\r\n      </mat-form-field>\r\n\r\n    </span>\r\n  </div>\r\n\r\n  <div class=\"igo-col igo-col-90 igo-col-100-m\" *ngIf=\"(currentFilter.operator !== 'Intersects' && currentFilter.operator !== 'Contains' && currentFilter.operator !== 'Within')\">\r\n    <mat-select [disabled]=\"!currentFilter.active\" [(ngModel)]=\"currentFilter.operator\" (selectionChange)=\"changeOperator(currentFilter)\">\r\n      <mat-option *ngFor=\"let operator of ogcFilterOperators | keyvalue\" [value]=\"operator.key\">{{('igo.geo.operators.'+ operator.key) | translate}}</mat-option>\r\n    </mat-select>\r\n  </div>\r\n\r\n  <div class=\"igo-col igo-col-90 igo-col-100-m\" *ngIf=\"(currentFilter.operator !== 'Intersects' && currentFilter.operator !== 'Contains' && currentFilter.operator !== 'Within')\">\r\n\r\n    <!-- PropertyIsEqualTo -->\r\n    <span *ngIf=\"currentFilter.operator === 'PropertyIsEqualTo' || currentFilter.operator === 'PropertyIsNotEqualTo'\">\r\n      <mat-form-field>\r\n        <input [disabled]=\"!currentFilter.active\" matInput [matAutocomplete]=\"auto\" #expressionequalto (keyup)=\"changeProperty(currentFilter,'expression',expressionequalto.value)\"\r\n          (ngModelChange)=\"changeProperty(currentFilter,'expression',expressionequalto.value)\" [ngModel]=\"currentFilter.expression\">\r\n        <mat-autocomplete #auto=\"matAutocomplete\">\r\n          <mat-option *ngFor=\"let value of values\" [value]=\"value\">\r\n            <span>{{ value }}</span>\r\n          </mat-option>\r\n        </mat-autocomplete>\r\n        <button mat-button *ngIf=\"currentFilter.expression\" matSuffix mat-icon-button aria-label=\"Clear\" (click)=\"currentFilter.expression=''\">\r\n          <mat-icon svgIcon=\"close\"></mat-icon>\r\n        </button>\r\n      </mat-form-field>\r\n\r\n    </span>\r\n    <!-- PropertyIsEqualTo  -->\r\n\r\n\r\n    <!-- PropertyIsLike  -->\r\n    <span *ngIf=\"currentFilter.operator === 'PropertyIsLike'\">\r\n      <mat-form-field>\r\n        <input [disabled]=\"!currentFilter.active\" matInput [matAutocomplete]=\"auto\" #pattern (keyup)=\"changeProperty(currentFilter,'pattern',pattern.value)\"\r\n          (ngModelChange)=\"changeProperty(currentFilter,'pattern',pattern.value)\" [ngModel]=\"currentFilter.pattern\">\r\n        <mat-autocomplete #auto=\"matAutocomplete\">\r\n          <mat-option *ngFor=\"let value of values\" [value]=\"value\">\r\n            <span>{{ value }}</span>\r\n          </mat-option>\r\n        </mat-autocomplete>\r\n        <button mat-button *ngIf=\"currentFilter.pattern\" matSuffix mat-icon-button aria-label=\"Clear\" (click)=\"currentFilter.pattern=''\">\r\n          <mat-icon svgIcon=\"close\"></mat-icon>\r\n        </button>\r\n      </mat-form-field>\r\n\r\n    </span>\r\n    <!-- PropertyIsLike  -->\r\n\r\n    <!-- PropertyIsNull  -->\r\n    <span *ngIf=\"currentFilter.operator === 'PropertyIsNull'\"></span>\r\n    <!-- PropertyIsNull  -->\r\n\r\n    <!-- PropertyIs_Than  -->\r\n    <span *ngIf=\"currentFilter.operator === 'PropertyIsGreaterThan' || currentFilter.operator === 'PropertyIsGreaterThanOrEqualTo' || currentFilter.operator === 'PropertyIsLessThan' || currentFilter.operator === 'PropertyIsLessThanOrEqualTo'\">\r\n      <mat-form-field>\r\n        <input [disabled]=\"!currentFilter.active\" matInput [matAutocomplete]=\"auto\" #expressionthan type=\"number\" (keyup)=\"changeNumericProperty(currentFilter,'expression',expressionthan.value)\"\r\n          (ngModelChange)=\"changeNumericProperty(currentFilter,'expression',expressionthan.value)\" [ngModel]=\"currentFilter.expression\">\r\n        <mat-autocomplete #auto=\"matAutocomplete\">\r\n          <mat-option *ngFor=\"let value of values\" [value]=\"value\">\r\n            <span>{{ value }}</span>\r\n          </mat-option>\r\n        </mat-autocomplete>\r\n        <button mat-button *ngIf=\"currentFilter.expression\" matSuffix mat-icon-button aria-label=\"Clear\" (click)=\"currentFilter.expression=''\">\r\n          <mat-icon svgIcon=\"close\"></mat-icon>\r\n        </button>\r\n      </mat-form-field>\r\n    </span>\r\n    <!-- PropertyIs_Than  -->\r\n\r\n\r\n    <!-- PropertyIsBetween -->\r\n    <span *ngIf=\"currentFilter.operator === 'PropertyIsBetween'\">\r\n      <mat-form-field>\r\n        <input [disabled]=\"!currentFilter.active\" matInput [matAutocomplete]=\"auto\" #lowerBoundary type=\"number\" (keyup)=\"changeNumericProperty(currentFilter,'lowerBoundary',lowerBoundary.value)\"\r\n          (ngModelChange)=\"changeNumericProperty(currentFilter,'lowerBoundary',lowerBoundary.value)\" [ngModel]=\"currentFilter.lowerBoundary\">\r\n        <mat-autocomplete #auto=\"matAutocomplete\">\r\n          <mat-option *ngFor=\"let value of values\" [value]=\"value\">\r\n            <span>{{ value }}</span>\r\n          </mat-option>\r\n        </mat-autocomplete>\r\n        <button mat-button *ngIf=\"currentFilter.lowerBoundary\" matSuffix mat-icon-button aria-label=\"Clear\" (click)=\"currentFilter.lowerBoundary=''\">\r\n          <mat-icon svgIcon=\"close\"></mat-icon>\r\n        </button>\r\n      </mat-form-field>\r\n      <mat-form-field>\r\n        <input [disabled]=\"!currentFilter.active\" matInput [matAutocomplete]=\"auto\" #upperBoundary type=\"number\" (keyup)=\"changeNumericProperty(currentFilter,'upperBoundary',upperBoundary.value)\"\r\n          (ngModelChange)=\"changeNumericProperty(currentFilter,'upperBoundary',upperBoundary.value)\" [ngModel]=\"currentFilter.upperBoundary\">\r\n        <mat-autocomplete #auto=\"matAutocomplete\">\r\n          <mat-option *ngFor=\"let value of values\" [value]=\"value\">\r\n            <span>{{ value }}</span>\r\n          </mat-option>\r\n        </mat-autocomplete>\r\n        <button mat-button *ngIf=\"currentFilter.upperBoundary\" matSuffix mat-icon-button aria-label=\"Clear\" (click)=\"currentFilter.upperBoundary=''\">\r\n          <mat-icon svgIcon=\"close\"></mat-icon>\r\n        </button>\r\n      </mat-form-field>\r\n\r\n    </span>\r\n    <!-- PropertyIsBetween  -->\r\n\r\n\r\n    <!-- During -->\r\n    <span *ngIf=\"currentFilter.operator === 'During'\">\r\n      <mat-form-field>\r\n        <input [disabled]=\"!currentFilter.active\" matInput [matAutocomplete]=\"auto\" #begin (keyup)=\"changeProperty(currentFilter,'begin',begin.value)\"\r\n          (ngModelChange)=\"changeProperty(currentFilter,'begin',begin.value)\" [ngModel]=\"currentFilter.begin\">\r\n        <mat-autocomplete #auto=\"matAutocomplete\">\r\n          <mat-option *ngFor=\"let value of values \" [value]=\"value\">\r\n            <span>{{ value }}</span>\r\n          </mat-option>\r\n        </mat-autocomplete>\r\n        <button mat-button *ngIf=\"currentFilter.begin\" matSuffix mat-icon-button aria-label=\"Clear\" (click)=\"currentFilter.begin=''\">\r\n          <mat-icon svgIcon=\"close\"></mat-icon>\r\n        </button>\r\n      </mat-form-field>\r\n\r\n      <mat-form-field>\r\n        <input [disabled]=\"!currentFilter.active\" matInput [matAutocomplete]=\"auto\" #end (keyup)=\"changeProperty(currentFilter,'end',end.value)\"\r\n          (ngModelChange)=\"changeProperty(currentFilter,'end',end.value)\" [ngModel]=\"currentFilter.end\">\r\n        <mat-autocomplete #auto=\"matAutocomplete\">\r\n          <mat-option *ngFor=\"let value of values\" [value]=\"value\">\r\n            <span>{{ value }}</span>\r\n          </mat-option>\r\n        </mat-autocomplete>\r\n        <button mat-button *ngIf=\"currentFilter.end\" matSuffix mat-icon-button aria-label=\"Clear\" (click)=\"currentFilter.end=''\">\r\n          <mat-icon svgIcon=\"close\"></mat-icon>\r\n        </button>\r\n      </mat-form-field>\r\n\r\n\r\n    </span>\r\n    <!-- During  -->\r\n  </div>\r\n  <!-- NON SPATIAL -->\r\n\r\n\r\n  <!-- PropertySpatial  -->\r\n  <div class=\"igo-col igo-col-90 igo-col-100-m\" *ngIf=\"(currentFilter.operator === 'Intersects' || currentFilter.operator === 'Contains' || currentFilter.operator === 'Within')\">\r\n    <mat-select [disabled]=\"!currentFilter.active\" [(ngModel)]=\"currentFilter.operator\" (selectionChange)=\"changeOperator(currentFilter)\">\r\n      <mat-option *ngFor=\"let operator of ogcFilterOperators | keyvalue\" [value]=\"operator.key\">{{('igo.geo.operators.'+ operator.key) | translate}}</mat-option>\r\n    </mat-select>\r\n  </div>\r\n  <div class=\"igo-col igo-col-90 igo-col-100-m\" *ngIf=\"(currentFilter.operator === 'Intersects' || currentFilter.operator === 'Contains' || currentFilter.operator === 'Within')\">\r\n    <mat-select [disabled]=\"!currentFilter.active\" [(ngModel)]=\"currentFilter.igoSpatialSelector\" (selectionChange)=\"changeGeometry(currentFilter,value)\">\r\n      <mat-option *ngFor=\"let igoSpatialSelector of igoSpatialSelectors\" [value]=\"igoSpatialSelector.type\">{{('igo.geo.spatialSelector.'+ igoSpatialSelector.type) | translate}}</mat-option>\r\n    </mat-select>\r\n  </div>\r\n\r\n  <div class=\"igo-col igo-col-90 igo-col-100-m\" *ngIf=\"(currentFilter.operator === 'Intersects' || currentFilter.operator === 'Contains' || currentFilter.operator === 'Within')\">\r\n    <button mat-button [disabled]=\"!currentFilter.active\" *ngIf=\"currentFilter.igoSpatialSelector === 'fixedExtent'\"\r\n      matSuffix mat-icon-button aria-label=\"Clear\" (click)=\"changeGeometry(currentFilter,value)\" tooltip-position=\"below\" matTooltipShowDelay=\"500\"\r\n      [matTooltip]=\"'igo.geo.spatialSelector.btnSetExtent' | translate\">\r\n      <mat-icon svgIcon=\"arrow-expand-all\"></mat-icon>\r\n    </button>\r\n\r\n\r\n    <mat-form-field *ngIf=\"currentFilter.igoSpatialSelector === 'snrc'\">\r\n      <input matInput #htmlSnrc (keyup)=\"changeGeometry(currentFilter,htmlSnrc.value)\" (blur)=\"changeGeometry(currentFilter,htmlSnrc.value)\"\r\n        [(ngModel)]=\"snrc\">\r\n      <button mat-button *ngIf=\"snrc\" matSuffix mat-icon-button aria-label=\"Clear\" (click)=\"snrc=''\">\r\n        <mat-icon svgIcon=\"close\"></mat-icon>\r\n      </button>\r\n    </mat-form-field>\r\n  </div>\r\n  <!-- PropertySpatial  -->\r\n\r\n  <div class=\"igo-col igo-col-100 igo-col-100-m\">\r\n    <div class=\"igo-layer-button-group\">\r\n      <mat-slide-toggle class=\"example-margin\" (change)=\"toggleFilterState($event,currentFilter,'active')\" tooltip-position=\"below\"\r\n        matTooltipShowDelay=\"500\" [matTooltip]=\"'igo.geo.filter.toggleFilterState' | translate\" [color]=\"color\" [checked]=\"currentFilter.active\"\r\n        [disabled]=\"disabled\">\r\n      </mat-slide-toggle>\r\n      <button mat-icon-button tooltip-position=\"below\" matTooltipShowDelay=\"500\" [matTooltip]=\"'igo.geo.filter.removeFilter' | translate\"\r\n        color=\"warn\" (click)=\"deleteFilter(currentFilter)\">\r\n        <mat-icon svgIcon=\"delete\"></mat-icon>\r\n      </button>\r\n    </div>\r\n  </div>\r\n  <mat-divider></mat-divider>\r\n</mat-list-item>\r\n",
                        styles: [":host{overflow:hidden}.mat-list-item{height:auto}.mat-list-item>>>div.mat-list-item-content{display:inline-table}.logical{font-weight:700}input,mat-select{margin-top:10px;text-align:center}.igo-layer-actions-container{width:100%;display:inline-block}.igo-layer-actions-container>div{text-align:center}.igo-layer-button-group{float:center;padding:0 3px}@media only screen and (max-width:450px),only screen and (max-height:450px){.igo-layer-button-group{float:none}}mat-icon.disabled{color:rgba(0,0,0,.38)}"]
                    }] }
        ];
        /** @nocollapse */
        OgcFilterFormComponent.ctorParameters = function () {
            return [
                { type: WktService }
            ];
        };
        OgcFilterFormComponent.propDecorators = {
            refreshFilters: [{ type: i0.Input }],
            datasource: [{ type: i0.Input }],
            map: [{ type: i0.Input }],
            currentFilter: [{ type: i0.Input }]
        };
        return OgcFilterFormComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var OgcFilterableFormComponent = /** @class */ (function () {
        function OgcFilterableFormComponent() {
            this.color = 'primary';
        }
        Object.defineProperty(OgcFilterableFormComponent.prototype, "refreshFunc", {
            get: /**
             * @return {?}
             */ function () {
                return this.refreshFilters;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(OgcFilterableFormComponent.prototype, "advancedOgcFilters", {
            get: /**
             * @return {?}
             */ function () {
                if (this.datasource.options.ogcFilters) {
                    return this.datasource.options.ogcFilters.advancedOgcFilters;
                }
                return;
            },
            enumerable: true,
            configurable: true
        });
        OgcFilterableFormComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'igo-ogc-filterable-form',
                        template: "<igo-list *ngIf=\"!advancedOgcFilters\" [navigation]=\"false\" [selection]=\"true\">\r\n  <igo-ogc-filter-toggle-button igoListItem [datasource]=\"datasource\" [map]=\"map\" [refreshFilters]=\"refreshFunc\">\r\n  </igo-ogc-filter-toggle-button>\r\n</igo-list>\r\n\r\n<igo-list *ngIf=\"advancedOgcFilters\" [navigation]=\"false\" [selection]=\"true\">\r\n  <ng-template ngFor let-currentFilter [ngForOf]=\"this.datasource.options.ogcFilters.interfaceOgcFilters\">\r\n    <igo-ogc-filter-form igoListItem [color]=\"color\" [currentFilter]=\"currentFilter\" [datasource]=\"datasource\"\r\n      [map]=\"map\" [refreshFilters]=\"refreshFunc\">\r\n    </igo-ogc-filter-form>\r\n  </ng-template>\r\n</igo-list>\r\n"
                    }] }
        ];
        /** @nocollapse */
        OgcFilterableFormComponent.ctorParameters = function () { return []; };
        OgcFilterableFormComponent.propDecorators = {
            datasource: [{ type: i0.Input }],
            map: [{ type: i0.Input }],
            refreshFilters: [{ type: i0.Input }]
        };
        return OgcFilterableFormComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var OgcFilterableItemComponent = /** @class */ (function () {
        function OgcFilterableItemComponent(ogcFilterService, downloadService) {
            this.ogcFilterService = ogcFilterService;
            this.downloadService = downloadService;
            this.color = 'primary';
            this.defaultLogicalParent = 'And';
            this.hasActiveSpatialFilter = false;
            this.filtersAreEditable = true;
            this.filtersCollapsed = true;
            this.hasPushButton = false;
        }
        Object.defineProperty(OgcFilterableItemComponent.prototype, "refreshFunc", {
            get: /**
             * @return {?}
             */ function () {
                return this.refreshFilters.bind(this);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(OgcFilterableItemComponent.prototype, "datasource", {
            get: /**
             * @return {?}
             */ function () {
                return ( /** @type {?} */(this.layer.dataSource));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(OgcFilterableItemComponent.prototype, "downloadable", {
            get: /**
             * @return {?}
             */ function () {
                return (( /** @type {?} */(this.datasource.options))).download;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        OgcFilterableItemComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var ogcFilters = this.datasource.options.ogcFilters;
                if (ogcFilters.pushButtons &&
                    ogcFilters.pushButtons.length > 0) {
                    if (ogcFilters.advancedOgcFilters === undefined) {
                        ogcFilters.advancedOgcFilters = false;
                    }
                    this.hasPushButton = true;
                }
                switch (this.datasource.options.type) {
                    case 'wms':
                        this.ogcFilterService.setOgcWMSFiltersOptions(this.datasource);
                        break;
                    case 'wfs':
                        this.ogcFilterService.setOgcWFSFiltersOptions(this.datasource);
                        break;
                    default:
                        break;
                }
                if (ogcFilters) {
                    if (ogcFilters.interfaceOgcFilters) {
                        this.lastRunOgcFilter = JSON.parse(JSON.stringify(ogcFilters.interfaceOgcFilters));
                        if (ogcFilters.interfaceOgcFilters.filter(( /**
                         * @param {?} f
                         * @return {?}
                         */function (f) { return f.wkt_geometry; })).length >= 1) {
                            this.hasActiveSpatialFilter = true;
                        }
                    }
                    this.filtersAreEditable = ogcFilters.editable
                        ? ogcFilters.editable
                        : false;
                }
            };
        /**
         * @return {?}
         */
        OgcFilterableItemComponent.prototype.addFilterToSequence = /**
         * @return {?}
         */
            function () {
                this.filtersCollapsed = false;
                /** @type {?} */
                var interfaceOgcFilters = this.datasource.options.ogcFilters.interfaceOgcFilters;
                /** @type {?} */
                var arr = interfaceOgcFilters || [];
                /** @type {?} */
                var lastLevel = arr.length === 0 ? 0 : arr[arr.length - 1].level;
                /** @type {?} */
                var firstFieldName = '';
                if (this.datasource.options.sourceFields.length > 0) {
                    firstFieldName =
                        this.datasource.options.sourceFields[0].name === undefined
                            ? ''
                            : this.datasource.options.sourceFields[0].name;
                }
                /** @type {?} */
                var fieldNameGeometry;
                /** @type {?} */
                var datasourceOptions = ( /** @type {?} */(this.datasource
                    .options));
                if (datasourceOptions.fieldNameGeometry) {
                    fieldNameGeometry = datasourceOptions.fieldNameGeometry;
                }
                else if ((( /** @type {?} */(this.datasource.options))).paramsWFS &&
                    (( /** @type {?} */(this.datasource.options))).paramsWFS.fieldNameGeometry) {
                    fieldNameGeometry = (( /** @type {?} */(this.datasource.options))).paramsWFS
                        .fieldNameGeometry;
                }
                /** @type {?} */
                var status = arr.length === 0 ? true : false;
                arr.push(new OgcFilterWriter().addInterfaceFilter(( /** @type {?} */({
                    propertyName: firstFieldName,
                    operator: 'PropertyIsEqualTo',
                    active: status,
                    igoSpatialSelector: 'fixedExtent'
                })), fieldNameGeometry, lastLevel, this.defaultLogicalParent));
                this.datasource.options.ogcFilters.interfaceOgcFilters = arr;
            };
        /**
         * @return {?}
         */
        OgcFilterableItemComponent.prototype.openDownload = /**
         * @return {?}
         */
            function () {
                this.downloadService.open(this.layer);
            };
        /**
         * @param {?=} force
         * @return {?}
         */
        OgcFilterableItemComponent.prototype.refreshFilters = /**
         * @param {?=} force
         * @return {?}
         */
            function (force) {
                if (force === true) {
                    this.lastRunOgcFilter = undefined;
                }
                /** @type {?} */
                var ogcFilters = this.datasource.options.ogcFilters;
                /** @type {?} */
                var ogcFilterWriter = new OgcFilterWriter();
                /** @type {?} */
                var activeFilters = ogcFilters.interfaceOgcFilters.filter(( /**
                 * @param {?} f
                 * @return {?}
                 */function (f) { return f.active === true; }));
                if (activeFilters.length === 0) {
                    ogcFilters.filters = undefined;
                    ogcFilters.filtered = false;
                }
                if (activeFilters.length > 1) {
                    activeFilters[0].parentLogical = activeFilters[1].parentLogical;
                }
                if (activeFilters.filter(( /**
                 * @param {?} af
                 * @return {?}
                 */function (af) { return ['Contains', 'Intersects', 'Within'].indexOf(af.operator) !== -1; })).length === 0) {
                    this.hasActiveSpatialFilter = false;
                }
                else {
                    this.hasActiveSpatialFilter = true;
                }
                if (!(JSON.stringify(this.lastRunOgcFilter) === JSON.stringify(activeFilters))) {
                    if (this.layer.dataSource.options.type === 'wfs') {
                        /** @type {?} */
                        var ogcDataSource = this.layer.dataSource;
                        /** @type {?} */
                        var ogcLayer = ogcDataSource.options.ogcFilters;
                        ogcLayer.filters = ogcFilterWriter.rebuiltIgoOgcFilterObjectFromSequence(activeFilters);
                        this.layer.dataSource.ol.clear();
                    }
                    else if (this.layer.dataSource.options.type === 'wms' &&
                        ogcFilters.enabled) {
                        /** @type {?} */
                        var rebuildFilter = '';
                        if (activeFilters.length >= 1) {
                            /** @type {?} */
                            var ogcDataSource = this.layer.dataSource;
                            /** @type {?} */
                            var ogcLayer = ogcDataSource.options.ogcFilters;
                            ogcLayer.filters = ogcFilterWriter.rebuiltIgoOgcFilterObjectFromSequence(activeFilters);
                            rebuildFilter = ogcFilterWriter.buildFilter(ogcLayer.filters, undefined, undefined, (( /** @type {?} */(this.layer.dataSource.options))).fieldNameGeometry);
                        }
                        this.ogcFilterService.filterByOgc(( /** @type {?} */(this.datasource)), rebuildFilter);
                        this.datasource.options.ogcFilters.filtered =
                            activeFilters.length === 0 ? false : true;
                    }
                    this.lastRunOgcFilter = JSON.parse(JSON.stringify(activeFilters));
                }
            };
        /**
         * @return {?}
         */
        OgcFilterableItemComponent.prototype.setVisible = /**
         * @return {?}
         */
            function () {
                this.layer.visible = true;
            };
        /**
         * @return {?}
         */
        OgcFilterableItemComponent.prototype.isAdvancedOgcFilters = /**
         * @return {?}
         */
            function () {
                return this.datasource.options.ogcFilters.advancedOgcFilters;
            };
        /**
         * @return {?}
         */
        OgcFilterableItemComponent.prototype.addFilterDisabled = /**
         * @return {?}
         */
            function () {
                return (!this.datasource.options.sourceFields || this.datasource.options.sourceFields.length === 0);
            };
        /**
         * @private
         * @param {?} value
         * @return {?}
         */
        OgcFilterableItemComponent.prototype.changeOgcFiltersAdvancedOgcFilters = /**
         * @private
         * @param {?} value
         * @return {?}
         */
            function (value) {
                this.datasource.options.ogcFilters.advancedOgcFilters = value;
            };
        /**
         * @param {?} isAdvancedOgcFilters
         * @return {?}
         */
        OgcFilterableItemComponent.prototype.changeOgcFilterType = /**
         * @param {?} isAdvancedOgcFilters
         * @return {?}
         */
            function (isAdvancedOgcFilters) {
                this.changeOgcFiltersAdvancedOgcFilters(isAdvancedOgcFilters.checked);
                if (isAdvancedOgcFilters.checked) {
                    this.refreshFilters(true);
                }
            };
        OgcFilterableItemComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'igo-ogc-filterable-item',
                        template: "<span *ngIf=\"filtersAreEditable\">\r\n<mat-list-item>\r\n\r\n  <mat-icon *ngIf=\"ogcFiltersHeaderShown\" class=\"igo-chevron\" mat-list-avatar igoCollapse [target]=\"ogcFilters\" [collapsed]=\"filtersCollapsed\" svgIcon=\"chevron-up\">\r\n  </mat-icon>\r\n  <h4 *ngIf=\"ogcFiltersHeaderShown\" matLine [matTooltip]=\"layer.title\" matTooltipShowDelay=\"500\">{{layer.title}}</h4>\r\n  <h4 *ngIf=\"!ogcFiltersHeaderShown\" matLine></h4>\r\n\r\n  <span *ngIf=\"downloadable && ogcFiltersHeaderShown\">\r\n    <button mat-icon-button tooltip-position=\"below\" matTooltipShowDelay=\"500\" [matTooltip]=\"'igo.geo.download.action' | translate\"\r\n      [color]=\"color\" (click)=\"openDownload()\">\r\n      <mat-icon svgIcon=\"download\"></mat-icon>\r\n    </button>\r\n  </span>\r\n  <button *ngIf=\"isAdvancedOgcFilters()\" [disabled]=\"addFilterDisabled()\" mat-icon-button tooltip-position=\"below\" matTooltipShowDelay=\"500\"\r\n    [matTooltip]=\"'igo.geo.filter.addFilter' | translate\" [color]=\"color\" (click)=\"addFilterToSequence()\">\r\n    <mat-icon svgIcon=\"plus\"></mat-icon>\r\n  </button>\r\n</mat-list-item>\r\n\r\n<button *ngIf=\"!layer.visible && ogcFiltersHeaderShown\" mat-icon-button tooltip-position=\"below\" matTooltipShowDelay=\"500\" [matTooltip]=\"'igo.geo.layer.showLayer' | translate\"\r\ncolor=\"warn\" (click)=\"setVisible()\">\r\n<mat-icon svgIcon=\"error-outline\"></mat-icon>\r\n</button>\r\n\r\n<div #ogcFilters class=\"igo-datasource-filters-container\">\r\n  <igo-ogc-filterable-form [datasource]=\"datasource\" [map]=\"map\" [refreshFilters]=\"refreshFunc\">\r\n  </igo-ogc-filterable-form>\r\n\r\n  <mat-checkbox labelPosition='before' *ngIf=\"hasPushButton\" (change)=\"changeOgcFilterType($event)\"\r\n    [(ngModel)]=\"datasource.options.ogcFilters.advancedOgcFilters\">\r\n    {{'igo.geo.filter.advancedOgcFilters' | translate}}\r\n  </mat-checkbox>\r\n</div>\r\n</span>\r\n",
                        styles: [":host{overflow:hidden}.igo-datasource-filters-container{text-align:center;width:100%;display:inline-block}mat-icon.disabled{color:rgba(0,0,0,.38)}"]
                    }] }
        ];
        /** @nocollapse */
        OgcFilterableItemComponent.ctorParameters = function () {
            return [
                { type: OGCFilterService },
                { type: DownloadService }
            ];
        };
        OgcFilterableItemComponent.propDecorators = {
            layer: [{ type: i0.Input }],
            map: [{ type: i0.Input }],
            ogcFiltersHeaderShown: [{ type: i0.Input }]
        };
        return OgcFilterableItemComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var OgcFilterableListComponent = /** @class */ (function () {
        function OgcFilterableListComponent() {
        }
        OgcFilterableListComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'igo-ogc-filterable-list',
                        template: "<igo-list [navigation]=\"false\" [selection]=\"false\">\r\n  <ng-template ngFor let-layer [ngForOf]=\"layers | filterableDataSource: 'ogc'\">\r\n    <igo-ogc-filterable-item igoListItem [ogcFiltersHeaderShown]=\"true\" [layer]=\"layer\" \r\n    [map]=\"layer.map\" ></igo-ogc-filterable-item>\r\n  </ng-template>\r\n</igo-list>\r\n",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        OgcFilterableListComponent.ctorParameters = function () { return []; };
        OgcFilterableListComponent.propDecorators = {
            layers: [{ type: i0.Input }],
            map: [{ type: i0.Input }]
        };
        return OgcFilterableListComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var OgcFilterableListBindingDirective = /** @class */ (function () {
        function OgcFilterableListBindingDirective(component, mapService) {
            this.mapService = mapService;
            this.component = component;
        }
        /**
         * @return {?}
         */
        OgcFilterableListBindingDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // Override input layers
                this.component.layers = [];
                this.layers$$ = this.mapService.getMap().layers$.subscribe(( /**
                 * @param {?} layers
                 * @return {?}
                 */function (layers) {
                    _this.component.layers = layers;
                }));
            };
        /**
         * @return {?}
         */
        OgcFilterableListBindingDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.layers$$.unsubscribe();
            };
        OgcFilterableListBindingDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[igoOgcFilterableListBinding]'
                    },] }
        ];
        /** @nocollapse */
        OgcFilterableListBindingDirective.ctorParameters = function () {
            return [
                { type: OgcFilterableListComponent, decorators: [{ type: i0.Self }] },
                { type: MapService }
            ];
        };
        return OgcFilterableListBindingDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var OgcFilterButtonComponent = /** @class */ (function () {
        function OgcFilterButtonComponent() {
            this.color = 'primary';
            this.ogcFilterCollapse = false;
        }
        Object.defineProperty(OgcFilterButtonComponent.prototype, "options", {
            get: /**
             * @return {?}
             */ function () {
                if (!this.layer) {
                    return;
                }
                return this.layer.dataSource.options;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        OgcFilterButtonComponent.prototype.toggleOgcFilter = /**
         * @return {?}
         */
            function () {
                if (this.layer.isInResolutionsRange) {
                    this.ogcFilterCollapse = !this.ogcFilterCollapse;
                }
            };
        OgcFilterButtonComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'igo-ogc-filter-button',
                        template: "<button *ngIf=\"ogcFiltersInLayers && options.ogcFilters && (options.ogcFilters.enabled\r\n&& options.ogcFilters.editable)\"\r\n  mat-icon-button\r\n  collapsibleButton\r\n  tooltip-position=\"below\"\r\n  matTooltipShowDelay=\"500\"\r\n  [matTooltip]=\"'igo.geo.filter.filterBy' | translate\"\r\n  [color]=\"color\"\r\n  (click)=\"toggleOgcFilter()\">\r\n  <mat-icon\r\n    [ngClass]='{disabled: !layer.isInResolutionsRange}'svgIcon=\"filter\"></mat-icon>\r\n</button>\r\n\r\n<div #ogcFilter class=\"igo-layer-actions-container\"\r\n*ngIf=\"options.ogcFilters && (options.ogcFilters.enabled\r\n&& options.ogcFilters.editable)\">\r\n  <igo-ogc-filterable-item\r\n    *ngIf=\"ogcFilterCollapse && options.ogcFilters.enabled\"\r\n    igoListItem\r\n    [ogcFiltersHeaderShown]=\"false\"\r\n    [map]=\"layer.map\"\r\n    [layer]=\"layer\">\r\n  </igo-ogc-filterable-item>\r\n</div>\r\n",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        styles: [""]
                    }] }
        ];
        /** @nocollapse */
        OgcFilterButtonComponent.ctorParameters = function () { return []; };
        OgcFilterButtonComponent.propDecorators = {
            layer: [{ type: i0.Input }],
            map: [{ type: i0.Input }],
            color: [{ type: i0.Input }],
            ogcFiltersInLayers: [{ type: i0.Input }]
        };
        return OgcFilterButtonComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var OgcFilterToggleButtonComponent = /** @class */ (function () {
        function OgcFilterToggleButtonComponent(ogcFilterService) {
            this.ogcFilterService = ogcFilterService;
            this.color = 'primary';
            this.pushButtonBundle = [];
            this.ogcFilterWriter = new OgcFilterWriter();
        }
        /**
         * @return {?}
         */
        OgcFilterToggleButtonComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                if (this.datasource.options.ogcFilters &&
                    this.datasource.options.ogcFilters.pushButtons) {
                    this.pushButtonBundle = ( /** @type {?} */(this.datasource.options.ogcFilters.pushButtons));
                }
                this.applyFilters();
            };
        /**
         * @param {?} pb
         * @return {?}
         */
        OgcFilterToggleButtonComponent.prototype.getToolTip = /**
         * @param {?} pb
         * @return {?}
         */
            function (pb) {
                /** @type {?} */
                var tt;
                if (pb.tooltip) {
                    tt = pb.tooltip;
                }
                return tt || '';
            };
        /**
         * @param {?} pb
         * @return {?}
         */
        OgcFilterToggleButtonComponent.prototype.getButtonColor = /**
         * @param {?} pb
         * @return {?}
         */
            function (pb) {
                /** @type {?} */
                var styles;
                if (pb.color) {
                    styles = {
                        'background-color': pb.enabled ? "rgba(" + pb.color + ")" : "rgba(255,255,255,0)",
                    };
                }
                return styles;
            };
        /**
         * @param {?} bundle
         * @return {?}
         */
        OgcFilterToggleButtonComponent.prototype.bundleIsVertical = /**
         * @param {?} bundle
         * @return {?}
         */
            function (bundle) {
                return bundle.vertical ? bundle.vertical : false;
            };
        /**
         * @param {?=} currentOgcPushButton
         * @return {?}
         */
        OgcFilterToggleButtonComponent.prototype.applyFilters = /**
         * @param {?=} currentOgcPushButton
         * @return {?}
         */
            function (currentOgcPushButton) {
                if (currentOgcPushButton) {
                    currentOgcPushButton.enabled = !currentOgcPushButton.enabled;
                }
                /** @type {?} */
                var filterQueryString = '';
                /** @type {?} */
                var conditions = [];
                this.pushButtonBundle.map(( /**
                 * @param {?} buttonBundle
                 * @return {?}
                 */function (buttonBundle) {
                    /** @type {?} */
                    var bundleCondition = [];
                    buttonBundle.ogcPushButtons
                        .filter(( /**
                 * @param {?} ogcpb
                 * @return {?}
                 */function (ogcpb) { return ogcpb.enabled === true; }))
                        .forEach(( /**
                 * @param {?} enabledPb
                 * @return {?}
                 */function (enabledPb) { return bundleCondition.push(enabledPb.filters); }));
                    if (bundleCondition.length >= 1) {
                        if (bundleCondition.length === 1) {
                            conditions.push(bundleCondition[0]);
                        }
                        else {
                            conditions.push({ logical: buttonBundle.logical, filters: bundleCondition });
                        }
                    }
                }));
                if (conditions.length >= 1) {
                    filterQueryString = this.ogcFilterWriter
                        .buildFilter(conditions.length === 1 ?
                        conditions[0] : ( /** @type {?} */({ logical: 'And', filters: conditions })));
                }
                if (this.datasource.options.type === 'wms') {
                    this.ogcFilterService.filterByOgc(( /** @type {?} */(this.datasource)), filterQueryString);
                }
                if (this.datasource.options.type === 'wfs') {
                    // TODO: Check how to prevent wfs to refresh when filter icon is pushed...
                    this.datasource.ol.clear();
                }
            };
        OgcFilterToggleButtonComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'igo-ogc-filter-toggle-button',
                        template: "<ng-container *ngFor=\"let bundle of pushButtonBundle\">\r\n        <mat-button-toggle-group appearance=\"legacy\" vertical={{bundleIsVertical(bundle)}} multiple=\"true\">\r\n            <mat-button-toggle [ngStyle]=\"getButtonColor(ogcPushButton)\" [checked]=\"ogcPushButton.enabled\"\r\n                (change)=\"applyFilters(ogcPushButton)\" tooltip-position=\"below\" matTooltipShowDelay=\"500\"\r\n                [matTooltip]=\"getToolTip(ogcPushButton)\" *ngFor=\"let ogcPushButton of bundle.ogcPushButtons\"\r\n                [value]=\"ogcPushButton\">{{ogcPushButton.title}}\r\n            </mat-button-toggle>\r\n        </mat-button-toggle-group>\r\n</ng-container>\r\n",
                        styles: [".mat-button-toggle-checked{font-weight:700}.mat-button-toggle-group{margin:5px;flex-wrap:wrap}"]
                    }] }
        ];
        /** @nocollapse */
        OgcFilterToggleButtonComponent.ctorParameters = function () {
            return [
                { type: OGCFilterService }
            ];
        };
        OgcFilterToggleButtonComponent.propDecorators = {
            refreshFilters: [{ type: i0.Input }],
            datasource: [{ type: i0.Input }],
            map: [{ type: i0.Input }]
        };
        return OgcFilterToggleButtonComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var IgoFilterModule = /** @class */ (function () {
        function IgoFilterModule() {
        }
        /**
         * @return {?}
         */
        IgoFilterModule.forRoot = /**
         * @return {?}
         */
            function () {
                return {
                    ngModule: IgoFilterModule,
                    providers: [
                        {
                            provide: material.MAT_DATE_LOCALE,
                            useValue: 'fr'
                        }
                    ]
                };
            };
        IgoFilterModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            forms.ReactiveFormsModule,
                            material.MatAutocompleteModule,
                            material.MatIconModule,
                            material.MatButtonModule,
                            material.MatButtonToggleModule,
                            material.MatCheckboxModule,
                            material.MatSliderModule,
                            material.MatSlideToggleModule,
                            material.MatFormFieldModule,
                            material.MatInputModule,
                            material.MatOptionModule,
                            material.MatSelectModule,
                            material.MatListModule,
                            material.MatTooltipModule,
                            material.MatDatepickerModule,
                            material.MatNativeDateModule,
                            // MatDatetimepickerModule,
                            // MatNativeDatetimeModule,
                            i1$1.IgoLanguageModule,
                            common$1.IgoCollapsibleModule,
                            common$1.IgoListModule,
                            common$1.IgoKeyValueModule
                        ],
                        exports: [
                            FilterableDataSourcePipe,
                            TimeFilterFormComponent,
                            TimeFilterItemComponent,
                            TimeFilterListComponent,
                            TimeFilterListBindingDirective,
                            OgcFilterFormComponent,
                            OgcFilterButtonComponent,
                            OgcFilterToggleButtonComponent,
                            OgcFilterableFormComponent,
                            OgcFilterableItemComponent,
                            OgcFilterableListComponent,
                            OgcFilterableListBindingDirective
                        ],
                        declarations: [
                            FilterableDataSourcePipe,
                            TimeFilterFormComponent,
                            TimeFilterItemComponent,
                            TimeFilterListComponent,
                            TimeFilterListBindingDirective,
                            OgcFilterFormComponent,
                            OgcFilterButtonComponent,
                            OgcFilterToggleButtonComponent,
                            OgcFilterableFormComponent,
                            OgcFilterableItemComponent,
                            OgcFilterableListComponent,
                            OgcFilterableListBindingDirective
                        ],
                        providers: [TimeFilterService, OGCFilterService]
                    },] }
        ];
        return IgoFilterModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * This input allows a user to draw a new geometry or to edit
     * an existing one on a map.
     */
    var GeometryFormFieldComponent = /** @class */ (function () {
        function GeometryFormFieldComponent(cdRef) {
            this.cdRef = cdRef;
            this.geometryType$ = new rxjs.BehaviorSubject(undefined);
            this.drawGuide$ = new rxjs.BehaviorSubject(0);
            this.value$ = new rxjs.BehaviorSubject(undefined);
            /**
             * Whether a geometry type toggle should be displayed
             */
            this.geometryTypeField = false;
            /**
             * Available geometry types
             */
            this.geometryTypes = ['Point', 'LineString', 'Polygon'];
            /**
             * Whether a draw guide field should be displayed
             */
            this.drawGuideField = false;
            /**
             * The drawGuide around the mouse pointer to help drawing
             */
            this.drawGuide = null;
            /**
             * Draw guide placeholder
             */
            this.drawGuidePlaceholder = '';
            /**
             * Whether a measure tooltip should be displayed
             */
            this.measure = false;
        }
        Object.defineProperty(GeometryFormFieldComponent.prototype, "geometryTypeModel", {
            get: /**
             * @return {?}
             */ function () { return this.geometryType$.value; },
            /**
             * The geometry type model
             */
            set: /**
             * The geometry type model
             * @param {?} value
             * @return {?}
             */ function (value) { this.geometryType$.next(value); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeometryFormFieldComponent.prototype, "drawGuideModel", {
            get: /**
             * @return {?}
             */ function () { return this.drawGuide$.value; },
            /**
             * The draw guide model
             */
            set: /**
             * The draw guide model
             * @param {?} value
             * @return {?}
             */ function (value) { this.drawGuide$.next(value); },
            enumerable: true,
            configurable: true
        });
        /**
         * Set up a value stream
         * @internal
         */
        /**
         * Set up a value stream
         * \@internal
         * @return {?}
         */
        GeometryFormFieldComponent.prototype.ngOnInit = /**
         * Set up a value stream
         * \@internal
         * @return {?}
         */
            function () {
                var _this = this;
                this.geometryType$.next(this.geometryType);
                this.drawGuide$.next(this.drawGuide);
                this.value$.next(this.formControl.value ? this.formControl.value : undefined);
                this.value$$ = this.formControl.valueChanges.subscribe(( /**
                 * @param {?} value
                 * @return {?}
                 */function (value) {
                    _this.value$.next(value ? value : undefined);
                }));
            };
        /**
         * Unsubscribe to the value stream
         * @internal
         */
        /**
         * Unsubscribe to the value stream
         * \@internal
         * @return {?}
         */
        GeometryFormFieldComponent.prototype.ngOnDestroy = /**
         * Unsubscribe to the value stream
         * \@internal
         * @return {?}
         */
            function () {
                this.value$$.unsubscribe();
            };
        /**
         * @param {?} geometryType
         * @return {?}
         */
        GeometryFormFieldComponent.prototype.onGeometryTypeChange = /**
         * @param {?} geometryType
         * @return {?}
         */
            function (geometryType) {
                if (this.value$.value !== undefined) {
                    return;
                }
                this.geometryType$.next(geometryType);
            };
        /**
         * @param {?} value
         * @return {?}
         */
        GeometryFormFieldComponent.prototype.onDrawGuideChange = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                this.drawGuide$.next(value);
            };
        GeometryFormFieldComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'igo-geometry-form-field',
                        template: "<igo-geometry-form-field-input\r\n  [formControl]=\"formControl\"\r\n  [map]=\"map\"\r\n  [geometryType]=\"geometryType$ | async\"\r\n  [drawGuide]=\"drawGuide$ | async\"\r\n  [measure]=\"measure\"\r\n  [drawStyle]=\"drawStyle\"\r\n  [overlayStyle]=\"overlayStyle\">\r\n</igo-geometry-form-field-input>\r\n\r\n<div *ngIf=\"geometryTypeField\" class=\"geometry-type-toggle\">\r\n  <mat-button-toggle-group\r\n    [disabled]=\"(value$ | async) !== undefined\"\r\n    [ngModel]=\"geometryTypeModel\"\r\n    (ngModelChange)=\"onGeometryTypeChange($event)\">\r\n    <mat-button-toggle\r\n      value=\"Point\"\r\n      [disabled]=\"geometryTypes.indexOf('Point') < 0\">\r\n      {{'igo.geo.geometry.point' | translate}}\r\n    </mat-button-toggle>\r\n    <mat-button-toggle\r\n      value=\"LineString\"\r\n      [disabled]=\"geometryTypes.indexOf('LineString') < 0\">\r\n      {{'igo.geo.geometry.line' | translate}}\r\n    </mat-button-toggle>\r\n    <mat-button-toggle\r\n      value=\"Polygon\"\r\n      [disabled]=\"geometryTypes.indexOf('Polygon') < 0\">\r\n      {{'igo.geo.geometry.polygon' | translate}}\r\n    </mat-button-toggle>\r\n  </mat-button-toggle-group>\r\n</div>\r\n\r\n<mat-form-field *ngIf=\"drawGuideField\" class=\"draw-guide-field\">\r\n  <input\r\n    matInput\r\n    type=\"number\"\r\n    [placeholder]=\"drawGuidePlaceholder\"\r\n    [ngModel]=\"drawGuideModel\"\r\n    (ngModelChange)=\"onDrawGuideChange($event)\">\r\n  <mat-icon\r\n    matPrefix\r\n    [color]=\"'primary'\"\r\n    svgIcon=\"adjust\">    \r\n  </mat-icon>\r\n  <span matSuffix class=\"draw-guide-units\">{{'igo.geo.measure.meters' | translate}}</span>\r\n</mat-form-field>",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        styles: [":host{display:block;width:100%}.draw-guide-field,.geometry-type-toggle{width:100%}.geometry-type-toggle{padding:10px;text-align:center}.draw-guide-field mat-icon{margin:0 10px}.draw-guide-units{padding:10px}"]
                    }] }
        ];
        /** @nocollapse */
        GeometryFormFieldComponent.ctorParameters = function () {
            return [
                { type: i0.ChangeDetectorRef }
            ];
        };
        GeometryFormFieldComponent.propDecorators = {
            formControl: [{ type: i0.Input }],
            map: [{ type: i0.Input }],
            geometryType: [{ type: i0.Input }],
            geometryTypeField: [{ type: i0.Input }],
            geometryTypes: [{ type: i0.Input }],
            drawGuideField: [{ type: i0.Input }],
            drawGuide: [{ type: i0.Input }],
            drawGuidePlaceholder: [{ type: i0.Input }],
            measure: [{ type: i0.Input }],
            drawStyle: [{ type: i0.Input }],
            overlayStyle: [{ type: i0.Input }]
        };
        /**
         * This input allows a user to draw a new geometry or to edit
         * an existing one on a map.
         */
        GeometryFormFieldComponent = __decorate([
            common$1.FormFieldComponent('geometry'),
            __metadata("design:paramtypes", [i0.ChangeDetectorRef])
        ], GeometryFormFieldComponent);
        return GeometryFormFieldComponent;
    }());

    var _a, _b;
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var MEASURE_UNIT_AUTO = 'auto';
    /** @enum {string} */
    var MeasureType = {
        Length: 'length',
        Area: 'area',
    };
    /** @enum {string} */
    var MeasureLengthUnit = {
        Meters: 'meters',
        Kilometers: 'kilometers',
        Miles: 'miles',
        Feet: 'feet',
    };
    /** @type {?} */
    var MeasureLengthUnitAbbreviation = (_a = {},
        _a[MeasureLengthUnit.Meters] = 'm',
        _a[MeasureLengthUnit.Kilometers] = 'km',
        _a[MeasureLengthUnit.Miles] = 'mi',
        _a[MeasureLengthUnit.Feet] = 'ft',
        _a);
    /** @enum {string} */
    var MeasureAreaUnit = {
        SquareMeters: 'squareMeters',
        SquareKilometers: 'squareKilometers',
        SquareMiles: 'squareMiles',
        SquareFeet: 'squareFeet',
        Hectares: 'hectares',
        Acres: 'acres',
    };
    /** @type {?} */
    var MeasureAreaUnitAbbreviation = (_b = {},
        _b[MeasureAreaUnit.SquareMeters] = 'm',
        _b[MeasureAreaUnit.SquareKilometers] = 'km',
        _b[MeasureAreaUnit.SquareMiles] = 'mi',
        _b[MeasureAreaUnit.SquareFeet] = 'ft',
        _b[MeasureAreaUnit.Hectares] = 'ha',
        _b[MeasureAreaUnit.Acres] = 'ac',
        _b);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Convert value from meters to kilometers
     * @param {?} value Value in meters
     * @return {?} Value in kilometers
     */
    function metersToKilometers(value) {
        return value * 0.001;
    }
    /**
     * Convert value from meters to feet
     * @param {?} value Value in meters
     * @return {?} Value in feet
     */
    function metersToFeet(value) {
        return value * 3.2808;
    }
    /**
     * Convert value from meters to miles
     * @param {?} value Value in meters
     * @return {?} Value in miles
     */
    function metersToMiles(value) {
        return value * 0.000621;
    }
    /**
     * Convert value from square meters to square kilometers
     * @param {?} value Value in square meters
     * @return {?} Value in square kilometers
     */
    function squareMetersToSquareKilometers(value) {
        return value * 0.000001;
    }
    /**
     * Convert value from square meters to square miles
     * @param {?} value Value in square meters
     * @return {?} Value in square miles
     */
    function squareMetersToSquareMiles(value) {
        return value * 0.0000003861;
    }
    /**
     * Convert value from square meters to square feet
     * @param {?} value Value in square meters
     * @return {?} Value in square feet
     */
    function squareMetersToSquareFeet(value) {
        return value * 10.764;
    }
    /**
     * Convert value from square meters to hectares
     * @param {?} value Value in square meters
     * @return {?} Value in hectares
     */
    function squareMetersToHectares(value) {
        return value * 0.0001;
    }
    /**
     * Convert value from square meters to acres
     * @param {?} value Value in square meters
     * @return {?} Value in acres
     */
    function squareMetersToAcres(value) {
        return value * 0.00024711;
    }
    /**
     * Convert value from meters to the specified length unit
     * @param {?} value Value in meters
     * @param {?} unit Length unit
     * @return {?} Value in unit
     */
    function metersToUnit(value, unit) {
        /** @type {?} */
        var conversionMapper = new Map([
            [MeasureLengthUnit.Meters, ( /**
                     * @param {?} val
                     * @return {?}
                     */function (val) { return val; })],
            [MeasureLengthUnit.Kilometers, metersToKilometers],
            [MeasureLengthUnit.Miles, metersToMiles],
            [MeasureLengthUnit.Feet, metersToFeet],
        ]);
        /** @type {?} */
        var conversion = conversionMapper.get(unit);
        return conversion ? conversion(value) : undefined;
    }
    /**
     * Convert value from square meters to the specified area unit
     * @param {?} value Value in meters
     * @param {?} unit Area unit
     * @return {?} Value in unit
     */
    function squareMetersToUnit(value, unit) {
        /** @type {?} */
        var conversionMapper = new Map([
            [MeasureAreaUnit.SquareMeters, ( /**
                     * @param {?} val
                     * @return {?}
                     */function (val) { return val; })],
            [MeasureAreaUnit.SquareKilometers, squareMetersToSquareKilometers],
            [MeasureAreaUnit.SquareMiles, squareMetersToSquareMiles],
            [MeasureAreaUnit.SquareFeet, squareMetersToSquareFeet],
            [MeasureAreaUnit.Hectares, squareMetersToHectares],
            [MeasureAreaUnit.Acres, squareMetersToAcres],
        ]);
        /** @type {?} */
        var conversion = conversionMapper.get(unit);
        return conversion ? conversion(value) : undefined;
    }
    /**
     * This method format a measure to a readable format
     * @param {?} measure Measure
     * @param {?=} options Formatting options
     * @return {?} Formatted measure
     */
    function formatMeasure(measure, options) {
        /** @type {?} */
        var decimal = options.decimal;
        if (decimal === undefined || decimal < 0) {
            decimal = 1;
        }
        /** @type {?} */
        var parts = [];
        if (options.locale !== undefined) {
            parts.push(measure.toLocaleString(options.locale, {
                minimumFractionDigits: decimal,
                maximumFractionDigits: decimal
            }));
        }
        else {
            parts.push(measure.toFixed(decimal).toString());
        }
        if (options.unit !== undefined && options.unitAbbr === true) {
            parts.push(MeasureLengthUnitAbbreviation[options.unit] ||
                MeasureAreaUnitAbbreviation[options.unit]);
        }
        return parts.filter(( /**
         * @param {?} p
         * @return {?}
         */function (p) { return p !== undefined; })).join(' ');
    }
    /**
     * Compute best length measure unit for a given measure in meters
     * @param {?} value Value in meters
     * @return {?} Measure unit
     */
    function computeBestLengthUnit(value) {
        /** @type {?} */
        var unit = MeasureLengthUnit.Meters;
        /** @type {?} */
        var converted = value;
        /** @type {?} */
        var possibleUnits = [MeasureLengthUnit.Kilometers];
        while (converted > 1000 && possibleUnits.length > 0) {
            unit = possibleUnits.pop();
            converted = metersToUnit(value, unit);
        }
        return unit;
    }
    /**
     * Compute best length measure unit for a given measure in square meters
     * @param {?} value Value in meters
     * @return {?} Measure unit
     */
    function computeBestAreaUnit(value) {
        /** @type {?} */
        var unit = MeasureAreaUnit.SquareMeters;
        /** @type {?} */
        var converted = value;
        /** @type {?} */
        var possibleUnits = [MeasureAreaUnit.SquareKilometers];
        while (converted > 1000000 && possibleUnits.length > 0) {
            unit = possibleUnits.pop();
            converted = squareMetersToUnit(value, unit);
        }
        return unit;
    }
    /**
     * Create a default style for a measure interaction
     * @return {?} OL style
     */
    function createMeasureInteractionStyle() {
        return new olstyle.Style({
            stroke: new olstyle.Stroke({
                color: '#ffcc33',
                lineDash: [10, 10],
                width: 2
            }),
            fill: new olstyle.Fill({
                color: 'rgba(255, 255, 255, 0.2)'
            }),
            image: new olstyle.Circle({
                radius: 5,
                stroke: new olstyle.Stroke({
                    color: '#ffcc33',
                }),
                fill: new olstyle.Fill({
                    color: 'rgba(255, 255, 255, 0.2)'
                })
            })
        });
    }
    /**
     * Create a default style for a measure layer
     * @return {?} OL style
     */
    function createMeasureLayerStyle() {
        return new olstyle.Style({
            stroke: new olstyle.Stroke({
                color: '#ffcc33',
                width: 2
            }),
            fill: new olstyle.Fill({
                color: 'rgba(255, 255, 255, 0.2)'
            })
        });
    }
    /**
     * Compute the length in meters of an OL geometry with a given projection
     * @param {?} olGeometry Ol geometry
     * @param {?} projection olGeometry's projection
     * @return {?} Length in meters
     */
    function measureOlGeometryLength(olGeometry, projection) {
        if (olGeometry instanceof OlPoint) {
            return undefined;
        }
        if (olGeometry.getFlatCoordinates().length === 0) {
            return undefined;
        }
        return sphere.getLength(olGeometry, { projection: projection });
    }
    /**
     * Compute the area in square meters of an OL geometry with a given projection
     * @param {?} olGeometry Ol geometry
     * @param {?} projection olGeometry's projection
     * @return {?} Area in square meters
     */
    function measureOlGeometryArea(olGeometry, projection) {
        if (olGeometry instanceof OlPoint || olGeometry instanceof OlLineString) {
            return undefined;
        }
        if (olGeometry.getFlatCoordinates().length === 0) {
            return undefined;
        }
        return sphere.getArea(olGeometry, { projection: projection });
    }
    /**
     * Compute the area (square meters), length (meters) and last length (meters)
     * of an OL geometry with a given projection.
     * @param {?} olGeometry Ol geometry
     * @param {?} projection olGeometry's projection
     * @return {?} Computed measure
     */
    function measureOlGeometry(olGeometry, projection) {
        /** @type {?} */
        var length = measureOlGeometryLength(olGeometry, projection);
        /** @type {?} */
        var area = measureOlGeometryArea(olGeometry, projection);
        /** @type {?} */
        var lengths = [];
        /** @type {?} */
        var coordinates = olGeometry.flatCoordinates;
        /** @type {?} */
        var coordinatesLength = coordinates.length;
        for (var i = 0; i <= coordinatesLength - 4; i += 2) {
            /** @type {?} */
            var olSegment = new OlLineString([
                [coordinates[i], coordinates[i + 1]],
                [coordinates[i + 2], coordinates[i + 3]]
            ]);
            lengths.push(measureOlGeometryLength(olSegment, projection));
        }
        return {
            area: area,
            length: length,
            lengths: lengths
        };
    }
    /**
     * Update an OL geometry midpoints and return an array of those points
     * @param {?} olGeometry OL Geometry
     * @return {?} OL points
     */
    function updateOlGeometryMidpoints(olGeometry) {
        /** @type {?} */
        var olMidpoints = getOlGeometryMidpoints(olGeometry);
        // TODO: handle multi geometries
        /** @type {?} */
        var coordinates = olGeometry.flatCoordinates;
        /** @type {?} */
        var midpointsLength = olMidpoints.length;
        for (var i = 0; i < midpointsLength; i++) {
            /** @type {?} */
            var j = i * 2;
            /** @type {?} */
            var olSegment = new OlLineString([
                [coordinates[j], coordinates[j + 1]],
                [coordinates[j + 2], coordinates[j + 3]]
            ]);
            /** @type {?} */
            var midpointCoordinate = olSegment.getCoordinateAt(0.5);
            /** @type {?} */
            var olMidpoint = olMidpoints[i];
            if (olMidpoint !== undefined) {
                olMidpoint.setCoordinates(midpointCoordinate);
            }
            else {
                olMidpoints[i] = new OlPoint(midpointCoordinate);
            }
        }
        return olMidpoints;
    }
    /**
     * Clear an OL geometry midpoints and return an array of those points
     * @param {?} olGeometry OL Geometry
     * @return {?}
     */
    function clearOlGeometryMidpoints(olGeometry) {
        /** @type {?} */
        var olMidpoints = olGeometry.get('_midpoints') || [];
        /** @type {?} */
        var midpointsLength = olMidpoints.length;
        for (var i = 0; i < midpointsLength; i++) {
            /** @type {?} */
            var olMidpoint = olMidpoints[i];
            if (olMidpoint !== undefined) {
                if (olMidpoint !== undefined) {
                    clearOlMidpointTooltip(olMidpoint);
                }
            }
        }
        olGeometry.set('_midpoints', undefined, true);
        return olMidpoints;
    }
    /**
     * Return an array of  OL geometry midpoints, if any
     * @param {?} olGeometry OL Geometry
     * @return {?} OL points
     */
    function getOlGeometryMidpoints(olGeometry) {
        /** @type {?} */
        var expectedNumber = Math.max((olGeometry.flatCoordinates.length / 2) - 1, 0);
        // TODO: This works but it's quite messy. If time permits,
        // clean this. Maybe a Tooltip class could handle that
        /** @type {?} */
        var olMidpoints = olGeometry.get('_midpoints');
        if (olMidpoints === undefined) {
            olMidpoints = new Array(expectedNumber);
            olGeometry.set('_midpoints', olMidpoints, true);
            return olMidpoints;
        }
        if (expectedNumber === olMidpoints.length) {
            return olMidpoints;
        }
        if (expectedNumber > olMidpoints.length) {
            olMidpoints.push.apply(olMidpoints, __spread(new Array(expectedNumber - olMidpoints.length)));
            return olMidpoints;
        }
        for (var i = expectedNumber; i < olMidpoints.length; i++) {
            /** @type {?} */
            var olMidpoint = olMidpoints[expectedNumber];
            if (olMidpoint !== undefined) {
                clearOlMidpointTooltip(olMidpoint);
            }
        }
        olMidpoints.splice(expectedNumber);
        return olMidpoints;
    }
    /**
     * Remove an OL midpoint's tooltip from the map
     * @param {?} olMidpoint OL Point
     * @return {?}
     */
    function clearOlMidpointTooltip(olMidpoint) {
        /** @type {?} */
        var olTooltip = olMidpoint.get('_tooltip');
        if (olTooltip !== undefined) {
            /** @type {?} */
            var olMap$$1 = olTooltip.getMap();
            if (olMap$$1 !== undefined) {
                olMap$$1.removeOverlay(olTooltip);
            }
        }
    }
    /**
     * Add an OL overlay at each midpoint and return an array of those overlays
     * @param {?} olGeometry OL Geometry
     * @return {?} OL overlays
     */
    function updateOlTooltipsAtMidpoints(olGeometry) {
        /** @type {?} */
        var olMidpoints = updateOlGeometryMidpoints(olGeometry);
        /** @type {?} */
        var olTooltips = olMidpoints.map(( /**
         * @param {?} olMidpoint
         * @return {?}
         */function (olMidpoint) {
            /** @type {?} */
            var olTooltip = olMidpoint.get('_tooltip');
            if (olTooltip === undefined) {
                olTooltip = createOlTooltipAtPoint(olMidpoint);
            }
            else {
                olTooltip.setPosition(olMidpoint.flatCoordinates);
            }
            return olTooltip;
        }));
        return olTooltips;
    }
    /**
     * Return an array of OL overlay at midspoints, if any
     * @param {?} olGeometry OL Geometry
     * @return {?} OL overlays
     */
    function getOlTooltipsAtMidpoints(olGeometry) {
        /** @type {?} */
        var olMidpoints = getOlGeometryMidpoints(olGeometry);
        return olMidpoints.map(( /**
         * @param {?} olMidpoint
         * @return {?}
         */function (olMidpoint) {
            return olMidpoint ? olMidpoint.get('_tooltip') : undefined;
        }));
    }
    /**
     * Update an OL geometry center and return it
     * @param {?} olGeometry OL Geometry
     * @return {?} OL point
     */
    function updateOlGeometryCenter(olGeometry) {
        /** @type {?} */
        var olCenter = olGeometry.get('_center');
        /** @type {?} */
        var centerCoordinate = olextent.getCenter(olGeometry.getExtent());
        if (olCenter !== undefined) {
            olCenter.setCoordinates(centerCoordinate);
        }
        else {
            olCenter = new OlPoint(centerCoordinate);
            olGeometry.set('_center', olCenter);
        }
        return olCenter;
    }
    /**
     * Add an OL overlay at the center of a geometry and return that overlay
     * @param {?} olGeometry OL Geometry
     * @return {?} OL overlay
     */
    function updateOlTooltipAtCenter(olGeometry) {
        /** @type {?} */
        var olCenter = updateOlGeometryCenter(olGeometry);
        /** @type {?} */
        var olTooltip = olCenter.get('_tooltip');
        if (olTooltip === undefined) {
            olTooltip = createOlTooltipAtPoint(olCenter);
        }
        else {
            olTooltip.setPosition(olCenter.flatCoordinates);
        }
        return olTooltip;
    }
    /**
     * Return an array of OL overlay at midspoints, if any
     * @param {?} olGeometry OL Geometry
     * @return {?} OL overlays
     */
    function getOlTooltipAtCenter(olGeometry) {
        /** @type {?} */
        var olCenter = olGeometry.get('_center');
        return olCenter ? olCenter.get('_tooltip') : undefined;
    }
    /**
     * Get all the tooltips of an OL geometry
     * @param {?} olGeometry OL Geometry
     * @return {?} OL overlays
     */
    function getTooltipsOfOlGeometry(olGeometry) {
        /** @type {?} */
        var olTooltips = [].concat(getOlTooltipsAtMidpoints(olGeometry) || []);
        /** @type {?} */
        var olCenterTooltip = getOlTooltipAtCenter(olGeometry);
        if (olCenterTooltip !== undefined) {
            olTooltips.push(olCenterTooltip);
        }
        return olTooltips;
    }
    /**
     * Create an OL overlay at a point and bind the overlay to the point
     * @param {?} olPoint OL Point
     * @return {?} OL overlay
     */
    function createOlTooltipAtPoint(olPoint) {
        /** @type {?} */
        var olTooltip = new OlOverlay({
            element: document.createElement('div'),
            offset: [-30, -10],
            className: [
                'igo-map-tooltip',
                'igo-map-tooltip-measure'
            ].join(' '),
            stopEvent: false
        });
        olTooltip.setPosition(olPoint.flatCoordinates);
        olPoint.set('_tooltip', olTooltip);
        return olTooltip;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /* tslint:disable */
    // See this issue: https://github.com/Microsoft/TypeScript/issues/13965
    // And the solution: https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work
    // for an explanation as to why the prototype is set manually
    /* tslint:enable */
    var GeometrySliceError = /** @class */ (function (_super) {
        __extends(GeometrySliceError, _super);
        function GeometrySliceError() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return GeometrySliceError;
    }(Error));
    var GeometrySliceMultiPolygonError = /** @class */ (function (_super) {
        __extends(GeometrySliceMultiPolygonError, _super);
        function GeometrySliceMultiPolygonError() {
            var _this = _super.call(this, 'Can\'t slice a MultiPolygon.') || this;
            Object.setPrototypeOf(_this, GeometrySliceMultiPolygonError.prototype);
            return _this;
        }
        return GeometrySliceMultiPolygonError;
    }(GeometrySliceError));
    var GeometrySliceLineStringError = /** @class */ (function (_super) {
        __extends(GeometrySliceLineStringError, _super);
        function GeometrySliceLineStringError() {
            var _this = _super.call(this, 'Can\'t slice with a line that has more than 2 points.') || this;
            Object.setPrototypeOf(_this, GeometrySliceLineStringError.prototype);
            return _this;
        }
        return GeometrySliceLineStringError;
    }(GeometrySliceError));
    var GeometrySliceTooManyIntersectionError = /** @class */ (function (_super) {
        __extends(GeometrySliceTooManyIntersectionError, _super);
        function GeometrySliceTooManyIntersectionError() {
            var _this = _super.call(this, 'More than 2 intersections found between the target polygon and the slicing line.') || this;
            Object.setPrototypeOf(_this, GeometrySliceTooManyIntersectionError.prototype);
            return _this;
        }
        return GeometrySliceTooManyIntersectionError;
    }(GeometrySliceError));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Create a default style for draw and modify interactions
     * @param {?=} color Style color (R, G, B)
     * @return {?} OL style
     */
    function createDrawInteractionStyle(color$$1) {
        color$$1 = color$$1 || [0, 153, 255];
        return new olstyle.Style({
            stroke: new olstyle.Stroke({
                color: color$$1.concat([1]),
                width: 2
            }),
            fill: new olstyle.Fill({
                color: color$$1.concat([0.2])
            }),
            image: new olstyle.Circle({
                radius: 8,
                stroke: new olstyle.Stroke({
                    color: color$$1.concat([1])
                }),
                fill: new olstyle.Fill({
                    color: color$$1.concat([0.2])
                })
            })
        });
    }
    /**
     * Create a default style for drawing a hole
     * @return {?} OL style
     */
    function createDrawHoleInteractionStyle() {
        return new olstyle.Style({
            stroke: new olstyle.Stroke({
                color: [0, 153, 255, 1],
                width: 2
            })
        });
    }
    /**
     * Slice geometry into two parts
     * @param {?} olGeometry OL geometry
     * @param {?} olSlicer Slicing line
     * @return {?} New OL geometries
     */
    function sliceOlGeometry(olGeometry, olSlicer) {
        if (olGeometry instanceof OlPolygon) {
            return sliceOlPolygon(olGeometry, olSlicer);
        }
        else if (olGeometry instanceof OlLineString) {
            return sliceOlLineString(olGeometry, olSlicer);
        }
        return [];
    }
    /**
     * Slice OL LineString into one or more lines
     * @param {?} olLineString OL line string
     * @param {?} olSlicer Slicing line
     * @return {?} New OL line strings
     */
    function sliceOlLineString(olLineString, olSlicer) {
        return [];
    }
    /**
     * Slice OL Polygon into one or more polygons
     * @param {?} olPolygon OL polygon
     * @param {?} olSlicer Slicing line
     * @return {?} New OL polygons
     */
    function sliceOlPolygon(olPolygon, olSlicer) {
        if (olPolygon.getLinearRingCount() > 1) {
            throw new GeometrySliceMultiPolygonError();
        }
        if (olSlicer.getCoordinates().length > 2) {
            throw new GeometrySliceLineStringError();
        }
        /** @type {?} */
        var olGeoJSON = new OlGeoJSON();
        /** @type {?} */
        var slicer = olGeoJSON.writeGeometryObject(olSlicer);
        /** @type {?} */
        var outerCoordinates = olPolygon.getLinearRing(0).getCoordinates();
        /** @type {?} */
        var parts = [[], []];
        /** @type {?} */
        var totalIntersectionCount = 0;
        for (var i = 0, ii = outerCoordinates.length - 1; i < ii; i++) {
            /** @type {?} */
            var segmentCoordinates = [outerCoordinates[i], outerCoordinates[i + 1]];
            /** @type {?} */
            var segment = helpers.lineString(segmentCoordinates);
            /** @type {?} */
            var intersections = lineIntersect(segment, slicer).features;
            /** @type {?} */
            var intersectionCount = intersections.length;
            totalIntersectionCount += intersectionCount;
            if (intersectionCount > 1 || totalIntersectionCount > 2) {
                throw new GeometrySliceTooManyIntersectionError();
            }
            parts[0].push(segmentCoordinates[0]);
            if (intersectionCount === 1) {
                /** @type {?} */
                var intersection = intersections[0].geometry.coordinates;
                parts[0].push(intersection);
                parts[1].push(intersection);
                parts.reverse();
            }
        }
        if (totalIntersectionCount <= 1) {
            return [];
        }
        parts[0].push(parts[0][0]);
        parts[1].push(parts[1][0]);
        return [new OlPolygon([parts[0]]), new OlPolygon([parts[1]])];
    }
    /**
     * Splice geometry into two parts
     * @param {?} olPolygon
     * @param {?} olLinearRing
     * @return {?} New OL geometries
     */
    function addLinearRingToOlPolygon(olPolygon, olLinearRing) {
        // TODO: make some validation and support updating an existing linear ring
        olPolygon.appendLinearRing(olLinearRing);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Control to draw geometries
     */
    var /**
     * Control to draw geometries
     */ DrawControl = /** @class */ (function () {
        function DrawControl(options) {
            this.options = options;
            /**
             * Draw start observable
             */
            this.start$ = new rxjs.Subject();
            /**
             * Draw end observable
             */
            this.end$ = new rxjs.Subject();
            /**
             * Geometry changes observable
             */
            this.changes$ = new rxjs.Subject();
            if (options.layer !== undefined) {
                this.olOverlayLayer = options.layer;
            }
            else {
                this.olOverlayLayer = this.createOlInnerOverlayLayer();
            }
        }
        Object.defineProperty(DrawControl.prototype, "active", {
            /**
             * Wheter the control is active
             */
            get: /**
             * Wheter the control is active
             * @return {?}
             */ function () {
                return this.olMap !== undefined;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DrawControl.prototype, "geometryType", {
            /**
             * Geometry type
             * @internal
             */
            get: /**
             * Geometry type
             * \@internal
             * @return {?}
             */ function () {
                return this.options.geometryType;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DrawControl.prototype, "olOverlaySource", {
            /**
             * OL overlay source
             * @internal
             */
            get: /**
             * OL overlay source
             * \@internal
             * @return {?}
             */ function () {
                return this.olOverlayLayer.getSource();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Add or remove this control to/from a map.
         * @param map OL Map
         */
        /**
         * Add or remove this control to/from a map.
         * @param {?} olMap
         * @return {?}
         */
        DrawControl.prototype.setOlMap = /**
         * Add or remove this control to/from a map.
         * @param {?} olMap
         * @return {?}
         */
            function (olMap$$1) {
                if (olMap$$1 === undefined) {
                    this.clearOlInnerOverlaySource();
                    this.removeOlInnerOverlayLayer();
                    this.removeOlDrawInteraction();
                    this.olMap = olMap$$1;
                    return;
                }
                this.olMap = olMap$$1;
                this.addOlInnerOverlayLayer();
                this.addOlDrawInteraction();
            };
        /**
         * Return the overlay source
         */
        /**
         * Return the overlay source
         * @return {?}
         */
        DrawControl.prototype.getSource = /**
         * Return the overlay source
         * @return {?}
         */
            function () {
                return this.olOverlaySource;
            };
        /**
         * Create an overlay source if none is defined in the options
         */
        /**
         * Create an overlay source if none is defined in the options
         * @private
         * @return {?}
         */
        DrawControl.prototype.createOlInnerOverlayLayer = /**
         * Create an overlay source if none is defined in the options
         * @private
         * @return {?}
         */
            function () {
                return new OlVectorLayer({
                    source: this.options.source ? this.options.source : new OlVectorSource(),
                    style: this.options.layerStyle,
                    zIndex: 500
                });
            };
        /**
         * Clear the overlay layer if it wasn't defined in the options
         */
        /**
         * Clear the overlay layer if it wasn't defined in the options
         * @private
         * @return {?}
         */
        DrawControl.prototype.removeOlInnerOverlayLayer = /**
         * Clear the overlay layer if it wasn't defined in the options
         * @private
         * @return {?}
         */
            function () {
                if (this.options.layer === undefined && this.olMap !== undefined) {
                    this.olMap.removeLayer(this.olOverlayLayer);
                }
            };
        /**
         * Add the overlay layer if it wasn't defined in the options
         */
        /**
         * Add the overlay layer if it wasn't defined in the options
         * @private
         * @return {?}
         */
        DrawControl.prototype.addOlInnerOverlayLayer = /**
         * Add the overlay layer if it wasn't defined in the options
         * @private
         * @return {?}
         */
            function () {
                if (this.options.layer === undefined) {
                    this.olMap.addLayer(this.olOverlayLayer);
                }
            };
        /**
         * Clear the overlay source if it wasn't defined in the options
         */
        /**
         * Clear the overlay source if it wasn't defined in the options
         * @private
         * @return {?}
         */
        DrawControl.prototype.clearOlInnerOverlaySource = /**
         * Clear the overlay source if it wasn't defined in the options
         * @private
         * @return {?}
         */
            function () {
                if (this.options.layer === undefined && this.options.source === undefined) {
                    this.olOverlaySource.clear();
                }
            };
        /**
         * Add a draw interaction to the map an set up some listeners
         */
        /**
         * Add a draw interaction to the map an set up some listeners
         * @private
         * @return {?}
         */
        DrawControl.prototype.addOlDrawInteraction = /**
         * Add a draw interaction to the map an set up some listeners
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var olDrawInteraction = new OlDraw({
                    type: this.geometryType,
                    source: this.getSource(),
                    stopClick: true,
                    style: this.options.drawStyle,
                    maxPoints: this.options.maxPoints,
                    freehand: false,
                    freehandCondition: ( /**
                     * @return {?}
                     */function () { return false; })
                });
                this.onDrawStartKey = olDrawInteraction
                    .on('drawstart', ( /**
             * @param {?} event
             * @return {?}
             */function (event) { return _this.onDrawStart(event); }));
                this.onDrawEndKey = olDrawInteraction
                    .on('drawend', ( /**
             * @param {?} event
             * @return {?}
             */function (event) { return _this.onDrawEnd(event); }));
                this.olMap.addInteraction(olDrawInteraction);
                this.olDrawInteraction = olDrawInteraction;
            };
        /**
         * Remove the draw interaction
         */
        /**
         * Remove the draw interaction
         * @private
         * @return {?}
         */
        DrawControl.prototype.removeOlDrawInteraction = /**
         * Remove the draw interaction
         * @private
         * @return {?}
         */
            function () {
                if (this.olDrawInteraction === undefined) {
                    return;
                }
                this.unsubscribeToKeyDown();
                olobservable.unByKey(this.onDrawStartKey);
                olobservable.unByKey(this.onDrawEndKey);
                if (this.olMap !== undefined) {
                    this.olMap.removeInteraction(this.olDrawInteraction);
                }
                this.olDrawInteraction = undefined;
            };
        /**
         * When drawing starts, clear the overlay and start watching from changes
         * @param event Draw start event
         */
        /**
         * When drawing starts, clear the overlay and start watching from changes
         * @private
         * @param {?} event Draw start event
         * @return {?}
         */
        DrawControl.prototype.onDrawStart = /**
         * When drawing starts, clear the overlay and start watching from changes
         * @private
         * @param {?} event Draw start event
         * @return {?}
         */
            function (event) {
                var _this = this;
                /** @type {?} */
                var olGeometry = event.feature.getGeometry();
                this.start$.next(olGeometry);
                this.clearOlInnerOverlaySource();
                this.onChangesKey = olGeometry.on('change', ( /**
                 * @param {?} olGeometryEvent
                 * @return {?}
                 */function (olGeometryEvent) {
                    _this.changes$.next(olGeometryEvent.target);
                }));
                this.subscribeToKeyDown();
            };
        /**
         * When drawing ends, update the geometry observable and start watching from changes
         * @param event Draw end event
         */
        /**
         * When drawing ends, update the geometry observable and start watching from changes
         * @private
         * @param {?} event Draw end event
         * @return {?}
         */
        DrawControl.prototype.onDrawEnd = /**
         * When drawing ends, update the geometry observable and start watching from changes
         * @private
         * @param {?} event Draw end event
         * @return {?}
         */
            function (event) {
                this.unsubscribeToKeyDown();
                if (this.onChangesKey !== undefined) {
                    olobservable.unByKey(this.onChangesKey);
                }
                this.end$.next(event.feature.getGeometry());
            };
        /**
         * Subscribe to CTRL key down to activate the draw control
         */
        /**
         * Subscribe to CTRL key down to activate the draw control
         * @private
         * @return {?}
         */
        DrawControl.prototype.subscribeToKeyDown = /**
         * Subscribe to CTRL key down to activate the draw control
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                this.unsubscribeToKeyDown();
                this.keyDown$$ = rxjs.fromEvent(document, 'keydown').subscribe(( /**
                 * @param {?} event
                 * @return {?}
                 */function (event) {
                    // On ESC key down, remove the last vertex
                    if (event.keyCode === 27) {
                        _this.olDrawInteraction.removeLastPoint();
                    }
                }));
            };
        /**
         * Unsubscribe to key down
         */
        /**
         * Unsubscribe to key down
         * @private
         * @return {?}
         */
        DrawControl.prototype.unsubscribeToKeyDown = /**
         * Unsubscribe to key down
         * @private
         * @return {?}
         */
            function () {
                if (this.keyDown$$ !== undefined) {
                    this.keyDown$$.unsubscribe();
                    this.keyDown$$ = undefined;
                }
            };
        return DrawControl;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Control to modify geometries
     */
    var /**
     * Control to modify geometries
     */ ModifyControl = /** @class */ (function () {
        function ModifyControl(options) {
            this.options = options;
            /**
             * Modify start observable
             */
            this.start$ = new rxjs.Subject();
            /**
             * Modify end observable
             */
            this.end$ = new rxjs.Subject();
            /**
             * Geometry changes observable
             */
            this.changes$ = new rxjs.Subject();
            this.olModifyInteractionIsActive = false;
            this.olTranslateInteractionIsActive = false;
            this.olDrawInteractionIsActive = false;
            this.removedOlInteractions = [];
            if (options.layer !== undefined) {
                this.olOverlayLayer = options.layer;
            }
            else {
                this.olOverlayLayer = this.createOlInnerOverlayLayer();
            }
            this.olLinearRingsLayer = this.createOlLinearRingsLayer();
        }
        Object.defineProperty(ModifyControl.prototype, "active", {
            /**
             * Wheter the control is active
             */
            get: /**
             * Wheter the control is active
             * @return {?}
             */ function () {
                return this.olMap !== undefined;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ModifyControl.prototype, "olOverlaySource", {
            /**
             * OL overlay source
             * @internal
             */
            get: /**
             * OL overlay source
             * \@internal
             * @return {?}
             */ function () {
                return this.olOverlayLayer.getSource();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ModifyControl.prototype, "olLinearRingsSource", {
            /**
             * OL linear rings source
             * @internal
             */
            get: /**
             * OL linear rings source
             * \@internal
             * @return {?}
             */ function () {
                return this.olLinearRingsLayer.getSource();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Add or remove this control to/from a map.
         * @param map OL Map
         */
        /**
         * Add or remove this control to/from a map.
         * @param {?} olMap
         * @return {?}
         */
        ModifyControl.prototype.setOlMap = /**
         * Add or remove this control to/from a map.
         * @param {?} olMap
         * @return {?}
         */
            function (olMap$$1) {
                if (olMap$$1 === undefined) {
                    this.clearOlInnerOverlaySource();
                    this.removeOlInnerOverlayLayer();
                    this.removeOlModifyInteraction();
                    this.removeOlTranslateInteraction();
                    this.removeOlDrawInteraction();
                    this.olMap = olMap$$1;
                    return;
                }
                this.olMap = olMap$$1;
                this.addOlInnerOverlayLayer();
                this.addOlDrawInteraction();
                this.addOlTranslateInteraction();
                this.activateTranslateInteraction();
                this.addOlModifyInteraction();
                this.activateModifyInteraction();
            };
        /**
         * Return the overlay source
         */
        /**
         * Return the overlay source
         * @return {?}
         */
        ModifyControl.prototype.getSource = /**
         * Return the overlay source
         * @return {?}
         */
            function () {
                return this.olOverlaySource;
            };
        /**
         * Add an OL geometry to the overlay and start modifying it
         * @param olGeometry Ol Geometry
         */
        /**
         * Add an OL geometry to the overlay and start modifying it
         * @param {?} olGeometry Ol Geometry
         * @return {?}
         */
        ModifyControl.prototype.setOlGeometry = /**
         * Add an OL geometry to the overlay and start modifying it
         * @param {?} olGeometry Ol Geometry
         * @return {?}
         */
            function (olGeometry) {
                /** @type {?} */
                var olFeature = new OlFeature({ geometry: olGeometry });
                this.olOverlaySource.clear();
                this.olOverlaySource.addFeature(olFeature);
            };
        /**
         * Create an overlay source if none is defined in the options
         */
        /**
         * Create an overlay source if none is defined in the options
         * @private
         * @return {?}
         */
        ModifyControl.prototype.createOlInnerOverlayLayer = /**
         * Create an overlay source if none is defined in the options
         * @private
         * @return {?}
         */
            function () {
                return new OlVectorLayer({
                    source: this.options.source ? this.options.source : new OlVectorSource(),
                    style: this.options.layerStyle,
                    zIndex: 500
                });
            };
        /**
         * Add the overlay layer if it wasn't defined in the options
         */
        /**
         * Add the overlay layer if it wasn't defined in the options
         * @private
         * @return {?}
         */
        ModifyControl.prototype.addOlInnerOverlayLayer = /**
         * Add the overlay layer if it wasn't defined in the options
         * @private
         * @return {?}
         */
            function () {
                if (this.options.layer === undefined) {
                    this.olMap.addLayer(this.olOverlayLayer);
                }
            };
        /**
         * Clear the overlay layer if it wasn't defined in the options
         */
        /**
         * Clear the overlay layer if it wasn't defined in the options
         * @private
         * @return {?}
         */
        ModifyControl.prototype.removeOlInnerOverlayLayer = /**
         * Clear the overlay layer if it wasn't defined in the options
         * @private
         * @return {?}
         */
            function () {
                if (this.options.layer === undefined && this.olMap !== undefined) {
                    this.olMap.removeLayer(this.olOverlayLayer);
                }
            };
        /**
         * Clear the overlay source if it wasn't defined in the options
         */
        /**
         * Clear the overlay source if it wasn't defined in the options
         * @private
         * @return {?}
         */
        ModifyControl.prototype.clearOlInnerOverlaySource = /**
         * Clear the overlay source if it wasn't defined in the options
         * @private
         * @return {?}
         */
            function () {
                if (this.options.layer === undefined && this.options.source === undefined) {
                    this.olOverlaySource.clear();
                }
            };
        /**
         * @private
         * @return {?}
         */
        ModifyControl.prototype.createOlLinearRingsLayer = /**
         * @private
         * @return {?}
         */
            function () {
                return new OlVectorLayer({
                    source: new OlVectorSource(),
                    style: createDrawHoleInteractionStyle(),
                    zIndex: 500
                });
            };
        /**
         * Add the linear rings layer
         */
        /**
         * Add the linear rings layer
         * @private
         * @return {?}
         */
        ModifyControl.prototype.addOlLinearRingsLayer = /**
         * Add the linear rings layer
         * @private
         * @return {?}
         */
            function () {
                this.olMap.addLayer(this.olLinearRingsLayer);
            };
        /**
         * Clear the linear rings layer
         */
        /**
         * Clear the linear rings layer
         * @private
         * @return {?}
         */
        ModifyControl.prototype.removeOlLinearRingsLayer = /**
         * Clear the linear rings layer
         * @private
         * @return {?}
         */
            function () {
                this.olMap.removeLayer(this.olLinearRingsLayer);
            };
        /**
         * Clear the linear rings source
         */
        /**
         * Clear the linear rings source
         * @private
         * @return {?}
         */
        ModifyControl.prototype.clearOlLinearRingsSource = /**
         * Clear the linear rings source
         * @private
         * @return {?}
         */
            function () {
                this.olLinearRingsSource.clear(true);
            };
        /**
         * Add a modify interaction to the map an set up some listeners
         */
        /**
         * Add a modify interaction to the map an set up some listeners
         * @private
         * @return {?}
         */
        ModifyControl.prototype.addOlModifyInteraction = /**
         * Add a modify interaction to the map an set up some listeners
         * @private
         * @return {?}
         */
            function () {
                /** @type {?} */
                var olModifyInteraction = new OlModify({
                    source: this.olOverlaySource,
                    style: this.options.drawStyle
                });
                this.olModifyInteraction = olModifyInteraction;
            };
        /**
         * Remove the modify interaction
         */
        /**
         * Remove the modify interaction
         * @private
         * @return {?}
         */
        ModifyControl.prototype.removeOlModifyInteraction = /**
         * Remove the modify interaction
         * @private
         * @return {?}
         */
            function () {
                if (this.olModifyInteraction === undefined) {
                    return;
                }
                this.deactivateModifyInteraction();
                this.olModifyInteraction = undefined;
            };
        /**
         * @private
         * @return {?}
         */
        ModifyControl.prototype.activateModifyInteraction = /**
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.olModifyInteractionIsActive === true) {
                    return;
                }
                this.olModifyInteractionIsActive = true;
                this.onModifyStartKey = this.olModifyInteraction
                    .on('modifystart', ( /**
             * @param {?} event
             * @return {?}
             */function (event) { return _this.onModifyStart(event); }));
                this.onModifyEndKey = this.olModifyInteraction
                    .on('modifyend', ( /**
             * @param {?} event
             * @return {?}
             */function (event) { return _this.onModifyEnd(event); }));
                this.olMap.addInteraction(this.olModifyInteraction);
            };
        /**
         * @private
         * @return {?}
         */
        ModifyControl.prototype.deactivateModifyInteraction = /**
         * @private
         * @return {?}
         */
            function () {
                if (this.olModifyInteractionIsActive === false) {
                    return;
                }
                this.olModifyInteractionIsActive = false;
                olobservable.unByKey(this.onModifyStartKey);
                olobservable.unByKey(this.onModifyEndKey);
                if (this.olMap !== undefined) {
                    this.olMap.removeInteraction(this.olModifyInteraction);
                }
            };
        /**
         * When modifying starts, clear the overlay and start watching for changes
         * @param event Modify start event
         */
        /**
         * When modifying starts, clear the overlay and start watching for changes
         * @private
         * @param {?} event Modify start event
         * @return {?}
         */
        ModifyControl.prototype.onModifyStart = /**
         * When modifying starts, clear the overlay and start watching for changes
         * @private
         * @param {?} event Modify start event
         * @return {?}
         */
            function (event) {
                var _this = this;
                /** @type {?} */
                var olGeometry = event.features.item(0).getGeometry();
                this.start$.next(olGeometry);
                this.onModifyKey = olGeometry.on('change', ( /**
                 * @param {?} olGeometryEvent
                 * @return {?}
                 */function (olGeometryEvent) {
                    _this.changes$.next(olGeometryEvent.target);
                }));
            };
        /**
         * When modifying ends, update the geometry observable and stop watching for changes
         * @param event Modify end event
         */
        /**
         * When modifying ends, update the geometry observable and stop watching for changes
         * @private
         * @param {?} event Modify end event
         * @return {?}
         */
        ModifyControl.prototype.onModifyEnd = /**
         * When modifying ends, update the geometry observable and stop watching for changes
         * @private
         * @param {?} event Modify end event
         * @return {?}
         */
            function (event) {
                if (this.onModifyKey !== undefined) {
                    olobservable.unByKey(this.onModifyKey);
                }
                this.end$.next(event.features.item(0).getGeometry());
            };
        /**
         * Subscribe to CTRL key down to activate the draw control
         */
        /**
         * Subscribe to CTRL key down to activate the draw control
         * @private
         * @return {?}
         */
        ModifyControl.prototype.subscribeToKeyDown = /**
         * Subscribe to CTRL key down to activate the draw control
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                this.keyDown$$ = rxjs.fromEvent(document, 'keydown').subscribe(( /**
                 * @param {?} event
                 * @return {?}
                 */function (event) {
                    // On ESC key down, remove the last vertex
                    if (event.keyCode === 27 && _this.olDrawInteractionIsActive === true) {
                        _this.olDrawInteraction.removeLastPoint();
                    }
                }));
            };
        /**
         * Unsubscribe to key down
         */
        /**
         * Unsubscribe to key down
         * @private
         * @return {?}
         */
        ModifyControl.prototype.unsubscribeToKeyDown = /**
         * Unsubscribe to key down
         * @private
         * @return {?}
         */
            function () {
                if (this.keyDown$$ !== undefined) {
                    this.keyDown$$.unsubscribe();
                }
            };
        /**
         * Add a translate interaction to the map an set up some listeners
         */
        /**
         * Add a translate interaction to the map an set up some listeners
         * @private
         * @return {?}
         */
        ModifyControl.prototype.addOlTranslateInteraction = /**
         * Add a translate interaction to the map an set up some listeners
         * @private
         * @return {?}
         */
            function () {
                /** @type {?} */
                var olTranslateInteraction = new OlTranslate({
                    layers: [this.olOverlayLayer]
                });
                this.olTranslateInteraction = olTranslateInteraction;
            };
        /**
         * Remove the translate interaction
         */
        /**
         * Remove the translate interaction
         * @private
         * @return {?}
         */
        ModifyControl.prototype.removeOlTranslateInteraction = /**
         * Remove the translate interaction
         * @private
         * @return {?}
         */
            function () {
                if (this.olTranslateInteraction === undefined) {
                    return;
                }
                this.deactivateTranslateInteraction();
                this.olTranslateInteraction = undefined;
            };
        /**
         * @private
         * @return {?}
         */
        ModifyControl.prototype.activateTranslateInteraction = /**
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.olTranslateInteractionIsActive === true) {
                    return;
                }
                this.olTranslateInteractionIsActive = true;
                this.onTranslateStartKey = this.olTranslateInteraction
                    .on('translatestart', ( /**
             * @param {?} event
             * @return {?}
             */function (event) { return _this.onTranslateStart(event); }));
                this.onTranslateEndKey = this.olTranslateInteraction
                    .on('translateend', ( /**
             * @param {?} event
             * @return {?}
             */function (event) { return _this.onTranslateEnd(event); }));
                this.olMap.addInteraction(this.olTranslateInteraction);
            };
        /**
         * @private
         * @return {?}
         */
        ModifyControl.prototype.deactivateTranslateInteraction = /**
         * @private
         * @return {?}
         */
            function () {
                if (this.olTranslateInteractionIsActive === false) {
                    return;
                }
                this.olTranslateInteractionIsActive = false;
                olobservable.unByKey(this.onTranslateStartKey);
                olobservable.unByKey(this.onTranslateEndKey);
                if (this.olMap !== undefined) {
                    this.olMap.removeInteraction(this.olTranslateInteraction);
                }
            };
        /**
         * When translation starts, clear the overlay and start watching for changes
         * @param event Translate start event
         */
        /**
         * When translation starts, clear the overlay and start watching for changes
         * @private
         * @param {?} event Translate start event
         * @return {?}
         */
        ModifyControl.prototype.onTranslateStart = /**
         * When translation starts, clear the overlay and start watching for changes
         * @private
         * @param {?} event Translate start event
         * @return {?}
         */
            function (event) {
                var _this = this;
                /** @type {?} */
                var olGeometry = event.features.item(0).getGeometry();
                this.start$.next(olGeometry);
                this.onTranslateKey = olGeometry.on('change', ( /**
                 * @param {?} olGeometryEvent
                 * @return {?}
                 */function (olGeometryEvent) {
                    _this.changes$.next(olGeometryEvent.target);
                }));
            };
        /**
         * When translation ends, update the geometry observable and stop watchign for changes
         * @param event Translate end event
         */
        /**
         * When translation ends, update the geometry observable and stop watchign for changes
         * @private
         * @param {?} event Translate end event
         * @return {?}
         */
        ModifyControl.prototype.onTranslateEnd = /**
         * When translation ends, update the geometry observable and stop watchign for changes
         * @private
         * @param {?} event Translate end event
         * @return {?}
         */
            function (event) {
                if (this.onTranslateKey !== undefined) {
                    olobservable.unByKey(this.onTranslateKey);
                }
                this.end$.next(event.features.item(0).getGeometry());
            };
        /**
         * Add a draw interaction to the map an set up some listeners
         */
        /**
         * Add a draw interaction to the map an set up some listeners
         * @private
         * @return {?}
         */
        ModifyControl.prototype.addOlDrawInteraction = /**
         * Add a draw interaction to the map an set up some listeners
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var olDrawInteraction = new OlDraw({
                    type: 'Polygon',
                    source: this.olLinearRingsSource,
                    stopClick: true,
                    style: createDrawHoleInteractionStyle(),
                    condition: ( /**
                     * @param {?} event
                     * @return {?}
                     */function (event) {
                        return _this.getOlGeometry().intersectsCoordinate(event.coordinate);
                    })
                });
                this.olDrawInteraction = olDrawInteraction;
                this.subscribeToDrawKeyDown();
            };
        /**
         * Subscribe to CTRL key down to activate the draw control
         */
        /**
         * Subscribe to CTRL key down to activate the draw control
         * @private
         * @return {?}
         */
        ModifyControl.prototype.subscribeToDrawKeyDown = /**
         * Subscribe to CTRL key down to activate the draw control
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                this.drawKeyDown$$ = rxjs.fromEvent(document, 'keydown').subscribe(( /**
                 * @param {?} event
                 * @return {?}
                 */function (event) {
                    if (event.keyCode !== 17) {
                        return;
                    }
                    _this.unsubscribeToDrawKeyDown();
                    /** @type {?} */
                    var olGeometry = _this.getOlGeometry();
                    if (!olGeometry || !(olGeometry instanceof OlPolygon)) {
                        return;
                    }
                    _this.subscribeToDrawKeyUp();
                    _this.deactivateModifyInteraction();
                    _this.deactivateTranslateInteraction();
                    _this.activateDrawInteraction();
                }));
            };
        /**
         * Subscribe to CTRL key up to deactivate the draw control
         */
        /**
         * Subscribe to CTRL key up to deactivate the draw control
         * @private
         * @return {?}
         */
        ModifyControl.prototype.subscribeToDrawKeyUp = /**
         * Subscribe to CTRL key up to deactivate the draw control
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                this.drawKeyUp$$ = rxjs.fromEvent(document, 'keyup').subscribe(( /**
                 * @param {?} event
                 * @return {?}
                 */function (event) {
                    if (event.keyCode !== 17) {
                        return;
                    }
                    _this.unsubscribeToDrawKeyUp();
                    _this.subscribeToDrawKeyDown();
                    _this.deactivateDrawInteraction();
                    _this.activateModifyInteraction();
                    _this.activateTranslateInteraction();
                }));
            };
        /**
         * Unsubscribe to draw key down
         */
        /**
         * Unsubscribe to draw key down
         * @private
         * @return {?}
         */
        ModifyControl.prototype.unsubscribeToDrawKeyDown = /**
         * Unsubscribe to draw key down
         * @private
         * @return {?}
         */
            function () {
                if (this.drawKeyDown$$ !== undefined) {
                    this.drawKeyDown$$.unsubscribe();
                }
            };
        /**
         * Unsubscribe to key up
         */
        /**
         * Unsubscribe to key up
         * @private
         * @return {?}
         */
        ModifyControl.prototype.unsubscribeToDrawKeyUp = /**
         * Unsubscribe to key up
         * @private
         * @return {?}
         */
            function () {
                if (this.drawKeyUp$$ !== undefined) {
                    this.drawKeyUp$$.unsubscribe();
                }
            };
        /**
         * Remove the draw interaction
         */
        /**
         * Remove the draw interaction
         * @private
         * @return {?}
         */
        ModifyControl.prototype.removeOlDrawInteraction = /**
         * Remove the draw interaction
         * @private
         * @return {?}
         */
            function () {
                if (this.olDrawInteraction === undefined) {
                    return;
                }
                this.unsubscribeToKeyDown();
                this.unsubscribeToDrawKeyUp();
                this.unsubscribeToDrawKeyDown();
                this.deactivateDrawInteraction();
                this.olDrawInteraction = undefined;
            };
        /**
         * Activate the draw interaction
         */
        /**
         * Activate the draw interaction
         * @private
         * @return {?}
         */
        ModifyControl.prototype.activateDrawInteraction = /**
         * Activate the draw interaction
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.olDrawInteractionIsActive === true) {
                    return;
                }
                this.clearOlLinearRingsSource();
                this.addOlLinearRingsLayer();
                this.olMap.getInteractions().forEach(( /**
                 * @param {?} olInteraction
                 * @return {?}
                 */function (olInteraction) {
                    if (olInteraction instanceof OlDragBoxInteraction) {
                        _this.olMap.removeInteraction(olInteraction);
                        _this.removedOlInteractions.push(olInteraction);
                    }
                }));
                this.olDrawInteractionIsActive = true;
                this.onDrawStartKey = this.olDrawInteraction
                    .on('drawstart', ( /**
             * @param {?} event
             * @return {?}
             */function (event) { return _this.onDrawStart(event); }));
                this.onDrawEndKey = this.olDrawInteraction
                    .on('drawend', ( /**
             * @param {?} event
             * @return {?}
             */function (event) { return _this.onDrawEnd(event); }));
                this.olMap.addInteraction(this.olDrawInteraction);
            };
        /**
         * Deactivate the draw interaction
         */
        /**
         * Deactivate the draw interaction
         * @private
         * @return {?}
         */
        ModifyControl.prototype.deactivateDrawInteraction = /**
         * Deactivate the draw interaction
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.olDrawInteractionIsActive === false) {
                    return;
                }
                this.removeOlLinearRingsLayer();
                this.removedOlInteractions.forEach(( /**
                 * @param {?} olInteraction
                 * @return {?}
                 */function (olInteraction) {
                    _this.olMap.addInteraction(olInteraction);
                }));
                this.olDrawInteractionIsActive = false;
                olobservable.unByKey(this.onDrawStartKey);
                olobservable.unByKey(this.onDrawEndKey);
                if (this.olMap !== undefined) {
                    this.olMap.removeInteraction(this.olDrawInteraction);
                }
            };
        /**
         * When draw start, add a new linerar ring to the geometrty and start watching for changes
         * @param event Draw start event
         */
        /**
         * When draw start, add a new linerar ring to the geometrty and start watching for changes
         * @private
         * @param {?} event Draw start event
         * @return {?}
         */
        ModifyControl.prototype.onDrawStart = /**
         * When draw start, add a new linerar ring to the geometrty and start watching for changes
         * @private
         * @param {?} event Draw start event
         * @return {?}
         */
            function (event) {
                var _this = this;
                /** @type {?} */
                var olGeometry = event.feature.getGeometry();
                /** @type {?} */
                var linearRingCoordinates = olGeometry.getLinearRing().getCoordinates();
                this.addLinearRingToOlGeometry(linearRingCoordinates);
                this.start$.next(this.getOlGeometry());
                this.onDrawKey = olGeometry.on('change', ( /**
                 * @param {?} olGeometryEvent
                 * @return {?}
                 */function (olGeometryEvent) {
                    /** @type {?} */
                    var _linearRingCoordinates = olGeometryEvent.target.getLinearRing().getCoordinates();
                    _this.updateLinearRingOfOlGeometry(_linearRingCoordinates);
                    _this.changes$.next(_this.getOlGeometry());
                }));
                this.subscribeToKeyDown();
            };
        /**
         * When translation ends, update the geometry observable and stop watchign for changes
         * @param event Draw end event
         */
        /**
         * When translation ends, update the geometry observable and stop watchign for changes
         * @private
         * @param {?} event Draw end event
         * @return {?}
         */
        ModifyControl.prototype.onDrawEnd = /**
         * When translation ends, update the geometry observable and stop watchign for changes
         * @private
         * @param {?} event Draw end event
         * @return {?}
         */
            function (event) {
                if (this.onDrawKey !== undefined) {
                    olobservable.unByKey(this.onDrawKey);
                }
                /** @type {?} */
                var linearRingCoordinates = event.feature.getGeometry().getLinearRing().getCoordinates();
                this.updateLinearRingOfOlGeometry(linearRingCoordinates);
                this.clearOlLinearRingsSource();
                this.end$.next(this.getOlGeometry());
                this.unsubscribeToKeyDown();
            };
        /**
         * Add a linear ring to the geometry being modified
         * @param coordinates Linear ring coordinates
         */
        /**
         * Add a linear ring to the geometry being modified
         * @private
         * @param {?} coordinates Linear ring coordinates
         * @return {?}
         */
        ModifyControl.prototype.addLinearRingToOlGeometry = /**
         * Add a linear ring to the geometry being modified
         * @private
         * @param {?} coordinates Linear ring coordinates
         * @return {?}
         */
            function (coordinates) {
                /** @type {?} */
                var olGeometry = this.getOlGeometry();
                /** @type {?} */
                var olLinearRing = new OlLinearRing(coordinates);
                addLinearRingToOlPolygon(olGeometry, olLinearRing);
            };
        /**
         * Update the last linear ring of the geometry being modified
         * @param coordinates Linear ring coordinates
         */
        /**
         * Update the last linear ring of the geometry being modified
         * @private
         * @param {?} coordinates Linear ring coordinates
         * @return {?}
         */
        ModifyControl.prototype.updateLinearRingOfOlGeometry = /**
         * Update the last linear ring of the geometry being modified
         * @private
         * @param {?} coordinates Linear ring coordinates
         * @return {?}
         */
            function (coordinates) {
                /** @type {?} */
                var olGeometry = this.getOlGeometry();
                // Remove the last linear ring (the one we are updating)
                /** @type {?} */
                var olLinearRings = olGeometry.getLinearRings().slice(0, -1);
                /** @type {?} */
                var newCoordinates = olLinearRings.map(( /**
                 * @param {?} olLinearRing
                 * @return {?}
                 */function (olLinearRing) {
                    return olLinearRing.getCoordinates();
                }));
                newCoordinates.push(coordinates);
                olGeometry.setCoordinates(newCoordinates);
            };
        /**
         * Get the geometry being modified
         * @returns OL Geometry
         */
        /**
         * Get the geometry being modified
         * @private
         * @return {?} OL Geometry
         */
        ModifyControl.prototype.getOlGeometry = /**
         * Get the geometry being modified
         * @private
         * @return {?} OL Geometry
         */
            function () {
                /** @type {?} */
                var olFeatures = this.olOverlaySource.getFeatures();
                return olFeatures.length > 0 ? olFeatures[0].getGeometry() : undefined;
            };
        return ModifyControl;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Control to modify geometries
     */
    var /**
     * Control to modify geometries
     */ SliceControl = /** @class */ (function () {
        function SliceControl(options) {
            this.options = options;
            /**
             * Slice end observable
             */
            this.end$ = new rxjs.Subject();
            /**
             * Slice error, if any
             */
            this.error$ = new rxjs.Subject();
            if (options.layer !== undefined) {
                this.olOverlayLayer = options.layer;
            }
            else {
                this.olOverlayLayer = this.createOlInnerOverlayLayer();
            }
        }
        Object.defineProperty(SliceControl.prototype, "active", {
            /**
             * Wheter the control is active
             */
            get: /**
             * Wheter the control is active
             * @return {?}
             */ function () {
                return this.olMap !== undefined;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SliceControl.prototype, "olOverlaySource", {
            /**
             * OL overlay source
             * @internal
             */
            get: /**
             * OL overlay source
             * \@internal
             * @return {?}
             */ function () {
                return this.olOverlayLayer.getSource();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Add or remove this control to/from a map.
         * @param map OL Map
         */
        /**
         * Add or remove this control to/from a map.
         * @param {?} olMap
         * @return {?}
         */
        SliceControl.prototype.setOlMap = /**
         * Add or remove this control to/from a map.
         * @param {?} olMap
         * @return {?}
         */
            function (olMap$$1) {
                if (olMap$$1 === undefined) {
                    this.clearOlInnerOverlaySource();
                    this.removeOlInnerOverlayLayer();
                    this.removeDrawLineControl();
                    this.olMap = olMap$$1;
                    return;
                }
                this.olMap = olMap$$1;
                this.addOlInnerOverlayLayer();
                this.addDrawLineControl();
            };
        /**
         * Return the overlay source
         */
        /**
         * Return the overlay source
         * @return {?}
         */
        SliceControl.prototype.getSource = /**
         * Return the overlay source
         * @return {?}
         */
            function () {
                return this.olOverlaySource;
            };
        /**
         * Add an OL geometry to the overlay for slicing
         * @param olGeometry Ol Geometry
         */
        /**
         * Add an OL geometry to the overlay for slicing
         * @param {?} olGeometry Ol Geometry
         * @return {?}
         */
        SliceControl.prototype.setOlGeometry = /**
         * Add an OL geometry to the overlay for slicing
         * @param {?} olGeometry Ol Geometry
         * @return {?}
         */
            function (olGeometry) {
                /** @type {?} */
                var olFeature = new OlFeature({ geometry: olGeometry });
                this.olOverlaySource.clear();
                this.olOverlaySource.addFeature(olFeature);
            };
        /**
         * Create an overlay source if none is defined in the options
         */
        /**
         * Create an overlay source if none is defined in the options
         * @private
         * @return {?}
         */
        SliceControl.prototype.createOlInnerOverlayLayer = /**
         * Create an overlay source if none is defined in the options
         * @private
         * @return {?}
         */
            function () {
                return new OlVectorLayer({
                    source: this.options.source ? this.options.source : new OlVectorSource(),
                    style: this.options.layerStyle,
                    zIndex: 500
                });
            };
        /**
         * Clear the overlay layer if it wasn't defined in the options
         */
        /**
         * Clear the overlay layer if it wasn't defined in the options
         * @private
         * @return {?}
         */
        SliceControl.prototype.removeOlInnerOverlayLayer = /**
         * Clear the overlay layer if it wasn't defined in the options
         * @private
         * @return {?}
         */
            function () {
                if (this.options.layer === undefined && this.olMap !== undefined) {
                    this.olMap.removeLayer(this.olOverlayLayer);
                }
            };
        /**
         * Add the overlay layer if it wasn't defined in the options
         */
        /**
         * Add the overlay layer if it wasn't defined in the options
         * @private
         * @return {?}
         */
        SliceControl.prototype.addOlInnerOverlayLayer = /**
         * Add the overlay layer if it wasn't defined in the options
         * @private
         * @return {?}
         */
            function () {
                if (this.options.layer === undefined) {
                    this.olMap.addLayer(this.olOverlayLayer);
                }
            };
        /**
         * Clear the overlay source if it wasn't defined in the options
         */
        /**
         * Clear the overlay source if it wasn't defined in the options
         * @private
         * @return {?}
         */
        SliceControl.prototype.clearOlInnerOverlaySource = /**
         * Clear the overlay source if it wasn't defined in the options
         * @private
         * @return {?}
         */
            function () {
                if (this.options.layer === undefined && this.options.source === undefined) {
                    this.olOverlaySource.clear();
                }
            };
        /**
         * Create a draw line control and add it to the map
         */
        /**
         * Create a draw line control and add it to the map
         * @private
         * @return {?}
         */
        SliceControl.prototype.addDrawLineControl = /**
         * Create a draw line control and add it to the map
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                this.drawLineControl = new DrawControl({
                    geometryType: 'LineString',
                    drawStyle: this.options.drawStyle,
                    maxPoints: 2
                });
                this.drawLineStart$$ = this.drawLineControl.start$
                    .subscribe(( /**
             * @param {?} olLine
             * @return {?}
             */function (olLine) { return _this.onDrawLineStart(olLine); }));
                this.drawLineEnd$$ = this.drawLineControl.end$
                    .subscribe(( /**
             * @param {?} olLine
             * @return {?}
             */function (olLine) { return _this.onDrawLineEnd(olLine); }));
                this.drawLineControl.setOlMap(this.olMap);
            };
        /**
         * Remove draw line control
         */
        /**
         * Remove draw line control
         * @private
         * @return {?}
         */
        SliceControl.prototype.removeDrawLineControl = /**
         * Remove draw line control
         * @private
         * @return {?}
         */
            function () {
                if (this.drawLineControl === undefined) {
                    return;
                }
                this.drawLineStart$$.unsubscribe();
                this.drawLineEnd$$.unsubscribe();
                this.drawLineControl.getSource().clear();
                this.drawLineControl.setOlMap(undefined);
            };
        /**
         * Clear the draw source and track the geometry being draw
         * @param olLine Ol linestring or polygon
         */
        /**
         * Clear the draw source and track the geometry being draw
         * @private
         * @param {?} olLine Ol linestring or polygon
         * @return {?}
         */
        SliceControl.prototype.onDrawLineStart = /**
         * Clear the draw source and track the geometry being draw
         * @private
         * @param {?} olLine Ol linestring or polygon
         * @return {?}
         */
            function (olLine) {
                this.drawLineControl.getSource().clear();
            };
        /**
         * Slice the first geometry encountered with the drawn line
         * @param olLine Ol linestring
         */
        /**
         * Slice the first geometry encountered with the drawn line
         * @private
         * @param {?} olLine Ol linestring
         * @return {?}
         */
        SliceControl.prototype.onDrawLineEnd = /**
         * Slice the first geometry encountered with the drawn line
         * @private
         * @param {?} olLine Ol linestring
         * @return {?}
         */
            function (olLine) {
                var _this = this;
                /** @type {?} */
                var olSlicedGeometries = [];
                /** @type {?} */
                var lineExtent = olLine.getExtent();
                /** @type {?} */
                var olFeaturesToRemove = [];
                try {
                    this.olOverlaySource.forEachFeatureInExtent(lineExtent, ( /**
                     * @param {?} olFeature
                     * @return {?}
                     */function (olFeature) {
                        /** @type {?} */
                        var olGeometry = olFeature.getGeometry();
                        /** @type {?} */
                        var olParts = sliceOlGeometry(olGeometry, olLine);
                        if (olParts.length > 0) {
                            olSlicedGeometries.push.apply(olSlicedGeometries, __spread(olParts));
                            olFeaturesToRemove.push(olFeature);
                        }
                    }));
                }
                catch (e) {
                    if (e instanceof GeometrySliceError) {
                        this.error$.next(e);
                        return;
                    }
                    else {
                        throw e;
                    }
                }
                this.drawLineControl.getSource().clear();
                this.olOverlaySource.addFeatures(olSlicedGeometries.map(( /**
                 * @param {?} olGeometry
                 * @return {?}
                 */function (olGeometry) { return new OlFeature(olGeometry); })));
                olFeaturesToRemove.forEach(( /**
                 * @param {?} olFeature
                 * @return {?}
                 */function (olFeature) {
                    _this.olOverlaySource.removeFeature(olFeature);
                }));
                this.error$.next(undefined);
                this.end$.next(olSlicedGeometries);
            };
        return SliceControl;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MeasurerDialogComponent = /** @class */ (function () {
        function MeasurerDialogComponent(dialogRef, data) {
            this.dialogRef = dialogRef;
            this.data = data;
            this.measureAreaUnit = MeasureAreaUnit;
            this.measureLengthUnit = MeasureLengthUnit;
        }
        /**
         * @return {?}
         */
        MeasurerDialogComponent.prototype.onNoClick = /**
         * @return {?}
         */
            function () {
                this.dialogRef.close();
            };
        MeasurerDialogComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'igo-measurer-dialog',
                        template: "<div mat-dialog-content>\r\n  <h3>{{'igo.geo.measure.dialog.title' | translate}}</h3>\r\n\r\n  <table>\r\n    <thead>\r\n      <tr>\r\n        <th colspan=\"2\">{{'igo.geo.measure.dialog.length.title' | translate}}</th>\r\n      </tr>\r\n    </thead>\r\n    <tbody>\r\n      <tr>\r\n        <td>{{'igo.geo.measure.dialog.lengthInMeters' | translate}}</td>\r\n        <td>{{data.length | measureFormat: measureLengthUnit.Meters}}</td>\r\n      </tr>\r\n      <tr>\r\n        <td>{{'igo.geo.measure.dialog.lengthInKilometers' | translate}}</td>\r\n        <td>{{data.length | measureFormat: measureLengthUnit.Kilometers}}</td>\r\n      </tr>\r\n      <tr>\r\n        <td>{{'igo.geo.measure.dialog.lengthInMiles' | translate}}</td>\r\n        <td>{{data.length | measureFormat: measureLengthUnit.Miles}}</td>\r\n      </tr>\r\n      <tr>\r\n        <td>{{'igo.geo.measure.dialog.lengthInFeet' | translate}}</td>\r\n        <td>{{data.length | measureFormat: measureLengthUnit.Feet}}</td>\r\n      </tr>\r\n    </tbody>\r\n  </table>\r\n\r\n  <table>\r\n    <thead>\r\n      <tr>\r\n        <th colspan=\"2\">{{'igo.geo.measure.dialog.area.title' | translate}}</th>\r\n      </tr>\r\n    </thead>\r\n    <tbody>\r\n      <tr>\r\n        <td>{{'igo.geo.measure.dialog.areaInSquareMeters' | translate}}</td>\r\n        <td>{{data.area | measureFormat: measureAreaUnit.SquareMeters}}</td>\r\n      </tr>\r\n      <tr>\r\n        <td>{{'igo.geo.measure.dialog.areaInSquareKilometers' | translate}}</td>\r\n        <td>{{data.area | measureFormat:measureAreaUnit.SquareKilometers}}</td>\r\n      </tr>\r\n      <tr>\r\n        <td>{{'igo.geo.measure.dialog.areaInSquareMiles' | translate}}</td>\r\n        <td>{{data.area | measureFormat: measureAreaUnit.SquareMiles}}</td>\r\n      </tr>\r\n      <tr>\r\n        <td>{{'igo.geo.measure.dialog.areaInAcres' | translate}}</td>\r\n        <td>{{data.area | measureFormat: measureAreaUnit.Acres}}</td>\r\n      </tr>\r\n      <tr>\r\n        <td>{{'igo.geo.measure.dialog.areaInHectares' | translate}}</td>\r\n        <td>{{data.area | measureFormat: measureAreaUnit.Hectares}}</td>\r\n      </tr>\r\n      <tr>\r\n        <td>{{'igo.geo.measure.dialog.perimeterInMeters' | translate}}</td>\r\n        <td>{{data.perimeter | measureFormat: measureLengthUnit.Meters}}</td>\r\n      </tr>\r\n    </tbody>\r\n  </table>\r\n</div>\r\n",
                        styles: ["h3{text-align:center;margin:0}table{width:100%;padding:10px}table tbody tr td:last-child{padding-left:10px}"]
                    }] }
        ];
        /** @nocollapse */
        MeasurerDialogComponent.ctorParameters = function () {
            return [
                { type: material.MatDialogRef },
                { type: undefined, decorators: [{ type: i0.Inject, args: [material.MAT_DIALOG_DATA,] }] }
            ];
        };
        return MeasurerDialogComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Tool to measure lengths and areas
     */
    var MeasurerComponent = /** @class */ (function () {
        function MeasurerComponent(languageService, dialog) {
            var _this = this;
            this.languageService = languageService;
            this.dialog = dialog;
            /**
             * Table template
             * \@internal
             */
            this.tableTemplate = {
                selection: true,
                selectMany: true,
                selectionCheckbox: true,
                sort: true,
                columns: [
                    {
                        name: 'length',
                        title: this.languageService.translate.instant('igo.geo.measure.lengthHeader'),
                        valueAccessor: ( /**
                         * @param {?} feature
                         * @return {?}
                         */function (feature) {
                            /** @type {?} */
                            var unit = _this.activeLengthUnit;
                            /** @type {?} */
                            var measure = metersToUnit(feature.properties.measure.length, unit);
                            return formatMeasure(measure, {
                                decimal: 1,
                                unit: unit,
                                unitAbbr: false,
                                locale: 'fr'
                            });
                        })
                    },
                    {
                        name: 'area',
                        title: this.languageService.translate.instant('igo.geo.measure.areaHeader'),
                        valueAccessor: ( /**
                         * @param {?} feature
                         * @return {?}
                         */function (feature) {
                            /** @type {?} */
                            var unit = _this.activeAreaUnit;
                            /** @type {?} */
                            var measure = squareMetersToUnit(feature.properties.measure.area, unit);
                            return measure ? formatMeasure(measure, {
                                decimal: 1,
                                unit: unit,
                                unitAbbr: false,
                                locale: 'fr'
                            }) : '';
                        })
                    }
                ]
            };
            /**
             * Reference to the MeasureType enum
             * \@internal
             */
            this.measureType = MeasureType;
            /**
             * Reference to the AreaMeasureUnit enum
             * \@internal
             */
            this.measureAreaUnit = MeasureAreaUnit;
            /**
             * Reference to the LengthMeasureUnit enum
             * \@internal
             */
            this.measureLengthUnit = MeasureLengthUnit;
            /**
             * Whether measure units should be automatically determined
             * \@internal
             */
            this.measureUnitsAuto = false;
            /**
             * Observable of area
             * \@internal
             */
            this.measure$ = new rxjs.BehaviorSubject({});
            /**
             * Observable of selected features
             * \@internal
             */
            this.selectedFeatures$ = new rxjs.BehaviorSubject([]);
            /**
             * OL draw source
             * \@internal
             */
            this.showTooltips = true;
            /**
             * Active mlength unit
             */
            this.activeLengthUnit = MeasureLengthUnit.Meters;
            /**
             * Active area unit
             */
            this.activeAreaUnit = MeasureAreaUnit.SquareMeters;
            /**
             * OL draw source
             */
            this.olDrawSource = new OlVectorSource();
            this._activeMeasureType = MeasureType.Length;
            /**
             * The minimum length a segment must have to display a tooltip.
             * It also applies to area tooltips.
             */
            this.minSegmentLength = 10;
        }
        Object.defineProperty(MeasurerComponent.prototype, "activeMeasureType", {
            get: /**
             * @return {?}
             */ function () { return this._activeMeasureType; },
            /**
             * Measure type
             * @internal
             */
            set: /**
             * Measure type
             * \@internal
             * @param {?} value
             * @return {?}
             */ function (value) { this.setActiveMeasureType(value); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MeasurerComponent.prototype, "drawControlIsActive", {
            /**
             * Wheter one of the draw control is active
             * @internal
             */
            get: /**
             * Wheter one of the draw control is active
             * \@internal
             * @return {?}
             */ function () {
                return this.activeDrawControl !== undefined;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MeasurerComponent.prototype, "projection", {
            get: /**
             * @return {?}
             */ function () {
                return this.map.ol.getView().getProjection();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Add draw controls and activate one
         * @internal
         */
        /**
         * Add draw controls and activate one
         * \@internal
         * @return {?}
         */
        MeasurerComponent.prototype.ngOnInit = /**
         * Add draw controls and activate one
         * \@internal
         * @return {?}
         */
            function () {
                this.initStore();
                this.createDrawLineControl();
                this.createDrawPolygonControl();
                this.createModifyControl();
                this.toggleDrawControl();
                this.onToggleTooltips(this.showTooltips);
                this.updateTooltipsOfOlSource(this.store.source.ol);
            };
        /**
         * Clear the overlay layer and any interaction added by this component.
         * @internal
         */
        /**
         * Clear the overlay layer and any interaction added by this component.
         * \@internal
         * @return {?}
         */
        MeasurerComponent.prototype.ngOnDestroy = /**
         * Clear the overlay layer and any interaction added by this component.
         * \@internal
         * @return {?}
         */
            function () {
                this.setActiveMeasureType(undefined);
                this.deactivateModifyControl();
                this.freezeStore();
            };
        /**
         * Set the measure type
         * @internal
         */
        /**
         * Set the measure type
         * \@internal
         * @param {?} measureType
         * @return {?}
         */
        MeasurerComponent.prototype.onMeasureTypeChange = /**
         * Set the measure type
         * \@internal
         * @param {?} measureType
         * @return {?}
         */
            function (measureType) {
                this.activeMeasureType = measureType;
            };
        /**
         * Activate or deactivate the current draw control
         * @internal
         */
        /**
         * Activate or deactivate the current draw control
         * \@internal
         * @param {?} toggle
         * @return {?}
         */
        MeasurerComponent.prototype.onToggleDrawControl = /**
         * Activate or deactivate the current draw control
         * \@internal
         * @param {?} toggle
         * @return {?}
         */
            function (toggle) {
                if (toggle === true) {
                    this.toggleDrawControl();
                }
                else {
                    this.deactivateDrawControl();
                }
            };
        /**
         * Activate or deactivate the current draw control
         * @internal
         */
        /**
         * Activate or deactivate the current draw control
         * \@internal
         * @param {?} toggle
         * @return {?}
         */
        MeasurerComponent.prototype.onToggleTooltips = /**
         * Activate or deactivate the current draw control
         * \@internal
         * @param {?} toggle
         * @return {?}
         */
            function (toggle) {
                this.showTooltips = toggle;
                if (toggle === true) {
                    this.showTooltipsOfOlSource(this.store.source.ol);
                }
                else {
                    this.clearTooltipsOfOlSource(this.store.source.ol);
                }
            };
        /**
         * Activate or deactivate the current draw control
         * @internal
         */
        /**
         * Activate or deactivate the current draw control
         * \@internal
         * @param {?} toggle
         * @return {?}
         */
        MeasurerComponent.prototype.onToggleMeasureUnitsAuto = /**
         * Activate or deactivate the current draw control
         * \@internal
         * @param {?} toggle
         * @return {?}
         */
            function (toggle) {
                this.measureUnitsAuto = toggle;
            };
        /**
         * Set the measure type
         * @internal
         */
        /**
         * Set the measure type
         * \@internal
         * @param {?} unit
         * @return {?}
         */
        MeasurerComponent.prototype.onLengthUnitChange = /**
         * Set the measure type
         * \@internal
         * @param {?} unit
         * @return {?}
         */
            function (unit) {
                this.activeLengthUnit = unit;
                this.table.refresh();
                this.updateTooltipsOfOlSource(this.store.source.ol);
                if (this.activeOlGeometry !== undefined) {
                    this.updateTooltipsOfOlGeometry(this.activeOlGeometry);
                }
            };
        /**
         * Set the measure type
         * @internal
         */
        /**
         * Set the measure type
         * \@internal
         * @param {?} unit
         * @return {?}
         */
        MeasurerComponent.prototype.onAreaUnitChange = /**
         * Set the measure type
         * \@internal
         * @param {?} unit
         * @return {?}
         */
            function (unit) {
                this.activeAreaUnit = unit;
                this.table.refresh();
                this.updateTooltipsOfOlSource(this.store.source.ol);
                if (this.activeOlGeometry !== undefined) {
                    this.updateTooltipsOfOlGeometry(this.activeOlGeometry);
                }
            };
        /**
         * @return {?}
         */
        MeasurerComponent.prototype.onCalculateClick = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var features = this.selectedFeatures$.value;
                /** @type {?} */
                var area = features.reduce(( /**
                 * @param {?} sum
                 * @param {?} feature
                 * @return {?}
                 */function (sum, feature) {
                    return sum + feature.properties.measure.area || 0;
                }), 0);
                /** @type {?} */
                var length = features.reduce(( /**
                 * @param {?} sum
                 * @param {?} feature
                 * @return {?}
                 */function (sum, feature) {
                    if (feature.geometry.type === 'Polygon') {
                        return sum;
                    }
                    return sum + feature.properties.measure.length || 0;
                }), 0);
                /** @type {?} */
                var perimeter = features.reduce(( /**
                 * @param {?} sum
                 * @param {?} feature
                 * @return {?}
                 */function (sum, feature) {
                    if (feature.geometry.type === 'LineString') {
                        return sum;
                    }
                    return sum + feature.properties.measure.length || 0;
                }), 0);
                this.openDialog({
                    area: area,
                    length: length,
                    perimeter: perimeter
                });
            };
        /**
         * @return {?}
         */
        MeasurerComponent.prototype.onDeleteClick = /**
         * @return {?}
         */
            function () {
                this.store.deleteMany(this.selectedFeatures$.value);
            };
        /**
         * @return {?}
         */
        MeasurerComponent.prototype.onModifyClick = /**
         * @return {?}
         */
            function () {
                if (this.selectedFeatures$.value.length !== 1) {
                    return;
                }
                if (this.modifyControl.active === true) {
                    this.deactivateModifyControl();
                    this.toggleDrawControl();
                }
                else {
                    /** @type {?} */
                    var feature_1 = this.selectedFeatures$.value[0];
                    /** @type {?} */
                    var olFeatures = this.store.layer.ol.getSource().getFeatures();
                    /** @type {?} */
                    var olFeature = olFeatures.find(( /**
                     * @param {?} _olFeature
                     * @return {?}
                     */function (_olFeature) {
                        return _olFeature.get('id') === feature_1.properties.id;
                    }));
                    if (olFeature !== undefined) {
                        this.deactivateDrawControl();
                        this.activateModifyControl();
                        /** @type {?} */
                        var olGeometry = olFeature.getGeometry();
                        this.clearTooltipsOfOlGeometry(olGeometry);
                        this.modifyControl.setOlGeometry(olGeometry);
                    }
                }
            };
        /**
         * @private
         * @param {?} data
         * @return {?}
         */
        MeasurerComponent.prototype.openDialog = /**
         * @private
         * @param {?} data
         * @return {?}
         */
            function (data) {
                this.dialog.open(MeasurerDialogComponent, { data: data });
            };
        /**
         * Initialize the measure store and set up some listeners
         * @internal
         */
        /**
         * Initialize the measure store and set up some listeners
         * \@internal
         * @private
         * @return {?}
         */
        MeasurerComponent.prototype.initStore = /**
         * Initialize the measure store and set up some listeners
         * \@internal
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var store = this.store;
                /** @type {?} */
                var layer = new VectorLayer({
                    title: 'Measures',
                    zIndex: 200,
                    source: new FeatureDataSource(),
                    style: createMeasureLayerStyle(),
                    showInLayerList: false,
                    exportable: false,
                    browsable: false
                });
                tryBindStoreLayer(store, layer);
                tryAddLoadingStrategy(store);
                tryAddSelectionStrategy(store, new FeatureStoreSelectionStrategy({
                    map: this.map,
                    many: true
                }));
                this.onFeatureAddedKey = store.source.ol.on('addfeature', ( /**
                 * @param {?} event
                 * @return {?}
                 */function (event) {
                    /** @type {?} */
                    var feature = event.feature;
                    /** @type {?} */
                    var olGeometry = feature.getGeometry();
                    _this.updateMeasureOfOlGeometry(olGeometry, feature.get('measure'));
                }));
                this.onFeatureRemovedKey = store.source.ol.on('removefeature', ( /**
                 * @param {?} event
                 * @return {?}
                 */function (event) {
                    /** @type {?} */
                    var olGeometry = event.feature.getGeometry();
                    _this.clearTooltipsOfOlGeometry(olGeometry);
                }));
                this.selectedFeatures$$ = store.stateView.manyBy$(( /**
                 * @param {?} record
                 * @return {?}
                 */function (record) {
                    return record.state.selected === true;
                })).pipe(operators.skip(1) // Skip initial emission
                )
                    .subscribe(( /**
             * @param {?} records
             * @return {?}
             */function (records) {
                    if (_this.modifyControl.active === true) {
                        _this.deactivateModifyControl();
                    }
                    _this.selectedFeatures$.next(records.map(( /**
                     * @param {?} record
                     * @return {?}
                     */function (record) { return record.entity; })));
                }));
            };
        /**
         * Freeze any store, meaning the layer is removed, strategies are deactivated
         * and some listener removed
         * @internal
         */
        /**
         * Freeze any store, meaning the layer is removed, strategies are deactivated
         * and some listener removed
         * \@internal
         * @private
         * @return {?}
         */
        MeasurerComponent.prototype.freezeStore = /**
         * Freeze any store, meaning the layer is removed, strategies are deactivated
         * and some listener removed
         * \@internal
         * @private
         * @return {?}
         */
            function () {
                /** @type {?} */
                var store = this.store;
                this.selectedFeatures$$.unsubscribe();
                olobservable.unByKey(this.onFeatureAddedKey);
                olobservable.unByKey(this.onFeatureRemovedKey);
                this.clearTooltipsOfOlSource(store.source.ol);
                this.map.removeLayer(store.layer);
                store.deactivateStrategyOfType(FeatureStoreLoadingStrategy);
                store.deactivateStrategyOfType(FeatureStoreSelectionStrategy);
            };
        /**
         * Create a draw line control
         */
        /**
         * Create a draw line control
         * @private
         * @return {?}
         */
        MeasurerComponent.prototype.createDrawLineControl = /**
         * Create a draw line control
         * @private
         * @return {?}
         */
            function () {
                this.drawLineControl = new DrawControl({
                    geometryType: 'LineString',
                    source: this.olDrawSource,
                    drawStyle: createMeasureInteractionStyle(),
                    layerStyle: new OlStyle({})
                });
            };
        /**
         * Create a draw polygon control
         */
        /**
         * Create a draw polygon control
         * @private
         * @return {?}
         */
        MeasurerComponent.prototype.createDrawPolygonControl = /**
         * Create a draw polygon control
         * @private
         * @return {?}
         */
            function () {
                this.drawPolygonControl = new DrawControl({
                    geometryType: 'Polygon',
                    source: this.olDrawSource,
                    drawStyle: createMeasureInteractionStyle(),
                    layerStyle: new OlStyle({})
                });
            };
        /**
         * Create a draw polygon control
         */
        /**
         * Create a draw polygon control
         * @private
         * @return {?}
         */
        MeasurerComponent.prototype.createModifyControl = /**
         * Create a draw polygon control
         * @private
         * @return {?}
         */
            function () {
                this.modifyControl = new ModifyControl({
                    source: this.olDrawSource,
                    drawStyle: createMeasureInteractionStyle(),
                    layerStyle: new OlStyle({})
                });
            };
        /**
         * Activate the right control
         */
        /**
         * Activate the right control
         * @private
         * @return {?}
         */
        MeasurerComponent.prototype.toggleDrawControl = /**
         * Activate the right control
         * @private
         * @return {?}
         */
            function () {
                this.deactivateDrawControl();
                // this.deactivateModifyControl();
                if (this.activeMeasureType === MeasureType.Length) {
                    this.activateDrawControl(this.drawLineControl);
                }
                else if (this.activeMeasureType === MeasureType.Area) {
                    this.activateDrawControl(this.drawPolygonControl);
                }
            };
        /**
         * Activate a given control
         * @param drawControl Draw control
         */
        /**
         * Activate a given control
         * @private
         * @param {?} drawControl Draw control
         * @return {?}
         */
        MeasurerComponent.prototype.activateDrawControl = /**
         * Activate a given control
         * @private
         * @param {?} drawControl Draw control
         * @return {?}
         */
            function (drawControl) {
                var _this = this;
                this.activeDrawControl = drawControl;
                this.drawStart$$ = drawControl.start$
                    .subscribe(( /**
             * @param {?} olGeometry
             * @return {?}
             */function (olGeometry) { return _this.onDrawStart(olGeometry); }));
                this.drawEnd$$ = drawControl.end$
                    .subscribe(( /**
             * @param {?} olGeometry
             * @return {?}
             */function (olGeometry) { return _this.onDrawEnd(olGeometry); }));
                this.drawChanges$$ = drawControl.changes$
                    .subscribe(( /**
             * @param {?} olGeometry
             * @return {?}
             */function (olGeometry) { return _this.onDrawChanges(olGeometry); }));
                drawControl.setOlMap(this.map.ol);
            };
        /**
         * Deactivate the active draw control
         */
        /**
         * Deactivate the active draw control
         * @private
         * @return {?}
         */
        MeasurerComponent.prototype.deactivateDrawControl = /**
         * Deactivate the active draw control
         * @private
         * @return {?}
         */
            function () {
                if (this.activeDrawControl === undefined) {
                    return;
                }
                this.olDrawSource.clear();
                if (this.drawStart$$ !== undefined) {
                    this.drawStart$$.unsubscribe();
                }
                if (this.drawEnd$$ !== undefined) {
                    this.drawEnd$$.unsubscribe();
                }
                if (this.drawChanges$$ !== undefined) {
                    this.drawChanges$$.unsubscribe();
                }
                this.clearTooltipsOfOlSource(this.olDrawSource);
                if (this.activeOlGeometry !== undefined) {
                    this.clearTooltipsOfOlGeometry(this.activeOlGeometry);
                }
                this.activeDrawControl.setOlMap(undefined);
                this.activeDrawControl = undefined;
                this.activeOlGeometry = undefined;
            };
        /**
         * @private
         * @param {?} measureType
         * @return {?}
         */
        MeasurerComponent.prototype.setActiveMeasureType = /**
         * @private
         * @param {?} measureType
         * @return {?}
         */
            function (measureType) {
                this._activeMeasureType = measureType;
                this.clearMeasures();
                this.toggleDrawControl();
            };
        /**
         * Clear the draw source and track the geometry being drawn
         * @param olGeometry Ol linestring or polygon
         */
        /**
         * Clear the draw source and track the geometry being drawn
         * @private
         * @param {?} olGeometry Ol linestring or polygon
         * @return {?}
         */
        MeasurerComponent.prototype.onDrawStart = /**
         * Clear the draw source and track the geometry being drawn
         * @private
         * @param {?} olGeometry Ol linestring or polygon
         * @return {?}
         */
            function (olGeometry) {
                this.activeOlGeometry = olGeometry;
            };
        /**
         * Clear the draw source and track the geometry being draw
         * @param olGeometry Ol linestring or polygon
         */
        /**
         * Clear the draw source and track the geometry being draw
         * @private
         * @param {?} olGeometry Ol linestring or polygon
         * @return {?}
         */
        MeasurerComponent.prototype.onDrawEnd = /**
         * Clear the draw source and track the geometry being draw
         * @private
         * @param {?} olGeometry Ol linestring or polygon
         * @return {?}
         */
            function (olGeometry) {
                this.activeOlGeometry = undefined;
                this.finalizeMeasureOfOlGeometry(olGeometry);
                this.addFeatureToStore(olGeometry);
                this.clearTooltipsOfOlGeometry(olGeometry);
                this.olDrawSource.clear(true);
            };
        /**
         * Update measures observables and map tooltips
         * @param olGeometry Ol linestring or polygon
         */
        /**
         * Update measures observables and map tooltips
         * @private
         * @param {?} olGeometry Ol linestring or polygon
         * @return {?}
         */
        MeasurerComponent.prototype.onDrawChanges = /**
         * Update measures observables and map tooltips
         * @private
         * @param {?} olGeometry Ol linestring or polygon
         * @return {?}
         */
            function (olGeometry) {
                /** @type {?} */
                var measure = measureOlGeometry(olGeometry, this.projection);
                this.updateMeasureOfOlGeometry(olGeometry, Object.assign({}, measure, {
                    area: undefined // We don't want to display an area tooltip while drawing.
                }));
                this.measure$.next(measure);
            };
        /**
         * Activate a given control
         * @param modifyControl Modify control
         */
        /**
         * Activate a given control
         * @private
         * @return {?}
         */
        MeasurerComponent.prototype.activateModifyControl = /**
         * Activate a given control
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var selection = ( /** @type {?} */(this.store.getStrategyOfType(FeatureStoreSelectionStrategy)));
                selection.deactivate();
                selection.clear();
                this.modifyStart$$ = this.modifyControl.start$
                    .subscribe(( /**
             * @param {?} olGeometry
             * @return {?}
             */function (olGeometry) { return _this.onModifyStart(olGeometry); }));
                this.modifyEnd$$ = this.modifyControl.end$
                    .subscribe(( /**
             * @param {?} olGeometry
             * @return {?}
             */function (olGeometry) { return _this.onModifyEnd(olGeometry); }));
                this.modifyChanges$$ = this.modifyControl.changes$
                    .subscribe(( /**
             * @param {?} olGeometry
             * @return {?}
             */function (olGeometry) { return _this.onModifyChanges(olGeometry); }));
                this.modifyControl.setOlMap(this.map.ol);
            };
        /**
         * Deactivate the active modify control
         */
        /**
         * Deactivate the active modify control
         * @private
         * @return {?}
         */
        MeasurerComponent.prototype.deactivateModifyControl = /**
         * Deactivate the active modify control
         * @private
         * @return {?}
         */
            function () {
                if (this.modifyStart$$ !== undefined) {
                    this.modifyStart$$.unsubscribe();
                }
                if (this.modifyEnd$$ !== undefined) {
                    this.modifyEnd$$.unsubscribe();
                }
                if (this.modifyChanges$$ !== undefined) {
                    this.modifyChanges$$.unsubscribe();
                }
                if (this.activeOlGeometry !== undefined) {
                    if (this.selectedFeatures$.value.length === 1) {
                        /** @type {?} */
                        var feature = this.selectedFeatures$.value[0];
                        this.addFeatureToStore(this.activeOlGeometry, feature);
                    }
                    this.finalizeMeasureOfOlGeometry(this.activeOlGeometry);
                }
                this.olDrawSource.clear();
                this.store.activateStrategyOfType(FeatureStoreSelectionStrategy);
                this.activeOlGeometry = undefined;
                this.modifyControl.setOlMap(undefined);
            };
        /**
         * Clear the draw source and track the geometry being drawn
         * @param olGeometry Ol linestring or polygon
         */
        /**
         * Clear the draw source and track the geometry being drawn
         * @private
         * @param {?} olGeometry Ol linestring or polygon
         * @return {?}
         */
        MeasurerComponent.prototype.onModifyStart = /**
         * Clear the draw source and track the geometry being drawn
         * @private
         * @param {?} olGeometry Ol linestring or polygon
         * @return {?}
         */
            function (olGeometry) {
                this.onDrawStart(olGeometry);
            };
        /**
         * Update measures observables and map tooltips
         * @param olGeometry Ol linestring or polygon
         */
        /**
         * Update measures observables and map tooltips
         * @private
         * @param {?} olGeometry Ol linestring or polygon
         * @return {?}
         */
        MeasurerComponent.prototype.onModifyChanges = /**
         * Update measures observables and map tooltips
         * @private
         * @param {?} olGeometry Ol linestring or polygon
         * @return {?}
         */
            function (olGeometry) {
                this.onDrawChanges(olGeometry);
            };
        /**
         * Clear the draw source and track the geometry being draw
         * @param olGeometry Ol linestring or polygon
         */
        /**
         * Clear the draw source and track the geometry being draw
         * @private
         * @param {?} olGeometry Ol linestring or polygon
         * @return {?}
         */
        MeasurerComponent.prototype.onModifyEnd = /**
         * Clear the draw source and track the geometry being draw
         * @private
         * @param {?} olGeometry Ol linestring or polygon
         * @return {?}
         */
            function (olGeometry) {
                this.finalizeMeasureOfOlGeometry(olGeometry);
            };
        /**
         * @private
         * @param {?} olGeometry
         * @return {?}
         */
        MeasurerComponent.prototype.finalizeMeasureOfOlGeometry = /**
         * @private
         * @param {?} olGeometry
         * @return {?}
         */
            function (olGeometry) {
                /** @type {?} */
                var measure = measureOlGeometry(olGeometry, this.projection);
                if (olGeometry instanceof OlPolygon) {
                    measure = Object.assign({}, measure, {
                        lengths: [] // We don't want to display an area tooltip while drawing.
                    });
                }
                this.updateMeasureOfOlGeometry(olGeometry, measure);
            };
        /**
         * Update measures observables
         * @param olGeometry Ol linestring or polygon
         * @param measure Measure
         */
        /**
         * Update measures observables
         * @private
         * @param {?} olGeometry Ol linestring or polygon
         * @param {?} measure Measure
         * @return {?}
         */
        MeasurerComponent.prototype.updateMeasureOfOlGeometry = /**
         * Update measures observables
         * @private
         * @param {?} olGeometry Ol linestring or polygon
         * @param {?} measure Measure
         * @return {?}
         */
            function (olGeometry, measure) {
                olGeometry.setProperties({ _measure: measure }, true);
                this.updateTooltipsOfOlGeometry(olGeometry);
            };
        /**
         * Clear the measures observables
         */
        /**
         * Clear the measures observables
         * @private
         * @return {?}
         */
        MeasurerComponent.prototype.clearMeasures = /**
         * Clear the measures observables
         * @private
         * @return {?}
         */
            function () {
                this.measure$.next({});
            };
        /**
         * Add a feature with measures to the store. The loading stragegy of the store
         * will trigger and add the feature to the map.
         * @internal
         */
        /**
         * Add a feature with measures to the store. The loading stragegy of the store
         * will trigger and add the feature to the map.
         * \@internal
         * @private
         * @param {?} olGeometry
         * @param {?=} feature
         * @return {?}
         */
        MeasurerComponent.prototype.addFeatureToStore = /**
         * Add a feature with measures to the store. The loading stragegy of the store
         * will trigger and add the feature to the map.
         * \@internal
         * @private
         * @param {?} olGeometry
         * @param {?=} feature
         * @return {?}
         */
            function (olGeometry, feature) {
                /** @type {?} */
                var featureId = feature ? feature.properties.id : utils.uuid();
                /** @type {?} */
                var projection = this.map.ol.getView().getProjection();
                /** @type {?} */
                var geometry = new OlGeoJSON().writeGeometryObject(olGeometry, {
                    featureProjection: projection,
                    dataProjection: projection
                });
                this.store.update({
                    type: FEATURE,
                    geometry: geometry,
                    projection: projection.getCode(),
                    properties: {
                        id: featureId,
                        measure: olGeometry.get('_measure')
                    },
                    meta: {
                        id: featureId
                    }
                });
            };
        /**
         * Update all the tooltips of an OL geometry
         * @param olGeometry OL Geometry
         * @param lengths Lengths of the OL geometry's segments
         * @param measureUnit Display tooltip measure in those units
         */
        /**
         * Update all the tooltips of an OL geometry
         * @private
         * @param {?} olGeometry OL Geometry
         * @return {?}
         */
        MeasurerComponent.prototype.updateTooltipsOfOlGeometry = /**
         * Update all the tooltips of an OL geometry
         * @private
         * @param {?} olGeometry OL Geometry
         * @return {?}
         */
            function (olGeometry) {
                /** @type {?} */
                var measure = olGeometry.get('_measure');
                /** @type {?} */
                var lengths = measure.lengths;
                /** @type {?} */
                var area = measure.area;
                /** @type {?} */
                var olMidpointsTooltips = updateOlTooltipsAtMidpoints(olGeometry);
                if (lengths.length === olMidpointsTooltips.length) {
                    for (var i = 0; i < olMidpointsTooltips.length; i++) {
                        /** @type {?} */
                        var length_1 = lengths[i];
                        if (length_1 !== undefined) {
                            this.updateOlTooltip(olMidpointsTooltips[i], metersToUnit(length_1, this.activeLengthUnit), this.activeLengthUnit, MeasureType.Length);
                        }
                    }
                }
                if (area !== undefined) {
                    this.updateOlTooltip(updateOlTooltipAtCenter(olGeometry), squareMetersToUnit(area, this.activeAreaUnit), this.activeAreaUnit, MeasureType.Area);
                }
            };
        /**
         * Show the map tooltips of a geoemtry
         */
        /**
         * Show the map tooltips of a geoemtry
         * @private
         * @param {?} olGeometry
         * @return {?}
         */
        MeasurerComponent.prototype.showTooltipsOfOlGeometry = /**
         * Show the map tooltips of a geoemtry
         * @private
         * @param {?} olGeometry
         * @return {?}
         */
            function (olGeometry) {
                var _this = this;
                getTooltipsOfOlGeometry(olGeometry).forEach(( /**
                 * @param {?} olTooltip
                 * @return {?}
                 */function (olTooltip) {
                    if (_this.shouldShowTooltip(olTooltip)) {
                        _this.map.ol.addOverlay(olTooltip);
                    }
                }));
            };
        /**
         * Clear the tooltips of an OL geometrys
         * @param olGeometry OL geometry with tooltips
         */
        /**
         * Clear the tooltips of an OL geometrys
         * @private
         * @param {?} olGeometry OL geometry with tooltips
         * @return {?}
         */
        MeasurerComponent.prototype.clearTooltipsOfOlGeometry = /**
         * Clear the tooltips of an OL geometrys
         * @private
         * @param {?} olGeometry OL geometry with tooltips
         * @return {?}
         */
            function (olGeometry) {
                var _this = this;
                getTooltipsOfOlGeometry(olGeometry).forEach(( /**
                 * @param {?} olTooltip
                 * @return {?}
                 */function (olTooltip) {
                    if (olTooltip !== undefined && olTooltip.getMap() !== undefined) {
                        _this.map.ol.removeOverlay(olTooltip);
                    }
                }));
            };
        /**
         * Show the map tooltips of all the geometries of a source
         */
        /**
         * Show the map tooltips of all the geometries of a source
         * @private
         * @param {?} olSource
         * @return {?}
         */
        MeasurerComponent.prototype.updateTooltipsOfOlSource = /**
         * Show the map tooltips of all the geometries of a source
         * @private
         * @param {?} olSource
         * @return {?}
         */
            function (olSource) {
                var _this = this;
                olSource.forEachFeature(( /**
                 * @param {?} olFeature
                 * @return {?}
                 */function (olFeature) {
                    _this.updateTooltipsOfOlGeometry(olFeature.getGeometry());
                }));
            };
        /**
         * Show the map tooltips of all the geometries of a source
         */
        /**
         * Show the map tooltips of all the geometries of a source
         * @private
         * @param {?} olSource
         * @return {?}
         */
        MeasurerComponent.prototype.showTooltipsOfOlSource = /**
         * Show the map tooltips of all the geometries of a source
         * @private
         * @param {?} olSource
         * @return {?}
         */
            function (olSource) {
                var _this = this;
                olSource.forEachFeature(( /**
                 * @param {?} olFeature
                 * @return {?}
                 */function (olFeature) {
                    _this.showTooltipsOfOlGeometry(olFeature.getGeometry());
                }));
            };
        /**
         * Clear the map tooltips
         * @param olDrawSource OL vector source
         */
        /**
         * Clear the map tooltips
         * @private
         * @param {?} olSource
         * @return {?}
         */
        MeasurerComponent.prototype.clearTooltipsOfOlSource = /**
         * Clear the map tooltips
         * @private
         * @param {?} olSource
         * @return {?}
         */
            function (olSource) {
                var _this = this;
                olSource.forEachFeature(( /**
                 * @param {?} olFeature
                 * @return {?}
                 */function (olFeature) {
                    /** @type {?} */
                    var olGeometry = olFeature.getGeometry();
                    if (olGeometry !== undefined) {
                        _this.clearTooltipsOfOlGeometry(olFeature.getGeometry());
                    }
                }));
            };
        /**
         * Update an OL tooltip properties and inner HTML and add it to the map if possible
         * @param olTooltip OL tooltip
         * @param measure The measure valeu ti display
         * @param measureUnit Display tooltip measure in those units
         */
        /**
         * Update an OL tooltip properties and inner HTML and add it to the map if possible
         * @private
         * @param {?} olTooltip OL tooltip
         * @param {?} measure The measure valeu ti display
         * @param {?} unit
         * @param {?} type
         * @return {?}
         */
        MeasurerComponent.prototype.updateOlTooltip = /**
         * Update an OL tooltip properties and inner HTML and add it to the map if possible
         * @private
         * @param {?} olTooltip OL tooltip
         * @param {?} measure The measure valeu ti display
         * @param {?} unit
         * @param {?} type
         * @return {?}
         */
            function (olTooltip, measure, unit, type) {
                olTooltip.setProperties({ _measure: measure, _unit: unit, _type: type }, true);
                olTooltip.getElement().innerHTML = this.computeTooltipInnerHTML(olTooltip);
                if (this.shouldShowTooltip(olTooltip)) {
                    this.map.ol.addOverlay(olTooltip);
                }
            };
        /**
         * Compute a tooltip's content
         * @param olTooltip OL overlay
         * @returns Inner HTML
         */
        /**
         * Compute a tooltip's content
         * @private
         * @param {?} olTooltip OL overlay
         * @return {?} Inner HTML
         */
        MeasurerComponent.prototype.computeTooltipInnerHTML = /**
         * Compute a tooltip's content
         * @private
         * @param {?} olTooltip OL overlay
         * @return {?} Inner HTML
         */
            function (olTooltip) {
                /** @type {?} */
                var properties = ( /** @type {?} */(olTooltip.getProperties()));
                return formatMeasure(properties._measure, {
                    decimal: 1,
                    unit: properties._unit,
                    unitAbbr: true,
                    locale: 'fr'
                });
            };
        /**
         * Whether a tooltip should be showned based on the length
         * of the segment it is bound to.
         * @param olTooltip OL overlay
         * @returns True if the tooltip should be shown
         */
        /**
         * Whether a tooltip should be showned based on the length
         * of the segment it is bound to.
         * @private
         * @param {?} olTooltip OL overlay
         * @return {?} True if the tooltip should be shown
         */
        MeasurerComponent.prototype.shouldShowTooltip = /**
         * Whether a tooltip should be showned based on the length
         * of the segment it is bound to.
         * @private
         * @param {?} olTooltip OL overlay
         * @return {?} True if the tooltip should be shown
         */
            function (olTooltip) {
                if (this.showTooltips === false) {
                    return false;
                }
                /** @type {?} */
                var properties = ( /** @type {?} */(olTooltip.getProperties()));
                /** @type {?} */
                var measure = properties._measure;
                if (measure === undefined) {
                    return false;
                }
                if (properties._unit === MeasureType.Length) {
                    /** @type {?} */
                    var minSegmentLength = metersToUnit(this.minSegmentLength, properties._unit) || 0;
                    return measure > Math.max(minSegmentLength, 0);
                }
                return true;
            };
        MeasurerComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'igo-measurer',
                        template: "<div>\r\n  <div class=\"measure-type-toggle\">\r\n    <mat-button-toggle-group\r\n      [value]=\"activeMeasureType\"\r\n      (change)=\"onMeasureTypeChange($event.value)\">\r\n      <mat-button-toggle [value]=\"measureType.Length\">\r\n        {{('igo.geo.measure.' + measureType.Length) | translate}}\r\n      </mat-button-toggle>\r\n      <mat-button-toggle [value]=\"measureType.Area\">\r\n        {{('igo.geo.measure.' + measureType.Area) | translate}}\r\n      </mat-button-toggle>\r\n    </mat-button-toggle-group>\r\n  </div>\r\n\r\n  <div class=\"measure-options\">\r\n    <mat-slide-toggle\r\n      [checked]=\"drawControlIsActive\"\r\n      [labelPosition]=\"'before'\"\r\n      (change)=\"onToggleDrawControl($event.checked)\">\r\n      {{'igo.geo.measure.toggleMeasure' | translate}}\r\n    </mat-slide-toggle>\r\n\r\n    <mat-slide-toggle\r\n      [checked]=\"showTooltips\"\r\n      [labelPosition]=\"'before'\"\r\n      (change)=\"onToggleTooltips($event.checked)\">\r\n      {{'igo.geo.measure.toggleMapTooltips' | translate}}\r\n    </mat-slide-toggle>\r\n\r\n    <mat-slide-toggle\r\n      [checked]=\"measureUnitsAuto\"\r\n      [labelPosition]=\"'before'\"\r\n      (change)=\"onToggleMeasureUnitsAuto($event.checked)\">\r\n      {{'igo.geo.measure.toggleAutoUnits' | translate}}\r\n    </mat-slide-toggle>\r\n  </div>\r\n\r\n  <ng-container *ngIf=\"measure$ | async as measure\">\r\n    <igo-measurer-item\r\n      [measureType]=\"measureType.Length\"\r\n      [measureUnit]=\"measureLengthUnit.Meters\"\r\n      [measure]=\"measure.length\"\r\n      [auto]=\"measureUnitsAuto\"\r\n      [placeholder]=\"(activeMeasureType === measureType.Area ? 'igo.geo.measure.perimeter' : 'igo.geo.measure.length') | translate\"\r\n      (measureUnitChange)=\"onLengthUnitChange($event)\">\r\n    </igo-measurer-item>\r\n\r\n    <igo-measurer-item\r\n      [measureType]=\"measureType.Area\"\r\n      [measureUnit]=\"measureAreaUnit.SquareMeters\"\r\n      [measure]=\"measure.area\"\r\n      [auto]=\"measureUnitsAuto\"\r\n      [placeholder]=\"'igo.geo.measure.area' | translate\"\r\n      (measureUnitChange)=\"onAreaUnitChange($event)\">\r\n    </igo-measurer-item>\r\n  </ng-container>\r\n\r\n  <div class=\"measure-store-buttons\">\r\n    <button\r\n      mat-icon-button\r\n      [matTooltip]=\"'igo.geo.measure.actionbar.calculate.tooltip' | translate\"\r\n      [disabled]=\"(selectedFeatures$ | async).length === 0\"\r\n      (click)=\"onCalculateClick()\">\r\n      <mat-icon svgIcon=\"calculator\"></mat-icon>\r\n    </button>\r\n\r\n    <button\r\n      mat-icon-button\r\n      [matTooltip]=\"'igo.geo.measure.actionbar.delete.tooltip' | translate\"\r\n      [disabled]=\"(selectedFeatures$ | async).length === 0\"\r\n      (click)=\"onDeleteClick()\">\r\n      <mat-icon svgIcon=\"delete\"></mat-icon>\r\n    </button>\r\n\r\n    <!--button\r\n      mat-icon-button\r\n      [matTooltip]=\"'igo.geo.measure.actionbar.modify.tooltip' | translate\"\r\n      [disabled]=\"(selectedFeatures$ | async).length !== 1\"\r\n      (click)=\"onModifyClick()\">\r\n      <mat-icon svgIcon=\"edit\"></mat-icon>\r\n    </button-->\r\n  </div>\r\n\r\n  <igo-entity-table\r\n    #table\r\n    class=\"table-compact\"\r\n    [store]=\"store\"\r\n    [template]=\"tableTemplate\">\r\n  </igo-entity-table>\r\n</div>\r\n",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        styles: [".measure-type-toggle{padding:10px;text-align:center}.measure-type-toggle mat-button-toggle-group{width:100%}.measure-type-toggle mat-button-toggle-group mat-button-toggle{width:50%}.measure-options{overflow-x:hidden}.measure-options mat-slide-toggle{width:100%;margin:10px}.measure-options mat-slide-toggle ::ng-deep .mat-slide-toggle-content{width:calc(100% - 60px);font-size:16px}.measure-store-buttons{width:100%;border-top:1px solid #ddd;border-bottom:1px solid #ddd}.measure-store-buttons button:first-of-type{margin-left:14px}"]
                    }] }
        ];
        /** @nocollapse */
        MeasurerComponent.ctorParameters = function () {
            return [
                { type: i1$1.LanguageService },
                { type: material.MatDialog }
            ];
        };
        MeasurerComponent.propDecorators = {
            map: [{ type: i0.Input }],
            store: [{ type: i0.Input }],
            activeMeasureType: [{ type: i0.Input }],
            minSegmentLength: [{ type: i0.Input }],
            table: [{ type: i0.ViewChild, args: ['table',] }]
        };
        return MeasurerComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * This pipe returns a measure converted from meters (or square meters)
     * to the specified unit. It also keeps a certain number of decimals.
     */
    var MeasureFormatPipe = /** @class */ (function () {
        function MeasureFormatPipe() {
        }
        /**
         * @ignore
         */
        /**
         * @ignore
         * @param {?} value
         * @param {?} unit
         * @param {?=} unitAbbr
         * @param {?=} decimal
         * @return {?}
         */
        MeasureFormatPipe.prototype.transform = /**
         * @ignore
         * @param {?} value
         * @param {?} unit
         * @param {?=} unitAbbr
         * @param {?=} decimal
         * @return {?}
         */
            function (value, unit, unitAbbr, decimal) {
                if (unitAbbr === void 0) {
                    unitAbbr = false;
                }
                if (decimal === void 0) {
                    decimal = 1;
                }
                /** @type {?} */
                var out;
                if (Object.values(MeasureAreaUnit).indexOf(unit) >= 0) {
                    out = squareMetersToUnit(value, ( /** @type {?} */(unit)));
                }
                else if (Object.values(MeasureLengthUnit).indexOf(unit) >= 0) {
                    out = metersToUnit(value, ( /** @type {?} */(unit)));
                }
                return out ? formatMeasure(out, {
                    decimal: 1,
                    unit: unit,
                    unitAbbr: unitAbbr,
                    locale: 'fr'
                }) : out;
            };
        MeasureFormatPipe.decorators = [
            { type: i0.Pipe, args: [{
                        name: 'measureFormat'
                    },] }
        ];
        return MeasureFormatPipe;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * This input allows a user to draw a new geometry or to edit
     * an existing one on a map. A text input is also displayed in the
     * form with some instructions.
     * This is still WIP.
     */
    var GeometryFormFieldInputComponent = /** @class */ (function () {
        function GeometryFormFieldInputComponent(cdRef, ngControl) {
            this.cdRef = cdRef;
            this.ngControl = ngControl;
            this.olGeoJSON = new OlGeoJSON();
            this.ready = false;
            this.olTooltip = OlOverlay;
            /**
             * The drawGuide around the mouse pointer to help drawing
             */
            this.drawGuide = null;
            /**
             * Whether a measure tooltip should be displayed
             */
            this.measure = false;
            this.onChange = ( /**
             * @return {?}
             */function () { });
            this.onTouched = ( /**
             * @return {?}
             */function () { });
            if (this.ngControl !== undefined) {
                // Setting the value accessor directly (instead of using
                // the providers) to avoid running into a circular import.
                this.ngControl.valueAccessor = this;
            }
        }
        Object.defineProperty(GeometryFormFieldInputComponent.prototype, "geometryType", {
            get: /**
             * @return {?}
             */ function () { return this._geometryType; },
            /**
             * The geometry type
             */
            set: /**
             * The geometry type
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._geometryType = value;
                if (this.ready === false) {
                    return;
                }
                this.deactivateControl();
                this.createDrawControl();
                this.toggleControl();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeometryFormFieldInputComponent.prototype, "drawStyle", {
            get: /**
             * @return {?}
             */ function () { return this._drawStyle; },
            /**
             * Style for the draw control (applies while the geometry is being drawn)
             */
            set: /**
             * Style for the draw control (applies while the geometry is being drawn)
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._drawStyle = value || createDrawInteractionStyle();
                if (this.isStyleWithRadius(this.drawStyle)) {
                    this.defaultDrawStyleRadius = this.drawStyle.getImage().getRadius();
                }
                else {
                    this.defaultDrawStyleRadius = null;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeometryFormFieldInputComponent.prototype, "overlayStyle", {
            get: /**
             * @return {?}
             */ function () {
                return this._overlayStyle || this.drawStyle;
            },
            /**
             * Style for the overlay layer (applies once the geometry is added to the map)
             * If not specified, drawStyle applies
             */
            set: /**
             * Style for the overlay layer (applies once the geometry is added to the map)
             * If not specified, drawStyle applies
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._overlayStyle = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeometryFormFieldInputComponent.prototype, "value", {
            get: /**
             * @return {?}
             */ function () { return this._value; },
            /**
             * The geometry value (GeoJSON)
             * Implemented as part of ControlValueAccessor.
             */
            set: /**
             * The geometry value (GeoJSON)
             * Implemented as part of ControlValueAccessor.
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (this.ready === false) {
                    this._value = value;
                    return;
                }
                if (value) {
                    this.addGeoJSONToOverlay(value);
                }
                else {
                    this.olOverlaySource.clear();
                }
                this._value = value;
                this.onChange(value);
                this.toggleControl();
                this.cdRef.detectChanges();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeometryFormFieldInputComponent.prototype, "olOverlaySource", {
            /**
             * The vector source to add the geometry to
             * @internal
             */
            get: /**
             * The vector source to add the geometry to
             * \@internal
             * @return {?}
             */ function () {
                return this.olOverlayLayer.getSource();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Create an overlay layer, add the initial geometry to it (if any)
         * and toggle the right interaction.
         * @internal
         */
        /**
         * Create an overlay layer, add the initial geometry to it (if any)
         * and toggle the right interaction.
         * \@internal
         * @return {?}
         */
        GeometryFormFieldInputComponent.prototype.ngOnInit = /**
         * Create an overlay layer, add the initial geometry to it (if any)
         * and toggle the right interaction.
         * \@internal
         * @return {?}
         */
            function () {
                this.addOlOverlayLayer();
                this.createMeasureTooltip();
                this.createDrawControl();
                this.createModifyControl();
                if (this.value) {
                    this.addGeoJSONToOverlay(this.value);
                }
                this.toggleControl();
                this.ready = true;
            };
        /**
         * Clear the overlay layer and any interaction added by this component.
         * @internal
         */
        /**
         * Clear the overlay layer and any interaction added by this component.
         * \@internal
         * @return {?}
         */
        GeometryFormFieldInputComponent.prototype.ngOnDestroy = /**
         * Clear the overlay layer and any interaction added by this component.
         * \@internal
         * @return {?}
         */
            function () {
                this.deactivateControl();
                this.olOverlaySource.clear();
                this.map.ol.removeLayer(this.olOverlayLayer);
            };
        /**
         * Implemented as part of ControlValueAccessor.
         */
        // tslint:disable-next-line:ban-types
        /**
         * Implemented as part of ControlValueAccessor.
         * @param {?} fn
         * @return {?}
         */
        // tslint:disable-next-line:ban-types
        GeometryFormFieldInputComponent.prototype.registerOnChange = /**
         * Implemented as part of ControlValueAccessor.
         * @param {?} fn
         * @return {?}
         */
            // tslint:disable-next-line:ban-types
            function (fn) {
                this.onChange = fn;
            };
        /**
         * Implemented as part of ControlValueAccessor.
         */
        // tslint:disable-next-line:ban-types
        /**
         * Implemented as part of ControlValueAccessor.
         * @param {?} fn
         * @return {?}
         */
        // tslint:disable-next-line:ban-types
        GeometryFormFieldInputComponent.prototype.registerOnTouched = /**
         * Implemented as part of ControlValueAccessor.
         * @param {?} fn
         * @return {?}
         */
            // tslint:disable-next-line:ban-types
            function (fn) {
                this.onTouched = fn;
            };
        /**
         * Implemented as part of ControlValueAccessor.
         */
        /**
         * Implemented as part of ControlValueAccessor.
         * @param {?} value
         * @return {?}
         */
        GeometryFormFieldInputComponent.prototype.writeValue = /**
         * Implemented as part of ControlValueAccessor.
         * @param {?} value
         * @return {?}
         */
            function (value) {
                this.value = value;
            };
        /**
         * Add an overlay layer to the map
         */
        /**
         * Add an overlay layer to the map
         * @private
         * @return {?}
         */
        GeometryFormFieldInputComponent.prototype.addOlOverlayLayer = /**
         * Add an overlay layer to the map
         * @private
         * @return {?}
         */
            function () {
                this.olOverlayLayer = new OlVectorLayer({
                    source: new OlVectorSource(),
                    zIndex: 500,
                    style: null
                });
                this.map.ol.addLayer(this.olOverlayLayer);
            };
        /**
         * Create a draw control and subscribe to it's geometry
         */
        /**
         * Create a draw control and subscribe to it's geometry
         * @private
         * @return {?}
         */
        GeometryFormFieldInputComponent.prototype.createDrawControl = /**
         * Create a draw control and subscribe to it's geometry
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                this.drawControl = new DrawControl({
                    geometryType: this.geometryType || 'Point',
                    layer: this.olOverlayLayer,
                    drawStyle: ( /**
                     * @param {?} olFeature
                     * @param {?} resolution
                     * @return {?}
                     */function (olFeature, resolution) {
                        /** @type {?} */
                        var style = _this.drawStyle;
                        _this.updateDrawStyleWithDrawGuide(style, resolution);
                        return style;
                    })
                });
            };
        /**
         * Create a modify control and subscribe to it's geometry
         */
        /**
         * Create a modify control and subscribe to it's geometry
         * @private
         * @return {?}
         */
        GeometryFormFieldInputComponent.prototype.createModifyControl = /**
         * Create a modify control and subscribe to it's geometry
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                this.modifyControl = new ModifyControl({
                    layer: this.olOverlayLayer,
                    drawStyle: ( /**
                     * @param {?} olFeature
                     * @param {?} resolution
                     * @return {?}
                     */function (olFeature, resolution) {
                        /** @type {?} */
                        var style = _this.drawStyle;
                        _this.updateDrawStyleWithDrawGuide(style, resolution);
                        return style;
                    })
                });
            };
        /**
         * Toggle the proper control (draw or modify)
         */
        /**
         * Toggle the proper control (draw or modify)
         * @private
         * @return {?}
         */
        GeometryFormFieldInputComponent.prototype.toggleControl = /**
         * Toggle the proper control (draw or modify)
         * @private
         * @return {?}
         */
            function () {
                this.deactivateControl();
                if (!this.value && this.geometryType) {
                    this.activateControl(this.drawControl);
                }
                else {
                    this.activateControl(this.modifyControl);
                }
            };
        /**
         * Activate a given control
         * @param control Control
         */
        /**
         * Activate a given control
         * @private
         * @param {?} control Control
         * @return {?}
         */
        GeometryFormFieldInputComponent.prototype.activateControl = /**
         * Activate a given control
         * @private
         * @param {?} control Control
         * @return {?}
         */
            function (control) {
                var _this = this;
                this.activeControl = control;
                this.olGeometryEnds$$ = control.end$
                    .subscribe(( /**
             * @param {?} olGeometry
             * @return {?}
             */function (olGeometry) { return _this.onOlGeometryEnds(olGeometry); }));
                if (this.measure === true && control === this.drawControl) {
                    this.olGeometryChanges$$ = control.changes$
                        .subscribe(( /**
                 * @param {?} olGeometry
                 * @return {?}
                 */function (olGeometry) { return _this.onOlGeometryChanges(olGeometry); }));
                }
                control.setOlMap(this.map.ol);
            };
        /**
         * Deactivate the active control
         */
        /**
         * Deactivate the active control
         * @private
         * @return {?}
         */
        GeometryFormFieldInputComponent.prototype.deactivateControl = /**
         * Deactivate the active control
         * @private
         * @return {?}
         */
            function () {
                this.removeMeasureTooltip();
                if (this.activeControl !== undefined) {
                    this.activeControl.setOlMap(undefined);
                }
                if (this.olGeometryEnds$$ !== undefined) {
                    this.olGeometryEnds$$.unsubscribe();
                }
                if (this.olGeometryChanges$$ !== undefined) {
                    this.olGeometryChanges$$.unsubscribe();
                }
                this.activeControl = undefined;
            };
        /**
         * Update measures observables and map tooltips
         * @param olGeometry Ol linestring or polygon
         */
        /**
         * Update measures observables and map tooltips
         * @private
         * @param {?} olGeometry Ol linestring or polygon
         * @return {?}
         */
        GeometryFormFieldInputComponent.prototype.onOlGeometryEnds = /**
         * Update measures observables and map tooltips
         * @private
         * @param {?} olGeometry Ol linestring or polygon
         * @return {?}
         */
            function (olGeometry) {
                this.removeMeasureTooltip();
                this.setOlGeometry(olGeometry);
            };
        /**
         * Update measures observables and map tooltips
         * @param olGeometry Ol linestring or polygon
         */
        /**
         * Update measures observables and map tooltips
         * @private
         * @param {?} olGeometry Ol linestring or polygon
         * @return {?}
         */
        GeometryFormFieldInputComponent.prototype.onOlGeometryChanges = /**
         * Update measures observables and map tooltips
         * @private
         * @param {?} olGeometry Ol linestring or polygon
         * @return {?}
         */
            function (olGeometry) {
                if (olGeometry.getType() !== 'Point') {
                    this.updateMeasureTooltip(olGeometry);
                }
            };
        /**
         * When drawing ends, convert the output value to GeoJSON and keep it.
         * Restore the double click interaction.
         * @param olGeometry OL geometry
         */
        /**
         * When drawing ends, convert the output value to GeoJSON and keep it.
         * Restore the double click interaction.
         * @private
         * @param {?} olGeometry OL geometry
         * @return {?}
         */
        GeometryFormFieldInputComponent.prototype.setOlGeometry = /**
         * When drawing ends, convert the output value to GeoJSON and keep it.
         * Restore the double click interaction.
         * @private
         * @param {?} olGeometry OL geometry
         * @return {?}
         */
            function (olGeometry) {
                if (olGeometry === undefined) {
                    return;
                }
                /** @type {?} */
                var value = this.olGeoJSON.writeGeometryObject(olGeometry, {
                    featureProjection: this.map.projection,
                    dataProjection: 'EPSG:4326'
                });
                this.writeValue(value);
            };
        /**
         * Add a GeoJSON geometry to the overlay
         * @param geometry GeoJSON geometry
         */
        /**
         * Add a GeoJSON geometry to the overlay
         * @private
         * @param {?} geometry GeoJSON geometry
         * @return {?}
         */
        GeometryFormFieldInputComponent.prototype.addGeoJSONToOverlay = /**
         * Add a GeoJSON geometry to the overlay
         * @private
         * @param {?} geometry GeoJSON geometry
         * @return {?}
         */
            function (geometry) {
                /** @type {?} */
                var olGeometry = this.olGeoJSON.readGeometry(geometry, {
                    dataProjection: 'EPSG:4326',
                    featureProjection: this.map.projection
                });
                /** @type {?} */
                var olFeature = new OlFeature({
                    geometry: olGeometry
                });
                olFeature.setStyle(this.overlayStyle);
                this.olOverlaySource.clear();
                this.olOverlaySource.addFeature(olFeature);
            };
        /**
         * Create the measure tooltip
         */
        /**
         * Create the measure tooltip
         * @private
         * @return {?}
         */
        GeometryFormFieldInputComponent.prototype.createMeasureTooltip = /**
         * Create the measure tooltip
         * @private
         * @return {?}
         */
            function () {
                this.olTooltip = new OlOverlay({
                    element: document.createElement('div'),
                    offset: [-30, -10],
                    className: [
                        'igo-map-tooltip',
                        'igo-map-tooltip-measure'
                    ].join(' '),
                    stopEvent: false
                });
            };
        /**
         * Update the measure tooltip of an OL geometry
         * @param olGeometry OL Geometry
         */
        /**
         * Update the measure tooltip of an OL geometry
         * @private
         * @param {?} olGeometry OL Geometry
         * @return {?}
         */
        GeometryFormFieldInputComponent.prototype.updateMeasureTooltip = /**
         * Update the measure tooltip of an OL geometry
         * @private
         * @param {?} olGeometry OL Geometry
         * @return {?}
         */
            function (olGeometry) {
                /** @type {?} */
                var measure = measureOlGeometry(olGeometry, this.map.projection);
                /** @type {?} */
                var lengths = measure.lengths;
                /** @type {?} */
                var lastIndex = olGeometry.getType() === 'Polygon' ? lengths.length - 2 : lengths.length - 1;
                /** @type {?} */
                var lastLength = lengths[lastIndex];
                /** @type {?} */
                var olMidpoints = updateOlGeometryMidpoints(olGeometry);
                /** @type {?} */
                var olLastMidpoint = olMidpoints[lastIndex];
                if (olMidpoints.length === 0 || olLastMidpoint === undefined) {
                    this.removeMeasureTooltip();
                    return;
                }
                this.olTooltip.setPosition(olLastMidpoint.flatCoordinates);
                /** @type {?} */
                var innerHtml = formatMeasure(lastLength, {
                    decimal: 1,
                    unit: MeasureLengthUnit.Meters,
                    unitAbbr: true,
                    locale: 'fr'
                });
                this.olTooltip.getElement().innerHTML = innerHtml;
                if (this.olTooltip.getMap() === undefined) {
                    this.map.ol.addOverlay(this.olTooltip);
                }
            };
        /**
         * Remove the measure tooltip from the map
         */
        /**
         * Remove the measure tooltip from the map
         * @private
         * @return {?}
         */
        GeometryFormFieldInputComponent.prototype.removeMeasureTooltip = /**
         * Remove the measure tooltip from the map
         * @private
         * @return {?}
         */
            function () {
                if (this.olTooltip.getMap && this.olTooltip.getMap() !== undefined) {
                    this.map.ol.removeOverlay(this.olTooltip);
                    this.olTooltip.setMap(undefined);
                }
            };
        /**
         * Adjust the draw style with the specified draw guide distance, if possible
         * @param olStyle Draw style to update
         * @param resolution Resolution (to make the screen size of symbol fit the drawGuide value)
         */
        /**
         * Adjust the draw style with the specified draw guide distance, if possible
         * @private
         * @param {?} olStyle Draw style to update
         * @param {?} resolution Resolution (to make the screen size of symbol fit the drawGuide value)
         * @return {?}
         */
        GeometryFormFieldInputComponent.prototype.updateDrawStyleWithDrawGuide = /**
         * Adjust the draw style with the specified draw guide distance, if possible
         * @private
         * @param {?} olStyle Draw style to update
         * @param {?} resolution Resolution (to make the screen size of symbol fit the drawGuide value)
         * @return {?}
         */
            function (olStyle, resolution) {
                if (this.isStyleWithRadius(olStyle)) {
                    /** @type {?} */
                    var drawGuide = this.drawGuide;
                    /** @type {?} */
                    var radius = void 0;
                    if (drawGuide === null || drawGuide < 0) {
                        radius = this.defaultDrawStyleRadius;
                    }
                    else {
                        radius = drawGuide > 0 ? drawGuide / resolution : drawGuide;
                    }
                    olStyle.getImage().setRadius(radius);
                }
            };
        /**
         * Returns wether a given Open Layers style has a radius property that can be set (used to set draw guide)
         * @param olStyle The style on which to perform the check
         */
        /**
         * Returns wether a given Open Layers style has a radius property that can be set (used to set draw guide)
         * @private
         * @param {?} olStyle The style on which to perform the check
         * @return {?}
         */
        GeometryFormFieldInputComponent.prototype.isStyleWithRadius = /**
         * Returns wether a given Open Layers style has a radius property that can be set (used to set draw guide)
         * @private
         * @param {?} olStyle The style on which to perform the check
         * @return {?}
         */
            function (olStyle) {
                return olStyle.getImage && olStyle.getImage().setRadius;
            };
        GeometryFormFieldInputComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'igo-geometry-form-field-input',
                        template: "<ng-template></ng-template>",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        GeometryFormFieldInputComponent.ctorParameters = function () {
            return [
                { type: i0.ChangeDetectorRef },
                { type: forms.NgControl, decorators: [{ type: i0.Optional }, { type: i0.Self }] }
            ];
        };
        GeometryFormFieldInputComponent.propDecorators = {
            map: [{ type: i0.Input }],
            geometryType: [{ type: i0.Input }],
            drawGuide: [{ type: i0.Input }],
            measure: [{ type: i0.Input }],
            drawStyle: [{ type: i0.Input }],
            overlayStyle: [{ type: i0.Input }],
            value: [{ type: i0.Input }]
        };
        return GeometryFormFieldInputComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @ignore
     */
    var IgoGeometryFormFieldModule = /** @class */ (function () {
        function IgoGeometryFormFieldModule() {
        }
        IgoGeometryFormFieldModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            forms.ReactiveFormsModule,
                            material.MatIconModule,
                            material.MatFormFieldModule,
                            material.MatInputModule,
                            material.MatButtonModule,
                            material.MatButtonToggleModule,
                            i1$1.IgoLanguageModule
                        ],
                        exports: [
                            GeometryFormFieldComponent,
                            GeometryFormFieldInputComponent
                        ],
                        declarations: [
                            GeometryFormFieldComponent,
                            GeometryFormFieldInputComponent
                        ]
                    },] }
        ];
        return IgoGeometryFormFieldModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var IgoGeometryModule = /** @class */ (function () {
        function IgoGeometryModule() {
        }
        IgoGeometryModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            IgoGeometryFormFieldModule
                        ],
                        exports: [
                            IgoGeometryFormFieldModule
                        ],
                        declarations: [],
                        providers: [],
                        entryComponents: [
                            GeometryFormFieldComponent
                        ]
                    },] }
        ];
        return IgoGeometryModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var ExportError = /** @class */ (function (_super) {
        __extends(ExportError, _super);
        function ExportError() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return ExportError;
    }(Error));
    var ExportInvalidFileError = /** @class */ (function (_super) {
        __extends(ExportInvalidFileError, _super);
        function ExportInvalidFileError() {
            var _this = _super.call(this, 'Invalid file.') || this;
            Object.setPrototypeOf(_this, ExportInvalidFileError.prototype);
            return _this;
        }
        return ExportInvalidFileError;
    }(ExportError));
    var ExportNothingToExportError = /** @class */ (function (_super) {
        __extends(ExportNothingToExportError, _super);
        function ExportNothingToExportError() {
            var _this = _super.call(this, 'Nothing to export.') || this;
            Object.setPrototypeOf(_this, ExportNothingToExportError.prototype);
            return _this;
        }
        return ExportNothingToExportError;
    }(ExportError));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Export array to CSV
     *
     * @param {?} rows Array of arrays to export as CSV
     * @param {?} fileName
     * @param {?=} separator Cell separator
     * @return {?}
     */
    function exportToCSV(rows, fileName, separator) {
        if (separator === void 0) {
            separator = ';';
        }
        /** @type {?} */
        var lines = rows.map(( /**
         * @param {?} row
         * @param {?} index
         * @return {?}
         */function (row, index) { return row.join(separator); }));
        /** @type {?} */
        var csvContent = lines.join('\n');
        downloadContent(csvContent, 'text/csv;charset=utf-8', fileName);
    }
    /**
     * Return an array of values from an array of entities.
     *
     * @param {?} entities Array of entities
     * @param {?} columns
     * @return {?}
     */
    function entitiesToRowData(entities, columns) {
        return entities.map(( /**
         * @param {?} entity
         * @return {?}
         */function (entity) {
            return columns.map(( /**
             * @param {?} column
             * @return {?}
             */function (column) {
                /** @type {?} */
                var valueAccessor;
                if (column.renderer === undefined || column.renderer === common$1.EntityTableColumnRenderer.Default) {
                    valueAccessor = column.valueAccessor;
                }
                valueAccessor = valueAccessor ? valueAccessor : common$1.getEntityProperty;
                return valueAccessor(entity, column.name);
            }));
        }));
    }
    /**
     * Trigger download of a file
     *
     * @param {?} content File content
     * @param {?} mimeType File mime type
     * @param {?} fileName File name
     * @return {?}
     */
    function downloadContent(content, mimeType, fileName) {
        /** @type {?} */
        var element = document.createElement('a');
        element.setAttribute('href', "data:" + mimeType + "," + encodeURIComponent(content));
        element.setAttribute('download', fileName);
        element.style.display = 'none';
        document.body.appendChild(element);
        element.click();
        document.body.removeChild(element);
    }
    /**
     * @param {?} error
     * @param {?} messageService
     * @param {?} languageService
     * @return {?}
     */
    function handleFileExportError(error, messageService, languageService) {
        if (error instanceof ExportNothingToExportError) {
            handleNothingToExportError(messageService, languageService);
            return;
        }
        /** @type {?} */
        var translate = languageService.translate;
        /** @type {?} */
        var title = translate.instant('igo.geo.export.failed.title');
        /** @type {?} */
        var message = translate.instant('igo.geo.export.failed.text');
        messageService.error(message, title);
    }
    /**
     * @param {?} messageService
     * @param {?} languageService
     * @return {?}
     */
    function handleNothingToExportError(messageService, languageService) {
        /** @type {?} */
        var translate = languageService.translate;
        /** @type {?} */
        var title = translate.instant('igo.geo.export.nothing.title');
        /** @type {?} */
        var message = translate.instant('igo.geo.export.nothing.text');
        messageService.error(message, title);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var ExportFormat = utils.strEnum(['GeoJSON', 'GML', 'GPX', 'KML', 'Shapefile']);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var ExportService = /** @class */ (function () {
        function ExportService(config) {
            this.config = config;
            this.ogreUrl = this.config.getConfig('importExport.url');
        }
        /**
         * @param {?} olFeatures
         * @param {?} format
         * @param {?} title
         * @param {?=} projectionIn
         * @param {?=} projectionOut
         * @return {?}
         */
        ExportService.prototype.export = /**
         * @param {?} olFeatures
         * @param {?} format
         * @param {?} title
         * @param {?=} projectionIn
         * @param {?=} projectionOut
         * @return {?}
         */
            function (olFeatures, format, title, projectionIn, projectionOut) {
                if (projectionIn === void 0) {
                    projectionIn = 'EPSG:4326';
                }
                if (projectionOut === void 0) {
                    projectionOut = 'EPSG:4326';
                }
                /** @type {?} */
                var exportOlFeatures = olFeatures.map(( /**
                 * @param {?} olFeature
                 * @return {?}
                 */function (olFeature) {
                    /** @type {?} */
                    var keys = olFeature.getKeys().filter(( /**
                     * @param {?} key
                     * @return {?}
                     */function (key) { return !key.startsWith('_'); }));
                    /** @type {?} */
                    var properties = keys.reduce(( /**
                     * @param {?} acc
                     * @param {?} key
                     * @return {?}
                     */function (acc, key) {
                        acc[key] = olFeature.get(key);
                        return acc;
                    }), { geometry: olFeature.getGeometry() });
                    return new OlFeature(properties);
                }));
                return this.exportAsync(exportOlFeatures, format, title, projectionIn, projectionOut);
            };
        /**
         * @private
         * @param {?} olFeatures
         * @param {?} format
         * @param {?} title
         * @param {?} projectionIn
         * @param {?} projectionOut
         * @return {?}
         */
        ExportService.prototype.exportAsync = /**
         * @private
         * @param {?} olFeatures
         * @param {?} format
         * @param {?} title
         * @param {?} projectionIn
         * @param {?} projectionOut
         * @return {?}
         */
            function (olFeatures, format, title, projectionIn, projectionOut) {
                var _this = this;
                /** @type {?} */
                var doExport = ( /**
                 * @param {?} observer
                 * @return {?}
                 */function (observer) {
                    /** @type {?} */
                    var nothingToExport = _this.nothingToExport(olFeatures, format);
                    if (nothingToExport === true) {
                        observer.error(new ExportNothingToExportError());
                        return;
                    }
                    /** @type {?} */
                    var ogreFormats = Object.keys(ExportService.ogreFormats);
                    if (ogreFormats.indexOf(format) >= 0) {
                        if (_this.ogreUrl === undefined) {
                            if (ExportService.noOgreFallbacks.indexOf(format) >= 0) {
                                _this.exportToFile(olFeatures, observer, format, title, projectionIn, projectionOut);
                            }
                            else {
                                observer.error(new ExportInvalidFileError());
                            }
                            return;
                        }
                        _this.exportWithOgre(olFeatures, observer, format, title, projectionIn, projectionOut);
                    }
                    else {
                        _this.exportToFile(olFeatures, observer, format, title, projectionIn, projectionOut);
                    }
                });
                return new rxjs.Observable(doExport);
            };
        /**
         * @private
         * @param {?} olFeatures
         * @param {?} observer
         * @param {?} format
         * @param {?} title
         * @param {?} projectionIn
         * @param {?} projectionOut
         * @return {?}
         */
        ExportService.prototype.exportToFile = /**
         * @private
         * @param {?} olFeatures
         * @param {?} observer
         * @param {?} format
         * @param {?} title
         * @param {?} projectionIn
         * @param {?} projectionOut
         * @return {?}
         */
            function (olFeatures, observer, format, title, projectionIn, projectionOut) {
                /** @type {?} */
                var olFormat = new olformat[format]();
                /** @type {?} */
                var featuresText = olFormat.writeFeatures(olFeatures, {
                    dataProjection: projectionOut,
                    featureProjection: projectionIn,
                    featureType: 'feature',
                    featureNS: 'http://example.com/feature'
                });
                /** @type {?} */
                var fileName = title + "." + format.toLowerCase();
                downloadContent(featuresText, 'text/plain;charset=utf-8', fileName);
                observer.complete();
            };
        /**
         * @private
         * @param {?} olFeatures
         * @param {?} observer
         * @param {?} format
         * @param {?} title
         * @param {?} projectionIn
         * @param {?} projectionOut
         * @return {?}
         */
        ExportService.prototype.exportWithOgre = /**
         * @private
         * @param {?} olFeatures
         * @param {?} observer
         * @param {?} format
         * @param {?} title
         * @param {?} projectionIn
         * @param {?} projectionOut
         * @return {?}
         */
            function (olFeatures, observer, format, title, projectionIn, projectionOut) {
                /** @type {?} */
                var featuresText = new olformat.GeoJSON().writeFeatures(olFeatures, {
                    dataProjection: projectionOut,
                    featureProjection: projectionIn,
                    featureType: 'feature',
                    featureNS: 'http://example.com/feature'
                });
                /** @type {?} */
                var url = this.ogreUrl + "/convert";
                /** @type {?} */
                var form = document.createElement('form');
                form.setAttribute('method', 'post');
                form.setAttribute('action', url);
                /** @type {?} */
                var geojsonField = document.createElement('input');
                geojsonField.setAttribute('type', 'hidden');
                geojsonField.setAttribute('name', 'json');
                geojsonField.setAttribute('value', featuresText);
                form.appendChild(geojsonField);
                /** @type {?} */
                var outputNameField = document.createElement('input');
                /** @type {?} */
                var outputName = format === 'Shapefile' ? title + ".zip" : title;
                outputNameField.setAttribute('type', 'hidden');
                outputNameField.setAttribute('name', 'outputName');
                outputNameField.setAttribute('value', outputName);
                form.appendChild(outputNameField);
                /** @type {?} */
                var ogreFormat = ExportService.ogreFormats[format];
                /** @type {?} */
                var outputFormatField = document.createElement('input');
                outputFormatField.setAttribute('type', 'hidden');
                outputFormatField.setAttribute('name', 'formatOutput');
                outputFormatField.setAttribute('value', ogreFormat);
                form.appendChild(outputFormatField);
                document.body.appendChild(form);
                form.submit();
                document.body.removeChild(form);
                observer.complete();
            };
        /**
         * @private
         * @param {?} olFeatures
         * @param {?} format
         * @return {?}
         */
        ExportService.prototype.nothingToExport = /**
         * @private
         * @param {?} olFeatures
         * @param {?} format
         * @return {?}
         */
            function (olFeatures, format) {
                if (olFeatures.length === 0) {
                    return true;
                }
                if (format === 'GPX') {
                    /** @type {?} */
                    var pointOrLine = olFeatures.find(( /**
                     * @param {?} olFeature
                     * @return {?}
                     */function (olFeature) {
                        return ['Point', 'LineString'].indexOf(olFeature.getGeometry().getType()) >= 0;
                    }));
                    return pointOrLine === undefined;
                }
                return false;
            };
        ExportService.ogreFormats = {
            GML: 'gml',
            GPX: 'gpx',
            KML: 'kml',
            Shapefile: 'ESRI Shapefile'
        };
        ExportService.noOgreFallbacks = ['GML', 'GPX', 'KML'];
        ExportService.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        ExportService.ctorParameters = function () {
            return [
                { type: i1$1.ConfigService }
            ];
        };
        /** @nocollapse */ ExportService.ngInjectableDef = i0.defineInjectable({ factory: function ExportService_Factory() { return new ExportService(i0.inject(i1$1.ConfigService)); }, token: ExportService, providedIn: "root" });
        return ExportService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var ImportError = /** @class */ (function (_super) {
        __extends(ImportError, _super);
        function ImportError() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return ImportError;
    }(Error));
    var ImportInvalidFileError = /** @class */ (function (_super) {
        __extends(ImportInvalidFileError, _super);
        function ImportInvalidFileError() {
            var _this = _super.call(this, 'Invalid file.') || this;
            Object.setPrototypeOf(_this, ImportInvalidFileError.prototype);
            return _this;
        }
        return ImportInvalidFileError;
    }(ImportError));
    var ImportUnreadableFileError = /** @class */ (function (_super) {
        __extends(ImportUnreadableFileError, _super);
        function ImportUnreadableFileError() {
            var _this = _super.call(this, 'Failed to read file.') || this;
            Object.setPrototypeOf(_this, ImportUnreadableFileError.prototype);
            return _this;
        }
        return ImportUnreadableFileError;
    }(ImportError));
    var ImportNothingToImportError = /** @class */ (function (_super) {
        __extends(ImportNothingToImportError, _super);
        function ImportNothingToImportError() {
            var _this = _super.call(this, 'Nothing to import.') || this;
            Object.setPrototypeOf(_this, ImportNothingToImportError.prototype);
            return _this;
        }
        return ImportNothingToImportError;
    }(ImportError));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} features
     * @param {?} map
     * @param {?} layerTitle
     * @return {?}
     */
    function addLayerAndFeaturesToMap(features, map, layerTitle) {
        /** @type {?} */
        var olFeatures = features.map(( /**
         * @param {?} feature
         * @return {?}
         */function (feature) { return featureToOl(feature, map.projection); }));
        /** @type {?} */
        var r = Math.floor(Math.random() * 255);
        /** @type {?} */
        var g = Math.floor(Math.random() * 255);
        /** @type {?} */
        var b = Math.floor(Math.random() * 255);
        /** @type {?} */
        var stroke = new olstyle.Stroke({
            color: [r, g, b, 1],
            width: 2
        });
        /** @type {?} */
        var fill = new olstyle.Fill({
            color: [r, g, b, 0.4]
        });
        /** @type {?} */
        var sourceOptions = {
            queryable: true
        };
        /** @type {?} */
        var source = new FeatureDataSource(sourceOptions);
        source.ol.addFeatures(olFeatures);
        /** @type {?} */
        var layer = new VectorLayer({
            title: layerTitle,
            source: source,
            style: new olstyle.Style({
                stroke: stroke,
                fill: fill,
                image: new olstyle.Circle({
                    radius: 5,
                    stroke: stroke,
                    fill: fill
                })
            })
        });
        map.addLayer(layer);
        moveToOlFeatures(map, olFeatures);
        return layer;
    }
    /**
     * @param {?} file
     * @param {?} features
     * @param {?} map
     * @param {?} messageService
     * @param {?} languageService
     * @return {?}
     */
    function handleFileImportSuccess(file, features, map, messageService, languageService) {
        if (features.length === 0) {
            this.handleNothingToImportError(file, messageService, languageService);
            return;
        }
        /** @type {?} */
        var layerTitle = computeLayerTitleFromFile(file);
        addLayerAndFeaturesToMap(features, map, layerTitle);
        /** @type {?} */
        var translate = languageService.translate;
        /** @type {?} */
        var messageTitle = translate.instant('igo.geo.dropGeoFile.success.title');
        /** @type {?} */
        var message = translate.instant('igo.geo.dropGeoFile.success.text', {
            value: layerTitle
        });
        messageService.success(message, messageTitle);
    }
    /**
     * @param {?} file
     * @param {?} error
     * @param {?} messageService
     * @param {?} languageService
     * @return {?}
     */
    function handleFileImportError(file, error, messageService, languageService) {
        /** @type {?} */
        var translate = languageService.translate;
        /** @type {?} */
        var title = translate.instant('igo.geo.dropGeoFile.invalid.title');
        /** @type {?} */
        var message = translate.instant('igo.geo.dropGeoFile.invalid.text', {
            value: file.name,
            mimeType: file.type
        });
        messageService.error(message, title);
    }
    /**
     * @param {?} file
     * @param {?} messageService
     * @param {?} languageService
     * @return {?}
     */
    function handleNothingToImportError(file, messageService, languageService) {
        /** @type {?} */
        var translate = languageService.translate;
        /** @type {?} */
        var title = translate.instant('igo.geo.dropGeoFile.empty.title');
        /** @type {?} */
        var message = translate.instant('igo.geo.dropGeoFile.empty.text', {
            value: file.name,
            mimeType: file.type
        });
        messageService.error(message, title);
    }
    /**
     * @param {?} file
     * @return {?}
     */
    function getFileExtension(file) {
        return file.name.split('.').pop().toLowerCase();
    }
    /**
     * @param {?} file
     * @return {?}
     */
    function computeLayerTitleFromFile(file) {
        return file.name.substr(0, file.name.lastIndexOf('.'));
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var ImportService = /** @class */ (function () {
        function ImportService(http, config) {
            this.http = http;
            this.config = config;
            this.ogreUrl = this.config.getConfig('importExport.url');
        }
        /**
         * @param {?} file
         * @param {?=} projectionIn
         * @param {?=} projectionOut
         * @return {?}
         */
        ImportService.prototype.import = /**
         * @param {?} file
         * @param {?=} projectionIn
         * @param {?=} projectionOut
         * @return {?}
         */
            function (file, projectionIn, projectionOut) {
                if (projectionIn === void 0) {
                    projectionIn = 'EPSG:4326';
                }
                if (projectionOut === void 0) {
                    projectionOut = 'EPSG:4326';
                }
                return this.importAsync(file, projectionIn, projectionOut);
            };
        /**
         * @private
         * @param {?} file
         * @return {?}
         */
        ImportService.prototype.getFileImporter = /**
         * @private
         * @param {?} file
         * @return {?}
         */
            function (file) {
                /** @type {?} */
                var extension = getFileExtension(file);
                /** @type {?} */
                var mimeType = file.type;
                /** @type {?} */
                var allowedMimeTypes = __spread(ImportService.allowedMimeTypes, ImportService.allowedZipMimeTypes);
                /** @type {?} */
                var allowedExtensions = ImportService.allowedExtensions;
                if (allowedMimeTypes.indexOf(mimeType) < 0 && allowedExtensions.indexOf(extension) < 0) {
                    return undefined;
                }
                else if (mimeType === 'application/json' || ['json', 'geojson', 'kml'].indexOf(extension) >= 0) {
                    return this.importFile;
                }
                else if (this.ogreUrl !== undefined) {
                    return this.importFileWithOgre;
                }
                return undefined;
            };
        /**
         * @private
         * @param {?} file
         * @param {?} projectionIn
         * @param {?} projectionOut
         * @return {?}
         */
        ImportService.prototype.importAsync = /**
         * @private
         * @param {?} file
         * @param {?} projectionIn
         * @param {?} projectionOut
         * @return {?}
         */
            function (file, projectionIn, projectionOut) {
                var _this = this;
                /** @type {?} */
                var doImport = ( /**
                 * @param {?} observer
                 * @return {?}
                 */function (observer) {
                    /** @type {?} */
                    var importer = _this.getFileImporter(file);
                    if (importer === undefined) {
                        observer.error(new ImportInvalidFileError());
                        return;
                    }
                    importer.call(_this, file, observer, projectionIn, projectionOut);
                });
                return new rxjs.Observable(doImport);
            };
        /**
         * @private
         * @param {?} file
         * @param {?} observer
         * @param {?} projectionIn
         * @param {?} projectionOut
         * @return {?}
         */
        ImportService.prototype.importFile = /**
         * @private
         * @param {?} file
         * @param {?} observer
         * @param {?} projectionIn
         * @param {?} projectionOut
         * @return {?}
         */
            function (file, observer, projectionIn, projectionOut) {
                var _this = this;
                /** @type {?} */
                var reader = new FileReader();
                reader.onload = ( /**
                 * @param {?} event
                 * @return {?}
                 */function (event) {
                    try {
                        /** @type {?} */
                        var features = _this.parseFeaturesFromFile(file, event.target.result, projectionIn, projectionOut);
                        observer.next(features);
                    }
                    catch (e) {
                        observer.error(new ImportUnreadableFileError());
                    }
                    observer.complete();
                });
                reader.onerror = ( /**
                 * @param {?} evt
                 * @return {?}
                 */function (evt) {
                    observer.error(new ImportUnreadableFileError());
                });
                reader.readAsText(file, 'UTF-8');
            };
        /**
         * @private
         * @param {?} file
         * @param {?} observer
         * @param {?} projectionIn
         * @param {?} projectionOut
         * @return {?}
         */
        ImportService.prototype.importFileWithOgre = /**
         * @private
         * @param {?} file
         * @param {?} observer
         * @param {?} projectionIn
         * @param {?} projectionOut
         * @return {?}
         */
            function (file, observer, projectionIn, projectionOut) {
                var _this = this;
                /** @type {?} */
                var url = this.ogreUrl + "/convert";
                /** @type {?} */
                var formData = new FormData();
                formData.append('upload', file);
                formData.append('sourceSrs', projectionIn);
                formData.append('targetSrs', projectionOut);
                formData.append('formatOutput', 'GEOJSON');
                formData.append('skipFailures', '');
                this.http
                    .post(url, formData, { headers: new i1.HttpHeaders() })
                    .subscribe(( /**
             * @param {?} response
             * @return {?}
             */function (response) {
                    if (response === null) {
                        observer.error(new ImportUnreadableFileError());
                        return;
                    }
                    /** @type {?} */
                    var errors = (( /** @type {?} */(response))).errors || [];
                    if (errors.length > 0) {
                        observer.error(new ImportUnreadableFileError());
                    }
                    else {
                        /** @type {?} */
                        var features = _this.parseFeaturesFromGeoJSON(file, response, projectionOut);
                        observer.next(features);
                        observer.complete();
                    }
                }), ( /**
                 * @param {?} error
                 * @return {?}
                 */function (error) {
                    observer.error(new ImportUnreadableFileError());
                }));
            };
        /**
         * @private
         * @param {?} file
         * @param {?} data
         * @param {?} projectionIn
         * @param {?} projectionOut
         * @return {?}
         */
        ImportService.prototype.parseFeaturesFromFile = /**
         * @private
         * @param {?} file
         * @param {?} data
         * @param {?} projectionIn
         * @param {?} projectionOut
         * @return {?}
         */
            function (file, data, projectionIn, projectionOut) {
                /** @type {?} */
                var extension = getFileExtension(file);
                /** @type {?} */
                var mimeType = file.type;
                /** @type {?} */
                var GeoJSON = new olformat.GeoJSON();
                /** @type {?} */
                var format;
                if (mimeType === 'application/vnd.google-earth.kml+xml') {
                    format = new olformat.KML();
                }
                else if (mimeType === 'application/gml+xml') {
                    format = new olformat.GML();
                }
                else if (mimeType === 'application/gpx+xml') {
                    format = new olformat.GPX();
                }
                else {
                    switch (extension) {
                        case 'kml':
                            format = new olformat.KML();
                            break;
                        case 'gpx':
                            format = new olformat.GPX();
                            break;
                        case 'gml':
                            format = new olformat.GML();
                            break;
                        default:
                            format = GeoJSON;
                            break;
                    }
                }
                /** @type {?} */
                var olFeatures = format.readFeatures(data, {
                    dataProjection: projectionIn,
                    featureProjection: projectionOut
                });
                /** @type {?} */
                var features = olFeatures.map(( /**
                 * @param {?} olFeature
                 * @return {?}
                 */function (olFeature) {
                    return Object.assign(GeoJSON.writeFeatureObject(olFeature), {
                        projection: projectionOut,
                        meta: {
                            id: utils.uuid(),
                            title: computeLayerTitleFromFile(file)
                        }
                    });
                }));
                return features;
            };
        /**
         * @private
         * @param {?} file
         * @param {?} data
         * @param {?} projectionOut
         * @return {?}
         */
        ImportService.prototype.parseFeaturesFromGeoJSON = /**
         * @private
         * @param {?} file
         * @param {?} data
         * @param {?} projectionOut
         * @return {?}
         */
            function (file, data, projectionOut) {
                /** @type {?} */
                var olFormat = new olformat.GeoJSON();
                /** @type {?} */
                var olFeatures = olFormat.readFeatures(data);
                /** @type {?} */
                var features = olFeatures.map(( /**
                 * @param {?} olFeature
                 * @return {?}
                 */function (olFeature) {
                    return Object.assign(olFormat.writeFeatureObject(olFeature), {
                        projection: projectionOut,
                        meta: {
                            id: utils.uuid(),
                            title: computeLayerTitleFromFile(file)
                        }
                    });
                }));
                return features;
            };
        ImportService.allowedMimeTypes = [
            'application/gml+xml',
            'application/vnd.google-earth.kml+xml',
            'application/gpx+xml',
            'application/json'
        ];
        ImportService.allowedZipMimeTypes = [
            'application/zip',
            'application/x-zip-compressed',
            'application/x-zip'
        ];
        ImportService.allowedExtensions = [
            'geojson',
            'kml',
            'gpx',
            'json',
            'gml'
        ];
        ImportService.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        ImportService.ctorParameters = function () {
            return [
                { type: i1.HttpClient },
                { type: i1$1.ConfigService }
            ];
        };
        /** @nocollapse */ ImportService.ngInjectableDef = i0.defineInjectable({ factory: function ImportService_Factory() { return new ImportService(i0.inject(i1.HttpClient), i0.inject(i1$1.ConfigService)); }, token: ImportService, providedIn: "root" });
        return ImportService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var ImportExportComponent = /** @class */ (function () {
        function ImportExportComponent(importService, exportService, languageService, messageService, formBuilder) {
            this.importService = importService;
            this.exportService = exportService;
            this.languageService = languageService;
            this.messageService = messageService;
            this.formBuilder = formBuilder;
            this.formats = ExportFormat;
            this.inputProj = 'EPSG:4326';
            this.buildForm();
        }
        /**
         * @return {?}
         */
        ImportExportComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.layers$$ = this.map.layers$.subscribe(( /**
                 * @param {?} layers
                 * @return {?}
                 */function (layers) {
                    _this.layers = ( /** @type {?} */(layers
                        .filter(( /**
                 * @param {?} layer
                 * @return {?}
                 */function (layer) {
                        return layer instanceof VectorLayer && layer.exportable === true;
                    }))));
                }));
            };
        /**
         * @return {?}
         */
        ImportExportComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.layers$$.unsubscribe();
            };
        /**
         * @param {?} files
         * @return {?}
         */
        ImportExportComponent.prototype.importFiles = /**
         * @param {?} files
         * @return {?}
         */
            function (files) {
                var _this = this;
                var e_1, _a;
                var _loop_1 = function (file) {
                    this_1.importService
                        .import(file, this_1.inputProj)
                        .subscribe(( /**
                 * @param {?} features
                 * @return {?}
                 */function (features) { return _this.onFileImportSuccess(file, features); }), ( /**
                     * @param {?} error
                     * @return {?}
                     */function (error) { return _this.onFileImportError(file, error); }));
                };
                var this_1 = this;
                try {
                    for (var files_1 = __values(files), files_1_1 = files_1.next(); !files_1_1.done; files_1_1 = files_1.next()) {
                        var file = files_1_1.value;
                        _loop_1(file);
                    }
                }
                catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                }
                finally {
                    try {
                        if (files_1_1 && !files_1_1.done && (_a = files_1.return))
                            _a.call(files_1);
                    }
                    finally {
                        if (e_1)
                            throw e_1.error;
                    }
                }
            };
        /**
         * @param {?} data
         * @return {?}
         */
        ImportExportComponent.prototype.handleExportFormSubmit = /**
         * @param {?} data
         * @return {?}
         */
            function (data) {
                var _this = this;
                /** @type {?} */
                var layer = this.map.getLayerById(data.layer);
                /** @type {?} */
                var olFeatures = layer.dataSource.ol.getFeatures();
                this.exportService
                    .export(olFeatures, data.format, layer.title, this.map.projection)
                    .subscribe(( /**
             * @return {?}
             */function () { }), ( /**
                 * @param {?} error
                 * @return {?}
                 */function (error) { return _this.onFileExportError(error); }));
            };
        /**
         * @private
         * @return {?}
         */
        ImportExportComponent.prototype.buildForm = /**
         * @private
         * @return {?}
         */
            function () {
                this.form = this.formBuilder.group({
                    format: ['', [forms.Validators.required]],
                    layer: ['', [forms.Validators.required]]
                });
            };
        /**
         * @private
         * @param {?} file
         * @param {?} features
         * @return {?}
         */
        ImportExportComponent.prototype.onFileImportSuccess = /**
         * @private
         * @param {?} file
         * @param {?} features
         * @return {?}
         */
            function (file, features) {
                handleFileImportSuccess(file, features, this.map, this.messageService, this.languageService);
            };
        /**
         * @private
         * @param {?} file
         * @param {?} error
         * @return {?}
         */
        ImportExportComponent.prototype.onFileImportError = /**
         * @private
         * @param {?} file
         * @param {?} error
         * @return {?}
         */
            function (file, error) {
                handleFileImportError(file, error, this.messageService, this.languageService);
            };
        /**
         * @private
         * @param {?} error
         * @return {?}
         */
        ImportExportComponent.prototype.onFileExportError = /**
         * @private
         * @param {?} error
         * @return {?}
         */
            function (error) {
                handleFileExportError(error, this.messageService, this.languageService);
            };
        ImportExportComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'igo-import-export',
                        template: "<mat-tab-group>\r\n\r\n  <mat-tab [label]=\"'igo.geo.importExportForm.importTabTitle' |\u00A0translate\">\r\n    <form class=\"igo-form\">\r\n      <div class=\"igo-input-container\">\r\n        <mat-form-field>\r\n          <input\r\n            matInput\r\n            placeholder=\"{{'igo.geo.importExportForm.importProjPlaceholder' | translate}}\"\r\n            name=\"inputProj\"\r\n            [(ngModel)]=\"inputProj\">\r\n        </mat-form-field>\r\n      </div>\r\n\r\n      <div class=\"igo-form-button-group\">\r\n        <button mat-raised-button type=\"button\" (click)=\"fileInput.click()\">\r\n          {{'igo.geo.importExportForm.importButton' | translate}}\r\n        </button>\r\n        <input\r\n          #fileInput\r\n          type=\"file\"\r\n          [style.display]=\"'none'\"\r\n          (click)=\"fileInput.value = null\"\r\n          (change)=\"importFiles($event.target.files)\">\r\n      </div>\r\n    </form>\r\n  </mat-tab>\r\n\r\n  <mat-tab [label]=\"'igo.geo.importExportForm.exportTabTitle' |\u00A0translate\">\r\n    <form class=\"igo-form\" [formGroup]=\"form\">\r\n\r\n      <div class=\"igo-input-container\">\r\n        <mat-form-field>\r\n          <mat-select\r\n            formControlName=\"layer\"\r\n            placeholder=\"{{'igo.geo.importExportForm.exportLayerPlaceholder' | translate}}\">\r\n            <mat-option *ngFor=\"let layer of layers\" [value]=\"layer.id\">\r\n              {{layer.title}}\r\n            </mat-option>\r\n          </mat-select>\r\n        </mat-form-field>\r\n      </div>\r\n\r\n      <div class=\"igo-input-container\">\r\n        <mat-form-field>\r\n          <mat-select\r\n            formControlName=\"format\"\r\n            placeholder=\"{{'igo.geo.importExportForm.exportFormatPlaceholder' | translate}}\">\r\n            <mat-option *ngFor=\"let format of formats | keyvalue \" [value]=\"format.key\">\r\n              {{format.value}}\r\n            </mat-option>\r\n          </mat-select>\r\n        </mat-form-field>\r\n      </div>\r\n\r\n      <div class=\"igo-form-button-group\">\r\n        <button\r\n          mat-raised-button\r\n          type=\"button\"\r\n          [disabled]=\"!form.valid\"\r\n          (click)=\"handleExportFormSubmit(form.value)\">\r\n          {{'igo.geo.importExportForm.exportButton' | translate}}\r\n        </button>\r\n      </div>\r\n\r\n    </form>\r\n  </mat-tab>\r\n\r\n</mat-tab-group>\r\n",
                        styles: ["mat-form-field{width:100%}.igo-form{padding:5px}.igo-form-button-group{text-align:center;padding-top:10px}"]
                    }] }
        ];
        /** @nocollapse */
        ImportExportComponent.ctorParameters = function () {
            return [
                { type: ImportService },
                { type: ExportService },
                { type: i1$1.LanguageService },
                { type: i1$1.MessageService },
                { type: forms.FormBuilder }
            ];
        };
        ImportExportComponent.propDecorators = {
            map: [{ type: i0.Input }]
        };
        return ImportExportComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var DropGeoFileDirective = /** @class */ (function (_super) {
        __extends(DropGeoFileDirective, _super);
        function DropGeoFileDirective(component, importService, languageService, messageService) {
            var _this = _super.call(this) || this;
            _this.component = component;
            _this.importService = importService;
            _this.languageService = languageService;
            _this.messageService = messageService;
            _this.filesDropped = new i0.EventEmitter();
            _this.filesInvalid = new i0.EventEmitter();
            return _this;
        }
        Object.defineProperty(DropGeoFileDirective.prototype, "map", {
            get: /**
             * @return {?}
             */ function () {
                return this.component.map;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        DropGeoFileDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.filesDropped$$ = this.filesDropped.subscribe(( /**
                 * @param {?} files
                 * @return {?}
                 */function (files) {
                    _this.onFilesDropped(files);
                }));
            };
        /**
         * @return {?}
         */
        DropGeoFileDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.filesDropped$$.unsubscribe();
            };
        /**
         * @param {?} evt
         * @return {?}
         */
        DropGeoFileDirective.prototype.onDragOver = /**
         * @param {?} evt
         * @return {?}
         */
            function (evt) {
                _super.prototype.onDragOver.call(this, evt);
            };
        /**
         * @param {?} evt
         * @return {?}
         */
        DropGeoFileDirective.prototype.onDragLeave = /**
         * @param {?} evt
         * @return {?}
         */
            function (evt) {
                _super.prototype.onDragLeave.call(this, evt);
            };
        /**
         * @param {?} evt
         * @return {?}
         */
        DropGeoFileDirective.prototype.onDrop = /**
         * @param {?} evt
         * @return {?}
         */
            function (evt) {
                _super.prototype.onDrop.call(this, evt);
            };
        /**
         * @private
         * @param {?} files
         * @return {?}
         */
        DropGeoFileDirective.prototype.onFilesDropped = /**
         * @private
         * @param {?} files
         * @return {?}
         */
            function (files) {
                var _this = this;
                var e_1, _a;
                var _loop_1 = function (file) {
                    this_1.importService
                        .import(file)
                        .subscribe(( /**
                 * @param {?} features
                 * @return {?}
                 */function (features) { return _this.onFileImportSuccess(file, features); }), ( /**
                     * @param {?} error
                     * @return {?}
                     */function (error) { return _this.onFileImportError(file, error); }));
                };
                var this_1 = this;
                try {
                    for (var files_1 = __values(files), files_1_1 = files_1.next(); !files_1_1.done; files_1_1 = files_1.next()) {
                        var file = files_1_1.value;
                        _loop_1(file);
                    }
                }
                catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                }
                finally {
                    try {
                        if (files_1_1 && !files_1_1.done && (_a = files_1.return))
                            _a.call(files_1);
                    }
                    finally {
                        if (e_1)
                            throw e_1.error;
                    }
                }
            };
        /**
         * @private
         * @param {?} file
         * @param {?} features
         * @return {?}
         */
        DropGeoFileDirective.prototype.onFileImportSuccess = /**
         * @private
         * @param {?} file
         * @param {?} features
         * @return {?}
         */
            function (file, features) {
                handleFileImportSuccess(file, features, this.map, this.messageService, this.languageService);
            };
        /**
         * @private
         * @param {?} file
         * @param {?} error
         * @return {?}
         */
        DropGeoFileDirective.prototype.onFileImportError = /**
         * @private
         * @param {?} file
         * @param {?} error
         * @return {?}
         */
            function (file, error) {
                handleFileImportError(file, error, this.messageService, this.languageService);
            };
        DropGeoFileDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[igoDropGeoFile]'
                    },] }
        ];
        /** @nocollapse */
        DropGeoFileDirective.ctorParameters = function () {
            return [
                { type: MapBrowserComponent },
                { type: ImportService },
                { type: i1$1.LanguageService },
                { type: i1$1.MessageService }
            ];
        };
        DropGeoFileDirective.propDecorators = {
            onDragOver: [{ type: i0.HostListener, args: ['dragover', ['$event'],] }],
            onDragLeave: [{ type: i0.HostListener, args: ['dragleave', ['$event'],] }],
            onDrop: [{ type: i0.HostListener, args: ['drop', ['$event'],] }]
        };
        return DropGeoFileDirective;
    }(common$1.DragAndDropDirective));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var IgoImportExportModule = /** @class */ (function () {
        function IgoImportExportModule() {
        }
        /**
         * @return {?}
         */
        IgoImportExportModule.forRoot = /**
         * @return {?}
         */
            function () {
                return {
                    ngModule: IgoImportExportModule
                };
            };
        IgoImportExportModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            forms.FormsModule,
                            forms.ReactiveFormsModule,
                            common.CommonModule,
                            material.MatButtonModule,
                            material.MatTabsModule,
                            material.MatSelectModule,
                            material.MatOptionModule,
                            material.MatFormFieldModule,
                            material.MatInputModule,
                            i1$1.IgoLanguageModule,
                            common$1.IgoKeyValueModule,
                            common$1.IgoDrapDropModule
                        ],
                        exports: [ImportExportComponent, DropGeoFileDirective],
                        declarations: [ImportExportComponent, DropGeoFileDirective]
                    },] }
        ];
        return IgoImportExportModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var IgoLayerModule = /** @class */ (function () {
        function IgoLayerModule() {
        }
        /**
         * @return {?}
         */
        IgoLayerModule.forRoot = /**
         * @return {?}
         */
            function () {
                return {
                    ngModule: IgoLayerModule,
                    providers: [LayerService, StyleService, LayerListService]
                };
            };
        IgoLayerModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            material.MatInputModule,
                            material.MatFormFieldModule,
                            common.CommonModule,
                            forms.FormsModule,
                            material.MatIconModule,
                            material.MatButtonModule,
                            material.MatTooltipModule,
                            material.MatListModule,
                            material.MatSliderModule,
                            material.MatBadgeModule,
                            i1$1.IgoLanguageModule,
                            common$1.IgoListModule,
                            common$1.IgoCollapsibleModule,
                            common$1.IgoImageModule
                        ],
                        exports: [
                            LayerItemComponent,
                            LayerLegendComponent,
                            LayerListComponent,
                            LayerListBindingDirective
                        ],
                        declarations: [
                            LayerItemComponent,
                            LayerLegendComponent,
                            LayerListComponent,
                            LayerListBindingDirective
                        ]
                    },] }
        ];
        return IgoLayerModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var IgoMapModule = /** @class */ (function () {
        function IgoMapModule() {
        }
        IgoMapModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            i1$1.IgoLanguageModule,
                            common$1.IgoConfirmDialogModule,
                            material.MatIconModule,
                            material.MatButtonModule,
                            material.MatTooltipModule
                        ],
                        exports: [
                            MapBrowserComponent,
                            ZoomButtonComponent,
                            GeolocateButtonComponent,
                            RotationButtonComponent,
                            BaseLayersSwitcherComponent,
                            MiniBaseMapComponent,
                            MapOfflineDirective
                        ],
                        declarations: [
                            MapBrowserComponent,
                            ZoomButtonComponent,
                            GeolocateButtonComponent,
                            RotationButtonComponent,
                            BaseLayersSwitcherComponent,
                            MiniBaseMapComponent,
                            MapOfflineDirective
                        ]
                    },] }
        ];
        return IgoMapModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Measurer item
     */
    var MeasurerItemComponent = /** @class */ (function () {
        function MeasurerItemComponent() {
            /**
             * Measure observable
             * \@internal
             */
            this.measure$ = new rxjs.BehaviorSubject(undefined);
            this._auto = false;
            /**
             * Event emitted when the measure unit changes
             */
            this.measureUnitChange = new i0.EventEmitter();
        }
        Object.defineProperty(MeasurerItemComponent.prototype, "measure", {
            get: /**
             * @return {?}
             */ function () { return this.measure$.value; },
            /**
             * Measure
             */
            set: /**
             * Measure
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.measure$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MeasurerItemComponent.prototype, "auto", {
            get: /**
             * @return {?}
             */ function () { return this._auto; },
            /**
             * Whther measure units should be automatically determined
             */
            set: /**
             * Whther measure units should be automatically determined
             * @param {?} value
             * @return {?}
             */ function (value) { this.toggleAutoUnit(value); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MeasurerItemComponent.prototype, "measureUnits", {
            /**
             * Available measure units for the measure type given
             * @internal
             */
            get: /**
             * Available measure units for the measure type given
             * \@internal
             * @return {?}
             */ function () {
                if (this.measureType === MeasureType.Area) {
                    return Object.values(MeasureAreaUnit);
                }
                return Object.values(MeasureLengthUnit);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Toggle the auto unit off
         * @internal
         */
        /**
         * Toggle the auto unit off
         * \@internal
         * @return {?}
         */
        MeasurerItemComponent.prototype.ngOnDestroy = /**
         * Toggle the auto unit off
         * \@internal
         * @return {?}
         */
            function () {
                this.toggleAutoUnit(false);
            };
        /**
         * Set the measure unit
         * @internal
         */
        /**
         * Set the measure unit
         * \@internal
         * @param {?} unit
         * @return {?}
         */
        MeasurerItemComponent.prototype.onMeasureUnitChange = /**
         * Set the measure unit
         * \@internal
         * @param {?} unit
         * @return {?}
         */
            function (unit) {
                this.measureUnit = unit;
                this.measureUnitChange.emit(unit);
            };
        /**
         * @private
         * @param {?} toggle
         * @return {?}
         */
        MeasurerItemComponent.prototype.toggleAutoUnit = /**
         * @private
         * @param {?} toggle
         * @return {?}
         */
            function (toggle) {
                var _this = this;
                if (this.measure$$ !== undefined) {
                    this.measure$$.unsubscribe();
                }
                if (toggle === true) {
                    this.measure$$ = this.measure$.subscribe(( /**
                     * @param {?} measure
                     * @return {?}
                     */function (measure) {
                        _this.computeBestMeasureUnit(measure);
                    }));
                }
                this._auto = toggle;
            };
        /**
         * @private
         * @param {?} measure
         * @return {?}
         */
        MeasurerItemComponent.prototype.computeBestMeasureUnit = /**
         * @private
         * @param {?} measure
         * @return {?}
         */
            function (measure) {
                /** @type {?} */
                var measureUnit = this.measureUnit;
                if (this.measureType === MeasureType.Area) {
                    measureUnit = computeBestAreaUnit(measure);
                }
                else if (this.measureType === MeasureType.Length) {
                    measureUnit = computeBestLengthUnit(measure);
                }
                if (measureUnit !== this.measureUnit) {
                    this.onMeasureUnitChange(measureUnit);
                }
            };
        MeasurerItemComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'igo-measurer-item',
                        template: "<mat-form-field class=\"measure-field\">\r\n  <input\r\n    matInput\r\n    [readonly]=\"true\"\r\n    [placeholder]=\"placeholder\"\r\n    [value]=\"((measure$ | async) || 0) | measureFormat: measureUnit\">\r\n</mat-form-field>\r\n<mat-form-field class=\"unit-field\">\r\n  <mat-select\r\n    [value]=\"measureUnit\"\r\n    [disabled]=\"auto\"\r\n    (selectionChange)=\"onMeasureUnitChange($event.value)\">\r\n    <mat-option *ngFor=\"let measureUnit of measureUnits\" [value]=\"measureUnit\">\r\n      {{('igo.geo.measure.' + measureUnit) | translate}}\r\n    </mat-option>\r\n  </mat-select>\r\n</mat-form-field>\r\n",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        styles: [":host{display:flex;width:100%;padding:5px 10px}.measure-field{display:flex;flex-flow:column nowrap;width:100%}.unit-field{width:110px;margin-left:10px}"]
                    }] }
        ];
        /** @nocollapse */
        MeasurerItemComponent.ctorParameters = function () { return []; };
        MeasurerItemComponent.propDecorators = {
            measureType: [{ type: i0.Input }],
            measureUnit: [{ type: i0.Input }],
            measure: [{ type: i0.Input }],
            auto: [{ type: i0.Input }],
            placeholder: [{ type: i0.Input }],
            measureUnitChange: [{ type: i0.Output }]
        };
        return MeasurerItemComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @ignore
     */
    var IgoMeasurerModule = /** @class */ (function () {
        function IgoMeasurerModule() {
        }
        IgoMeasurerModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            material.MatButtonModule,
                            material.MatButtonToggleModule,
                            material.MatIconModule,
                            material.MatTooltipModule,
                            material.MatFormFieldModule,
                            material.MatInputModule,
                            material.MatSelectModule,
                            material.MatSlideToggleModule,
                            i1$1.IgoLanguageModule,
                            common$1.IgoEntityTableModule
                        ],
                        declarations: [
                            MeasureFormatPipe,
                            MeasurerItemComponent,
                            MeasurerComponent,
                            MeasurerDialogComponent
                        ],
                        exports: [
                            MeasureFormatPipe,
                            MeasurerComponent
                        ],
                        entryComponents: [
                            MeasurerDialogComponent
                        ]
                    },] }
        ];
        return IgoMeasurerModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var IgoMeasureModule = /** @class */ (function () {
        function IgoMeasureModule() {
        }
        IgoMeasureModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [],
                        declarations: [],
                        exports: [
                            IgoMeasurerModule
                        ]
                    },] }
        ];
        return IgoMeasureModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @enum {number} */
    var OverlayAction = {
        None: 0,
        Move: 1,
        Zoom: 2,
        ZoomIfOutMapExtent: 3,
    };
    OverlayAction[OverlayAction.None] = 'None';
    OverlayAction[OverlayAction.Move] = 'Move';
    OverlayAction[OverlayAction.Zoom] = 'Zoom';
    OverlayAction[OverlayAction.ZoomIfOutMapExtent] = 'ZoomIfOutMapExtent';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var OverlayService = /** @class */ (function () {
        function OverlayService() {
            this.features$ = new rxjs.BehaviorSubject([
                [],
                undefined
            ]);
        }
        /**
         * @param {?} features
         * @param {?=} action
         * @return {?}
         */
        OverlayService.prototype.setFeatures = /**
         * @param {?} features
         * @param {?=} action
         * @return {?}
         */
            function (features, action) {
                if (action === void 0) {
                    action = OverlayAction.None;
                }
                this.features$.next([features, action]);
            };
        /**
         * @return {?}
         */
        OverlayService.prototype.clear = /**
         * @return {?}
         */
            function () {
                this.features$.next([[], OverlayAction.None]);
            };
        OverlayService.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        OverlayService.ctorParameters = function () { return []; };
        /** @nocollapse */ OverlayService.ngInjectableDef = i0.defineInjectable({ factory: function OverlayService_Factory() { return new OverlayService(); }, token: OverlayService, providedIn: "root" });
        return OverlayService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var OverlayDirective = /** @class */ (function () {
        function OverlayDirective(component, overlayService) {
            this.component = component;
            this.overlayService = overlayService;
            this.format = new OlGeoJSON();
        }
        Object.defineProperty(OverlayDirective.prototype, "map", {
            get: /**
             * @return {?}
             */ function () {
                return this.component.map;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        OverlayDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.features$$ = this.overlayService.features$.subscribe(( /**
                 * @param {?} res
                 * @return {?}
                 */function (res) {
                    return _this.handleFeatures(res[0], res[1]);
                }));
            };
        /**
         * @return {?}
         */
        OverlayDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.features$$.unsubscribe();
            };
        /**
         * @private
         * @param {?} features
         * @param {?} action
         * @return {?}
         */
        OverlayDirective.prototype.handleFeatures = /**
         * @private
         * @param {?} features
         * @param {?} action
         * @return {?}
         */
            function (features, action) { };
        OverlayDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[igoOverlay]'
                    },] }
        ];
        /** @nocollapse */
        OverlayDirective.ctorParameters = function () {
            return [
                { type: MapBrowserComponent, decorators: [{ type: i0.Self }] },
                { type: OverlayService }
            ];
        };
        return OverlayDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var IgoOverlayModule = /** @class */ (function () {
        function IgoOverlayModule() {
        }
        /**
         * @return {?}
         */
        IgoOverlayModule.forRoot = /**
         * @return {?}
         */
            function () {
                return {
                    ngModule: IgoOverlayModule
                };
            };
        IgoOverlayModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [],
                        exports: [OverlayDirective],
                        declarations: [OverlayDirective]
                    },] }
        ];
        return IgoOverlayModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var html2canvas = _html2canvas;
    var PrintService = /** @class */ (function () {
        function PrintService(messageService, activityService, languageService) {
            this.messageService = messageService;
            this.activityService = activityService;
            this.languageService = languageService;
        }
        /**
         * @param {?} map
         * @param {?} options
         * @return {?}
         */
        PrintService.prototype.print = /**
         * @param {?} map
         * @param {?} options
         * @return {?}
         */
            function (map, options) {
                var _this = this;
                /** @type {?} */
                var status$ = new rxjs.Subject();
                /** @type {?} */
                var paperFormat = options.paperFormat;
                /** @type {?} */
                var resolution = +options.resolution;
                // Default is 96
                /** @type {?} */
                var orientation = options.orientation;
                this.activityId = this.activityService.register();
                /** @type {?} */
                var doc = new jsPDF({
                    orientation: orientation,
                    format: paperFormat.toLowerCase()
                });
                /** @type {?} */
                var dimensions = [
                    doc.internal.pageSize.width,
                    doc.internal.pageSize.height
                ];
                /** @type {?} */
                var margins = [20, 10, 20, 10];
                /** @type {?} */
                var width = dimensions[0] - margins[3] - margins[1];
                /** @type {?} */
                var height = dimensions[1] - margins[0] - margins[2];
                /** @type {?} */
                var size = [width, height];
                if (options.title !== undefined) {
                    this.addTitle(doc, options.title, dimensions[0]);
                }
                if (options.showProjection === true || options.showScale === true) {
                    this.addProjScale(doc, map, resolution, options.showProjection, options.showScale);
                }
                if (options.comment !== '') {
                    this.addComment(doc, options.comment);
                }
                this.addMap(doc, map, resolution, size, margins).subscribe(( /**
                 * @param {?} status
                 * @return {?}
                 */function (status) {
                    if (status === utils.SubjectStatus.Done) {
                        if (options.showLegend === true) {
                            _this.addLegend(doc, map, margins, resolution);
                        }
                        else {
                            _this.saveDoc(doc);
                        }
                    }
                    if (status === utils.SubjectStatus.Done || status === utils.SubjectStatus.Error) {
                        _this.activityService.unregister(_this.activityId);
                        status$.next(utils.SubjectStatus.Done);
                    }
                }));
                return status$;
            };
        /**
         * Get html code for all layers legend
         * @param  map IgoMap
         * @param  width The width that the legend need to be
         * @return Html code for the legend
         */
        /**
         * Get html code for all layers legend
         * @param {?} map IgoMap
         * @param {?} width The width that the legend need to be
         * @param {?} resolution
         * @return {?} Html code for the legend
         */
        PrintService.prototype.getLayersLegendHtml = /**
         * Get html code for all layers legend
         * @param {?} map IgoMap
         * @param {?} width The width that the legend need to be
         * @param {?} resolution
         * @return {?} Html code for the legend
         */
            function (map, width, resolution) {
                /** @type {?} */
                var html = '';
                /** @type {?} */
                var legends = getLayersLegends(map.layers, map.viewController.getScale(resolution));
                if (legends.length === 0) {
                    return html;
                }
                // Define important style to be sure that all container is convert
                // to image not just visible part
                html += '<style media="screen" type="text/css">';
                html += '.html2canvas-container { width: ' + width;
                html += 'mm !important; height: 2000px !important; }';
                html += '</style>';
                html += '<font size="2" face="Courier New" >';
                html += '<div style="display:inline-block;max-width:' + width + 'mm">';
                // For each legend, define an html table cell
                legends.forEach(( /**
                 * @param {?} legend
                 * @return {?}
                 */function (legend) {
                    html +=
                        '<table border=1 style="display:inline-block;vertical-align:top">';
                    html += '<tr><th width="170px">' + legend.title + '</th>';
                    html += '<td><img class="printImageLegend" src="' + legend.url + '">';
                    html += '</td></tr></table>';
                }));
                html += '</div>';
                return html;
            };
        /**
         * Get all the legend in a single image
         * * @param  format - Image format. default value to "png"
         * @return The image of the legend
         */
        /**
         * Get all the legend in a single image
         * * \@param  format - Image format. default value to "png"
         * @param {?} map
         * @param {?=} format
         * @param {?=} doZipFile
         * @param {?=} resolution
         * @return {?} The image of the legend
         */
        PrintService.prototype.getLayersLegendImage = /**
         * Get all the legend in a single image
         * * \@param  format - Image format. default value to "png"
         * @param {?} map
         * @param {?=} format
         * @param {?=} doZipFile
         * @param {?=} resolution
         * @return {?} The image of the legend
         */
            function (map, format, doZipFile, resolution) {
                if (format === void 0) {
                    format = 'png';
                }
                /** @type {?} */
                var status$ = new rxjs.Subject();
                // Get html code for the legend
                /** @type {?} */
                var width = 200;
                // milimeters unit, originally define for document pdf
                /** @type {?} */
                var html = this.getLayersLegendHtml(map, width, resolution);
                /** @type {?} */
                var that = this;
                format = format.toLowerCase();
                // If no legend show No LEGEND in an image
                if (html.length === 0) {
                    html = '<font size="12" face="Courier New" >';
                    html += '<div align="center"><b>NO LEGEND</b></div>';
                }
                // Create div to contain html code for legend
                /** @type {?} */
                var div = window.document.createElement('div');
                // Add html code to convert in the new window
                window.document.body.appendChild(div);
                div.innerHTML = html;
                // Define event to execute after all images are loaded to create the canvas
                setTimeout(( /**
                 * @return {?}
                 */function () {
                    html2canvas(div, { useCORS: true }).then(( /**
                     * @param {?} canvas
                     * @return {?}
                     */function (canvas) {
                        /** @type {?} */
                        var status = utils.SubjectStatus.Done;
                        try {
                            if (!doZipFile) {
                                // Save the canvas as file
                                that.saveCanvasImageAsFile(canvas, 'legendImage', format);
                            }
                            else {
                                // Add the canvas to zip
                                that.generateCanvaFileToZip(canvas, 'legendImage' + '.' + format);
                            }
                            div.parentNode.removeChild(div); // remove temp div (IE)
                        }
                        catch (err) {
                            status = utils.SubjectStatus.Error;
                        }
                        status$.next(status);
                    }));
                }), 500);
            };
        /**
         * @private
         * @param {?} doc
         * @param {?} title
         * @param {?} pageWidth
         * @return {?}
         */
        PrintService.prototype.addTitle = /**
         * @private
         * @param {?} doc
         * @param {?} title
         * @param {?} pageWidth
         * @return {?}
         */
            function (doc, title, pageWidth) {
                /** @type {?} */
                var pdfResolution = 96;
                /** @type {?} */
                var titleSize = 32;
                /** @type {?} */
                var titleWidth = ((titleSize * 25.4) / pdfResolution) * title.length;
                /** @type {?} */
                var titleMarginLeft;
                if (titleWidth > pageWidth) {
                    titleMarginLeft = 0;
                }
                else {
                    titleMarginLeft = (pageWidth - titleWidth) / 2;
                }
                doc.setFont('courier');
                doc.setFontSize(32);
                doc.text(title, titleMarginLeft, 15);
            };
        /**
         * Add comment to the document
         * * @param  doc - pdf document
         * * @param  comment - Comment to add in the document
         * * @param  size - Size of the document
         */
        /**
         * Add comment to the document
         * * \@param  doc - pdf document
         * * \@param  comment - Comment to add in the document
         * * \@param  size - Size of the document
         * @private
         * @param {?} doc
         * @param {?} comment
         * @return {?}
         */
        PrintService.prototype.addComment = /**
         * Add comment to the document
         * * \@param  doc - pdf document
         * * \@param  comment - Comment to add in the document
         * * \@param  size - Size of the document
         * @private
         * @param {?} doc
         * @param {?} comment
         * @return {?}
         */
            function (doc, comment) {
                /** @type {?} */
                var commentSize = 16;
                /** @type {?} */
                var commentMarginLeft = 20;
                /** @type {?} */
                var marginBottom = 5;
                /** @type {?} */
                var heightPixels = doc.internal.pageSize.height - marginBottom;
                doc.setFont('courier');
                doc.setFontSize(commentSize);
                doc.text(comment, commentMarginLeft, heightPixels);
            };
        /**
         * Add projection and/or scale to the document
         * @param  doc - pdf document
         * @param  map - Map of the app
         * @param  dpi - DPI resolution of the document
         * @param  projection - Bool to indicate if projection need to be added
         * @param  scale - Bool to indicate if scale need to be added
         */
        /**
         * Add projection and/or scale to the document
         * @private
         * @param {?} doc - pdf document
         * @param {?} map - Map of the app
         * @param {?} dpi - DPI resolution of the document
         * @param {?} projection - Bool to indicate if projection need to be added
         * @param {?} scale - Bool to indicate if scale need to be added
         * @return {?}
         */
        PrintService.prototype.addProjScale = /**
         * Add projection and/or scale to the document
         * @private
         * @param {?} doc - pdf document
         * @param {?} map - Map of the app
         * @param {?} dpi - DPI resolution of the document
         * @param {?} projection - Bool to indicate if projection need to be added
         * @param {?} scale - Bool to indicate if scale need to be added
         * @return {?}
         */
            function (doc, map, dpi, projection, scale) {
                /** @type {?} */
                var translate = this.languageService.translate;
                /** @type {?} */
                var projScaleSize = 16;
                /** @type {?} */
                var projScaleMarginLeft = 20;
                /** @type {?} */
                var marginBottom = 15;
                /** @type {?} */
                var heightPixels = doc.internal.pageSize.height - marginBottom;
                /** @type {?} */
                var textProjScale = '';
                if (projection === true) {
                    /** @type {?} */
                    var projText = translate.instant('igo.geo.printForm.projection');
                    textProjScale += projText + ': ' + map.projection;
                }
                if (scale === true) {
                    if (projection === true) {
                        textProjScale += '   ';
                    }
                    /** @type {?} */
                    var scaleText = translate.instant('igo.geo.printForm.scale');
                    /** @type {?} */
                    var mapScale = map.viewController.getScale(dpi);
                    textProjScale += scaleText + ' ~ 1 ' + formatScale(mapScale);
                }
                doc.setFont('courier');
                doc.setFontSize(projScaleSize);
                doc.text(textProjScale, projScaleMarginLeft, heightPixels);
            };
        /**
         * Add the legend to the document
         * @param  doc - Pdf document where legend will be added
         * @param  map - Map of the app
         * @param  margins - Page margins
         */
        /**
         * Add the legend to the document
         * @private
         * @param {?} doc - Pdf document where legend will be added
         * @param {?} map - Map of the app
         * @param {?} margins - Page margins
         * @param {?} resolution
         * @return {?}
         */
        PrintService.prototype.addLegend = /**
         * Add the legend to the document
         * @private
         * @param {?} doc - Pdf document where legend will be added
         * @param {?} map - Map of the app
         * @param {?} margins - Page margins
         * @param {?} resolution
         * @return {?}
         */
            function (doc, map, margins, resolution) {
                var _this = this;
                /** @type {?} */
                var that = this;
                // Get html code for the legend
                /** @type {?} */
                var width = doc.internal.pageSize.width;
                /** @type {?} */
                var html = this.getLayersLegendHtml(map, width, resolution);
                // If no legend, save the map directly
                if (html === '') {
                    this.saveDoc(doc);
                    return true;
                }
                // Create div to contain html code for legend
                /** @type {?} */
                var div = window.document.createElement('div');
                html2canvas(div, { useCORS: true }).then(( /**
                 * @param {?} canvas
                 * @return {?}
                 */function (canvas) {
                    /** @type {?} */
                    var imgData;
                    /** @type {?} */
                    var position = 10;
                    imgData = canvas.toDataURL('image/png');
                    doc.addPage();
                    /** @type {?} */
                    var imageSize = _this.getImageSizeToFitPdf(doc, canvas, margins);
                    doc.addImage(imgData, 'PNG', 10, position, imageSize[0], imageSize[1]);
                    that.saveDoc(doc);
                    div.parentNode.removeChild(div); // remove temp div (IE style)
                }));
                // Add html code to convert in the new window
                window.document.body.appendChild(div);
                div.innerHTML = html;
            };
        /**
         * @private
         * @param {?} doc
         * @param {?} canvas
         * @param {?} margins
         * @return {?}
         */
        PrintService.prototype.addCanvas = /**
         * @private
         * @param {?} doc
         * @param {?} canvas
         * @param {?} margins
         * @return {?}
         */
            function (doc, canvas, margins) {
                /** @type {?} */
                var image;
                image = canvas.toDataURL('image/jpeg');
                if (image !== undefined) {
                    /** @type {?} */
                    var imageSize = this.getImageSizeToFitPdf(doc, canvas, margins);
                    doc.addImage(image, 'JPEG', margins[3], margins[0], imageSize[0], imageSize[1]);
                    doc.rect(margins[3], margins[0], imageSize[0], imageSize[1]);
                }
            };
        // TODO fix printing with image resolution
        // TODO fix printing with image resolution
        /**
         * @private
         * @param {?} doc
         * @param {?} map
         * @param {?} resolution
         * @param {?} size
         * @param {?} margins
         * @return {?}
         */
        PrintService.prototype.addMap =
            // TODO fix printing with image resolution
            /**
             * @private
             * @param {?} doc
             * @param {?} map
             * @param {?} resolution
             * @param {?} size
             * @param {?} margins
             * @return {?}
             */
            function (doc, map, resolution, size, margins) {
                var _this = this;
                /** @type {?} */
                var status$ = new rxjs.Subject();
                /** @type {?} */
                var mapSize = map.ol.getSize();
                /** @type {?} */
                var extent = map.ol.getView().calculateExtent(mapSize);
                /** @type {?} */
                var widthPixels = Math.round((size[0] * resolution) / 25.4);
                /** @type {?} */
                var heightPixels = Math.round((size[1] * resolution) / 25.4);
                /** @type {?} */
                var timeout;
                map.ol.once('postcompose', ( /**
                 * @param {?} event
                 * @return {?}
                 */function (event) {
                    /** @type {?} */
                    var canvas = event.context.canvas;
                    /** @type {?} */
                    var mapStatus$$ = map.status$.subscribe(( /**
                     * @param {?} mapStatus
                     * @return {?}
                     */function (mapStatus) {
                        clearTimeout(timeout);
                        if (mapStatus !== utils.SubjectStatus.Done) {
                            return;
                        }
                        mapStatus$$.unsubscribe();
                        /** @type {?} */
                        var status = utils.SubjectStatus.Done;
                        try {
                            _this.addCanvas(doc, canvas, margins);
                        }
                        catch (err) {
                            status = utils.SubjectStatus.Error;
                            _this.messageService.error(_this.languageService.translate.instant('igo.geo.printForm.corsErrorMessageBody'), _this.languageService.translate.instant('igo.geo.printForm.corsErrorMessageHeader'), 'print');
                        }
                        _this.renderMap(map, mapSize, extent);
                        status$.next(status);
                    }));
                    // If no loading as started after 200ms, then probably no loading
                    // is required.
                    timeout = window.setTimeout(( /**
                     * @return {?}
                     */function () {
                        mapStatus$$.unsubscribe();
                        /** @type {?} */
                        var status = utils.SubjectStatus.Done;
                        try {
                            _this.addCanvas(doc, canvas, margins);
                        }
                        catch (err) {
                            status = utils.SubjectStatus.Error;
                            _this.messageService.error(_this.languageService.translate.instant('igo.geo.printForm.corsErrorMessageBody'), _this.languageService.translate.instant('igo.geo.printForm.corsErrorMessageHeader'), 'print');
                        }
                        _this.renderMap(map, mapSize, extent);
                        status$.next(status);
                    }), 200);
                }));
                this.renderMap(map, [widthPixels, heightPixels], extent);
                return status$;
            };
        /**
         * @param {?} nbFileToProcess
         * @return {?}
         */
        PrintService.prototype.defineNbFileToProcess = /**
         * @param {?} nbFileToProcess
         * @return {?}
         */
            function (nbFileToProcess) {
                this.nbFileToProcess = nbFileToProcess;
            };
        /**
         * Download an image of the map with addition of informations
         * @param  map - Map of the app
         * @param  format - Image format. default value to "png"
         * @param  projection - Indicate if projection need to be add. Default to false
         * @param  scale - Indicate if scale need to be add. Default to false
         * @param  legend - Indicate if the legend of layers need to be download. Default to false
         * @param  title - Title to add for the map - Default to blank
         * @param  comment - Comment to add for the map - Default to blank
         * @param  doZipFile - Indicate if we do a zip with the file
         * @return Image file of the map with extension format given as parameter
         */
        /**
         * Download an image of the map with addition of informations
         * @param {?} map - Map of the app
         * @param {?} resolution
         * @param {?=} format - Image format. default value to "png"
         * @param {?=} projection - Indicate if projection need to be add. Default to false
         * @param {?=} scale - Indicate if scale need to be add. Default to false
         * @param {?=} legend - Indicate if the legend of layers need to be download. Default to false
         * @param {?=} title - Title to add for the map - Default to blank
         * @param {?=} comment - Comment to add for the map - Default to blank
         * @param {?=} doZipFile - Indicate if we do a zip with the file
         * @return {?} Image file of the map with extension format given as parameter
         */
        PrintService.prototype.downloadMapImage = /**
         * Download an image of the map with addition of informations
         * @param {?} map - Map of the app
         * @param {?} resolution
         * @param {?=} format - Image format. default value to "png"
         * @param {?=} projection - Indicate if projection need to be add. Default to false
         * @param {?=} scale - Indicate if scale need to be add. Default to false
         * @param {?=} legend - Indicate if the legend of layers need to be download. Default to false
         * @param {?=} title - Title to add for the map - Default to blank
         * @param {?=} comment - Comment to add for the map - Default to blank
         * @param {?=} doZipFile - Indicate if we do a zip with the file
         * @return {?} Image file of the map with extension format given as parameter
         */
            function (map, resolution, format, projection, scale, legend, title, comment, doZipFile) {
                var _this = this;
                if (format === void 0) {
                    format = 'png';
                }
                if (projection === void 0) {
                    projection = false;
                }
                if (scale === void 0) {
                    scale = false;
                }
                if (legend === void 0) {
                    legend = false;
                }
                if (title === void 0) {
                    title = '';
                }
                if (comment === void 0) {
                    comment = '';
                }
                if (doZipFile === void 0) {
                    doZipFile = true;
                }
                /** @type {?} */
                var status$ = new rxjs.Subject();
                // const resolution = map.ol.getView().getResolution();
                this.activityId = this.activityService.register();
                /** @type {?} */
                var translate = this.languageService.translate;
                map.ol.once('postcompose', ( /**
                 * @param {?} event
                 * @return {?}
                 */function (event) {
                    format = format.toLowerCase();
                    /** @type {?} */
                    var context = event.context;
                    /** @type {?} */
                    var newCanvas = document.createElement('canvas');
                    /** @type {?} */
                    var newContext = newCanvas.getContext('2d');
                    // Postion in height to set the canvas in new canvas
                    /** @type {?} */
                    var positionHCanvas = 0;
                    // Position in width to set the Proj/Scale in new canvas
                    /** @type {?} */
                    var positionWProjScale = 10;
                    // Get height/width of map canvas
                    /** @type {?} */
                    var width = context.canvas.width;
                    /** @type {?} */
                    var height = context.canvas.height;
                    // Set Font to calculate comment width
                    newContext.font = '20px Calibri';
                    /** @type {?} */
                    var commentWidth = newContext.measureText(comment).width;
                    // Add height for title if defined
                    height = title !== '' ? height + 30 : height;
                    // Add height for projection or scale (same line) if defined
                    height = projection !== false || scale !== false ? height + 30 : height;
                    /** @type {?} */
                    var positionHProjScale = height - 10;
                    // Define number of line depending of the comment length
                    /** @type {?} */
                    var commentNbLine = Math.ceil(commentWidth / width);
                    // Add height for multiline comment if defined
                    height = comment !== '' ? height + commentNbLine * 30 : height;
                    /** @type {?} */
                    var positionHComment = height - commentNbLine * 20 + 5;
                    // Set the new canvas with the new calculated size
                    newCanvas.width = width;
                    newCanvas.height = height;
                    // Patch Jpeg default black background to white
                    if (format === 'jpeg') {
                        newContext.fillStyle = '#ffffff';
                        newContext.fillRect(0, 0, width, height);
                        newContext.fillStyle = '#000000';
                    }
                    // If a title need to be added to canvas
                    if (title !== '') {
                        // Set font for title
                        newContext.font = '26px Calibri';
                        positionHCanvas = 30;
                        newContext.textAlign = 'center';
                        newContext.fillText(title, width / 2, 20);
                    }
                    // Set font for next section
                    newContext.font = '20px Calibri';
                    // If projection need to be added to canvas
                    if (projection !== false) {
                        /** @type {?} */
                        var projText = translate.instant('igo.geo.printForm.projection');
                        newContext.textAlign = 'start';
                        newContext.fillText(projText + ': ' + map.projection, positionWProjScale, positionHProjScale);
                        positionWProjScale += 200; // Width position change for scale position
                    }
                    // If scale need to be added to canvas
                    if (scale !== false) {
                        /** @type {?} */
                        var scaleText = translate.instant('igo.geo.printForm.scale');
                        /** @type {?} */
                        var mapScale = map.viewController.getScale(resolution);
                        newContext.textAlign = 'start';
                        newContext.fillText(scaleText + ' ~ 1 : ' + formatScale(mapScale), positionWProjScale, positionHProjScale);
                    }
                    // If a comment need to be added to canvas
                    if (comment !== '') {
                        newContext.textAlign = 'center';
                        // If only one line, no need to multiline the comment
                        if (commentNbLine === 1) {
                            newContext.fillText(comment, width / 2, positionHComment);
                        }
                        else {
                            // Separate the setenses to be approx. the same length
                            /** @type {?} */
                            var nbCommentChar = comment.length;
                            /** @type {?} */
                            var CommentLengthToCut = Math.floor(nbCommentChar / commentNbLine);
                            /** @type {?} */
                            var commentCurrentLine = '';
                            /** @type {?} */
                            var positionFirstCutChar = 0;
                            /** @type {?} */
                            var positionLastBlank = void 0;
                            // Loop for the number of line calculated
                            for (var i = 0; i < commentNbLine; i++) {
                                // For all line except last
                                if (commentNbLine - 1 > i) {
                                    // Get comment current line to find the right place tu cut comment
                                    commentCurrentLine = comment.substr(positionFirstCutChar, CommentLengthToCut);
                                    // Cut the setence at blank
                                    positionLastBlank = commentCurrentLine.lastIndexOf(' ');
                                    newContext.fillText(commentCurrentLine.substr(0, positionLastBlank), width / 2, positionHComment);
                                    positionFirstCutChar += positionLastBlank;
                                    // Go to next line for insertion
                                    positionHComment += 20;
                                }
                                else {
                                    // Don't cut last part
                                    newContext.fillText(comment.substr(positionFirstCutChar), width / 2, positionHComment);
                                }
                            }
                        }
                    }
                    // Add map to new canvas
                    newContext.drawImage(context.canvas, 0, positionHCanvas);
                    /** @type {?} */
                    var status = utils.SubjectStatus.Done;
                    try {
                        // Save the canvas as file
                        if (!doZipFile) {
                            _this.saveCanvasImageAsFile(newCanvas, 'map', format);
                        }
                        else if (format.toLowerCase() === 'tiff') {
                            // Add the canvas to zip
                            _this.generateCanvaFileToZip(newCanvas, 'map' + map.projection.replace(':', '_') + '.' + format);
                        }
                        else {
                            // Add the canvas to zip
                            _this.generateCanvaFileToZip(newCanvas, 'map' + '.' + format);
                        }
                    }
                    catch (err) {
                        status = utils.SubjectStatus.Error;
                    }
                    status$.next(status);
                    if (format.toLowerCase() === 'tiff') {
                        /** @type {?} */
                        var tiwContent = _this.getWorldFileInformation(map);
                        /** @type {?} */
                        var blob = new Blob([tiwContent], {
                            type: 'text/plain;charset=utf-8'
                        });
                        if (!doZipFile) {
                            // saveAs automaticly replace ':' for '_'
                            fileSaver.saveAs(blob, 'map' + map.projection + '.tfw');
                            _this.saveFileProcessing();
                        }
                        else {
                            // Add the canvas to zip
                            _this.addFileToZip('map' + map.projection.replace(':', '_') + '.tfw', blob);
                        }
                    }
                }));
                map.ol.renderSync();
            };
        /**
         * @private
         * @param {?} map
         * @param {?} size
         * @param {?} extent
         * @return {?}
         */
        PrintService.prototype.renderMap = /**
         * @private
         * @param {?} map
         * @param {?} size
         * @param {?} extent
         * @return {?}
         */
            function (map, size, extent) {
                map.ol.renderSync();
            };
        /**
         * Save document
         * @param  doc - Document to save
         */
        /**
         * Save document
         * @private
         * @param {?} doc - Document to save
         * @return {?}
         */
        PrintService.prototype.saveDoc = /**
         * Save document
         * @private
         * @param {?} doc - Document to save
         * @return {?}
         */
            function (doc) {
                doc.save('map.pdf');
            };
        /**
         * Calculate the best Image size to fit in pdf
         * @param doc - Pdf Document
         * @param canvas - Canvas of image
         * @param margins - Page margins
         */
        /**
         * Calculate the best Image size to fit in pdf
         * @private
         * @param {?} doc - Pdf Document
         * @param {?} canvas - Canvas of image
         * @param {?} margins - Page margins
         * @return {?}
         */
        PrintService.prototype.getImageSizeToFitPdf = /**
         * Calculate the best Image size to fit in pdf
         * @private
         * @param {?} doc - Pdf Document
         * @param {?} canvas - Canvas of image
         * @param {?} margins - Page margins
         * @return {?}
         */
            function (doc, canvas, margins) {
                // Define variable to calculate best size to fit in one page
                /** @type {?} */
                var pageHeight = doc.internal.pageSize.getHeight() - (margins[0] + margins[2]);
                /** @type {?} */
                var pageWidth = doc.internal.pageSize.getWidth() - (margins[1] + margins[3]);
                /** @type {?} */
                var canHeight = canvas.height;
                /** @type {?} */
                var canWidth = canvas.width;
                /** @type {?} */
                var heightRatio = canHeight / pageHeight;
                /** @type {?} */
                var widthRatio = canWidth / pageWidth;
                /** @type {?} */
                var maxRatio = heightRatio > widthRatio ? heightRatio : widthRatio;
                /** @type {?} */
                var imgHeigh = maxRatio > 1 ? canHeight / maxRatio : canHeight;
                /** @type {?} */
                var imgWidth = maxRatio > 1 ? canWidth / maxRatio : canWidth;
                return [imgWidth, imgHeigh];
            };
        /**
         * Get a world file information for tiff
         * @param  map - Map of the app
         */
        /**
         * Get a world file information for tiff
         * @private
         * @param {?} map - Map of the app
         * @return {?}
         */
        PrintService.prototype.getWorldFileInformation = /**
         * Get a world file information for tiff
         * @private
         * @param {?} map - Map of the app
         * @return {?}
         */
            function (map) {
                /** @type {?} */
                var currentResolution = map.viewController.getResolution();
                /** @type {?} */
                var currentExtent = map.getExtent();
                return [
                    currentResolution,
                    0,
                    0,
                    -currentResolution,
                    currentExtent[0] + currentResolution / 0.5,
                    currentExtent[3] - currentResolution / 0.5
                ].join('\n');
            };
        /**
         * Save canvas image as file
         * @param canvas - Canvas to save
         * @param name - Name of the file
         * @param format - file format
         */
        /**
         * Save canvas image as file
         * @private
         * @param {?} canvas - Canvas to save
         * @param {?} name - Name of the file
         * @param {?} format - file format
         * @return {?}
         */
        PrintService.prototype.saveCanvasImageAsFile = /**
         * Save canvas image as file
         * @private
         * @param {?} canvas - Canvas to save
         * @param {?} name - Name of the file
         * @param {?} format - file format
         * @return {?}
         */
            function (canvas, name, format) {
                /** @type {?} */
                var blobFormat = 'image/' + format;
                /** @type {?} */
                var that = this;
                try {
                    canvas.toDataURL(); // Just to make the catch trigger wihtout toBlob Error throw not catched
                    // If navigator is Internet Explorer
                    if (navigator.msSaveBlob) {
                        navigator.msSaveBlob(canvas.msToBlob(), name + '.' + format);
                        this.saveFileProcessing();
                    }
                    else {
                        canvas.toBlob(( /**
                         * @param {?} blob
                         * @return {?}
                         */function (blob) {
                            // download image
                            fileSaver.saveAs(blob, name + '.' + format);
                            that.saveFileProcessing();
                        }), blobFormat);
                    }
                }
                catch (err) {
                    this.messageService.error(this.languageService.translate.instant('igo.geo.printForm.corsErrorMessageBody'), this.languageService.translate.instant('igo.geo.printForm.corsErrorMessageHeader'), 'print');
                }
            };
        /**
         * Add file to a zip
         * @param canvas - File to add to the zip
         * @param  name -Name of the fileoverview
         */
        /**
         * Add file to a zip
         * @private
         * @param {?} canvas - File to add to the zip
         * @param {?} name -Name of the fileoverview
         * @return {?}
         */
        PrintService.prototype.generateCanvaFileToZip = /**
         * Add file to a zip
         * @private
         * @param {?} canvas - File to add to the zip
         * @param {?} name -Name of the fileoverview
         * @return {?}
         */
            function (canvas, name) {
                /** @type {?} */
                var blobFormat = 'image/' + 'jpeg';
                /** @type {?} */
                var that = this;
                if (!this.hasOwnProperty('zipFile') ||
                    typeof this.zipFile === 'undefined') {
                    this.zipFile = new JSZip();
                }
                try {
                    canvas.toDataURL(); // Just to make the catch trigger wihtout toBlob Error throw not catched
                    if (navigator.msSaveBlob) {
                        this.addFileToZip(name, canvas.msToBlob());
                    }
                    else {
                        canvas.toBlob(( /**
                         * @param {?} blob
                         * @return {?}
                         */function (blob) {
                            that.addFileToZip(name, blob);
                        }), blobFormat);
                    }
                }
                catch (err) {
                    this.messageService.error(this.languageService.translate.instant('igo.geo.printForm.corsErrorMessageBody'), this.languageService.translate.instant('igo.geo.printForm.corsErrorMessageHeader'), 'print');
                }
            };
        /**
         * Add file to zip, if all file are zipped, download
         * @param name - Name of the files
         * @param blob - Contain of file
         */
        /**
         * Add file to zip, if all file are zipped, download
         * @private
         * @param {?} name - Name of the files
         * @param {?} blob - Contain of file
         * @return {?}
         */
        PrintService.prototype.addFileToZip = /**
         * Add file to zip, if all file are zipped, download
         * @private
         * @param {?} name - Name of the files
         * @param {?} blob - Contain of file
         * @return {?}
         */
            function (name, blob) {
                // add file to zip
                this.zipFile.file(name, blob);
                this.nbFileToProcess--;
                // If all files are proccessed
                if (this.nbFileToProcess === 0) {
                    // Download zip file
                    this.getZipFile();
                    // Stop loading
                    this.activityService.unregister(this.activityId);
                }
            };
        /**
         * @private
         * @return {?}
         */
        PrintService.prototype.saveFileProcessing = /**
         * @private
         * @return {?}
         */
            function () {
                this.nbFileToProcess--;
                // If all files are proccessed
                if (this.nbFileToProcess === 0) {
                    // Stop loading
                    this.activityService.unregister(this.activityId);
                }
            };
        /**
         * Get the zipped file
         * @return Retun a zip file
         */
        /**
         * Get the zipped file
         * @private
         * @return {?} Retun a zip file
         */
        PrintService.prototype.getZipFile = /**
         * Get the zipped file
         * @private
         * @return {?} Retun a zip file
         */
            function () {
                /** @type {?} */
                var that = this;
                this.zipFile.generateAsync({ type: 'blob' }).then(( /**
                 * @param {?} blob
                 * @return {?}
                 */function (blob) {
                    // 1) generate the zip file
                    fileSaver.saveAs(blob, 'map.zip');
                    delete that.zipFile;
                }));
            };
        PrintService.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        PrintService.ctorParameters = function () {
            return [
                { type: i1$1.MessageService },
                { type: i1$1.ActivityService },
                { type: i1$1.LanguageService }
            ];
        };
        /** @nocollapse */ PrintService.ngInjectableDef = i0.defineInjectable({ factory: function PrintService_Factory() { return new PrintService(i0.inject(i1$1.MessageService), i0.inject(i1$1.ActivityService), i0.inject(i1$1.LanguageService)); }, token: PrintService, providedIn: "root" });
        return PrintService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var PrintComponent = /** @class */ (function () {
        function PrintComponent(printService) {
            this.printService = printService;
            this.disabled = false;
        }
        Object.defineProperty(PrintComponent.prototype, "map", {
            get: /**
             * @return {?}
             */ function () {
                return this._map;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._map = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PrintComponent.prototype, "outputFormat", {
            get: /**
             * @return {?}
             */ function () {
                return this._outputFormat;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._outputFormat = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PrintComponent.prototype, "paperFormat", {
            get: /**
             * @return {?}
             */ function () {
                return this._paperFormat;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._paperFormat = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PrintComponent.prototype, "orientation", {
            get: /**
             * @return {?}
             */ function () {
                return this._orientation;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._orientation = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PrintComponent.prototype, "imageFormat", {
            get: /**
             * @return {?}
             */ function () {
                return this._imageFormat;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._imageFormat = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PrintComponent.prototype, "resolution", {
            get: /**
             * @return {?}
             */ function () {
                return this._resolution;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._resolution = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} data
         * @return {?}
         */
        PrintComponent.prototype.handleFormSubmit = /**
         * @param {?} data
         * @return {?}
         */
            function (data) {
                this.disabled = true;
                if (data.isPrintService === true) {
                    this.printService
                        .print(this.map, data)
                        .subscribe();
                }
                else {
                    /** @type {?} */
                    var nbFileToProcess = 1;
                    if (data.showLegend) {
                        nbFileToProcess++;
                    }
                    if (data.imageFormat.toLowerCase() === 'tiff') {
                        nbFileToProcess++;
                    }
                    this.printService.defineNbFileToProcess(nbFileToProcess);
                    /** @type {?} */
                    var resolution = +data.resolution;
                    this.printService.downloadMapImage(this.map, resolution, data.imageFormat, data.showProjection, data.showScale, data.showLegend, data.title, data.comment, data.doZipFile);
                    if (data.showLegend) {
                        this.printService.getLayersLegendImage(this.map, data.imageFormat, data.doZipFile, +resolution);
                    }
                }
                this.disabled = false;
            };
        PrintComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'igo-print',
                        template: "<igo-print-form\r\n  [outputFormat]=\"outputFormat\"\r\n  [paperFormat]=\"paperFormat\"\r\n  [orientation]=\"orientation\"\r\n  [imageFormat]=\"imageFormat\"\r\n  [resolution]=\"resolution\"\r\n  [disabled]=\"disabled\"\r\n  (submit)=\"handleFormSubmit($event)\">\r\n</igo-print-form>\r\n"
                    }] }
        ];
        /** @nocollapse */
        PrintComponent.ctorParameters = function () {
            return [
                { type: PrintService }
            ];
        };
        PrintComponent.propDecorators = {
            map: [{ type: i0.Input }],
            outputFormat: [{ type: i0.Input }],
            paperFormat: [{ type: i0.Input }],
            orientation: [{ type: i0.Input }],
            imageFormat: [{ type: i0.Input }],
            resolution: [{ type: i0.Input }]
        };
        return PrintComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var PrintOutputFormat = utils.strEnum(['Pdf', 'Image']);
    /** @type {?} */
    var PrintPaperFormat = utils.strEnum([
        'A0',
        'A1',
        'A2',
        'A3',
        'A4',
        'A5',
        'Letter',
        'Legal'
    ]);
    /** @type {?} */
    var PrintOrientation = utils.strEnum(['landscape', 'portrait']);
    /** @type {?} */
    var PrintResolution = utils.strEnum(['72', '96', '150', '300']);
    /** @type {?} */
    var PrintSaveImageFormat = utils.strEnum([
        'Bmp',
        'Gif',
        'Jpeg',
        'Png',
        'Tiff'
    ]);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var PrintFormComponent = /** @class */ (function () {
        function PrintFormComponent(formBuilder) {
            this.formBuilder = formBuilder;
            this.outputFormats = PrintOutputFormat;
            this.paperFormats = PrintPaperFormat;
            this.orientations = PrintOrientation;
            this.resolutions = PrintResolution;
            this.imageFormats = PrintSaveImageFormat;
            this.isPrintService = true;
            this._disabled = false;
            this.submit = new i0.EventEmitter();
            this.form = this.formBuilder.group({
                title: ['', []],
                comment: ['', []],
                outputFormat: ['', [forms.Validators.required]],
                paperFormat: ['', [forms.Validators.required]],
                imageFormat: ['', [forms.Validators.required]],
                resolution: ['', [forms.Validators.required]],
                orientation: ['', [forms.Validators.required]],
                showProjection: false,
                showScale: false,
                showLegend: false,
                doZipFile: [{ hidden: this.isPrintService }]
            });
        }
        Object.defineProperty(PrintFormComponent.prototype, "disabled", {
            get: /**
             * @return {?}
             */ function () {
                return this._disabled;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._disabled = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PrintFormComponent.prototype, "imageFormat", {
            get: /**
             * @return {?}
             */ function () {
                return this.imageFormatField.value;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.imageFormatField.setValue(value || PrintSaveImageFormat.Jpeg, {
                    onlySelf: true
                });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PrintFormComponent.prototype, "outputFormat", {
            get: /**
             * @return {?}
             */ function () {
                return this.outputFormatField.value;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.outputFormatField.setValue(value || PrintOutputFormat.Pdf, {
                    onlySelf: true
                });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PrintFormComponent.prototype, "paperFormat", {
            get: /**
             * @return {?}
             */ function () {
                return this.paperFormatField.value;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.paperFormatField.setValue(value || PrintPaperFormat.Letter, {
                    onlySelf: true
                });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PrintFormComponent.prototype, "orientation", {
            get: /**
             * @return {?}
             */ function () {
                return this.orientationField.value;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.orientationField.setValue(value || PrintOrientation.landscape, {
                    onlySelf: true
                });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PrintFormComponent.prototype, "resolution", {
            get: /**
             * @return {?}
             */ function () {
                return this.resolutionField.value;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.resolutionField.setValue(value || PrintResolution['96'], {
                    onlySelf: true
                });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PrintFormComponent.prototype, "title", {
            get: /**
             * @return {?}
             */ function () {
                return this.titleField.value;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.titleField.setValue(value, { onlySelf: true });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PrintFormComponent.prototype, "comment", {
            get: /**
             * @return {?}
             */ function () {
                return this.commentField.value;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.commentField.setValue(value, { onlySelf: true });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PrintFormComponent.prototype, "showProjection", {
            get: /**
             * @return {?}
             */ function () {
                return this.showProjectionField.value;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.showProjectionField.setValue(value, { onlySelf: true });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PrintFormComponent.prototype, "showScale", {
            get: /**
             * @return {?}
             */ function () {
                return this.showScaleField.value;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.showScaleField.setValue(value, { onlySelf: true });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PrintFormComponent.prototype, "showLegend", {
            get: /**
             * @return {?}
             */ function () {
                return this.showLegendField.value;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.showLegendField.setValue(value, { onlySelf: true });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PrintFormComponent.prototype, "doZipFile", {
            get: /**
             * @return {?}
             */ function () {
                return this.doZipFileField.value;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.doZipFileField.setValue(value, { onlySelf: true });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PrintFormComponent.prototype, "outputFormatField", {
            get: /**
             * @return {?}
             */ function () {
                return ( /** @type {?} */((( /** @type {?} */(this.form.controls))).outputFormat));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PrintFormComponent.prototype, "paperFormatField", {
            get: /**
             * @return {?}
             */ function () {
                return ( /** @type {?} */((( /** @type {?} */(this.form.controls))).paperFormat));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PrintFormComponent.prototype, "imageFormatField", {
            get: /**
             * @return {?}
             */ function () {
                return ( /** @type {?} */((( /** @type {?} */(this.form.controls))).imageFormat));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PrintFormComponent.prototype, "orientationField", {
            get: /**
             * @return {?}
             */ function () {
                return ( /** @type {?} */((( /** @type {?} */(this.form.controls))).orientation));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PrintFormComponent.prototype, "resolutionField", {
            get: /**
             * @return {?}
             */ function () {
                return ( /** @type {?} */((( /** @type {?} */(this.form.controls))).resolution));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PrintFormComponent.prototype, "commentField", {
            get: /**
             * @return {?}
             */ function () {
                return ( /** @type {?} */((( /** @type {?} */(this.form.controls))).comment));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PrintFormComponent.prototype, "showProjectionField", {
            get: /**
             * @return {?}
             */ function () {
                return ( /** @type {?} */((( /** @type {?} */(this.form.controls))).showProjection));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PrintFormComponent.prototype, "showScaleField", {
            get: /**
             * @return {?}
             */ function () {
                return ( /** @type {?} */((( /** @type {?} */(this.form.controls))).showScale));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PrintFormComponent.prototype, "showLegendField", {
            get: /**
             * @return {?}
             */ function () {
                return ( /** @type {?} */((( /** @type {?} */(this.form.controls))).showLegend));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PrintFormComponent.prototype, "doZipFileField", {
            get: /**
             * @return {?}
             */ function () {
                return ( /** @type {?} */((( /** @type {?} */(this.form.controls))).doZipFile));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PrintFormComponent.prototype, "titleField", {
            get: /**
             * @return {?}
             */ function () {
                return ( /** @type {?} */((( /** @type {?} */(this.form.controls))).title));
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        PrintFormComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.doZipFileField.setValue(false);
            };
        /**
         * @param {?} data
         * @param {?} isValid
         * @return {?}
         */
        PrintFormComponent.prototype.handleFormSubmit = /**
         * @param {?} data
         * @param {?} isValid
         * @return {?}
         */
            function (data, isValid) {
                this.submitted = true;
                data.isPrintService = this.isPrintService;
                if (isValid) {
                    this.submit.emit(data);
                }
            };
        /**
         * @return {?}
         */
        PrintFormComponent.prototype.toggleImageSaveProp = /**
         * @return {?}
         */
            function () {
                if (this.outputFormatField.value === 'Image') {
                    this.isPrintService = false;
                }
                else {
                    this.isPrintService = true;
                }
            };
        PrintFormComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'igo-print-form',
                        template: "<form class=\"igo-form\" [formGroup]=\"form\">\r\n  <div class=\"igo-input-container\">\r\n    <mat-form-field>\r\n      <input\r\n        matInput\r\n        formControlName=\"title\"\r\n        placeholder=\"{{'igo.geo.printForm.title' | translate}}\">\r\n    </mat-form-field>\r\n  </div>\r\n\r\n  <div class=\"igo-input-container\">\r\n    <mat-form-field>\r\n      <input\r\n        matInput\r\n        formControlName=\"comment\"\r\n        placeholder=\"{{'igo.geo.printForm.comment' | translate}}\">\r\n    </mat-form-field>\r\n  </div>\r\n\r\n  <div class=\"igo-input-container\">\r\n    <div class=\"print-slide-toggle-container\">\r\n      <mat-slide-toggle\r\n        class=\"print-option\"\r\n        formControlName=\"showProjection\"\r\n        [labelPosition]=\"'before'\">\r\n        {{'igo.geo.printForm.showProjection' | translate}}\r\n      </mat-slide-toggle>\r\n      <mat-slide-toggle\r\n        class=\"print-option\"\r\n        formControlName=\"showScale\"\r\n        [labelPosition]=\"'before'\">\r\n        {{'igo.geo.printForm.showScale' | translate}}\r\n      </mat-slide-toggle>\r\n      <mat-slide-toggle\r\n        class=\"print-option\"\r\n        formControlName=\"showLegend\"\r\n        [labelPosition]=\"'before'\">\r\n        {{'igo.geo.printForm.showLegend' | translate}}\r\n      </mat-slide-toggle>\r\n      <mat-slide-toggle\r\n        class=\"print-option\"\r\n        formControlName=\"doZipFile\"\r\n        [labelPosition]=\"'before'\"\r\n        [style.display]=\"isPrintService ? 'none' : ''\">\r\n        {{'igo.geo.printForm.doZipFile' | translate}}\r\n      </mat-slide-toggle>\r\n    </div>\r\n  </div>\r\n\r\n  <div class=\"igo-input-container\">\r\n    <mat-form-field>\r\n      <mat-select (selectionChange)=\"toggleImageSaveProp()\"\r\n        formControlName=\"outputFormat\"\r\n        placeholder=\"{{'igo.geo.printForm.outputFormat' | translate}}\">\r\n        <mat-option *ngFor=\"let outputFormat of outputFormats | keyvalue \" [value]=\"outputFormat.key\">\r\n            {{outputFormat.value}}\r\n        </mat-option>\r\n      </mat-select>\r\n    </mat-form-field>\r\n  </div>\r\n\r\n  <div class=\"igo-input-container\" [style.display]=\"isPrintService ? 'block' : 'none'\">\r\n    <mat-form-field>\r\n      <mat-select\r\n        formControlName=\"paperFormat\"\r\n        placeholder=\"{{'igo.geo.printForm.paperFormat' | translate}}\">\r\n        <mat-option *ngFor=\"let paperFormat of paperFormats | keyvalue \" [value]=\"paperFormat.key\">\r\n          {{('igo.geo.printForm.paperFormats.' + paperFormat.value) | translate}}\r\n        </mat-option>\r\n      </mat-select>\r\n    </mat-form-field>\r\n  </div>\r\n\r\n  <div class=\"igo-input-container\" [style.display]=\"isPrintService ? 'none' : 'block'\">\r\n    <mat-form-field>\r\n      <mat-select\r\n        formControlName=\"imageFormat\"\r\n        placeholder=\"{{'igo.geo.printForm.imageFormat' | translate}}\">\r\n        <mat-option *ngFor=\"let imageFormat of imageFormats | keyvalue \" [value]=\"imageFormat.key\">\r\n          {{imageFormat.value}}\r\n        </mat-option>\r\n      </mat-select>\r\n    </mat-form-field>\r\n  </div>\r\n\r\n  <div class=\"igo-input-container\" style=\"display: none;\">\r\n    <mat-form-field>\r\n      <mat-select\r\n        formControlName=\"resolution\"\r\n        placeholder=\"{{'igo.geo.printForm.resolution' | translate}}\">\r\n        <mat-option *ngFor=\"let resolution of resolutions | keyvalue \" [value]=\"resolution.key\">\r\n          {{resolution.value + ' PPI'}}\r\n        </mat-option>\r\n      </mat-select>\r\n    </mat-form-field>\r\n  </div>\r\n\r\n  <div class=\"igo-input-container\" [style.display]=\"isPrintService ? 'block' : 'none'\">\r\n    <mat-form-field>\r\n      <mat-select\r\n        formControlName=\"orientation\"\r\n        placeholder=\"{{'igo.geo.printForm.orientation' | translate}}\">\r\n        <mat-option *ngFor=\"let orientation of orientations | keyvalue \" [value]=\"orientation.key\">\r\n          {{('igo.geo.printForm.' + orientation.value) | translate}}\r\n        </mat-option>\r\n      </mat-select>\r\n    </mat-form-field>\r\n  </div>\r\n\r\n  <div class=\"igo-form-button-group print-button-top-padding\">\r\n    <button\r\n      mat-raised-button\r\n      type=\"button\"\r\n      [disabled]=\"!form.valid || disabled\"\r\n      (click)=\"handleFormSubmit(form.value, form.valid)\">\r\n      {{'igo.geo.printForm.saveBtn' | translate}}\r\n    </button>\r\n  </div>\r\n\r\n</form>\r\n",
                        styles: ["mat-form-field{width:100%}.print-slide-toggle-container{overflow-x:hidden}.print-slide-toggle-container mat-slide-toggle{width:100%;margin:10px}.print-slide-toggle-container mat-slide-toggle ::ng-deep .mat-slide-toggle-content{width:calc(100% - 60px);font-size:16px}.print-option{display:block;margin-right:10px;margin-bottom:15px}.print-button-top-padding{padding-top:25px}.igo-form{padding:10px 5px 5px}.igo-form-button-group{text-align:center}"]
                    }] }
        ];
        /** @nocollapse */
        PrintFormComponent.ctorParameters = function () {
            return [
                { type: forms.FormBuilder }
            ];
        };
        PrintFormComponent.propDecorators = {
            disabled: [{ type: i0.Input }],
            imageFormat: [{ type: i0.Input }],
            outputFormat: [{ type: i0.Input }],
            paperFormat: [{ type: i0.Input }],
            orientation: [{ type: i0.Input }],
            resolution: [{ type: i0.Input }],
            title: [{ type: i0.Input }],
            comment: [{ type: i0.Input }],
            showProjection: [{ type: i0.Input }],
            showScale: [{ type: i0.Input }],
            showLegend: [{ type: i0.Input }],
            doZipFile: [{ type: i0.Input }],
            submit: [{ type: i0.Output }]
        };
        return PrintFormComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var IgoPrintModule = /** @class */ (function () {
        function IgoPrintModule() {
        }
        IgoPrintModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            forms.ReactiveFormsModule,
                            material.MatIconModule,
                            material.MatButtonModule,
                            material.MatSelectModule,
                            material.MatOptionModule,
                            material.MatInputModule,
                            material.MatFormFieldModule,
                            material.MatSlideToggleModule,
                            i1$1.IgoLanguageModule,
                            common$1.IgoKeyValueModule
                        ],
                        exports: [PrintComponent, PrintFormComponent],
                        declarations: [PrintComponent, PrintFormComponent]
                    },] }
        ];
        return IgoPrintModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Map search source factory
     * @ignore
     * @param {?} config
     * @return {?}
     */
    function querySearchSourceFactory(config) {
        return new QuerySearchSource(config.getConfig("searchSources." + QuerySearchSource.id) || {});
    }
    /**
     * Function that returns a provider for the map search source
     * @return {?}
     */
    function provideQuerySearchSource() {
        return {
            provide: SearchSource,
            useFactory: querySearchSourceFactory,
            multi: true,
            deps: [i1$1.ConfigService]
        };
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var IgoQueryModule = /** @class */ (function () {
        function IgoQueryModule() {
        }
        /**
         * @return {?}
         */
        IgoQueryModule.forRoot = /**
         * @return {?}
         */
            function () {
                return {
                    ngModule: IgoQueryModule,
                    providers: [provideQuerySearchSource()]
                };
            };
        IgoQueryModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [QueryDirective],
                        declarations: [QueryDirective],
                        providers: [QueryService]
                    },] }
        ];
        return IgoQueryModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Service where all available search sources are registered.
     */
    var /**
     * Service where all available search sources are registered.
     */ SearchSourceService = /** @class */ (function () {
        function SearchSourceService(sources) {
            this.sources = sources;
        }
        /**
         * Return available search sources
         * @returns Search sources
         */
        /**
         * Return available search sources
         * @return {?} Search sources
         */
        SearchSourceService.prototype.getSources = /**
         * Return available search sources
         * @return {?} Search sources
         */
            function () {
                return this.sources;
            };
        /**
         * Return enabled search sources
         * @returns Search sources
         */
        /**
         * Return enabled search sources
         * @return {?} Search sources
         */
        SearchSourceService.prototype.getEnabledSources = /**
         * Return enabled search sources
         * @return {?} Search sources
         */
            function () {
                return this.getSources().filter(( /**
                 * @param {?} source
                 * @return {?}
                 */function (source) { return source.enabled === true; }));
            };
        /**
         * Enable search sources of given type
         * @param type Search type
         * @todo It would be better to track the enabled search sources
         *  without updating their 'enabled' property.
         */
        /**
         * Enable search sources of given type
         * \@todo It would be better to track the enabled search sources
         *  without updating their 'enabled' property.
         * @param {?} type Search type
         * @return {?}
         */
        SearchSourceService.prototype.enableSourcesByType = /**
         * Enable search sources of given type
         * \@todo It would be better to track the enabled search sources
         *  without updating their 'enabled' property.
         * @param {?} type Search type
         * @return {?}
         */
            function (type) {
                this.getSources().forEach(( /**
                 * @param {?} source
                 * @return {?}
                 */function (source) {
                    if ((( /** @type {?} */(source.constructor))).type === type) {
                        source.enabled = true;
                    }
                    else {
                        source.enabled = false;
                    }
                }));
            };
        /**
         * Set Param from the selected settings
         * @param source search-source
         * @param setting settings
         */
        /**
         * Set Param from the selected settings
         * @param {?} source search-source
         * @param {?} setting settings
         * @return {?}
         */
        SearchSourceService.prototype.setParamFromSetting = /**
         * Set Param from the selected settings
         * @param {?} source search-source
         * @param {?} setting settings
         * @return {?}
         */
            function (source, setting) {
                source.setParamFromSetting(setting);
            };
        return SearchSourceService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Function that checks whether a search source implements TextSearch
     * @param {?} source Search source
     * @return {?} True if the search source implements TextSearch
     */
    function sourceCanSearch(source) {
        return (( /** @type {?} */(source))).search !== undefined;
    }
    /**
     * Function that checks whether a search source implements ReverseSearch
     * @param {?} source Search source
     * @return {?} True if the search source implements ReverseSearch
     */
    function sourceCanReverseSearch(source) {
        return (( /** @type {?} */(source))).reverseSearch !== undefined;
    }
    /**
     * Return a search result out of an Feature. This is used to adapt
     * the IGO query module to the new Feature/SearchResult interfaces
     * @param {?} feature feature
     * @param {?} source Search source
     * @return {?} SearchResult
     */
    function featureToSearchResult(feature, source) {
        return {
            source: source,
            data: feature,
            meta: {
                dataType: FEATURE,
                id: ( /** @type {?} */(feature.meta.id)),
                title: feature.meta.title,
                icon: 'map-marker'
            }
        };
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * This service perform researches in all the search sources enabled.
     * It returns Research objects who's 'request' property needs to be
     * subscribed to in order to trigger the research. This services has
     * keeps internal state of the researches it performed
     * and the results they yielded.
     */
    var SearchService = /** @class */ (function () {
        function SearchService(searchSourceService, mapService) {
            this.searchSourceService = searchSourceService;
            this.mapService = mapService;
        }
        /**
         * Perform a research by text
         * @param term Any text
         * @returns Researches
         */
        /**
         * Perform a research by text
         * @param {?} term Any text
         * @param {?=} options
         * @return {?} Researches
         */
        SearchService.prototype.search = /**
         * Perform a research by text
         * @param {?} term Any text
         * @param {?=} options
         * @return {?} Researches
         */
            function (term, options) {
                if (!this.termIsValid(term)) {
                    return [];
                }
                /** @type {?} */
                var response = stringToLonLat(term, this.mapService.getMap().projection);
                if (response.lonLat) {
                    return this.reverseSearch(response.lonLat);
                }
                else {
                    console.log(response.message);
                }
                /** @type {?} */
                var sources = this.searchSourceService.getEnabledSources()
                    .filter(sourceCanSearch);
                return this.searchSources(sources, term, options || {});
            };
        /**
         * Perform a research by lon/lat
         * @param lonLat Any lon/lat coordinates
         * @returns Researches
         */
        /**
         * Perform a research by lon/lat
         * @param {?} lonLat Any lon/lat coordinates
         * @param {?=} options
         * @return {?} Researches
         */
        SearchService.prototype.reverseSearch = /**
         * Perform a research by lon/lat
         * @param {?} lonLat Any lon/lat coordinates
         * @param {?=} options
         * @return {?} Researches
         */
            function (lonLat, options) {
                /** @type {?} */
                var sources = this.searchSourceService.getEnabledSources()
                    .filter(sourceCanReverseSearch);
                return this.reverseSearchSources(sources, lonLat, options || {});
            };
        /**
         * Create a text research out of all given search sources
         * @param sources Search sources that implement TextSearch
         * @param term Search term
         * @returns Observable of Researches
         */
        /**
         * Create a text research out of all given search sources
         * @private
         * @param {?} sources Search sources that implement TextSearch
         * @param {?} term Search term
         * @param {?} options
         * @return {?} Observable of Researches
         */
        SearchService.prototype.searchSources = /**
         * Create a text research out of all given search sources
         * @private
         * @param {?} sources Search sources that implement TextSearch
         * @param {?} term Search term
         * @param {?} options
         * @return {?} Observable of Researches
         */
            function (sources, term, options) {
                return sources.map(( /**
                 * @param {?} source
                 * @return {?}
                 */function (source) {
                    return {
                        request: (( /** @type {?} */(( /** @type {?} */(source))))).search(term, options),
                        reverse: false,
                        source: source
                    };
                }));
            };
        /**
         * Create a reverse research out of all given search sources
         * @param sources Search sources that implement ReverseSearch
         * @param lonLat Any lon/lat coordinates
         * @returns Observable of Researches
         */
        /**
         * Create a reverse research out of all given search sources
         * @private
         * @param {?} sources Search sources that implement ReverseSearch
         * @param {?} lonLat Any lon/lat coordinates
         * @param {?} options
         * @return {?} Observable of Researches
         */
        SearchService.prototype.reverseSearchSources = /**
         * Create a reverse research out of all given search sources
         * @private
         * @param {?} sources Search sources that implement ReverseSearch
         * @param {?} lonLat Any lon/lat coordinates
         * @param {?} options
         * @return {?} Observable of Researches
         */
            function (sources, lonLat, options) {
                return sources.map(( /**
                 * @param {?} source
                 * @return {?}
                 */function (source) {
                    return {
                        request: (( /** @type {?} */(( /** @type {?} */(source))))).reverseSearch(lonLat, options),
                        reverse: true,
                        source: source
                    };
                }));
            };
        /**
         * Validate that a search term is valid
         * @param term Search term
         * @returns True if the search term is valid
         */
        /**
         * Validate that a search term is valid
         * @private
         * @param {?} term Search term
         * @return {?} True if the search term is valid
         */
        SearchService.prototype.termIsValid = /**
         * Validate that a search term is valid
         * @private
         * @param {?} term Search term
         * @return {?} True if the search term is valid
         */
            function (term) {
                return typeof term === 'string' && term !== '';
            };
        SearchService.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        SearchService.ctorParameters = function () {
            return [
                { type: SearchSourceService },
                { type: MapService }
            ];
        };
        /** @nocollapse */ SearchService.ngInjectableDef = i0.defineInjectable({ factory: function SearchService_Factory() { return new SearchService(i0.inject(SearchSourceService), i0.inject(MapService)); }, token: SearchService, providedIn: "root" });
        return SearchService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @abstract
     */
    var /**
     * @abstract
     */ RoutingSource = /** @class */ (function () {
        function RoutingSource() {
        }
        return RoutingSource;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var RoutingSourceService = /** @class */ (function () {
        function RoutingSourceService(sources) {
            this.sources = sources;
        }
        return RoutingSourceService;
    }());
    /**
     * @param {?} sources
     * @return {?}
     */
    function routingSourceServiceFactory(sources) {
        return new RoutingSourceService(sources);
    }
    /**
     * @return {?}
     */
    function provideRoutingSourceService() {
        return {
            provide: RoutingSourceService,
            useFactory: routingSourceServiceFactory,
            deps: [RoutingSource]
        };
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var RoutingService = /** @class */ (function () {
        function RoutingService(routingSourceService) {
            this.routingSourceService = routingSourceService;
        }
        /**
         * @param {?} coordinates
         * @return {?}
         */
        RoutingService.prototype.route = /**
         * @param {?} coordinates
         * @return {?}
         */
            function (coordinates) {
                var _this = this;
                if (coordinates.length === 0) {
                    return;
                }
                return this.routingSourceService.sources
                    .filter(( /**
             * @param {?} source
             * @return {?}
             */function (source) { return source.enabled; }))
                    .map(( /**
             * @param {?} source
             * @return {?}
             */function (source) { return _this.routeSource(source, coordinates); }));
            };
        /**
         * @param {?} source
         * @param {?} coordinates
         * @return {?}
         */
        RoutingService.prototype.routeSource = /**
         * @param {?} source
         * @param {?} coordinates
         * @return {?}
         */
            function (source, coordinates) {
                /** @type {?} */
                var request = source.route(coordinates);
                return request;
            };
        RoutingService.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        RoutingService.ctorParameters = function () {
            return [
                { type: RoutingSourceService }
            ];
        };
        /** @nocollapse */ RoutingService.ngInjectableDef = i0.defineInjectable({ factory: function RoutingService_Factory() { return new RoutingService(i0.inject(RoutingSourceService)); }, token: RoutingService, providedIn: "root" });
        return RoutingService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var RoutingFormService = /** @class */ (function () {
        function RoutingFormService() {
            this.mapWaitingForRoutingClick = false;
        }
        /**
         * @return {?}
         */
        RoutingFormService.prototype.getStopsCoordinates = /**
         * @return {?}
         */
            function () {
                return this.stopsCoordinates;
            };
        /**
         * @param {?} stopsCoordinates
         * @return {?}
         */
        RoutingFormService.prototype.setStopsCoordinates = /**
         * @param {?} stopsCoordinates
         * @return {?}
         */
            function (stopsCoordinates) {
                this.stopsCoordinates = stopsCoordinates;
            };
        /**
         * @return {?}
         */
        RoutingFormService.prototype.isMapWaitingForRoutingClick = /**
         * @return {?}
         */
            function () {
                return this.mapWaitingForRoutingClick;
            };
        /**
         * @return {?}
         */
        RoutingFormService.prototype.setMapWaitingForRoutingClick = /**
         * @return {?}
         */
            function () {
                this.mapWaitingForRoutingClick = true;
            };
        /**
         * @return {?}
         */
        RoutingFormService.prototype.unsetMapWaitingForRoutingClick = /**
         * @return {?}
         */
            function () {
                this.mapWaitingForRoutingClick = false;
            };
        RoutingFormService.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        RoutingFormService.ctorParameters = function () { return []; };
        return RoutingFormService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var RoutingFormComponent = /** @class */ (function () {
        function RoutingFormComponent(formBuilder, routingService, languageService, messageService, searchService, queryService, routingFormService, route) {
            this.formBuilder = formBuilder;
            this.routingService = routingService;
            this.languageService = languageService;
            this.messageService = messageService;
            this.searchService = searchService;
            this.queryService = queryService;
            this.routingFormService = routingFormService;
            this.route = route;
            this.invalidKeys = ['Control', 'Shift', 'Alt'];
            this.projection = 'EPSG:4326';
            this.routesQueries$$ = [];
            this.stream$ = new rxjs.Subject();
            this.focusOnStop = false;
            this.focusKey = [];
            this._term = '';
            this._debounce = 300;
            this._length = 3;
            this.submit = new i0.EventEmitter();
        }
        Object.defineProperty(RoutingFormComponent.prototype, "term", {
            // https://stackoverflow.com/questions/46364852/create-input-fields-dynamically-in-angular-2
            get: 
            // https://stackoverflow.com/questions/46364852/create-input-fields-dynamically-in-angular-2
            /**
             * @return {?}
             */
            function () {
                return this._term;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._term = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RoutingFormComponent.prototype, "debounce", {
            get: /**
             * @return {?}
             */ function () {
                return this._debounce;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._debounce = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RoutingFormComponent.prototype, "length", {
            get: /**
             * @return {?}
             */ function () {
                return this._length;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._length = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RoutingFormComponent.prototype, "map", {
            get: /**
             * @return {?}
             */ function () {
                return this._map;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._map = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} selectedRoute
         * @return {?}
         */
        RoutingFormComponent.prototype.changeRoute = /**
         * @param {?} selectedRoute
         * @return {?}
         */
            function (selectedRoute) {
                this.showRouteGeometry();
            };
        /**
         * @return {?}
         */
        RoutingFormComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.unsubscribeRoutesQueries();
                this.unlistenSingleClick();
                this.queryService.queryEnabled = true;
                /** @type {?} */
                var stopCoordinates = [];
                this.stops.value.forEach(( /**
                 * @param {?} stop
                 * @return {?}
                 */function (stop) {
                    stopCoordinates.push(stop.stopCoordinates);
                }));
                this.routingRoutesOverlayDataSource.ol.clear();
                this.routingStopsOverlayDataSource.ol.clear();
                this.routingFormService.setStopsCoordinates(stopCoordinates);
            };
        /**
         * @return {?}
         */
        RoutingFormComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.browserLanguage = this.languageService.getLanguage();
                this.stopsForm = this.formBuilder.group({
                    routingType: 'car',
                    routingMode: 'driving',
                    // loop
                    stopOrderPriority: true,
                    routingFixedStartEnd: false,
                    stops: this.formBuilder.array([
                        this.createStop('start'),
                        this.createStop('end')
                    ])
                });
                this.routingStopsOverlayDataSource = new FeatureDataSource({});
                this.routingRoutesOverlayDataSource = new FeatureDataSource({});
            };
        /**
         * @return {?}
         */
        RoutingFormComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.queryService.queryEnabled = false;
                this.focusOnStop = false;
                /** @type {?} */
                var stopsLayer = new VectorLayer({
                    title: 'routingStopOverlay',
                    zIndex: 999,
                    id: 'routingStops',
                    source: this.routingStopsOverlayDataSource,
                    showInLayerList: false
                });
                /** @type {?} */
                var routesLayer = new VectorLayer({
                    title: 'routingRoutesOverlay',
                    zIndex: 999,
                    id: 'routingRoutes',
                    opacity: 0.75,
                    source: this.routingRoutesOverlayDataSource,
                    showInLayerList: false
                });
                this.map.addLayer(routesLayer);
                this.map.addLayer(stopsLayer);
                /** @type {?} */
                var selectedStopFeature;
                /** @type {?} */
                var selectStops = new olinteraction.Select({
                    layers: [stopsLayer.ol],
                    condition: olcondition.pointerMove,
                    hitTolerance: 7
                });
                /** @type {?} */
                var translateStop = new olinteraction.Translate({
                    layers: [stopsLayer.ol],
                    features: selectedStopFeature
                });
                // TODO: Check to disable pointermove IF a stop is already selected
                /** @type {?} */
                var selectRouteHover = new olinteraction.Select({
                    layers: [routesLayer.ol],
                    condition: olcondition.pointerMove,
                    hitTolerance: 7
                });
                this.selectRoute = new olinteraction.Select({
                    layers: [routesLayer.ol],
                    hitTolerance: 7
                });
                this.map.ol.on('pointermove', ( /**
                 * @param {?} evt
                 * @return {?}
                 */function (evt) {
                    /** @type {?} */
                    var selectRouteCnt = selectRouteHover.getFeatures().getLength();
                    if (selectRouteCnt === 0) {
                        _this.routingFormService.unsetMapWaitingForRoutingClick();
                    }
                    else {
                        _this.routingFormService.setMapWaitingForRoutingClick();
                    }
                }));
                selectStops.on('select', ( /**
                 * @param {?} evt
                 * @return {?}
                 */function (evt) {
                    selectedStopFeature = evt.target.getFeatures()[0];
                }));
                this.selectRoute.on('select', ( /**
                 * @param {?} evt
                 * @return {?}
                 */function (evt) {
                    if (_this.focusOnStop === false) {
                        /** @type {?} */
                        var selectCoordinates = olproj.transform((( /** @type {?} */(evt))).mapBrowserEvent.coordinate, _this.map.projection, _this.projection);
                        _this.addStop();
                        /** @type {?} */
                        var pos = _this.stops.length - 2;
                        _this.stops.at(pos).patchValue({ stopCoordinates: selectCoordinates });
                        _this.handleLocationProposals(selectCoordinates, pos);
                        _this.addStopOverlay(selectCoordinates, pos);
                        _this.selectRoute.getFeatures().clear();
                    }
                    _this.selectRoute.getFeatures().clear();
                }));
                this.routesQueries$$.push(this.stopsForm.statusChanges
                    .pipe(operators.debounceTime(this._debounce))
                    .subscribe(( /**
             * @param {?} val
             * @return {?}
             */function (val) { return _this.onFormChange(); })));
                translateStop.on('translateend', ( /**
                 * @param {?} evt
                 * @return {?}
                 */function (evt) {
                    /** @type {?} */
                    var translatedID = evt.features.getArray()[0].getId();
                    /** @type {?} */
                    var translatedPos = translatedID.split('_');
                    /** @type {?} */
                    var p;
                    switch (translatedPos[1]) {
                        case 'start':
                            p = 0;
                            break;
                        case 'end':
                            p = _this.stops.length - 1;
                            break;
                        default:
                            p = Number(translatedPos[1]);
                            break;
                    }
                    /** @type {?} */
                    var translationEndCoordinates = olproj.transform(evt.features
                        .getArray()[0]
                        .getGeometry()
                        .getCoordinates(), _this.map.projection, _this.projection);
                    _this.stops
                        .at(p)
                        .patchValue({ stopCoordinates: translationEndCoordinates });
                    _this.stops.at(p).patchValue({ stopProposals: [] });
                    _this.handleLocationProposals(translationEndCoordinates, p);
                }));
                this.map.ol.addInteraction(selectStops);
                this.map.ol.addInteraction(selectRouteHover);
                this.map.ol.addInteraction(this.selectRoute);
                this.map.ol.addInteraction(translateStop);
                this.routesQueries$$.push(this.stream$
                    .pipe(operators.debounceTime(this._debounce), operators.distinctUntilChanged())
                    .subscribe(( /**
             * @param {?} term
             * @return {?}
             */function (term) { return _this.handleTermChanged(term); })));
            };
        /**
         * @param {?} coordinates
         * @param {?} stopIndex
         * @return {?}
         */
        RoutingFormComponent.prototype.handleLocationProposals = /**
         * @param {?} coordinates
         * @param {?} stopIndex
         * @return {?}
         */
            function (coordinates, stopIndex) {
                var _this = this;
                /** @type {?} */
                var groupedLocations = [];
                this.searchService
                    .reverseSearch(coordinates, { zoom: this.map.getZoom() })
                    .map(( /**
             * @param {?} res
             * @return {?}
             */function (res) {
                    return _this.routesQueries$$.push(res.request.pipe(operators.map(( /**
                     * @param {?} f
                     * @return {?}
                     */function (f) { return f; }))).subscribe(( /**
                     * @param {?} results
                     * @return {?}
                     */function (results) {
                        results.forEach(( /**
                         * @param {?} result
                         * @return {?}
                         */function (result) {
                            if (groupedLocations.filter(( /**
                             * @param {?} f
                             * @return {?}
                             */function (f) { return f.source === result.source; }))
                                .length === 0) {
                                groupedLocations.push({
                                    source: result.source,
                                    results: results.map(( /**
                                     * @param {?} r
                                     * @return {?}
                                     */function (r) { return r.data; }))
                                });
                            }
                        }));
                        _this.stops
                            .at(stopIndex)
                            .patchValue({ stopProposals: groupedLocations });
                        // TODO: Prefer another source?
                        if (results[0]) {
                            if (results[0].source.getId() === 'icherchereverse') {
                                // prefer address type.
                                /** @type {?} */
                                var resultPos = 0;
                                for (var i = 0; i < results.length; i++) {
                                    /** @type {?} */
                                    var feature = results[i].data;
                                    if (feature.properties.type === 'adresse') {
                                        resultPos = i;
                                        break;
                                    }
                                }
                                _this.stops.at(stopIndex).patchValue({
                                    stopPoint: common$1.getEntityTitle(results[resultPos])
                                });
                                if (results[resultPos].data.geometry.type === 'Point') {
                                    _this.stops.at(stopIndex).patchValue({
                                        stopCoordinates: results[resultPos].data.geometry.coordinates
                                    });
                                }
                            }
                        }
                        else {
                            _this.stops.at(stopIndex).patchValue({ stopPoint: coordinates });
                            _this.stops.at(stopIndex).patchValue({ stopProposals: [] });
                        }
                    })));
                }));
            };
        /**
         * @param {?} index
         * @return {?}
         */
        RoutingFormComponent.prototype.routingText = /**
         * @param {?} index
         * @return {?}
         */
            function (index) {
                if (index === 0) {
                    return 'start';
                }
                else if (index === this.stops.length - 1 || this.stops.length === 1) {
                    return 'end';
                }
                else {
                    return 'intermediate';
                }
            };
        /**
         * @param {?} index
         * @return {?}
         */
        RoutingFormComponent.prototype.raiseStop = /**
         * @param {?} index
         * @return {?}
         */
            function (index) {
                if (index > 0) {
                    this.moveStop(index, -1);
                }
            };
        /**
         * @param {?} index
         * @return {?}
         */
        RoutingFormComponent.prototype.lowerStop = /**
         * @param {?} index
         * @return {?}
         */
            function (index) {
                if (index < this.stops.length - 1) {
                    this.moveStop(index, 1);
                }
            };
        /**
         * @param {?} index
         * @param {?} diff
         * @return {?}
         */
        RoutingFormComponent.prototype.moveStop = /**
         * @param {?} index
         * @param {?} diff
         * @return {?}
         */
            function (index, diff) {
                /** @type {?} */
                var fromValue = this.stops.at(index);
                this.removeStop(index);
                this.stops.insert(index + diff, fromValue);
                this.stops.at(index).patchValue({ routingText: this.routingText(index) });
                this.stops
                    .at(index + diff)
                    .patchValue({ routingText: this.routingText(index + diff) });
                if (this.stops.at(index).value.stopCoordinates) {
                    this.addStopOverlay(this.stops.at(index).value.stopCoordinates, index);
                }
                if (this.stops.at(index + diff).value.stopCoordinates) {
                    this.addStopOverlay(this.stops.at(index + diff).value.stopCoordinates, index + diff);
                }
            };
        Object.defineProperty(RoutingFormComponent.prototype, "stops", {
            get: /**
             * @return {?}
             */ function () {
                return ( /** @type {?} */(this.stopsForm.get('stops')));
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        RoutingFormComponent.prototype.getStopsCoordinates = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var stopCoordinates = [];
                this.stops.value.forEach(( /**
                 * @param {?} stop
                 * @return {?}
                 */function (stop) {
                    if (stop.stopCoordinates instanceof Array) {
                        stopCoordinates.push(stop.stopCoordinates);
                    }
                }));
                this.routingFormService.setStopsCoordinates(stopCoordinates);
                return stopCoordinates;
            };
        /**
         * @return {?}
         */
        RoutingFormComponent.prototype.addStop = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var insertIndex = this.stops.length - 1;
                this.stops.insert(insertIndex, this.createStop());
            };
        /**
         * @param {?=} routingPos
         * @return {?}
         */
        RoutingFormComponent.prototype.createStop = /**
         * @param {?=} routingPos
         * @return {?}
         */
            function (routingPos) {
                if (routingPos === void 0) {
                    routingPos = 'intermediate';
                }
                return this.formBuilder.group({
                    stopPoint: [''],
                    stopProposals: [[]],
                    routingText: routingPos,
                    stopCoordinates: ['', [forms.Validators.required]]
                });
            };
        /**
         * @param {?} index
         * @return {?}
         */
        RoutingFormComponent.prototype.removeStop = /**
         * @param {?} index
         * @return {?}
         */
            function (index) {
                var _this = this;
                this.routingStopsOverlayDataSource.ol.clear();
                this.stops.removeAt(index);
                /** @type {?} */
                var cnt = 0;
                this.stops.value.forEach(( /**
                 * @param {?} stop
                 * @return {?}
                 */function (stop) {
                    _this.stops.at(cnt).patchValue({ routingText: _this.routingText(cnt) });
                    _this.addStopOverlay(_this.stops.at(cnt).value.stopCoordinates, cnt);
                    cnt++;
                }));
            };
        /**
         * @return {?}
         */
        RoutingFormComponent.prototype.resetForm = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.routesResults = undefined;
                /** @type {?} */
                var nbStops = this.stops.length;
                for (var i = 0; i < nbStops; i++) {
                    this.stops.removeAt(0);
                }
                this.stops.insert(0, this.createStop('start'));
                this.stops.insert(1, this.createStop('end'));
                this.routingStopsOverlayDataSource.ol.getFeatures().forEach(( /**
                 * @param {?} element
                 * @return {?}
                 */function (element) {
                    _this.deleteRoutingOverlaybyID(element.getId());
                }));
                this.routingRoutesOverlayDataSource.ol.clear();
                this.routingStopsOverlayDataSource.ol.clear();
                this.selectRoute.getFeatures().clear();
            };
        /**
         * @return {?}
         */
        RoutingFormComponent.prototype.onFormChange = /**
         * @return {?}
         */
            function () {
                if (this.stopsForm.valid) {
                    this.routingRoutesOverlayDataSource.ol.clear();
                    /** @type {?} */
                    var coords = this.getStopsCoordinates();
                    if (coords.length >= 2) {
                        this.getRoutes(coords);
                    }
                    else {
                        this.routingRoutesOverlayDataSource.ol.clear();
                    }
                }
            };
        /**
         * @param {?} step
         * @param {?} cnt
         * @return {?}
         */
        RoutingFormComponent.prototype.formatStep = /**
         * @param {?} step
         * @param {?} cnt
         * @return {?}
         */
            function (step, cnt) {
                return this.formatInstruction(step.maneuver.type, step.maneuver.modifier, step.name, step.maneuver.bearing_after, cnt, step.maneuver.exit, cnt === this.activeRoute.steps.length - 1);
            };
        /**
         * @param {?} type
         * @param {?} modifier
         * @param {?} route
         * @param {?} direction
         * @param {?} stepPosition
         * @param {?} exit
         * @param {?=} lastStep
         * @return {?}
         */
        RoutingFormComponent.prototype.formatInstruction = /**
         * @param {?} type
         * @param {?} modifier
         * @param {?} route
         * @param {?} direction
         * @param {?} stepPosition
         * @param {?} exit
         * @param {?=} lastStep
         * @return {?}
         */
            function (type, modifier, route, direction, stepPosition, exit, lastStep) {
                if (lastStep === void 0) {
                    lastStep = false;
                }
                /** @type {?} */
                var directiveFr;
                /** @type {?} */
                var directiveEn;
                /** @type {?} */
                var image = 'arrow_forward';
                /** @type {?} */
                var cssClass = 'rotate-270';
                /** @type {?} */
                var translatedDirection = this.translateBearing(direction);
                /** @type {?} */
                var translatedModifier = this.translateModifier(modifier);
                /** @type {?} */
                var enPrefix = modifier === 'straight' ? '' : 'on the ';
                /** @type {?} */
                var frPrefix = modifier === 'straight' ? '' : ' ';
                /** @type {?} */
                var frAggregatedDirection = frPrefix + translatedModifier;
                /** @type {?} */
                var enAggregatedDirection = enPrefix + translatedModifier;
                if (modifier && modifier.search('slight') >= 0) {
                    enAggregatedDirection = translatedModifier;
                }
                if (modifier === 'uturn') {
                    image = 'fast_forward';
                    cssClass = 'rotate-90';
                }
                else if (modifier === 'sharp right') {
                    image = 'subdirectory_arrow_right';
                    cssClass = 'icon-flipped';
                }
                else if (modifier === 'right') {
                    image = 'subdirectory_arrow_right';
                    cssClass = 'icon-flipped';
                }
                else if (modifier === 'slight right') {
                    image = 'arrow_forward';
                    cssClass = 'rotate-290';
                }
                else if (modifier === 'straight') {
                    image = 'arrow_forward';
                }
                else if (modifier === 'slight left') {
                    image = 'arrow_forward';
                    cssClass = 'rotate-250';
                }
                else if (modifier === 'left') {
                    image = 'subdirectory_arrow_left';
                    cssClass = 'icon-flipped';
                }
                else if (modifier === 'sharp left') {
                    image = 'subdirectory_arrow_left';
                    cssClass = 'icon-flipped';
                }
                if (type === 'turn') {
                    if (modifier === 'straight') {
                        directiveFr = 'Continuer sur ' + route;
                        directiveEn = 'Continue on ' + route;
                    }
                    else if (modifier === 'uturn') {
                        directiveFr = 'Faire demi-tour sur ' + route;
                        directiveEn = 'Make u-turn on ' + route;
                    }
                    else {
                        directiveFr = 'Tourner ' + frAggregatedDirection + ' sur ' + route;
                        directiveEn = 'Turn ' + translatedModifier + ' onto ' + route;
                    }
                }
                else if (type === 'new name') {
                    directiveFr =
                        'Continuer en direction ' + translatedDirection + ' sur ' + route;
                    directiveEn = 'Head ' + translatedDirection + ' on ' + route;
                    image = 'explore';
                    cssClass = '';
                }
                else if (type === 'depart') {
                    directiveFr =
                        'Aller en direction ' + translatedDirection + ' sur ' + route;
                    directiveEn = 'Head ' + translatedDirection + ' on ' + route;
                    image = 'explore';
                    cssClass = '';
                }
                else if (type === 'arrive') {
                    if (lastStep) {
                        /** @type {?} */
                        var coma = ', ';
                        if (!translatedModifier) {
                            frAggregatedDirection = '';
                            enAggregatedDirection = '';
                            coma = '';
                        }
                        directiveFr = 'Vous tes arriv' + coma + frAggregatedDirection;
                        directiveEn =
                            'You have reached your destination' + coma + enAggregatedDirection;
                    }
                    else {
                        directiveFr = 'Vous atteignez le point intermdiare sur ' + route;
                        directiveEn = 'You have reached the intermediate stop onto ' + route;
                        image = 'location_on';
                        cssClass = '';
                    }
                }
                else if (type === 'merge') {
                    directiveFr = 'Continuer sur ' + route;
                    directiveEn = 'Continue on ' + route;
                    image = 'arrow_forward';
                    cssClass = 'rotate-270';
                }
                else if (type === 'on ramp') {
                    directiveFr = "Prendre l'entre d'autoroute " + frAggregatedDirection;
                    directiveEn = 'Take the ramp ' + enAggregatedDirection;
                }
                else if (type === 'off ramp') {
                    directiveFr = "Prendre la sortie d'autoroute " + frAggregatedDirection;
                    directiveEn = 'Take exit ' + enAggregatedDirection;
                }
                else if (type === 'fork') {
                    if (modifier.search('left') >= 0) {
                        directiveFr = 'Garder la gauche sur ' + route;
                        directiveEn = 'Merge left onto ' + route;
                    }
                    else if (modifier.search('right') >= 0) {
                        directiveFr = 'Garder la droite sur ' + route;
                        directiveEn = 'Merge right onto ' + route;
                    }
                    else {
                        directiveFr = 'Continuer sur ' + route;
                        directiveEn = 'Continue on ' + route;
                    }
                }
                else if (type === 'end of road') {
                    directiveFr =
                        ' la fin de la route, tourner ' + translatedModifier + ' sur ' + route;
                    directiveEn =
                        'At the end of the road, turn ' + translatedModifier + ' onto ' + route;
                }
                else if (type === 'use lane') {
                    directiveFr = 'Prendre la voie de ... ';
                    directiveEn = 'Take the lane ...';
                }
                else if (type === 'continue' && modifier !== 'uturn') {
                    directiveFr = 'Continuer sur ' + route;
                    directiveEn = 'Continue on ' + route;
                    image = 'arrow_forward';
                    cssClass = 'rotate-270';
                }
                else if (type === 'roundabout') {
                    directiveFr = 'Au rond-point, prendre la ' + exit;
                    directiveFr += exit === 1 ? 're' : 'e';
                    directiveFr += ' sortie vers ' + route;
                    directiveEn = 'At the roundabout, take the ' + exit;
                    directiveEn += exit === 1 ? 'st' : 'rd';
                    directiveEn += ' exit towards ' + route;
                    image = 'donut_large';
                    cssClass = '';
                }
                else if (type === 'rotary') {
                    directiveFr = 'Rond-point rotary....';
                    directiveEn = 'Roundabout rotary....';
                    image = 'donut_large';
                    cssClass = '';
                }
                else if (type === 'roundabout turn') {
                    directiveFr = 'Rond-point, prendre la ...';
                    directiveEn = 'Roundabout, take the ...';
                    image = 'donut_large';
                    cssClass = '';
                }
                else if (type === 'exit roundabout') {
                    directiveFr = 'Poursuivre vers ' + route;
                    directiveEn = 'Continue to ' + route;
                    image = 'arrow_forward';
                    cssClass = 'rotate-270';
                }
                else if (type === 'notification') {
                    directiveFr = 'notification ....';
                    directiveEn = 'notification ....';
                }
                else if (modifier === 'uturn') {
                    directiveFr =
                        'Faire demi-tour et continuer en direction ' +
                            translatedDirection +
                            ' sur ' +
                            route;
                    directiveEn =
                        'Make u-turn and head ' + translatedDirection + ' on ' + route;
                }
                else {
                    directiveFr = '???';
                    directiveEn = '???';
                }
                if (lastStep) {
                    image = 'flag';
                    cssClass = '';
                }
                if (stepPosition === 0) {
                    image = 'explore';
                    cssClass = '';
                }
                /** @type {?} */
                var directive;
                if (this.browserLanguage === 'fr') {
                    directive = directiveFr;
                }
                else if (this.browserLanguage === 'en') {
                    directive = directiveEn;
                }
                return { instruction: directive, image: image, cssClass: cssClass };
            };
        /**
         * @param {?} modifier
         * @return {?}
         */
        RoutingFormComponent.prototype.translateModifier = /**
         * @param {?} modifier
         * @return {?}
         */
            function (modifier) {
                if (modifier === 'uturn') {
                    return this.languageService.translate.instant('igo.geo.routing.uturn');
                }
                else if (modifier === 'sharp right') {
                    return this.languageService.translate.instant('igo.geo.routing.sharp right');
                }
                else if (modifier === 'right') {
                    return this.languageService.translate.instant('igo.geo.routing.right');
                }
                else if (modifier === 'slight right') {
                    return this.languageService.translate.instant('igo.geo.routing.slight right');
                }
                else if (modifier === 'sharp left') {
                    return this.languageService.translate.instant('igo.geo.routing.sharp left');
                }
                else if (modifier === 'left') {
                    return this.languageService.translate.instant('igo.geo.routing.left');
                }
                else if (modifier === 'slight left') {
                    return this.languageService.translate.instant('igo.geo.routing.slight left');
                }
                else if (modifier === 'straight') {
                    return this.languageService.translate.instant('igo.geo.routing.straight');
                }
                else {
                    return modifier;
                }
            };
        /**
         * @param {?} bearing
         * @return {?}
         */
        RoutingFormComponent.prototype.translateBearing = /**
         * @param {?} bearing
         * @return {?}
         */
            function (bearing) {
                if (bearing >= 337 || bearing < 23) {
                    return this.languageService.translate.instant('igo.geo.cardinalPoints.n');
                }
                else if (bearing < 67) {
                    return this.languageService.translate.instant('igo.geo.cardinalPoints.ne');
                }
                else if (bearing < 113) {
                    return this.languageService.translate.instant('igo.geo.cardinalPoints.e');
                }
                else if (bearing < 157) {
                    return this.languageService.translate.instant('igo.geo.cardinalPoints.se');
                }
                else if (bearing < 203) {
                    return this.languageService.translate.instant('igo.geo.cardinalPoints.s');
                }
                else if (bearing < 247) {
                    return this.languageService.translate.instant('igo.geo.cardinalPoints.sw');
                }
                else if (bearing < 293) {
                    return this.languageService.translate.instant('igo.geo.cardinalPoints.w');
                }
                else if (bearing < 337) {
                    return this.languageService.translate.instant('igo.geo.cardinalPoints.nw');
                }
                else {
                    return;
                }
            };
        /**
         * @param {?} distance
         * @return {?}
         */
        RoutingFormComponent.prototype.formatDistance = /**
         * @param {?} distance
         * @return {?}
         */
            function (distance) {
                if (distance === 0) {
                    return;
                }
                if (distance >= 100000) {
                    return Math.round(distance / 1000) + ' km';
                }
                if (distance >= 10000) {
                    return Math.round(distance / 100) / 10 + ' km';
                }
                if (distance >= 100) {
                    return Math.round(distance / 100) / 10 + ' km';
                }
                return distance + ' m';
            };
        /**
         * @param {?} duration
         * @param {?=} summary
         * @return {?}
         */
        RoutingFormComponent.prototype.formatDuration = /**
         * @param {?} duration
         * @param {?=} summary
         * @return {?}
         */
            function (duration, summary) {
                if (summary === void 0) {
                    summary = false;
                }
                if (duration >= 3600) {
                    /** @type {?} */
                    var hour = Math.floor(duration / 3600);
                    /** @type {?} */
                    var minute = Math.round((duration / 3600 - hour) * 60);
                    if (minute === 60) {
                        return hour + 1 + ' h';
                    }
                    return hour + ' h ' + minute + ' min';
                }
                if (duration >= 60) {
                    return Math.round(duration / 60) + ' min';
                }
                return duration + ' s';
            };
        /**
         * @param {?} step
         * @param {?=} zoomToExtent
         * @return {?}
         */
        RoutingFormComponent.prototype.showSegment = /**
         * @param {?} step
         * @param {?=} zoomToExtent
         * @return {?}
         */
            function (step, zoomToExtent) {
                if (zoomToExtent === void 0) {
                    zoomToExtent = false;
                }
                this.showRouteSegmentGeometry(step.geometry.coordinates, zoomToExtent);
            };
        /**
         * @param {?} coordinates
         * @param {?=} zoomToExtent
         * @return {?}
         */
        RoutingFormComponent.prototype.showRouteSegmentGeometry = /**
         * @param {?} coordinates
         * @param {?=} zoomToExtent
         * @return {?}
         */
            function (coordinates, zoomToExtent) {
                if (zoomToExtent === void 0) {
                    zoomToExtent = false;
                }
                this.deleteRoutingOverlaybyID('endSegment');
                /** @type {?} */
                var geometry4326 = new olgeom.LineString(coordinates);
                /** @type {?} */
                var geometry3857 = geometry4326.transform('EPSG:4326', 'EPSG:3857');
                /** @type {?} */
                var routeSegmentCoordinates = (( /** @type {?} */(geometry3857))).getCoordinates();
                /** @type {?} */
                var lastPoint = routeSegmentCoordinates[0];
                /** @type {?} */
                var geometry = new olgeom.Point(lastPoint);
                /** @type {?} */
                var feature = new OlFeature({ geometry: geometry });
                feature.setId('endSegment');
                if (geometry === null) {
                    return;
                }
                if (geometry.getType() === 'Point') {
                    feature.setStyle([
                        new olstyle.Style({
                            geometry: geometry,
                            image: new olstyle.Circle({
                                radius: 7,
                                stroke: new olstyle.Stroke({ color: '#FF0000', width: 3 })
                            })
                        })
                    ]);
                }
                if (zoomToExtent) {
                    this.map.viewController.zoomToExtent(feature.getGeometry().getExtent());
                }
                this.routingRoutesOverlayDataSource.ol.addFeature(feature);
            };
        /**
         * @return {?}
         */
        RoutingFormComponent.prototype.zoomRoute = /**
         * @return {?}
         */
            function () {
                this.map.viewController.zoomToExtent(this.routingRoutesOverlayDataSource.ol.getExtent());
            };
        /**
         * @param {?=} moveToExtent
         * @return {?}
         */
        RoutingFormComponent.prototype.showRouteGeometry = /**
         * @param {?=} moveToExtent
         * @return {?}
         */
            function (moveToExtent) {
                if (moveToExtent === void 0) {
                    moveToExtent = false;
                }
                /** @type {?} */
                var geom = this.activeRoute.geometry.coordinates;
                /** @type {?} */
                var geometry4326 = new olgeom.LineString(geom);
                /** @type {?} */
                var geometry3857 = geometry4326.transform('EPSG:4326', 'EPSG:3857');
                this.routingRoutesOverlayDataSource.ol.clear();
                /** @type {?} */
                var routingFeature = new OlFeature({ geometry: geometry3857 });
                routingFeature.setStyle([
                    new olstyle.Style({
                        stroke: new olstyle.Stroke({ color: '#6a7982', width: 10 })
                    }),
                    new olstyle.Style({
                        stroke: new olstyle.Stroke({ color: '#4fa9dd', width: 6 })
                    })
                ]);
                this.routingRoutesOverlayDataSource.ol.addFeature(routingFeature);
                if (moveToExtent) {
                    this.map.viewController.zoomToExtent(this.routingRoutesOverlayDataSource.ol.getExtent());
                }
            };
        /**
         * @param {?} stopsArrayCoordinates
         * @param {?=} moveToExtent
         * @return {?}
         */
        RoutingFormComponent.prototype.getRoutes = /**
         * @param {?} stopsArrayCoordinates
         * @param {?=} moveToExtent
         * @return {?}
         */
            function (stopsArrayCoordinates, moveToExtent) {
                var _this = this;
                if (moveToExtent === void 0) {
                    moveToExtent = false;
                }
                /** @type {?} */
                var routeResponse = this.routingService.route(stopsArrayCoordinates);
                if (routeResponse) {
                    routeResponse.map(( /**
                     * @param {?} res
                     * @return {?}
                     */function (res) {
                        return _this.routesQueries$$.push(res.subscribe(( /**
                         * @param {?} route
                         * @return {?}
                         */function (route) {
                            _this.routesResults = route;
                            _this.activeRoute = ( /** @type {?} */(_this.routesResults[0]));
                            _this.showRouteGeometry(moveToExtent);
                        })));
                    }));
                }
            };
        /**
         * @private
         * @return {?}
         */
        RoutingFormComponent.prototype.unlistenSingleClick = /**
         * @private
         * @return {?}
         */
            function () {
                if (this.focusKey.length !== 0) {
                    this.focusKey.forEach(( /**
                     * @param {?} key
                     * @return {?}
                     */function (key) {
                        olobservable.unByKey(key);
                    }));
                }
            };
        /**
         * @private
         * @return {?}
         */
        RoutingFormComponent.prototype.unsubscribeRoutesQueries = /**
         * @private
         * @return {?}
         */
            function () {
                this.routesQueries$$.forEach(( /**
                 * @param {?} sub
                 * @return {?}
                 */function (sub) { return sub.unsubscribe(); }));
                this.routesQueries$$ = [];
            };
        /**
         * @return {?}
         */
        RoutingFormComponent.prototype.copyLinkToClipboard = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var successful = utils.Clipboard.copy(this.getUrl());
                if (successful) {
                    /** @type {?} */
                    var translate = this.languageService.translate;
                    /** @type {?} */
                    var title = translate.instant('igo.geo.routingForm.dialog.copyTitle');
                    /** @type {?} */
                    var msg = translate.instant('igo.geo.routingForm.dialog.copyMsgLink');
                    this.messageService.success(msg, title);
                }
            };
        /**
         * @return {?}
         */
        RoutingFormComponent.prototype.copyDirectionsToClipboard = /**
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var indent = '\t';
                /** @type {?} */
                var activeRouteDirective = this.languageService.translate.instant('igo.geo.routingForm.instructions') + ':\n';
                /** @type {?} */
                var wayPointList = '';
                /** @type {?} */
                var summary = this.languageService.translate.instant('igo.geo.routingForm.summary') +
                    ': \n' +
                    indent +
                    this.activeRoute.title +
                    '\n' +
                    indent +
                    this.formatDistance(this.activeRoute.distance) +
                    '\n' +
                    indent +
                    this.formatDuration(this.activeRoute.duration) +
                    '\n\n' +
                    this.languageService.translate.instant('igo.geo.routingForm.stopsList') +
                    ':\n';
                /** @type {?} */
                var url = this.languageService.translate.instant('igo.geo.routingForm.link') +
                    ':\n' +
                    indent +
                    this.getUrl();
                /** @type {?} */
                var wayPointsCnt = 1;
                this.stops.value.forEach(( /**
                 * @param {?} stop
                 * @return {?}
                 */function (stop) {
                    /** @type {?} */
                    var coord = '';
                    /** @type {?} */
                    var stopPoint = '';
                    if (stop.stopPoint !== stop.stopCoordinates) {
                        stopPoint = stop.stopPoint;
                        coord =
                            ' (' +
                                [stop.stopCoordinates[1], stop.stopCoordinates[0]].join(',') +
                                ')';
                    }
                    else {
                        stopPoint = [stop.stopCoordinates[1], stop.stopCoordinates[0]].join(',');
                    }
                    wayPointList =
                        wayPointList +
                            indent +
                            wayPointsCnt.toLocaleString() +
                            '. ' +
                            stopPoint +
                            coord +
                            '\n';
                    wayPointsCnt++;
                }));
                // Directions
                /** @type {?} */
                var localCnt = 0;
                this.activeRoute.steps.forEach(( /**
                 * @param {?} step
                 * @return {?}
                 */function (step) {
                    /** @type {?} */
                    var instruction = _this.formatStep(step, localCnt).instruction;
                    /** @type {?} */
                    var distance = _this.formatDistance(step.distance) === undefined
                        ? ''
                        : ' (' + _this.formatDistance(step.distance) + ')';
                    activeRouteDirective =
                        activeRouteDirective +
                            indent +
                            (localCnt + 1).toLocaleString() +
                            '. ' +
                            instruction +
                            distance +
                            '\n';
                    localCnt++;
                }));
                /** @type {?} */
                var directionsBody = summary + wayPointList + '\n' + url + '\n\n' + activeRouteDirective;
                /** @type {?} */
                var successful = utils.Clipboard.copy(directionsBody);
                if (successful) {
                    /** @type {?} */
                    var translate = this.languageService.translate;
                    /** @type {?} */
                    var title = translate.instant('igo.geo.routingForm.dialog.copyTitle');
                    /** @type {?} */
                    var msg = translate.instant('igo.geo.routingForm.dialog.copyMsg');
                    this.messageService.success(msg, title);
                }
            };
        /**
         * @private
         * @param {?} term
         * @return {?}
         */
        RoutingFormComponent.prototype.handleTermChanged = /**
         * @private
         * @param {?} term
         * @return {?}
         */
            function (term) {
                var _this = this;
                if (term !== undefined || term.length !== 0) {
                    /** @type {?} */
                    var searchProposals_1 = [];
                    /** @type {?} */
                    var researches = this.searchService.search(term);
                    researches.map(( /**
                     * @param {?} res
                     * @return {?}
                     */function (res) {
                        return _this.routesQueries$$.push(res.request.subscribe(( /**
                         * @param {?} results
                         * @return {?}
                         */function (results) {
                            results
                                .filter(( /**
                         * @param {?} r
                         * @return {?}
                         */function (r) { return r.data.geometry; }))
                                .forEach(( /**
                         * @param {?} element
                         * @return {?}
                         */function (element) {
                                if (searchProposals_1.filter(( /**
                                 * @param {?} r
                                 * @return {?}
                                 */function (r) { return r.source === element.source; }))
                                    .length === 0) {
                                    searchProposals_1.push({
                                        source: element.source,
                                        results: results.map(( /**
                                         * @param {?} r
                                         * @return {?}
                                         */function (r) { return r.data; }))
                                    });
                                }
                            }));
                            _this.stops
                                .at(_this.currentStopIndex)
                                .patchValue({ stopProposals: searchProposals_1 });
                        })));
                    }));
                }
            };
        /**
         * @param {?} term
         * @return {?}
         */
        RoutingFormComponent.prototype.setTerm = /**
         * @param {?} term
         * @return {?}
         */
            function (term) {
                this.term = term;
                if (this.keyIsValid(term) &&
                    (term.length >= this.length || term.length === 0)) {
                    this.stream$.next(term);
                }
            };
        /**
         * @private
         * @param {?} key
         * @return {?}
         */
        RoutingFormComponent.prototype.keyIsValid = /**
         * @private
         * @param {?} key
         * @return {?}
         */
            function (key) {
                return this.invalidKeys.find(( /**
                 * @param {?} value
                 * @return {?}
                 */function (value) { return value === key; })) === undefined;
            };
        /**
         * @param {?} i
         * @param {?} event
         * @return {?}
         */
        RoutingFormComponent.prototype.keyup = /**
         * @param {?} i
         * @param {?} event
         * @return {?}
         */
            function (i, event) {
                var _this = this;
                /** @type {?} */
                var term = (( /** @type {?} */(event.target))).value;
                this.setTerm(term);
                this.map.ol.un('singleclick', ( /**
                 * @param {?} evt
                 * @return {?}
                 */function (evt) {
                    _this.handleMapClick(evt, i);
                }));
            };
        /**
         * @param {?} stopIndex
         * @return {?}
         */
        RoutingFormComponent.prototype.clearStop = /**
         * @param {?} stopIndex
         * @return {?}
         */
            function (stopIndex) {
                this.deleteRoutingOverlaybyID(this.getStopOverlayID(stopIndex));
                this.stops.removeAt(stopIndex);
                this.stops.insert(stopIndex, this.createStop(this.routingText(stopIndex)));
                this.routingRoutesOverlayDataSource.ol.clear();
            };
        /**
         * @param {?} proposal
         * @param {?} i
         * @return {?}
         */
        RoutingFormComponent.prototype.chooseProposal = /**
         * @param {?} proposal
         * @param {?} i
         * @return {?}
         */
            function (proposal, i) {
                if (proposal !== undefined) {
                    /** @type {?} */
                    var geomCoord = void 0;
                    /** @type {?} */
                    var geom = (( /** @type {?} */(proposal))).geometry;
                    if (geom.type === 'Point') {
                        geomCoord = geom.coordinates;
                    }
                    else if (geom.type.search('Line') >= 0) {
                        /** @type {?} */
                        var coordArray = [];
                        if (geom.coordinates instanceof Array) {
                            // Middle segment of multilinestring
                            coordArray =
                                geom.coordinates[Math.floor(geom.coordinates.length / 2)];
                        }
                        else {
                            coordArray = geom.coordinates;
                        }
                        // middle point of coords
                        geomCoord = coordArray[Math.floor(coordArray.length / 2)];
                    }
                    else if (geom.type.search('Polygon') >= 0) {
                        /** @type {?} */
                        var polygonExtent = proposal.extent;
                        /** @type {?} */
                        var long = polygonExtent[0] + (polygonExtent[2] - polygonExtent[0]) / 2;
                        /** @type {?} */
                        var lat = polygonExtent[1] + (polygonExtent[3] - polygonExtent[1]) / 2;
                        geomCoord = [long, lat];
                    }
                    if (geomCoord !== undefined) {
                        this.stops.at(i).patchValue({ stopCoordinates: geomCoord });
                        this.addStopOverlay(geomCoord, i);
                        /** @type {?} */
                        var proposalExtent = this.routingStopsOverlayDataSource.ol
                            .getFeatureById(this.getStopOverlayID(i))
                            .getGeometry()
                            .getExtent();
                        if (!olextent.intersects(proposalExtent, this.map.getExtent())) {
                            this.map.viewController.moveToExtent(proposalExtent);
                        }
                    }
                }
            };
        /**
         * @param {?} i
         * @return {?}
         */
        RoutingFormComponent.prototype.focus = /**
         * @param {?} i
         * @return {?}
         */
            function (i) {
                var _this = this;
                this.unlistenSingleClick();
                this.currentStopIndex = i;
                this.focusOnStop = true;
                this.routingFormService.setMapWaitingForRoutingClick();
                this.focusKey.push(this.map.ol.once('singleclick', ( /**
                 * @param {?} evt
                 * @return {?}
                 */function (evt) {
                    _this.handleMapClick(evt, i);
                })));
            };
        /**
         * @private
         * @param {?} event
         * @param {?=} indexPos
         * @return {?}
         */
        RoutingFormComponent.prototype.handleMapClick = /**
         * @private
         * @param {?} event
         * @param {?=} indexPos
         * @return {?}
         */
            function (event, indexPos) {
                var _this = this;
                this.stops.at(indexPos).patchValue({ stopProposals: [] });
                if (this.currentStopIndex === undefined) {
                    this.addStop();
                    indexPos = this.stops.length - 2;
                    this.stops.at(indexPos).value.stopProposals = [];
                }
                else {
                    indexPos = this.currentStopIndex;
                }
                /** @type {?} */
                var clickCoordinates = olproj.transform(event.coordinate, this.map.projection, this.projection);
                this.stops.at(indexPos).patchValue({ stopCoordinates: clickCoordinates });
                this.handleLocationProposals(clickCoordinates, indexPos);
                this.addStopOverlay(clickCoordinates, indexPos);
                setTimeout(( /**
                 * @return {?}
                 */function () {
                    _this.focusOnStop = false; // prevent to trigger map click and Select on routes at same time.
                }), 500);
                this.routingFormService.unsetMapWaitingForRoutingClick();
            };
        /**
         * @param {?} index
         * @return {?}
         */
        RoutingFormComponent.prototype.geolocateStop = /**
         * @param {?} index
         * @return {?}
         */
            function (index) {
                moveToOlFeatures(this.map, [this.map.geolocationFeature], FeatureMotion.Move);
                /** @type {?} */
                var geolocateCoordinates = this.map.getCenter(this.projection);
                this.stops.at(index).patchValue({ stopCoordinates: geolocateCoordinates });
                this.addStopOverlay(geolocateCoordinates, index);
                this.handleLocationProposals(geolocateCoordinates, index);
            };
        /**
         * @param {?} coordinates
         * @param {?} index
         * @return {?}
         */
        RoutingFormComponent.prototype.addStopOverlay = /**
         * @param {?} coordinates
         * @param {?} index
         * @return {?}
         */
            function (coordinates, index) {
                /** @type {?} */
                var routingText = this.routingText(index);
                /** @type {?} */
                var stopColor;
                /** @type {?} */
                var stopText;
                if (routingText === 'start') {
                    stopColor = 'green';
                    stopText = this.languageService.translate.instant('igo.geo.routingForm.start');
                }
                else if (routingText === 'end') {
                    stopColor = 'red';
                    stopText = this.languageService.translate.instant('igo.geo.routingForm.end');
                }
                else {
                    stopColor = 'yellow';
                    stopText =
                        this.languageService.translate.instant('igo.geo.routingForm.intermediate') +
                            ' #' +
                            index;
                }
                /** @type {?} */
                var geometry = new olgeom.Point(olproj.transform(coordinates, this.projection, this.map.projection));
                /** @type {?} */
                var feature = new OlFeature({ geometry: geometry });
                /** @type {?} */
                var stopID = this.getStopOverlayID(index);
                this.deleteRoutingOverlaybyID(stopID);
                feature.setId(stopID);
                if (geometry === null) {
                    return;
                }
                if (geometry.getType() === 'Point') {
                    /** @type {?} */
                    var olStyle = createOverlayMarkerStyle(stopColor);
                    // stopText
                    feature.setStyle(olStyle);
                }
                this.routingStopsOverlayDataSource.ol.addFeature(feature);
            };
        /**
         * @param {?} index
         * @return {?}
         */
        RoutingFormComponent.prototype.getStopOverlayID = /**
         * @param {?} index
         * @return {?}
         */
            function (index) {
                /** @type {?} */
                var txt;
                if (index === 0) {
                    txt = 'start';
                }
                else if (index === this.stops.length - 1) {
                    txt = 'end';
                }
                else {
                    txt = index;
                }
                return 'routingStop_' + txt;
            };
        /**
         * @private
         * @param {?} id
         * @return {?}
         */
        RoutingFormComponent.prototype.deleteRoutingOverlaybyID = /**
         * @private
         * @param {?} id
         * @return {?}
         */
            function (id) {
                if (this.routingStopsOverlayDataSource.ol.getFeatureById(id)) {
                    this.routingStopsOverlayDataSource.ol.removeFeature(this.routingStopsOverlayDataSource.ol.getFeatureById(id));
                }
                if (this.routingRoutesOverlayDataSource.ol.getFeatureById(id)) {
                    this.routingRoutesOverlayDataSource.ol.removeFeature(this.routingRoutesOverlayDataSource.ol.getFeatureById(id));
                }
            };
        /**
         * @private
         * @return {?}
         */
        RoutingFormComponent.prototype.getUrl = /**
         * @private
         * @return {?}
         */
            function () {
                if (!this.route) {
                    return;
                }
                /** @type {?} */
                var routingKey = this.route.options.routingCoordKey;
                /** @type {?} */
                var stopsCoordinates = [];
                if (this.routingFormService &&
                    this.routingFormService.getStopsCoordinates() &&
                    this.routingFormService.getStopsCoordinates().length !== 0) {
                    this.routingFormService.getStopsCoordinates().forEach(( /**
                     * @param {?} coord
                     * @return {?}
                     */function (coord) {
                        stopsCoordinates.push(coord);
                    }));
                }
                /** @type {?} */
                var routingUrl = '';
                if (stopsCoordinates.length >= 2) {
                    routingUrl = routingKey + "=" + stopsCoordinates.join(';');
                }
                return "" + location.origin + location.pathname + "?tool=directions&" + routingUrl;
            };
        RoutingFormComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'igo-routing-form',
                        template: "<form class=\"igo-form\" [formGroup]=\"stopsForm\">\r\n  <!-- <div class=\"igo-form-button-group\">\r\n\r\n  </div> -->\r\n  <div #inputs formArrayName=\"stops\" *ngFor=\"let stop of stops.controls; let i = index;\">\r\n    <mat-list-item [formGroupName]=\"i\">\r\n\r\n      <div class=\"igo-input-container\">\r\n        <button *ngIf=\"map.geolocationFeature\" mat-icon-button tooltip-position=\"below\" matTooltipShowDelay=\"500\" [matTooltip]=\"'igo.geo.routingForm.geolocate' | translate\" (click)=\"geolocateStop(i)\">\r\n          <mat-icon svgIcon=\"crosshairs-gps\"></mat-icon>\r\n        </button>\r\n        <mat-form-field>\r\n          <input matInput formControlName=\"stopPoint\" [matAutocomplete]=\"auto\" placeholder=\"{{'igo.geo.routingForm.'+stop.value.routingText | translate}}\"\r\n            (focus)=\"focus(i)\" (keyup)=\"keyup(i,$event)\">\r\n\r\n          <mat-autocomplete #auto=\"matAutocomplete\">\r\n            <mat-optgroup *ngFor=\"let source of stop.value.stopProposals\" [label]=\"source.source\" [disabled]=\"source.disabled\">\r\n              <mat-option *ngFor=\"let result of source.results\" [value]=\"result.title\" (onSelectionChange)=\"chooseProposal(result,i)\">\r\n                {{ result.title }}\r\n              </mat-option>\r\n            </mat-optgroup>\r\n          </mat-autocomplete>\r\n        </mat-form-field>\r\n        <button mat-button *ngIf=\"stop.value && (stop.value.stopPoint.length>0 || stop.value.stopProposals.length>0)\" matSuffix mat-icon-button\r\n          aria-label=\"Clear\" (click)=\"clearStop(i)\">\r\n          <mat-icon svgIcon=\"close\"></mat-icon>\r\n        </button>\r\n        <!-- <div class=\"igo-form-button-group\"> -->\r\n\r\n\r\n          <!-- <button *ngIf=\"i !== 0\" mat-icon-button tooltip-position=\"below\" matTooltipShowDelay=\"500\" [matTooltip]=\"'igo.geo.routingForm.raiseStop' | translate\"\r\n            [color]=\"color\" (click)=\"raiseStop(i)\">\r\n            <mat-icon svgIcon=\"arrow-upward\"></mat-icon>\r\n          </button>\r\n          <button *ngIf=\"i !== stops.length - 1\" mat-icon-button tooltip-position=\"below\" matTooltipShowDelay=\"500\" [matTooltip]=\"'igo.geo.routingForm.lowerStop' | translate\"\r\n            [color]=\"color\" (click)=\"lowerStop(i)\">\r\n            <mat-icon svgIcon=\"arrow-downward\"></mat-icon>\r\n          </button> -->\r\n\r\n          <button *ngIf=\"i !== 0 && i !== stops.length - 1\" mat-icon-button tooltip-position=\"below\" matTooltipShowDelay=\"500\" [matTooltip]=\"'igo.geo.routingForm.removeStop' | translate\"\r\n            color=\"warn\" (click)=\"removeStop(i)\">\r\n            <mat-icon svgIcon=\"delete\"></mat-icon>\r\n          </button>\r\n        <!-- </div> -->\r\n      </div>\r\n\r\n    </mat-list-item>\r\n  </div>\r\n  <div class=\"igo-form-button-group\">\r\n    <button mat-icon-button tooltip-position=\"below\" matTooltipShowDelay=\"500\"\r\n      [matTooltip]=\"'igo.geo.routingForm.zoomRoute' | translate\"\r\n      *ngIf=\"routesResults\" color=\"primary\" (click)=\"zoomRoute()\">\r\n      <mat-icon svgIcon=\"zoom-in\"></mat-icon>\r\n    </button>\r\n      <button mat-icon-button tooltip-position=\"below\" matTooltipShowDelay=\"500\" [matTooltip]=\"'igo.geo.routingForm.addStop' | translate\"\r\n      color=\"primary\" (click)=\"addStop()\">\r\n      <mat-icon svgIcon=\"map-marker-plus\"></mat-icon>\r\n    </button>\r\n    <button mat-icon-button tooltip-position=\"below\" matTooltipShowDelay=\"500\" [matTooltip]=\"'igo.geo.routingForm.resetRoutingBtn' | translate\"\r\n      *ngIf=\"routesResults\" color=\"warn\" (click)=\"resetForm()\">\r\n      <mat-icon svgIcon=\"restore-page\"></mat-icon>\r\n    </button>\r\n    <button mat-icon-button *ngIf=\"routesResults\" tooltip-position=\"below\" matTooltipShowDelay=\"500\" [matTooltip]=\"'igo.geo.routingForm.copy' | translate\"\r\n      color=\"primary\" (click)=\"copyDirectionsToClipboard()\">\r\n      <mat-icon svgIcon=\"content-copy\"></mat-icon>\r\n    </button>\r\n    <button mat-icon-button *ngIf=\"routesResults\" tooltip-position=\"below\" matTooltipShowDelay=\"500\" [matTooltip]=\"'igo.geo.routingForm.link' | translate\"\r\n    color=\"primary\" (click)=\"copyLinkToClipboard()\">\r\n    <mat-icon svgIcon=\"link\"></mat-icon>\r\n  </button>\r\n  </div>\r\n\r\n</form>\r\n\r\n<div class=\"igo-input-container\" *ngIf=\"routesResults\">\r\n  <mat-form-field *ngIf=\"routesResults && routesResults.length > 1\">\r\n    <mat-select placeholder=\"{{'igo.geo.routingForm.drivingOptions' | translate}}\" (selectionChange)=\"changeRoute($event)\" [(ngModel)]=\"activeRoute\">\r\n      <mat-option *ngFor=\"let pathRouting of routesResults; let cnt = index;\" [value]=\"pathRouting\">\r\n        Option {{cnt + 1}} : {{this.formatDistance(pathRouting.distance)}} ({{this.formatDuration(pathRouting.duration)}})\r\n      </mat-option>\r\n    </mat-select>\r\n  </mat-form-field>\r\n\r\n  <mat-divider *ngIf=\"routesResults && routesResults.length === 0\"></mat-divider>\r\n\r\n  <mat-list>\r\n    <h3 mat-header>{{activeRoute.title}}</h3>\r\n    <h3 mat-subheader>{{this.formatDistance(activeRoute.distance)}}, {{this.formatDuration(activeRoute.duration)}}</h3>\r\n\r\n    <mat-list-item (mouseenter)=\"showSegment(step)\" (click)=\"showSegment(step,true)\" *ngFor=\"let step of activeRoute.steps; let cnt = index;\"\r\n      igoListItem>\r\n      <mat-icon [ngClass]=\"this.formatStep(step,cnt).cssClass\" mat-list-icon svgIcon=\"{{this.formatStep(step,cnt).image}}\"></mat-icon>\r\n\r\n      <h4 mat-line (click)=\"showSegment(step,true)\">{{cnt +1}}. {{this.formatStep(step,cnt).instruction}}</h4>\r\n      <h4 mat-line class=\"right\">{{this.formatDistance(step.distance)}}</h4>\r\n    </mat-list-item>\r\n\r\n    <mat-divider></mat-divider>\r\n\r\n  </mat-list>\r\n\r\n</div>\r\n",
                        styles: ["mat-form-field{width:70%}.mat-list-item{height:auto}.mat-line{word-wrap:break-word!important;white-space:pre-wrap!important}.mat-line.right{text-align:right}.rotate-90{-webkit-transform:rotate(90deg);transform:rotate(90deg)}.rotate-45{-webkit-transform:rotate(45deg);transform:rotate(45deg)}.rotate-270{-webkit-transform:rotate(270deg);transform:rotate(270deg)}.rotate-250{-webkit-transform:rotate(250deg);transform:rotate(250deg)}.rotate-290{-webkit-transform:rotate(290deg);transform:rotate(290deg)}.icon-flipped{-webkit-transform:scaleY(-1);transform:scaleY(-1)}"]
                    }] }
        ];
        /** @nocollapse */
        RoutingFormComponent.ctorParameters = function () {
            return [
                { type: forms.FormBuilder },
                { type: RoutingService },
                { type: i1$1.LanguageService },
                { type: i1$1.MessageService },
                { type: SearchService },
                { type: QueryService },
                { type: RoutingFormService },
                { type: i1$1.RouteService, decorators: [{ type: i0.Optional }] }
            ];
        };
        RoutingFormComponent.propDecorators = {
            term: [{ type: i0.Input }],
            length: [{ type: i0.Input }],
            map: [{ type: i0.Input }],
            submit: [{ type: i0.Output }]
        };
        return RoutingFormComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var RoutingFormBindingDirective = /** @class */ (function () {
        function RoutingFormBindingDirective(component, routingFormService, route) {
            this.component = component;
            this.routingFormService = routingFormService;
            this.route = route;
        }
        /**
         * @return {?}
         */
        RoutingFormBindingDirective.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var storedStopsCoordinates = this.routingFormService.getStopsCoordinates();
                if (!storedStopsCoordinates &&
                    this.route &&
                    this.route.options.routingCoordKey) {
                    this.route.queryParams.subscribe(( /**
                     * @param {?} params
                     * @return {?}
                     */function (params) {
                        /** @type {?} */
                        var routingParams = params[( /** @type {?} */(_this.route.options.routingCoordKey))];
                        /** @type {?} */
                        var stopsCoordinatesFromURL = [];
                        if (routingParams) {
                            /** @type {?} */
                            var routingCoordUrl_1 = routingParams.split(';');
                            if (routingCoordUrl_1.length >= 2) {
                                /** @type {?} */
                                var cnt_1 = 0;
                                routingCoordUrl_1.forEach(( /**
                                 * @param {?} coord
                                 * @return {?}
                                 */function (coord) {
                                    if (cnt_1 !== 0 && cnt_1 !== routingCoordUrl_1.length - 1) {
                                        _this.component.stops.insert(cnt_1, _this.component.createStop());
                                    }
                                    /** @type {?} */
                                    var stopCoordinatesFromURL = JSON.parse('[' + coord + ']');
                                    _this.component.stops
                                        .at(cnt_1)
                                        .patchValue({ stopCoordinates: stopCoordinatesFromURL });
                                    _this.component.stops
                                        .at(cnt_1)
                                        .patchValue({ stopPoint: stopCoordinatesFromURL });
                                    _this.component.handleLocationProposals(stopCoordinatesFromURL, cnt_1);
                                    stopsCoordinatesFromURL.push(stopCoordinatesFromURL);
                                    _this.component.addStopOverlay(stopCoordinatesFromURL, cnt_1);
                                    cnt_1++;
                                }));
                                _this.component.getRoutes(stopsCoordinatesFromURL, true);
                            }
                        }
                    }));
                }
                else if (storedStopsCoordinates) {
                    for (var i = 0; i < storedStopsCoordinates.length; i++) {
                        if (i !== 0 && i !== storedStopsCoordinates.length - 1) {
                            this.component.stops.insert(i, this.component.createStop());
                        }
                        if (storedStopsCoordinates[i] instanceof Array) {
                            this.component.addStopOverlay(storedStopsCoordinates[i], i);
                            this.component.stops
                                .at(i)
                                .patchValue({ stopCoordinates: storedStopsCoordinates[i] });
                            this.component.stops
                                .at(i)
                                .patchValue({ stopPoint: storedStopsCoordinates[i] });
                            this.component.handleLocationProposals(storedStopsCoordinates[i], i);
                        }
                    }
                }
            };
        RoutingFormBindingDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[igoRoutingFormBinding]'
                    },] }
        ];
        /** @nocollapse */
        RoutingFormBindingDirective.ctorParameters = function () {
            return [
                { type: RoutingFormComponent, decorators: [{ type: i0.Self }] },
                { type: RoutingFormService },
                { type: i1$1.RouteService, decorators: [{ type: i0.Optional }] }
            ];
        };
        return RoutingFormBindingDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var IgoRoutingModule = /** @class */ (function () {
        function IgoRoutingModule() {
        }
        /**
         * @return {?}
         */
        IgoRoutingModule.forRoot = /**
         * @return {?}
         */
            function () {
                return {
                    ngModule: IgoRoutingModule
                };
            };
        IgoRoutingModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            forms.ReactiveFormsModule,
                            material.MatIconModule,
                            material.MatButtonModule,
                            material.MatListModule,
                            material.MatDividerModule,
                            material.MatFormFieldModule,
                            material.MatInputModule,
                            material.MatOptionModule,
                            material.MatSelectModule,
                            material.MatTooltipModule,
                            material.MatAutocompleteModule,
                            i1$1.IgoLanguageModule
                        ],
                        exports: [RoutingFormComponent, RoutingFormBindingDirective],
                        declarations: [RoutingFormComponent, RoutingFormBindingDirective],
                        providers: [RoutingFormService, provideRoutingSourceService()]
                    },] }
        ];
        return IgoRoutingModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Search source factory
     * @ignore
     * @param {?} sources
     * @return {?}
     */
    function searchSourceServiceFactory(sources) {
        return new SearchSourceService(sources);
    }
    /**
     * Function that returns a provider for the SearchSource service
     * @return {?}
     */
    function provideSearchSourceService() {
        return {
            provide: SearchSourceService,
            useFactory: searchSourceServiceFactory,
            deps: [SearchSource]
        };
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var IChercheSearchResultFormatter = /** @class */ (function () {
        function IChercheSearchResultFormatter(languageService) {
            this.languageService = languageService;
        }
        /**
         * @param {?} result
         * @return {?}
         */
        IChercheSearchResultFormatter.prototype.formatResult = /**
         * @param {?} result
         * @return {?}
         */
            function (result) {
                return result;
            };
        IChercheSearchResultFormatter.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        IChercheSearchResultFormatter.ctorParameters = function () {
            return [
                { type: i1$1.LanguageService }
            ];
        };
        return IChercheSearchResultFormatter;
    }());
    /**
     * ICherche search source
     */
    var IChercheSearchSource = /** @class */ (function (_super) {
        __extends(IChercheSearchSource, _super);
        function IChercheSearchSource(http, options, formatter) {
            var _this = _super.call(this, options) || this;
            _this.http = http;
            _this.formatter = formatter;
            return _this;
        }
        /**
         * @return {?}
         */
        IChercheSearchSource.prototype.getId = /**
         * @return {?}
         */
            function () {
                return IChercheSearchSource.id;
            };
        /**
         * @protected
         * @return {?}
         */
        IChercheSearchSource.prototype.getDefaultOptions = /**
         * @protected
         * @return {?}
         */
            function () {
                return {
                    title: 'ICherche Qubec',
                    searchUrl: 'https://geoegl.msp.gouv.qc.ca/apis/icherche/geocode',
                    settings: [
                        {
                            type: 'checkbox',
                            title: 'results type',
                            name: 'type',
                            values: [
                                {
                                    title: 'Adresse',
                                    value: 'adresses',
                                    enabled: true
                                },
                                // {
                                //   title: 'Ancienne adresse',
                                //   value: 'ancienne_adresse',
                                //   enabled: true
                                // },
                                {
                                    title: 'Code Postal',
                                    value: 'codes-postaux',
                                    enabled: true
                                },
                                {
                                    title: 'Route',
                                    value: 'routes',
                                    enabled: false
                                },
                                {
                                    title: 'Municipalit',
                                    value: 'municipalites',
                                    enabled: true
                                },
                                // {
                                //   title: 'Ancienne municipalit',
                                //   value: 'ancienne_municipalite',
                                //   enabled: true
                                // },
                                {
                                    title: 'mrc',
                                    value: 'mrc',
                                    enabled: true
                                },
                                {
                                    title: 'Rgion administrative',
                                    value: 'regadmin',
                                    enabled: true
                                },
                                {
                                    title: 'Lieu',
                                    value: 'lieux',
                                    enabled: true
                                },
                                {
                                    title: 'Borne',
                                    value: 'bornes',
                                    enabled: false
                                },
                                {
                                    title: 'Entreprise',
                                    value: 'entreprises',
                                    enabled: false
                                }
                            ]
                        },
                        {
                            type: 'radiobutton',
                            title: 'results limit',
                            name: 'limit',
                            values: [
                                {
                                    title: '1',
                                    value: 1,
                                    enabled: false
                                },
                                {
                                    title: '5',
                                    value: 5,
                                    enabled: true
                                },
                                {
                                    title: '10',
                                    value: 10,
                                    enabled: false
                                },
                                {
                                    title: '25',
                                    value: 25,
                                    enabled: false
                                },
                                {
                                    title: '50',
                                    value: 50,
                                    enabled: false
                                }
                            ]
                        },
                        {
                            type: 'radiobutton',
                            title: 'trust level',
                            name: 'ecmax',
                            values: [
                                {
                                    title: '10',
                                    value: 10,
                                    enabled: false
                                },
                                {
                                    title: '30',
                                    value: 30,
                                    enabled: true
                                },
                                {
                                    title: '50',
                                    value: 50,
                                    enabled: false
                                },
                                {
                                    title: '75',
                                    value: 75,
                                    enabled: false
                                },
                                {
                                    title: '100',
                                    value: 100,
                                    enabled: false
                                }
                            ]
                        }
                    ]
                };
            };
        /**
         * Search a location by name or keyword
         * @param term Location name or keyword
         * @returns Observable of <SearchResult<Feature>[]
         */
        /**
         * Search a location by name or keyword
         * @param {?} term Location name or keyword
         * @param {?=} options
         * @return {?} Observable of <SearchResult<Feature>[]
         */
        IChercheSearchSource.prototype.search = /**
         * Search a location by name or keyword
         * @param {?} term Location name or keyword
         * @param {?=} options
         * @return {?} Observable of <SearchResult<Feature>[]
         */
            function (term, options) {
                var _this = this;
                /** @type {?} */
                var params = this.computeRequestParams(term, options || {});
                return this.http
                    .get(this.searchUrl, { params: params })
                    .pipe(operators.map(( /**
             * @param {?} response
             * @return {?}
             */function (response) { return _this.extractResults(response); })));
            };
        /**
         * @private
         * @param {?} term
         * @param {?} options
         * @return {?}
         */
        IChercheSearchSource.prototype.computeRequestParams = /**
         * @private
         * @param {?} term
         * @param {?} options
         * @return {?}
         */
            function (term, options) {
                return new i1.HttpParams({
                    fromObject: Object.assign({
                        q: this.computeTerm(term),
                        geometry: true,
                        type: 'adresses,codes-postaux,municipalites,mrc,regadmin,lieux,entreprises,bornes'
                    }, this.params, this.computeOptionsParam(term, options || {}).params)
                });
            };
        /**
         * @private
         * @param {?} response
         * @return {?}
         */
        IChercheSearchSource.prototype.extractResults = /**
         * @private
         * @param {?} response
         * @return {?}
         */
            function (response) {
                var _this = this;
                return response.features.map(( /**
                 * @param {?} data
                 * @return {?}
                 */function (data) {
                    return _this.formatter.formatResult(_this.dataToResult(data));
                }));
            };
        /**
         * @private
         * @param {?} data
         * @return {?}
         */
        IChercheSearchSource.prototype.dataToResult = /**
         * @private
         * @param {?} data
         * @return {?}
         */
            function (data) {
                /** @type {?} */
                var properties = this.computeProperties(data);
                /** @type {?} */
                var id = [this.getId(), properties.type, properties.code].join('.');
                /** @type {?} */
                var subtitleHtml = data.highlight.title2
                    ? ' <small> ' + data.highlight.title2 + '</small>'
                    : '';
                return {
                    source: this,
                    data: {
                        type: FEATURE,
                        projection: 'EPSG:4326',
                        geometry: data.geometry,
                        extent: data.bbox,
                        properties: properties,
                        meta: {
                            id: id,
                            title: data.properties.nom
                        }
                    },
                    meta: {
                        dataType: FEATURE,
                        id: id,
                        title: data.properties.nom,
                        titleHtml: data.highlight.title + subtitleHtml,
                        icon: 'map-marker'
                    }
                };
            };
        /**
         * @private
         * @param {?} data
         * @return {?}
         */
        IChercheSearchSource.prototype.computeProperties = /**
         * @private
         * @param {?} data
         * @return {?}
         */
            function (data) {
                /** @type {?} */
                var properties = utils.ObjectUtils.removeKeys(data.properties, IChercheSearchSource.propertiesBlacklist);
                return Object.assign(properties, { type: data.index });
            };
        /**
         * Remove hashtag from query
         * @param term Query with hashtag
         */
        /**
         * Remove hashtag from query
         * @private
         * @param {?} term Query with hashtag
         * @return {?}
         */
        IChercheSearchSource.prototype.computeTerm = /**
         * Remove hashtag from query
         * @private
         * @param {?} term Query with hashtag
         * @return {?}
         */
            function (term) {
                return term.replace(/(#[^\s]*)/g, '');
            };
        /**
         * Add hashtag to param if valid
         * @param term Query with hashtag
         * @param options TextSearchOptions
         */
        /**
         * Add hashtag to param if valid
         * @private
         * @param {?} term Query with hashtag
         * @param {?} options TextSearchOptions
         * @return {?}
         */
        IChercheSearchSource.prototype.computeOptionsParam = /**
         * Add hashtag to param if valid
         * @private
         * @param {?} term Query with hashtag
         * @param {?} options TextSearchOptions
         * @return {?}
         */
            function (term, options) {
                var _this = this;
                /** @type {?} */
                var tags = term.match(/(#[^\s]+)/g);
                if (tags) {
                    /** @type {?} */
                    var typeValue_1 = '';
                    /** @type {?} */
                    var hashtagToAdd_1 = false;
                    tags.forEach(( /**
                     * @param {?} value
                     * @return {?}
                     */function (value) {
                        if (_super.prototype.hashtagValid.call(_this, _super.prototype.getSettingsValues.call(_this, 'type'), value, true)) {
                            typeValue_1 += value.substring(1) + ',';
                            hashtagToAdd_1 = true;
                        }
                    }));
                    if (hashtagToAdd_1) {
                        options.params = Object.assign(options.params || {}, {
                            type: typeValue_1.slice(0, -1)
                        });
                    }
                }
                return options;
            };
        IChercheSearchSource.id = 'icherche';
        IChercheSearchSource.type = FEATURE;
        IChercheSearchSource.propertiesBlacklist = [];
        IChercheSearchSource.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        IChercheSearchSource.ctorParameters = function () {
            return [
                { type: i1.HttpClient },
                { type: undefined, decorators: [{ type: i0.Inject, args: ['options',] }] },
                { type: IChercheSearchResultFormatter, decorators: [{ type: i0.Inject, args: [IChercheSearchResultFormatter,] }] }
            ];
        };
        return IChercheSearchSource;
    }(SearchSource));
    /**
     * IChercheReverse search source
     */
    var IChercheReverseSearchSource = /** @class */ (function (_super) {
        __extends(IChercheReverseSearchSource, _super);
        function IChercheReverseSearchSource(http, options) {
            var _this = _super.call(this, options) || this;
            _this.http = http;
            return _this;
        }
        /**
         * @return {?}
         */
        IChercheReverseSearchSource.prototype.getId = /**
         * @return {?}
         */
            function () {
                return IChercheReverseSearchSource.id;
            };
        /**
         * @protected
         * @return {?}
         */
        IChercheReverseSearchSource.prototype.getDefaultOptions = /**
         * @protected
         * @return {?}
         */
            function () {
                return {
                    title: 'Territoire (Gocodage invers)',
                    searchUrl: 'https://geoegl.msp.gouv.qc.ca/apis/territoires/locate',
                    settings: [
                        {
                            type: 'checkbox',
                            title: 'results type',
                            name: 'type',
                            values: [
                                {
                                    title: 'Adresse',
                                    value: 'adresses',
                                    enabled: true
                                },
                                {
                                    title: 'Route',
                                    value: 'routes',
                                    enabled: false
                                },
                                {
                                    title: 'Arrondissement',
                                    value: 'arrondissements',
                                    enabled: false
                                },
                                {
                                    title: 'Municipalit',
                                    value: 'municipalites',
                                    enabled: true
                                },
                                {
                                    title: 'mrc',
                                    value: 'mrc',
                                    enabled: true
                                },
                                {
                                    title: 'Rgion administrative',
                                    value: 'regadmin',
                                    enabled: true
                                }
                            ]
                        }
                    ]
                };
            };
        /**
         * Search a location by coordinates
         * @param lonLat Location coordinates
         * @param distance Search raidus around lonLat
         * @returns Observable of <SearchResult<Feature>[]
         */
        /**
         * Search a location by coordinates
         * @param {?} lonLat Location coordinates
         * @param {?=} options
         * @return {?} Observable of <SearchResult<Feature>[]
         */
        IChercheReverseSearchSource.prototype.reverseSearch = /**
         * Search a location by coordinates
         * @param {?} lonLat Location coordinates
         * @param {?=} options
         * @return {?} Observable of <SearchResult<Feature>[]
         */
            function (lonLat, options) {
                var _this = this;
                /** @type {?} */
                var params = this.computeRequestParams(lonLat, options || {});
                return this.http.get(this.searchUrl, { params: params }).pipe(operators.map(( /**
                 * @param {?} response
                 * @return {?}
                 */function (response) {
                    return _this.extractResults(response);
                })));
            };
        /**
         * @private
         * @param {?} lonLat
         * @param {?=} options
         * @return {?}
         */
        IChercheReverseSearchSource.prototype.computeRequestParams = /**
         * @private
         * @param {?} lonLat
         * @param {?=} options
         * @return {?}
         */
            function (lonLat, options) {
                /** @type {?} */
                var distance = options.distance;
                return new i1.HttpParams({
                    fromObject: Object.assign({
                        loc: lonLat.join(','),
                        buffer: distance ? String(distance) : '100',
                        geometry: true
                    }, this.params, options.params || {})
                });
            };
        /**
         * @private
         * @param {?} response
         * @return {?}
         */
        IChercheReverseSearchSource.prototype.extractResults = /**
         * @private
         * @param {?} response
         * @return {?}
         */
            function (response) {
                var _this = this;
                return response.features.map(( /**
                 * @param {?} data
                 * @return {?}
                 */function (data) {
                    return _this.dataToResult(data);
                }));
            };
        /**
         * @private
         * @param {?} data
         * @return {?}
         */
        IChercheReverseSearchSource.prototype.dataToResult = /**
         * @private
         * @param {?} data
         * @return {?}
         */
            function (data) {
                /** @type {?} */
                var properties = this.computeProperties(data);
                /** @type {?} */
                var extent = this.computeExtent(data);
                /** @type {?} */
                var id = [this.getId(), properties.type, properties.code].join('.');
                return {
                    source: this,
                    data: {
                        type: FEATURE,
                        projection: 'EPSG:4326',
                        geometry: data.geometry,
                        extent: extent,
                        properties: properties,
                        meta: {
                            id: id,
                            title: data.properties.nom
                        }
                    },
                    meta: {
                        dataType: FEATURE,
                        id: id,
                        title: data.properties.nom,
                        icon: 'map-marker'
                    }
                };
            };
        /**
         * @private
         * @param {?} data
         * @return {?}
         */
        IChercheReverseSearchSource.prototype.computeProperties = /**
         * @private
         * @param {?} data
         * @return {?}
         */
            function (data) {
                /** @type {?} */
                var properties = utils.ObjectUtils.removeKeys(data.properties, IChercheReverseSearchSource.propertiesBlacklist);
                return properties;
            };
        /**
         * @private
         * @param {?} data
         * @return {?}
         */
        IChercheReverseSearchSource.prototype.computeExtent = /**
         * @private
         * @param {?} data
         * @return {?}
         */
            function (data) {
                return data.bbox
                    ? [data.bbox[0], data.bbox[2], data.bbox[1], data.bbox[3]]
                    : undefined;
            };
        IChercheReverseSearchSource.id = 'icherchereverse';
        IChercheReverseSearchSource.type = FEATURE;
        IChercheReverseSearchSource.propertiesBlacklist = ['doc_type'];
        IChercheReverseSearchSource.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        IChercheReverseSearchSource.ctorParameters = function () {
            return [
                { type: i1.HttpClient },
                { type: undefined, decorators: [{ type: i0.Inject, args: ['options',] }] }
            ];
        };
        return IChercheReverseSearchSource;
    }(SearchSource));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * ICherche search result formatter factory
     * @ignore
     * @param {?} languageService
     * @return {?}
     */
    function defaultIChercheSearchResultFormatterFactory(languageService) {
        return new IChercheSearchResultFormatter(languageService);
    }
    /**
     * Function that returns a provider for the ICherche search result formatter
     * @return {?}
     */
    function provideDefaultIChercheSearchResultFormatter() {
        return {
            provide: IChercheSearchResultFormatter,
            useFactory: defaultIChercheSearchResultFormatterFactory,
            deps: [i1$1.LanguageService]
        };
    }
    /**
     * ICherche search source factory
     * @ignore
     * @param {?} http
     * @param {?} config
     * @param {?} formatter
     * @return {?}
     */
    function ichercheSearchSourceFactory(http, config, formatter) {
        return new IChercheSearchSource(http, config.getConfig("searchSources." + IChercheSearchSource.id), formatter);
    }
    /**
     * Function that returns a provider for the ICherche search source
     * @return {?}
     */
    function provideIChercheSearchSource() {
        return {
            provide: SearchSource,
            useFactory: ichercheSearchSourceFactory,
            multi: true,
            deps: [i1.HttpClient, i1$1.ConfigService, IChercheSearchResultFormatter]
        };
    }
    /**
     * IChercheReverse search source factory
     * @ignore
     * @param {?} http
     * @param {?} config
     * @return {?}
     */
    function ichercheReverseSearchSourceFactory(http, config) {
        return new IChercheReverseSearchSource(http, config.getConfig("searchSources." + IChercheReverseSearchSource.id));
    }
    /**
     * Function that returns a provider for the IChercheReverse search source
     * @return {?}
     */
    function provideIChercheReverseSearchSource() {
        return {
            provide: SearchSource,
            useFactory: ichercheReverseSearchSourceFactory,
            multi: true,
            deps: [i1.HttpClient, i1$1.ConfigService]
        };
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var GoogleLinks = /** @class */ (function () {
        function GoogleLinks() {
        }
        /**
         * @param {?} lon
         * @param {?} lat
         * @return {?}
         */
        GoogleLinks.getGoogleMapsLink = /**
         * @param {?} lon
         * @param {?} lat
         * @return {?}
         */
            function (lon, lat) {
                return 'https://www.google.com/maps?q=' + lat + ',' + lon;
            };
        /**
         * @param {?} lon
         * @param {?} lat
         * @return {?}
         */
        GoogleLinks.getGoogleStreetViewLink = /**
         * @param {?} lon
         * @param {?} lat
         * @return {?}
         */
            function (lon, lat) {
                return 'https://www.google.com/maps?q=&layer=c&cbll=' + lat + ',' + lon;
            };
        return GoogleLinks;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var CoordinatesSearchResultFormatter = /** @class */ (function () {
        function CoordinatesSearchResultFormatter(languageService) {
            this.languageService = languageService;
        }
        /**
         * @param {?} result
         * @return {?}
         */
        CoordinatesSearchResultFormatter.prototype.formatResult = /**
         * @param {?} result
         * @return {?}
         */
            function (result) {
                return result;
            };
        CoordinatesSearchResultFormatter.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        CoordinatesSearchResultFormatter.ctorParameters = function () {
            return [
                { type: i1$1.LanguageService }
            ];
        };
        return CoordinatesSearchResultFormatter;
    }());
    /**
     * CoordinatesReverse search source
     */
    var CoordinatesReverseSearchSource = /** @class */ (function (_super) {
        __extends(CoordinatesReverseSearchSource, _super);
        function CoordinatesReverseSearchSource(options) {
            return _super.call(this, options) || this;
        }
        /**
         * @return {?}
         */
        CoordinatesReverseSearchSource.prototype.getId = /**
         * @return {?}
         */
            function () {
                return CoordinatesReverseSearchSource.id;
            };
        /**
         * @protected
         * @return {?}
         */
        CoordinatesReverseSearchSource.prototype.getDefaultOptions = /**
         * @protected
         * @return {?}
         */
            function () {
                return {
                    title: 'Coordinates'
                };
            };
        /**
         * Search a location by coordinates
         * @param lonLat Location coordinates
         * @param distance Search raidus around lonLat
         * @returns Observable of <SearchResult<Feature>[]
         */
        /**
         * Search a location by coordinates
         * @param {?} lonLat Location coordinates
         * @param {?=} options
         * @return {?} Observable of <SearchResult<Feature>[]
         */
        CoordinatesReverseSearchSource.prototype.reverseSearch = /**
         * Search a location by coordinates
         * @param {?} lonLat Location coordinates
         * @param {?=} options
         * @return {?} Observable of <SearchResult<Feature>[]
         */
            function (lonLat, options) {
                return rxjs.of([this.dataToResult(lonLat)]);
            };
        /**
         * @private
         * @param {?} data
         * @return {?}
         */
        CoordinatesReverseSearchSource.prototype.dataToResult = /**
         * @private
         * @param {?} data
         * @return {?}
         */
            function (data) {
                return {
                    source: this,
                    data: {
                        type: FEATURE,
                        projection: 'EPSG:4326',
                        geometry: {
                            type: 'Point',
                            coordinates: [data[0], data[1]]
                        },
                        extent: undefined,
                        properties: {
                            type: 'point',
                            coordonnees: String(data[0]) + ', ' + String(data[1]),
                            format: 'degrs decimaux',
                            systemeCoordonnees: 'WGS84',
                            GoogleMaps: GoogleLinks.getGoogleMapsLink(data[0], data[1]),
                            GoogleStreetView: GoogleLinks.getGoogleStreetViewLink(data[0], data[1])
                        }
                    },
                    meta: {
                        dataType: FEATURE,
                        id: '1',
                        title: String(data[0]) + ', ' + String(data[1]),
                        icon: 'map-marker'
                    }
                };
            };
        CoordinatesReverseSearchSource.id = 'coordinatesreverse';
        CoordinatesReverseSearchSource.type = FEATURE;
        CoordinatesReverseSearchSource.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        CoordinatesReverseSearchSource.ctorParameters = function () {
            return [
                { type: undefined, decorators: [{ type: i0.Inject, args: ['options',] }] }
            ];
        };
        return CoordinatesReverseSearchSource;
    }(SearchSource));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * ICherche search result formatter factory
     * @ignore
     * @param {?} languageService
     * @return {?}
     */
    function defaultCoordinatesSearchResultFormatterFactory(languageService) {
        return new CoordinatesSearchResultFormatter(languageService);
    }
    /**
     * Function that returns a provider for the ICherche search result formatter
     * @return {?}
     */
    function provideDefaultCoordinatesSearchResultFormatter() {
        return {
            provide: CoordinatesSearchResultFormatter,
            useFactory: defaultCoordinatesSearchResultFormatterFactory,
            deps: [i1$1.LanguageService]
        };
    }
    /**
     * CoordinatesReverse search source factory
     * @ignore
     * @param {?} config
     * @return {?}
     */
    function CoordinatesReverseSearchSourceFactory(config) {
        return new CoordinatesReverseSearchSource(config.getConfig("searchSources." + CoordinatesReverseSearchSource.id));
    }
    /**
     * Function that returns a provider for the IChercheReverse search source
     * @return {?}
     */
    function provideCoordinatesReverseSearchSource() {
        return {
            provide: SearchSource,
            useFactory: CoordinatesReverseSearchSourceFactory,
            multi: true,
            deps: [i1$1.ConfigService]
        };
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var SEARCH_TYPES = [FEATURE, LAYER];

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * This component allows a user to select a search type yo enable. In it's
     * current version, only one search type can be selected at once (radio). If
     * this component were to support more than one search source enabled (checkbox),
     * the searchbar component would require a small change to it's
     * placeholder getter. The search source service already supports having
     * more than one search source enabled.
     */
    var SearchSelectorComponent = /** @class */ (function () {
        function SearchSelectorComponent(searchSourceService) {
            this.searchSourceService = searchSourceService;
            /**
             * List of available search types
             */
            this.searchTypes = SEARCH_TYPES;
            /**
             * Event emitted when the enabled search type changes
             */
            this.change = new i0.EventEmitter();
        }
        /**
         * Enable the first search type if the enabled input is not defined
         * @internal
         */
        /**
         * Enable the first search type if the enabled input is not defined
         * \@internal
         * @return {?}
         */
        SearchSelectorComponent.prototype.ngOnInit = /**
         * Enable the first search type if the enabled input is not defined
         * \@internal
         * @return {?}
         */
            function () {
                /** @type {?} */
                var initial = this.enabled || this.searchTypes[0];
                this.enableSearchType(initial);
            };
        /**
         * Enable the selected search type
         * @param searchType Search type
         * @internal
         */
        /**
         * Enable the selected search type
         * \@internal
         * @param {?} searchType Search type
         * @return {?}
         */
        SearchSelectorComponent.prototype.onSearchTypeChange = /**
         * Enable the selected search type
         * \@internal
         * @param {?} searchType Search type
         * @return {?}
         */
            function (searchType) {
                this.enableSearchType(searchType);
            };
        /**
         * Get a search type's title. The title
         * for all availables search typers needs to be defined in the locale
         * files or an error will be thrown.
         * @param searchType Search type
         * @internal
         */
        /**
         * Get a search type's title. The title
         * for all availables search typers needs to be defined in the locale
         * files or an error will be thrown.
         * \@internal
         * @param {?} searchType Search type
         * @return {?}
         */
        SearchSelectorComponent.prototype.getSearchTypeTitle = /**
         * Get a search type's title. The title
         * for all availables search typers needs to be defined in the locale
         * files or an error will be thrown.
         * \@internal
         * @param {?} searchType Search type
         * @return {?}
         */
            function (searchType) {
                return "search." + searchType.toLowerCase() + ".title";
            };
        /**
         * Emit an event and enable the search sources of the given type.
         * @param searchType Search type
         */
        /**
         * Emit an event and enable the search sources of the given type.
         * @private
         * @param {?} searchType Search type
         * @return {?}
         */
        SearchSelectorComponent.prototype.enableSearchType = /**
         * Emit an event and enable the search sources of the given type.
         * @private
         * @param {?} searchType Search type
         * @return {?}
         */
            function (searchType) {
                this.enabled = searchType;
                this.searchSourceService.enableSourcesByType(searchType);
                this.change.emit(searchType);
            };
        SearchSelectorComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'igo-search-selector',
                        template: "<div class=\"igo-search-selector\">\r\n  <button\r\n    mat-icon-button\r\n    class=\"igo-search-selector-button\"\r\n    color=\"primary\"\r\n    tooltip-position=\"below\"\r\n    matTooltipShowDelay=\"500\"\r\n    [matTooltip]=\"'igo.geo.search.menu.tooltip' | translate\"\r\n    [matMenuTriggerFor]=\"searchSelectorMenu\">\r\n    <mat-icon svgIcon=\"menu-down\"></mat-icon>\r\n  </button>\r\n\r\n  <mat-menu\r\n    #searchSelectorMenu=\"matMenu\"\r\n    class=\"no-border-radius\"\r\n    xPosition=\"before\"\r\n    yPosition=\"above\">\r\n    <mat-radio-group\r\n      class=\"igo-search-selector-radio-group\"\r\n      [value]=\"enabled\"\r\n      (change)=\"onSearchTypeChange($event.value)\">\r\n      <mat-radio-button *ngFor=\"let searchType of searchTypes\" [value]=\"searchType\">\r\n        {{getSearchTypeTitle(searchType) | translate}}\r\n      </mat-radio-button>\r\n    </mat-radio-group>\r\n  </mat-menu>\r\n\r\n</div>\r\n",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        styles: [".igo-search-selector-button ::ng-deep div.mat-button-ripple-round{border-radius:0}.igo-search-selector-radio-group{display:inline-flex;flex-direction:column}.igo-search-selector-radio-group mat-radio-button{margin:5px}"]
                    }] }
        ];
        /** @nocollapse */
        SearchSelectorComponent.ctorParameters = function () {
            return [
                { type: SearchSourceService }
            ];
        };
        SearchSelectorComponent.propDecorators = {
            searchTypes: [{ type: i0.Input }],
            enabled: [{ type: i0.Input }],
            change: [{ type: i0.Output }]
        };
        return SearchSelectorComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @ignore
     */
    var IgoSearchSelectorModule = /** @class */ (function () {
        function IgoSearchSelectorModule() {
        }
        IgoSearchSelectorModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            material.MatTooltipModule,
                            material.MatIconModule,
                            material.MatButtonModule,
                            material.MatMenuModule,
                            material.MatRadioModule,
                            material.MatTabsModule,
                            material.MatCheckboxModule,
                            i1$1.IgoLanguageModule
                        ],
                        exports: [SearchSelectorComponent],
                        declarations: [SearchSelectorComponent]
                    },] }
        ];
        return IgoSearchSelectorModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * This component allows a user to select a search type yo enable. In it's
     * current version, only one search type can be selected at once (radio). If
     * this component were to support more than one search source enabled (checkbox),
     * the searchbar component would require a small change to it's
     * placeholder getter. The search source service already supports having
     * more than one search source enabled.
     */
    var SearchSettingsComponent = /** @class */ (function () {
        function SearchSettingsComponent(searchSourceService) {
            this.searchSourceService = searchSourceService;
            /**
             * Event emitted when the enabled search type changes
             */
            this.change = new i0.EventEmitter();
        }
        /**
         * Get all search sources
         * @internal
         */
        /**
         * Get all search sources
         * \@internal
         * @return {?}
         */
        SearchSettingsComponent.prototype.getSearchSources = /**
         * Get all search sources
         * \@internal
         * @return {?}
         */
            function () {
                return this.searchSourceService.getSources();
            };
        /**
         * Triggered when a setting is checked (checkbox style)
         * @internal
         */
        /**
         * Triggered when a setting is checked (checkbox style)
         * \@internal
         * @param {?} event
         * @param {?} source
         * @param {?} setting
         * @param {?} settingValue
         * @return {?}
         */
        SearchSettingsComponent.prototype.settingsValueCheckedCheckbox = /**
         * Triggered when a setting is checked (checkbox style)
         * \@internal
         * @param {?} event
         * @param {?} source
         * @param {?} setting
         * @param {?} settingValue
         * @return {?}
         */
            function (event, source, setting, settingValue) {
                settingValue.enabled = event.checked;
                source.setParamFromSetting(setting);
            };
        /**
         * Triggered when a setting is checked (radiobutton style)
         * @internal
         */
        /**
         * Triggered when a setting is checked (radiobutton style)
         * \@internal
         * @param {?} event
         * @param {?} source
         * @param {?} setting
         * @param {?} settingValue
         * @return {?}
         */
        SearchSettingsComponent.prototype.settingsValueCheckedRadioButton = /**
         * Triggered when a setting is checked (radiobutton style)
         * \@internal
         * @param {?} event
         * @param {?} source
         * @param {?} setting
         * @param {?} settingValue
         * @return {?}
         */
            function (event, source, setting, settingValue) {
                setting.values.forEach(( /**
                 * @param {?} conf
                 * @return {?}
                 */function (conf) {
                    if (conf.value !== settingValue.value) {
                        conf.enabled = !event.source.checked;
                    }
                    else {
                        conf.enabled = event.source.checked;
                    }
                }));
                source.setParamFromSetting(setting);
            };
        /**
         * @param {?} event
         * @param {?} source
         * @return {?}
         */
        SearchSettingsComponent.prototype.onCheckSearchSource = /**
         * @param {?} event
         * @param {?} source
         * @return {?}
         */
            function (event, source) {
                source.enabled = event.checked;
            };
        SearchSettingsComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'igo-search-settings',
                        template: "<div class=\"igo-search-settings\">\r\n\r\n  <button\r\n    mat-icon-button\r\n    class=\"igo-search-settings-button\"\r\n    color=\"primary\"\r\n    tooltip-position=\"below\"\r\n    matTooltipShowDelay=\"500\"\r\n    [matTooltip]=\"'igo.geo.search.menu.tooltip' | translate\"\r\n    [matMenuTriggerFor]=\"searchSettingsMenu\">\r\n    <mat-icon svgIcon=\"settings\"></mat-icon>\r\n  </button>\r\n  <mat-menu\r\n    #searchSettingsMenu=\"matMenu\"\r\n    class=\"no-border-radius\">\r\n      <ng-container *ngFor=\"let source of getSearchSources()\">\r\n        <span class=\"igo-search-settings-search-source\">\r\n          <mat-checkbox\r\n            class=\"igo-search-settings-checkbox\"\r\n            [checked]=\"source.enabled\"\r\n            [value]=\"source\"\r\n            (click)=\"$event.stopPropagation()\"\r\n            (change)=\"onCheckSearchSource($event, source)\">\r\n          </mat-checkbox>\r\n          <button *ngIf=\"source.settings.length\u00A0>\u00A00\"\r\n            [matMenuTriggerFor]=\"sub_menu\"\r\n            mat-menu-item>{{source.title}}\r\n          </button>\r\n          <button\r\n            mat-menu-item\r\n            *ngIf=\"source.settings.length\u00A0===\u00A00\">\r\n            {{source.title}}\r\n          </button>\r\n        </span>\r\n          <mat-menu #sub_menu=\"matMenu\">\r\n            <ng-container *ngFor=\"let setting of source.settings\">\r\n              <button\r\n                  mat-menu-item\r\n                  [matMenuTriggerFor]=\"test_sub_menu\">\r\n                {{'igo.geo.search.searchSources.settings.'+ setting.title | translate}}\r\n              </button>\r\n              <mat-menu #test_sub_menu=\"matMenu\"\r\n                [ngSwitch]=\"setting.type\"\r\n                yPosition=\"above\">\r\n                <span *ngSwitchCase=\"'radiobutton'\">\r\n                  <mat-radio-group\r\n                    class=\"igo-search-settings-radio-group\"\r\n                    [value]=\"setting\">\r\n                    <mat-radio-button *ngFor=\"let settingValue of setting.values\"\r\n                      [value]=\"settingValue\"\r\n                      [checked]=\"settingValue.enabled\"\r\n                      (click)=\"$event.stopPropagation()\"\r\n                      (change)=\"settingsValueCheckedRadioButton($event, source, setting, settingValue)\">\r\n                      {{settingValue.title}}\r\n                    </mat-radio-button>\r\n                  </mat-radio-group>\r\n                </span>\r\n                <span *ngSwitchCase=\"'checkbox'\">\r\n                  <mat-checkbox class=\"igo-search-settings-radio-group\"\r\n                    class=\"mat-menu-item\"\r\n                    [checked]=\"settingValue.enabled\"\r\n                    [value]=\"setting\"\r\n                    (click)=\"$event.stopPropagation()\"\r\n                    (change)=\"settingsValueCheckedCheckbox($event, source, setting, settingValue)\"\r\n                    *ngFor=\"let settingValue of setting.values\">{{settingValue.title}}\r\n                  </mat-checkbox>\r\n                </span>\r\n              </mat-menu>\r\n            </ng-container>\r\n          </mat-menu>\r\n      </ng-container>\r\n  </mat-menu>\r\n</div>\r\n",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        styles: [".igo-search-settings-button ::ng-deep div.mat-button-ripple-round{border-radius:0}.igo-search-settings-radio-group{display:inline-flex;flex-direction:column}.igo-search-settings-radio-group mat-radio-button{margin:5px}.igo-search-settings-checkbox mat-radio-button{display:inline-flex}.igo-search-settings-search-source{display:inline-flex;width:100%}.igo-search-settings-search-source mat-checkbox{display:inline-flex;margin-left:5px;margin-right:5px}"]
                    }] }
        ];
        /** @nocollapse */
        SearchSettingsComponent.ctorParameters = function () {
            return [
                { type: SearchSourceService }
            ];
        };
        SearchSettingsComponent.propDecorators = {
            change: [{ type: i0.Output }]
        };
        return SearchSettingsComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @ignore
     */
    var IgoSearchSettingsModule = /** @class */ (function () {
        function IgoSearchSettingsModule() {
        }
        IgoSearchSettingsModule.decorators = [
            { type: i0.NgModule, args: [{
                        declarations: [SearchSettingsComponent],
                        imports: [
                            common.CommonModule,
                            material.MatTooltipModule,
                            material.MatIconModule,
                            material.MatButtonModule,
                            material.MatMenuModule,
                            material.MatRadioModule,
                            material.MatCheckboxModule,
                            i1$1.IgoLanguageModule
                        ],
                        exports: [SearchSettingsComponent]
                    },] }
        ];
        return IgoSearchSettingsModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Searchbar that triggers a research in all search sources enabled.
     * If the store input is defined, the search results will be loaded
     * into that store. An event is always emitted when a research is completed.
     */
    var SearchBarComponent = /** @class */ (function () {
        function SearchBarComponent(searchService) {
            this.searchService = searchService;
            /**
             * Invalid keys
             */
            this.invalidKeys = ['Control', 'Shift', 'Alt'];
            /**
             * Search term stream
             */
            this.stream$ = new rxjs.Subject();
            /**
             * Search term
             */
            this.term = '';
            /**
             * Whether a float label should be displayed
             */
            this.floatLabel = 'never';
            /**
             * Whether this component is disabled
             */
            this.disabled = false;
            /**
             * Icons color (search and clear)
             */
            this.color = 'primary';
            /**
             * Debounce time between each keystroke
             */
            this.debounce = 300;
            /**
             * Minimum term length required to trigger a research
             */
            this.minLength = 2;
            /**
             * List of available search types
             */
            this.searchTypes = SEARCH_TYPES;
            /**
             * Event emitted when the search term changes
             */
            this.change = new i0.EventEmitter();
            /**
             * Event emitted when a research is completed
             */
            this.search = new i0.EventEmitter();
            /**
             * Event emitted when the search type changes
             */
            this.searchTypeChange = new i0.EventEmitter();
            this._placeholder = '';
        }
        Object.defineProperty(SearchBarComponent.prototype, "emptyClass", {
            /**
             * Host's empty class
             * @internal
             */
            get: /**
             * Host's empty class
             * \@internal
             * @return {?}
             */ function () {
                return this.empty;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchBarComponent.prototype, "empty", {
            /**
             * Whether the search bar is empty
             * @internal
             */
            get: /**
             * Whether the search bar is empty
             * \@internal
             * @return {?}
             */ function () {
                return this.term.length === 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchBarComponent.prototype, "placeholder", {
            get: /**
             * @return {?}
             */ function () {
                return this.empty ? this._placeholder : '';
            },
            /**
             * Search bar palceholder
             * @internal
             */
            set: /**
             * Search bar palceholder
             * \@internal
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._placeholder = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Subscribe to the search term stream and trigger researches
         * @internal
         */
        /**
         * Subscribe to the search term stream and trigger researches
         * \@internal
         * @return {?}
         */
        SearchBarComponent.prototype.ngOnInit = /**
         * Subscribe to the search term stream and trigger researches
         * \@internal
         * @return {?}
         */
            function () {
                var _this = this;
                this.stream$$ = this.stream$
                    .pipe(operators.debounce(( /**
             * @param {?} term
             * @return {?}
             */function (term) {
                    return term === '' ? rxjs.EMPTY : rxjs.timer(300);
                })), operators.distinctUntilChanged())
                    .subscribe(( /**
             * @param {?} term
             * @return {?}
             */function (term) { return _this.onTermChange(term); }));
            };
        /**
         * Unsubscribe to the search term stream
         * @internal
         */
        /**
         * Unsubscribe to the search term stream
         * \@internal
         * @return {?}
         */
        SearchBarComponent.prototype.ngOnDestroy = /**
         * Unsubscribe to the search term stream
         * \@internal
         * @return {?}
         */
            function () {
                this.stream$$.unsubscribe();
            };
        /**
         * When a user types, validates the key and send it into the
         * stream if it's valid
         * @param event Keyboard event
         * @internal
         */
        /**
         * When a user types, validates the key and send it into the
         * stream if it's valid
         * \@internal
         * @param {?} event Keyboard event
         * @return {?}
         */
        SearchBarComponent.prototype.onKeyup = /**
         * When a user types, validates the key and send it into the
         * stream if it's valid
         * \@internal
         * @param {?} event Keyboard event
         * @return {?}
         */
            function (event) {
                /** @type {?} */
                var key = (( /** @type {?} */(event.target))).value;
                if (!this.keyIsValid(key)) {
                    return;
                }
                this.setTerm(key);
            };
        /**
         * Clear the stream and the input
         * @internal
         */
        /**
         * Clear the stream and the input
         * \@internal
         * @return {?}
         */
        SearchBarComponent.prototype.onClearButtonClick = /**
         * Clear the stream and the input
         * \@internal
         * @return {?}
         */
            function () {
                this.clear();
            };
        /**
         * Update the placeholder with the enabled search type. The placeholder
         * for all availables search typers needs to be defined in the locale
         * files or an error will be thrown.
         * @param searchType Enabled search type
         * @internal
         */
        /**
         * Update the placeholder with the enabled search type. The placeholder
         * for all availables search typers needs to be defined in the locale
         * files or an error will be thrown.
         * \@internal
         * @param {?} searchType Enabled search type
         * @return {?}
         */
        SearchBarComponent.prototype.onSearchTypeChange = /**
         * Update the placeholder with the enabled search type. The placeholder
         * for all availables search typers needs to be defined in the locale
         * files or an error will be thrown.
         * \@internal
         * @param {?} searchType Enabled search type
         * @return {?}
         */
            function (searchType) {
                this.searchTypeChange.emit(searchType);
                this.placeholder = "search." + searchType.toLowerCase() + ".placeholder";
                this.doSearch(this.term);
            };
        /**
         * Send the term into the stream only if this component is not disabled
         * @param term Search term
         */
        /**
         * Send the term into the stream only if this component is not disabled
         * @param {?} term Search term
         * @return {?}
         */
        SearchBarComponent.prototype.setTerm = /**
         * Send the term into the stream only if this component is not disabled
         * @param {?} term Search term
         * @return {?}
         */
            function (term) {
                if (this.disabled) {
                    return;
                }
                this.term = term;
                if (term.replace(/(#[^\s]*)/g, '').trim().length >= this.minLength ||
                    term.replace(/(#[^\s]*)/g, '').trim().length === 0) {
                    this.stream$.next(term);
                }
            };
        /**
         * Clear the stream and the input
         */
        /**
         * Clear the stream and the input
         * @private
         * @return {?}
         */
        SearchBarComponent.prototype.clear = /**
         * Clear the stream and the input
         * @private
         * @return {?}
         */
            function () {
                this.term = '';
                this.stream$.next(this.term);
                this.input.nativeElement.focus();
            };
        /**
         * Validate if a given key stroke is a valid input
         */
        /**
         * Validate if a given key stroke is a valid input
         * @private
         * @param {?} key
         * @return {?}
         */
        SearchBarComponent.prototype.keyIsValid = /**
         * Validate if a given key stroke is a valid input
         * @private
         * @param {?} key
         * @return {?}
         */
            function (key) {
                return this.invalidKeys.indexOf(key) === -1;
            };
        /**
         * When the search term changes, emit an event and trigger a
         * research in every enabled search sources.
         * @param term Search term
         */
        /**
         * When the search term changes, emit an event and trigger a
         * research in every enabled search sources.
         * @private
         * @param {?} term Search term
         * @return {?}
         */
        SearchBarComponent.prototype.onTermChange = /**
         * When the search term changes, emit an event and trigger a
         * research in every enabled search sources.
         * @private
         * @param {?} term Search term
         * @return {?}
         */
            function (term) {
                this.change.emit(term);
                this.doSearch(term);
            };
        /**
         * Execute the search
         * @param term Search term
         */
        /**
         * Execute the search
         * @private
         * @param {?} term Search term
         * @return {?}
         */
        SearchBarComponent.prototype.doSearch = /**
         * Execute the search
         * @private
         * @param {?} term Search term
         * @return {?}
         */
            function (term) {
                var _this = this;
                if (term === undefined || term.replace(/(#[^\s]*)/g, '').trim() === '') {
                    if (this.store !== undefined) {
                        this.store.clear();
                    }
                    return;
                }
                if (this.store !== undefined) {
                    this.store.softClear();
                }
                /** @type {?} */
                var researches = this.searchService.search(term);
                researches.map(( /**
                 * @param {?} research
                 * @return {?}
                 */function (research) {
                    research.request.subscribe(( /**
                     * @param {?} results
                     * @return {?}
                     */function (results) {
                        _this.onResearchCompleted(research, results);
                    }));
                }));
            };
        /**
         * When a research  is completed, emit an event and update
         * the store's items.
         * @param research Research
         * @param results Research results
         */
        /**
         * When a research  is completed, emit an event and update
         * the store's items.
         * @private
         * @param {?} research Research
         * @param {?} results Research results
         * @return {?}
         */
        SearchBarComponent.prototype.onResearchCompleted = /**
         * When a research  is completed, emit an event and update
         * the store's items.
         * @private
         * @param {?} research Research
         * @param {?} results Research results
         * @return {?}
         */
            function (research, results) {
                this.search.emit({ research: research, results: results });
                if (this.store !== undefined) {
                    /** @type {?} */
                    var newResults = this.store.entities$.value
                        .filter(( /**
                 * @param {?} result
                 * @return {?}
                 */function (result) { return result.source !== research.source; }))
                        .concat(results);
                    this.store.load(newResults);
                }
            };
        SearchBarComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'igo-search-bar',
                        template: "<div class=\"igo-search-bar-container\">\r\n  <mat-form-field [floatLabel]=\"floatLabel\">\r\n    <input\r\n      #input\r\n      matInput\r\n      autocomplete=\"off\"\r\n      [ngClass]=\"{'hasSearchIcon': searchIcon}\"\r\n      [disabled]=\"disabled\"\r\n      [placeholder]=\"placeholder | translate\"\r\n      [ngModel]=\"term\"\r\n      (keyup)=\"onKeyup($event)\"\r\n      (touchend)=\"onKeyup($event)\">\r\n  </mat-form-field>\r\n\r\n  <div class=\"search-bar-buttons\">\r\n    <button\r\n      mat-icon-button\r\n      [color]=\"color\"\r\n      *ngIf=\"searchIcon !== undefined\">\r\n      <mat-icon svgIcon=\"{{searchIcon}}\"></mat-icon>\r\n    </button>\r\n\r\n    <button\r\n      mat-icon-button\r\n      [color]=\"color\"\r\n      (click)=\"onClearButtonClick()\"\r\n      *ngIf=\"!empty\">\r\n      <mat-icon svgIcon=\"close\"></mat-icon>\r\n    </button>\r\n\r\n    <igo-search-selector\r\n      [searchTypes]=\"searchTypes\"\r\n      (change)=\"onSearchTypeChange($event)\">\r\n    </igo-search-selector>\r\n\r\n    <igo-search-settings></igo-search-settings>\r\n  </div>\r\n\r\n\r\n</div>\r\n",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        styles: [":host ::ng-deep .mat-form-field{padding:0 5px}:host ::ng-deep .mat-form-field-wrapper{margin-bottom:-1.5em}:host ::ng-deep span.mat-form-field-label-wrapper{top:-20px}:host ::ng-deep div.mat-form-field-infix{left:5px;right:5px;padding:0 0 12px!important}:host ::ng-deep div.mat-form-field-underline{display:none}.igo-search-bar-container{position:relative;width:100%;display:inline-flex;overflow:hidden}.igo-search-bar-container>mat-form-field{width:calc(100% - (2 * 40px))}:host.empty .igo-search-bar-container>mat-form-field{width:calc(100% - 40px)}.search-bar-buttons{position:relative;right:0;display:inline-flex;top:0}.search-bar-buttons>button:nth-child(2)::before{content:'';left:0;top:5px;border-right:1px solid #ddd;height:28px}igo-search-selector,igo-search-settings{background-color:#fff;top:0;border-radius:0}"]
                    }] }
        ];
        /** @nocollapse */
        SearchBarComponent.ctorParameters = function () {
            return [
                { type: SearchService }
            ];
        };
        SearchBarComponent.propDecorators = {
            term: [{ type: i0.Input }],
            floatLabel: [{ type: i0.Input }],
            disabled: [{ type: i0.Input }],
            color: [{ type: i0.Input }],
            debounce: [{ type: i0.Input }],
            minLength: [{ type: i0.Input }],
            searchIcon: [{ type: i0.Input }],
            store: [{ type: i0.Input }],
            searchTypes: [{ type: i0.Input }],
            change: [{ type: i0.Output }],
            search: [{ type: i0.Output }],
            searchTypeChange: [{ type: i0.Output }],
            input: [{ type: i0.ViewChild, args: ['input',] }],
            emptyClass: [{ type: i0.HostBinding, args: ['class.empty',] }]
        };
        return SearchBarComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SearchUrlParamDirective = /** @class */ (function () {
        function SearchUrlParamDirective(component, ref, route) {
            this.component = component;
            this.ref = ref;
            this.route = route;
        }
        /**
         * @return {?}
         */
        SearchUrlParamDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.route && this.route.options.searchKey) {
                    this.route.queryParams.subscribe(( /**
                     * @param {?} params
                     * @return {?}
                     */function (params) {
                        /** @type {?} */
                        var searchParams = params[( /** @type {?} */(_this.route.options.searchKey))];
                        if (searchParams) {
                            _this.component.setTerm(searchParams);
                            _this.ref.detectChanges();
                        }
                    }));
                }
            };
        SearchUrlParamDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[igoSearchUrlParam]'
                    },] }
        ];
        /** @nocollapse */
        SearchUrlParamDirective.ctorParameters = function () {
            return [
                { type: SearchBarComponent, decorators: [{ type: i0.Self }] },
                { type: i0.ChangeDetectorRef },
                { type: i1$1.RouteService, decorators: [{ type: i0.Optional }] }
            ];
        };
        return SearchUrlParamDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @ignore
     */
    var IgoSearchBarModule = /** @class */ (function () {
        function IgoSearchBarModule() {
        }
        IgoSearchBarModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            material.MatTooltipModule,
                            material.MatIconModule,
                            material.MatButtonModule,
                            material.MatMenuModule,
                            material.MatRadioModule,
                            material.MatFormFieldModule,
                            material.MatInputModule,
                            i1$1.IgoLanguageModule,
                            IgoSearchSelectorModule,
                            IgoSearchSettingsModule
                        ],
                        exports: [
                            SearchBarComponent,
                        ],
                        declarations: [
                            SearchBarComponent,
                            SearchUrlParamDirective
                        ]
                    },] }
        ];
        return IgoSearchBarModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @enum {string} */
    var SearchResultMode = {
        Grouped: 'grouped',
        Flat: 'flat',
    };
    /**
     * List of search results with focus and selection capabilities.
     * This component is dumb and only emits events.
     */
    var SearchResultsComponent = /** @class */ (function () {
        function SearchResultsComponent(cdRef) {
            this.cdRef = cdRef;
            /**
             * Reference to the SearchResultMode enum
             * \@internal
             */
            this.searchResultMode = SearchResultMode;
            /**
             * Search results display mode
             */
            this.mode = SearchResultMode.Grouped;
            /**
             * Event emitted when a result is focused
             */
            this.resultFocus = new i0.EventEmitter();
            /**
             * Event emitted when a result is selected
             */
            this.resultSelect = new i0.EventEmitter();
        }
        Object.defineProperty(SearchResultsComponent.prototype, "results$", {
            get: /**
             * @return {?}
             */ function () {
                if (this._results$ === undefined) {
                    this._results$ = this.liftResults();
                }
                return this._results$;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Bind the search results store to the watcher
         * @internal
         */
        /**
         * Bind the search results store to the watcher
         * \@internal
         * @return {?}
         */
        SearchResultsComponent.prototype.ngOnInit = /**
         * Bind the search results store to the watcher
         * \@internal
         * @return {?}
         */
            function () {
                this.watcher = new common$1.EntityStoreWatcher(this.store, this.cdRef);
            };
        /**
         * Unbind the search results store from the watcher
         * @internal
         */
        /**
         * Unbind the search results store from the watcher
         * \@internal
         * @return {?}
         */
        SearchResultsComponent.prototype.ngOnDestroy = /**
         * Unbind the search results store from the watcher
         * \@internal
         * @return {?}
         */
            function () {
                this.watcher.destroy();
            };
        /**
         * When a result is focused, update it's state in the store and emit
         * an event.
         * @param result Search result
         * @internal
         */
        /**
         * When a result is focused, update it's state in the store and emit
         * an event.
         * \@internal
         * @param {?} result Search result
         * @return {?}
         */
        SearchResultsComponent.prototype.onResultFocus = /**
         * When a result is focused, update it's state in the store and emit
         * an event.
         * \@internal
         * @param {?} result Search result
         * @return {?}
         */
            function (result) {
                this.store.state.update(result, { focused: true }, true);
                this.resultFocus.emit(result);
            };
        /**
         * Compute a group title
         * @param group Search results group
         * @returns Group title
         * @internal
         */
        /**
         * Compute a group title
         * \@internal
         * @param {?} group Search results group
         * @return {?} Group title
         */
        SearchResultsComponent.prototype.computeGroupTitle = /**
         * Compute a group title
         * \@internal
         * @param {?} group Search results group
         * @return {?} Group title
         */
            function (group) {
                /** @type {?} */
                var parts = [group.source.title];
                /** @type {?} */
                var count = group.results.length;
                if (count > 1) {
                    parts.push("(" + count + ")");
                }
                return parts.join(' ');
            };
        /**
         * When a result is selected, update it's state in the store and emit
         * an event. A selected result is also considered focused
         * @param result Search result
         * @internal
         */
        /**
         * When a result is selected, update it's state in the store and emit
         * an event. A selected result is also considered focused
         * \@internal
         * @param {?} result Search result
         * @return {?}
         */
        SearchResultsComponent.prototype.onResultSelect = /**
         * When a result is selected, update it's state in the store and emit
         * an event. A selected result is also considered focused
         * \@internal
         * @param {?} result Search result
         * @return {?}
         */
            function (result) {
                this.store.state.update(result, {
                    focused: true,
                    selected: true
                }, true);
                this.resultSelect.emit(result);
            };
        /**
         * Return an observable of the search results, grouped by search source
         * @returns Observable of grouped search results
         * @internal
         */
        /**
         * Return an observable of the search results, grouped by search source
         * \@internal
         * @private
         * @return {?} Observable of grouped search results
         */
        SearchResultsComponent.prototype.liftResults = /**
         * Return an observable of the search results, grouped by search source
         * \@internal
         * @private
         * @return {?} Observable of grouped search results
         */
            function () {
                var _this = this;
                return this.store.view.all$().pipe(operators.debounce(( /**
                 * @param {?} results
                 * @return {?}
                 */function (results) {
                    return results.length === 0 ? rxjs.EMPTY : rxjs.timer(200);
                })), operators.map(( /**
                 * @param {?} results
                 * @return {?}
                 */function (results) {
                    return _this.groupResults(results.sort(_this.sortByOrder));
                })));
            };
        /**
         * Sort the results by display order.
         * @param r1 First result
         * @param r2 Second result
         */
        /**
         * Sort the results by display order.
         * @private
         * @param {?} r1 First result
         * @param {?} r2 Second result
         * @return {?}
         */
        SearchResultsComponent.prototype.sortByOrder = /**
         * Sort the results by display order.
         * @private
         * @param {?} r1 First result
         * @param {?} r2 Second result
         * @return {?}
         */
            function (r1, r2) {
                return r1.source.displayOrder - r2.source.displayOrder;
            };
        /**
         * Group results by search source
         * @param results Search results from all sources
         * @returns Search results grouped by source
         */
        /**
         * Group results by search source
         * @private
         * @param {?} results Search results from all sources
         * @return {?} Search results grouped by source
         */
        SearchResultsComponent.prototype.groupResults = /**
         * Group results by search source
         * @private
         * @param {?} results Search results from all sources
         * @return {?} Search results grouped by source
         */
            function (results) {
                /** @type {?} */
                var grouped = new Map();
                results.forEach(( /**
                 * @param {?} result
                 * @return {?}
                 */function (result) {
                    /** @type {?} */
                    var source = result.source;
                    /** @type {?} */
                    var sourceResults = grouped.get(source);
                    if (sourceResults === undefined) {
                        sourceResults = [];
                        grouped.set(source, sourceResults);
                    }
                    sourceResults.push(result);
                }));
                return Array.from(grouped.keys()).map(( /**
                 * @param {?} source
                 * @return {?}
                 */function (source) {
                    return { source: source, results: grouped.get(source) };
                }));
            };
        SearchResultsComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'igo-search-results',
                        template: "<igo-list [navigation]=\"true\">\r\n  <ng-template\r\n    #groupTemplate\r\n    ngFor let-group\r\n    [ngForOf]=\"results$ | async\">\r\n\r\n    <igo-collapsible\r\n      *ngIf=\"mode === searchResultMode.Grouped; else flatTemplate\"\r\n      [title]=\"computeGroupTitle(group)\">\r\n      <ng-container *ngTemplateOutlet=\"storeItemTemplate; context: {results: group.results}\"></ng-container>\r\n    </igo-collapsible>\r\n\r\n    <ng-template #flatTemplate>\r\n      <ng-container *ngTemplateOutlet=\"storeItemTemplate; context: {results: group.results}\"></ng-container>\r\n    </ng-template>\r\n\r\n    <ng-template #storeItemTemplate let-results=\"results\">\r\n      <ng-template ngFor let-result [ngForOf]=\"results\">\r\n        <igo-search-results-item\r\n          igoListItem\r\n          color=\"accent\"\r\n          [result]=\"result\"\r\n          [focused]=\"store.state.get(result).focused\"\r\n          [selected]=\"store.state.get(result).selected\"\r\n          (focus)=\"onResultFocus(result)\"\r\n          (select)=\"onResultSelect(result)\">\r\n        </igo-search-results-item>\r\n      </ng-template>\r\n    </ng-template>\r\n\r\n  </ng-template>\r\n</igo-list>\r\n",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        SearchResultsComponent.ctorParameters = function () {
            return [
                { type: i0.ChangeDetectorRef }
            ];
        };
        SearchResultsComponent.propDecorators = {
            store: [{ type: i0.Input }],
            mode: [{ type: i0.Input }],
            resultFocus: [{ type: i0.Output }],
            resultSelect: [{ type: i0.Output }]
        };
        return SearchResultsComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Search results list item
     */
    var SearchResultsItemComponent = /** @class */ (function () {
        function SearchResultsItemComponent() {
        }
        Object.defineProperty(SearchResultsItemComponent.prototype, "title", {
            /**
             * Search result title
             * @internal
             */
            get: /**
             * Search result title
             * \@internal
             * @return {?}
             */ function () {
                return common$1.getEntityTitle(this.result);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchResultsItemComponent.prototype, "titleHtml", {
            /**
             * Search result HTML title
             * @internal
             */
            get: /**
             * Search result HTML title
             * \@internal
             * @return {?}
             */ function () {
                return common$1.getEntityTitleHtml(this.result);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchResultsItemComponent.prototype, "icon", {
            /**
             * Search result icon
             * @internal
             */
            get: /**
             * Search result icon
             * \@internal
             * @return {?}
             */ function () {
                return common$1.getEntityIcon(this.result);
            },
            enumerable: true,
            configurable: true
        });
        SearchResultsItemComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'igo-search-results-item',
                        template: "<mat-list-item>\r\n  <mat-icon *ngIf=\"icon\" mat-list-avatar svgIcon=\"{{icon}}\"></mat-icon>\r\n  <h4 matLine *ngIf=\"titleHtml\" [innerHtml]=\"titleHtml\"></h4>\r\n  <h4 matLine *ngIf=\"!titleHtml\">{{title}}</h4>\r\n</mat-list-item>\r\n",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        styles: ["h4 :ng-deep small{color:\"#8C8C8C\"}"]
                    }] }
        ];
        /** @nocollapse */
        SearchResultsItemComponent.ctorParameters = function () { return []; };
        SearchResultsItemComponent.propDecorators = {
            result: [{ type: i0.Input }]
        };
        return SearchResultsItemComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @ignore
     */
    var IgoSearchResultsModule = /** @class */ (function () {
        function IgoSearchResultsModule() {
        }
        IgoSearchResultsModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            material.MatTooltipModule,
                            material.MatIconModule,
                            material.MatListModule,
                            common$1.IgoCollapsibleModule,
                            common$1.IgoListModule,
                            i1$1.IgoLanguageModule
                        ],
                        exports: [
                            SearchResultsComponent
                        ],
                        declarations: [
                            SearchResultsComponent,
                            SearchResultsItemComponent
                        ]
                    },] }
        ];
        return IgoSearchResultsModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var IgoSearchModule = /** @class */ (function () {
        function IgoSearchModule() {
        }
        /**
         * @return {?}
         */
        IgoSearchModule.forRoot = /**
         * @return {?}
         */
            function () {
                return {
                    ngModule: IgoSearchModule,
                    providers: [
                        provideSearchSourceService(),
                        provideDefaultIChercheSearchResultFormatter(),
                        provideDefaultCoordinatesSearchResultFormatter()
                    ]
                };
            };
        IgoSearchModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            IgoSearchBarModule,
                            IgoSearchSelectorModule,
                            IgoSearchResultsModule,
                            IgoSearchSettingsModule
                        ],
                        exports: [
                            IgoSearchBarModule,
                            IgoSearchSelectorModule,
                            IgoSearchResultsModule,
                            IgoSearchSettingsModule
                        ],
                        declarations: []
                    },] }
        ];
        return IgoSearchModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var ToastComponent = /** @class */ (function () {
        function ToastComponent() {
            this.format = new OlGeoJSON();
            this.opened = new i0.EventEmitter();
        }
        Object.defineProperty(ToastComponent.prototype, "expanded", {
            get: /**
             * @return {?}
             */ function () {
                return this._expanded;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.state = value ? 'expanded' : 'collapsed';
                this._expanded = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ToastComponent.prototype, "map", {
            get: /**
             * @return {?}
             */ function () {
                return this._map;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._map = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ToastComponent.prototype, "feature", {
            get: /**
             * @return {?}
             */ function () {
                return this._feature;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._feature = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ToastComponent.prototype, "title", {
            /**
             * @internal
             */
            get: /**
             * \@internal
             * @return {?}
             */ function () { return common$1.getEntityTitle(this.feature); },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ToastComponent.prototype.toggle = /**
         * @return {?}
         */
            function () {
                this.expanded = !this.expanded;
                this.opened.emit(this.expanded);
            };
        /**
         * @return {?}
         */
        ToastComponent.prototype.zoomToFeatureExtent = /**
         * @return {?}
         */
            function () {
                if (this.feature.geometry) {
                    /** @type {?} */
                    var olFeature = this.format.readFeature(this.feature, {
                        dataProjection: this.feature.projection,
                        featureProjection: this.map.projection
                    });
                    moveToOlFeatures(this.map, [olFeature], FeatureMotion.Zoom);
                }
            };
        /**
         * @param {?} action
         * @return {?}
         */
        ToastComponent.prototype.swipe = /**
         * @param {?} action
         * @return {?}
         */
            function (action) {
                if (action === ToastComponent.SWIPE_ACTION.UP) {
                    if (!this.expanded) {
                        this.toggle();
                    }
                }
                else if (action === ToastComponent.SWIPE_ACTION.DOWN) {
                    if (this.expanded) {
                        this.toggle();
                    }
                }
            };
        ToastComponent.SWIPE_ACTION = {
            UP: 'swipeup',
            DOWN: 'swipedown'
        };
        ToastComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'igo-toast',
                        template: "<igo-flexible #flex\r\n  collapsedMobile=\"51px\"\r\n  expandedMobile=\"300px\"\r\n  [state]=\"state\"\r\n  (swipeup)=\"swipe($event.type)\"\r\n  (swipedown)=\"swipe($event.type)\">\r\n\r\n  <igo-panel [title]=\"title\">\r\n    <button\r\n      mat-icon-button\r\n      panelLeftButton\r\n      (click)=\"toggle()\">\r\n      <mat-icon [svgIcon]=\"['collapsed', 'initial'].indexOf(flex.state) >= 0 ? 'arrow_upward' : 'arrow_downward'\"></mat-icon>\r\n    </button>\r\n\r\n    <button mat-icon-button panelRightButton class=\"igo-icon-button\" (click)=\"zoomToFeatureExtent()\" *ngIf=\"feature.geometry\">\r\n      <mat-icon svgIcon=\"zoom-in\"></mat-icon>\r\n    </button>\r\n\r\n    <igo-feature-details [feature]=\"feature\"></igo-feature-details>\r\n  </igo-panel>\r\n\r\n</igo-flexible>\r\n",
                        styles: [":host{position:absolute;bottom:0;width:100%;max-height:calc(100% - 50px);background-color:#fff}igo-feature-details ::ng-deep table{width:100%}"]
                    }] }
        ];
        /** @nocollapse */
        ToastComponent.ctorParameters = function () { return []; };
        ToastComponent.propDecorators = {
            expanded: [{ type: i0.Input }],
            map: [{ type: i0.Input }],
            feature: [{ type: i0.Input }],
            opened: [{ type: i0.Output }]
        };
        return ToastComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var IgoToastModule = /** @class */ (function () {
        function IgoToastModule() {
        }
        /**
         * @return {?}
         */
        IgoToastModule.forRoot = /**
         * @return {?}
         */
            function () {
                return {
                    ngModule: IgoToastModule
                };
            };
        IgoToastModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            material.MatIconModule,
                            material.MatButtonModule,
                            common$1.IgoPanelModule,
                            common$1.IgoFlexibleModule,
                            IgoFeatureModule
                        ],
                        exports: [ToastComponent],
                        declarations: [ToastComponent]
                    },] }
        ];
        return IgoToastModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var OgcFilterComponent = /** @class */ (function () {
        function OgcFilterComponent(cdRef) {
            this.cdRef = cdRef;
            /**
             * Event emitted on complete
             */
            this.complete = new i0.EventEmitter();
            /**
             * Event emitted on cancel
             */
            this.cancel = new i0.EventEmitter();
        }
        /**
         * Implemented as part of OnUpdateInputs
         */
        /**
         * Implemented as part of OnUpdateInputs
         * @return {?}
         */
        OgcFilterComponent.prototype.onUpdateInputs = /**
         * Implemented as part of OnUpdateInputs
         * @return {?}
         */
            function () {
                this.cdRef.detectChanges();
            };
        /**
         * On close, emit the cancel event
         */
        /**
         * On close, emit the cancel event
         * @return {?}
         */
        OgcFilterComponent.prototype.onClose = /**
         * On close, emit the cancel event
         * @return {?}
         */
            function () {
                this.cancel.emit();
            };
        OgcFilterComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'igo-ogc-filter',
                        template: "<igo-ogc-filterable-item\r\n  [layer]=\"layer\" \r\n  [map]=\"map\" >\r\n</igo-ogc-filterable-item>\r\n\r\n<div>\r\n  <button\r\n    mat-button\r\n    type=\"button\"\r\n    (click)=\"onClose()\">\r\n    {{ 'igo.geo.workspace.ogcFilter.close' | translate }}\r\n  </button>\r\n</div>\r\n",
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        styles: [""]
                    }] }
        ];
        /** @nocollapse */
        OgcFilterComponent.ctorParameters = function () {
            return [
                { type: i0.ChangeDetectorRef }
            ];
        };
        OgcFilterComponent.propDecorators = {
            layer: [{ type: i0.Input }],
            map: [{ type: i0.Input }],
            complete: [{ type: i0.Output }],
            cancel: [{ type: i0.Output }]
        };
        return OgcFilterComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var OgcFilterWidget = new i0.InjectionToken('OgcFilterWidget');
    /**
     * @param {?} widgetService
     * @return {?}
     */
    function ogcFilterWidgetFactory(widgetService) {
        return widgetService.create(OgcFilterComponent);
    }
    /**
     * @return {?}
     */
    function provideOgcFilterWidget() {
        return {
            provide: OgcFilterWidget,
            useFactory: ogcFilterWidgetFactory,
            deps: [common$1.WidgetService]
        };
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @ignore
     */
    var IgoOgcFilterModule = /** @class */ (function () {
        function IgoOgcFilterModule() {
        }
        IgoOgcFilterModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            material.MatButtonModule,
                            i1$1.IgoLanguageModule,
                            IgoFilterModule
                        ],
                        exports: [OgcFilterComponent],
                        declarations: [OgcFilterComponent],
                        entryComponents: [OgcFilterComponent]
                    },] }
        ];
        return IgoOgcFilterModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var WfsWorkspace = /** @class */ (function (_super) {
        __extends(WfsWorkspace, _super);
        function WfsWorkspace(options) {
            var _this = _super.call(this, options) || this;
            _this.options = options;
            return _this;
        }
        Object.defineProperty(WfsWorkspace.prototype, "layer", {
            get: /**
             * @return {?}
             */ function () { return this.options.layer; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WfsWorkspace.prototype, "map", {
            get: /**
             * @return {?}
             */ function () { return this.options.map; },
            enumerable: true,
            configurable: true
        });
        return WfsWorkspace;
    }(common$1.Workspace));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var WfsWorkspaceService = /** @class */ (function () {
        function WfsWorkspaceService() {
        }
        /**
         * @param {?} layer
         * @param {?} map
         * @return {?}
         */
        WfsWorkspaceService.prototype.createWorkspace = /**
         * @param {?} layer
         * @param {?} map
         * @return {?}
         */
            function (layer, map) {
                return new WfsWorkspace({
                    id: layer.id,
                    title: layer.title,
                    layer: layer,
                    map: map,
                    entityStore: this.createFeatureStore(layer, map),
                    actionStore: new common$1.ActionStore([]),
                    meta: {
                        tableTemplate: this.createTableTemplate(layer)
                    }
                });
            };
        /**
         * @private
         * @param {?} layer
         * @param {?} map
         * @return {?}
         */
        WfsWorkspaceService.prototype.createFeatureStore = /**
         * @private
         * @param {?} layer
         * @param {?} map
         * @return {?}
         */
            function (layer, map) {
                /** @type {?} */
                var store = new FeatureStore([], { map: map });
                store.bindLayer(layer);
                /** @type {?} */
                var loadingStrategy = new FeatureStoreLoadingLayerStrategy({});
                /** @type {?} */
                var selectionStrategy = new FeatureStoreSelectionStrategy({
                    map: map,
                    hitTolerance: 5
                });
                store.addStrategy(loadingStrategy, true);
                store.addStrategy(selectionStrategy, true);
                return store;
            };
        /**
         * @private
         * @param {?} layer
         * @return {?}
         */
        WfsWorkspaceService.prototype.createTableTemplate = /**
         * @private
         * @param {?} layer
         * @return {?}
         */
            function (layer) {
                /** @type {?} */
                var fields = layer.dataSource.options.sourceFields || [];
                /** @type {?} */
                var columns = fields.map(( /**
                 * @param {?} field
                 * @return {?}
                 */function (field) {
                    return {
                        name: "properties." + field.name,
                        title: field.alias ? field.alias : field.name
                    };
                }));
                return {
                    selection: true,
                    sort: true,
                    columns: columns
                };
            };
        WfsWorkspaceService.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        WfsWorkspaceService.ctorParameters = function () { return []; };
        /** @nocollapse */ WfsWorkspaceService.ngInjectableDef = i0.defineInjectable({ factory: function WfsWorkspaceService_Factory() { return new WfsWorkspaceService(); }, token: WfsWorkspaceService, providedIn: "root" });
        return WfsWorkspaceService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var WmsWorkspace = /** @class */ (function (_super) {
        __extends(WmsWorkspace, _super);
        function WmsWorkspace(options) {
            var _this = _super.call(this, options) || this;
            _this.options = options;
            return _this;
        }
        Object.defineProperty(WmsWorkspace.prototype, "layer", {
            get: /**
             * @return {?}
             */ function () { return this.options.layer; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WmsWorkspace.prototype, "map", {
            get: /**
             * @return {?}
             */ function () { return this.options.map; },
            enumerable: true,
            configurable: true
        });
        return WmsWorkspace;
    }(common$1.Workspace));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var WmsWorkspaceService = /** @class */ (function () {
        function WmsWorkspaceService() {
        }
        /**
         * @param {?} layer
         * @param {?} map
         * @return {?}
         */
        WmsWorkspaceService.prototype.createWorkspace = /**
         * @param {?} layer
         * @param {?} map
         * @return {?}
         */
            function (layer, map) {
                return new WmsWorkspace({
                    id: layer.id,
                    title: layer.title,
                    layer: layer,
                    map: map,
                    actionStore: new common$1.ActionStore([])
                });
            };
        WmsWorkspaceService.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        WmsWorkspaceService.ctorParameters = function () { return []; };
        /** @nocollapse */ WmsWorkspaceService.ngInjectableDef = i0.defineInjectable({ factory: function WmsWorkspaceService_Factory() { return new WmsWorkspaceService(); }, token: WmsWorkspaceService, providedIn: "root" });
        return WmsWorkspaceService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var WorkspaceSelectorDirective = /** @class */ (function () {
        function WorkspaceSelectorDirective(component, wfsWorkspaceService, wmsWorkspaceService) {
            this.component = component;
            this.wfsWorkspaceService = wfsWorkspaceService;
            this.wmsWorkspaceService = wmsWorkspaceService;
        }
        Object.defineProperty(WorkspaceSelectorDirective.prototype, "workspaceStore", {
            get: /**
             * @return {?}
             */ function () {
                return this.component.store;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        WorkspaceSelectorDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.layers$$ = this.map.layers$
                    .pipe(operators.debounceTime(50))
                    .subscribe(( /**
             * @param {?} layers
             * @return {?}
             */function (layers) {
                    return _this.onLayersChange(layers);
                }));
            };
        /**
         * @return {?}
         */
        WorkspaceSelectorDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.layers$$.unsubscribe();
            };
        /**
         * @private
         * @param {?} layers
         * @return {?}
         */
        WorkspaceSelectorDirective.prototype.onLayersChange = /**
         * @private
         * @param {?} layers
         * @return {?}
         */
            function (layers) {
                var _this = this;
                /** @type {?} */
                var editableLayers = layers.filter(( /**
                 * @param {?} layer
                 * @return {?}
                 */function (layer) {
                    return _this.layerIsEditable(layer);
                }));
                /** @type {?} */
                var editableLayersIds = editableLayers.map(( /**
                 * @param {?} layer
                 * @return {?}
                 */function (layer) { return layer.id; }));
                /** @type {?} */
                var workspacesToAdd = editableLayers
                    .map(( /**
             * @param {?} layer
             * @return {?}
             */function (layer) { return _this.getOrCreateWorkspace(layer); }))
                    .filter(( /**
             * @param {?} workspace
             * @return {?}
             */function (workspace) { return workspace !== undefined; }));
                /** @type {?} */
                var workspacesToRemove = this.workspaceStore.all()
                    .filter(( /**
             * @param {?} workspace
             * @return {?}
             */function (workspace) {
                    return editableLayersIds.indexOf(workspace.id) < 0;
                }));
                if (workspacesToRemove.length > 0) {
                    workspacesToRemove.forEach(( /**
                     * @param {?} workspace
                     * @return {?}
                     */function (workspace) {
                        workspace.deactivate();
                    }));
                    this.workspaceStore.state.updateMany(workspacesToRemove, { active: false, selected: false });
                    this.workspaceStore.deleteMany(workspacesToRemove);
                }
                if (workspacesToAdd.length > 0) {
                    this.workspaceStore.insertMany(workspacesToAdd);
                }
            };
        /**
         * @private
         * @param {?} layer
         * @return {?}
         */
        WorkspaceSelectorDirective.prototype.getOrCreateWorkspace = /**
         * @private
         * @param {?} layer
         * @return {?}
         */
            function (layer) {
                /** @type {?} */
                var workspace = this.workspaceStore.get(layer.id);
                if (workspace !== undefined) {
                    return;
                }
                if (layer.dataSource instanceof WFSDataSource) {
                    return this.wfsWorkspaceService.createWorkspace(( /** @type {?} */(layer)), this.map);
                }
                else if (layer.dataSource instanceof WMSDataSource) {
                    return this.wmsWorkspaceService.createWorkspace(( /** @type {?} */(layer)), this.map);
                }
                return;
            };
        /**
         * @private
         * @param {?} layer
         * @return {?}
         */
        WorkspaceSelectorDirective.prototype.layerIsEditable = /**
         * @private
         * @param {?} layer
         * @return {?}
         */
            function (layer) {
                /** @type {?} */
                var dataSource = layer.dataSource;
                if (dataSource instanceof WFSDataSource) {
                    return true;
                }
                if (dataSource instanceof WMSDataSource) {
                    /** @type {?} */
                    var dataSourceOptions = ( /** @type {?} */((dataSource.options ||
                        {})));
                    return (dataSourceOptions.ogcFilters && dataSourceOptions.ogcFilters.enabled);
                }
                return false;
            };
        WorkspaceSelectorDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[igoWorkspaceSelector]'
                    },] }
        ];
        /** @nocollapse */
        WorkspaceSelectorDirective.ctorParameters = function () {
            return [
                { type: common$1.WorkspaceSelectorComponent },
                { type: WfsWorkspaceService },
                { type: WmsWorkspaceService }
            ];
        };
        WorkspaceSelectorDirective.propDecorators = {
            map: [{ type: i0.Input }]
        };
        return WorkspaceSelectorDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @ignore
     */
    var IgoWorkspaceSelectorModule = /** @class */ (function () {
        function IgoWorkspaceSelectorModule() {
        }
        IgoWorkspaceSelectorModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            common.CommonModule
                        ],
                        exports: [
                            WorkspaceSelectorDirective
                        ],
                        declarations: [
                            WorkspaceSelectorDirective
                        ]
                    },] }
        ];
        return IgoWorkspaceSelectorModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var IgoGeoWorkspaceModule = /** @class */ (function () {
        function IgoGeoWorkspaceModule() {
        }
        IgoGeoWorkspaceModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            common$1.IgoWidgetModule,
                            IgoWorkspaceSelectorModule,
                            IgoOgcFilterModule
                        ],
                        exports: [
                            IgoWorkspaceSelectorModule,
                            IgoOgcFilterModule
                        ],
                        declarations: [],
                        providers: [
                            provideOgcFilterWidget()
                        ]
                    },] }
        ];
        return IgoGeoWorkspaceModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var IgoWktModule = /** @class */ (function () {
        function IgoWktModule() {
        }
        /**
         * @return {?}
         */
        IgoWktModule.forRoot = /**
         * @return {?}
         */
            function () {
                return {
                    ngModule: IgoWktModule,
                    providers: []
                };
            };
        IgoWktModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [],
                        exports: [],
                        declarations: []
                    },] }
        ];
        return IgoWktModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var IgoGeoModule = /** @class */ (function () {
        function IgoGeoModule() {
        }
        /**
         * @return {?}
         */
        IgoGeoModule.forRoot = /**
         * @return {?}
         */
            function () {
                return {
                    ngModule: IgoGeoModule,
                    providers: []
                };
            };
        IgoGeoModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [],
                        declarations: [],
                        exports: [
                            IgoCatalogModule,
                            IgoDataSourceModule,
                            IgoDownloadModule,
                            IgoFeatureModule,
                            IgoFilterModule,
                            IgoGeometryModule,
                            IgoImportExportModule,
                            IgoLayerModule,
                            IgoMapModule,
                            IgoMeasureModule,
                            IgoMetadataModule,
                            IgoOverlayModule,
                            IgoPrintModule,
                            IgoQueryModule,
                            IgoRoutingModule,
                            IgoSearchModule,
                            IgoToastModule,
                            IgoGeoWorkspaceModule,
                            IgoWktModule
                        ]
                    },] }
        ];
        return IgoGeoModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * ILayer search source
     */
    var ILayerSearchSource = /** @class */ (function (_super) {
        __extends(ILayerSearchSource, _super);
        function ILayerSearchSource(http, languageService, options) {
            var _this = _super.call(this, options) || this;
            _this.http = http;
            _this.languageService = languageService;
            _this.title$ = new rxjs.BehaviorSubject('');
            _this.languageService.translate.get(_this.options.title).subscribe(( /**
             * @param {?} title
             * @return {?}
             */function (title) { return _this.title$.next(title); }));
            return _this;
        }
        Object.defineProperty(ILayerSearchSource.prototype, "title", {
            get: /**
             * @return {?}
             */ function () {
                return this.title$.getValue();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ILayerSearchSource.prototype.getId = /**
         * @return {?}
         */
            function () {
                return ILayerSearchSource.id;
            };
        /**
         * @protected
         * @return {?}
         */
        ILayerSearchSource.prototype.getDefaultOptions = /**
         * @protected
         * @return {?}
         */
            function () {
                return {
                    title: 'igo.geo.search.dataSources.name',
                    searchUrl: 'https://geoegl.msp.gouv.qc.ca/apis/layers/search'
                };
            };
        /**
         * Search a layer by name or keyword
         * @param term Layer name or keyword
         * @returns Observable of <SearchResult<LayerOptions>[]
         */
        /**
         * Search a layer by name or keyword
         * @param {?} term Layer name or keyword
         * @param {?=} options
         * @return {?} Observable of <SearchResult<LayerOptions>[]
         */
        ILayerSearchSource.prototype.search = /**
         * Search a layer by name or keyword
         * @param {?} term Layer name or keyword
         * @param {?=} options
         * @return {?} Observable of <SearchResult<LayerOptions>[]
         */
            function (term, options) {
                var _this = this;
                /** @type {?} */
                var params = this.computeSearchRequestParams(term, options || {});
                return this.http
                    .get(this.searchUrl, { params: params })
                    .pipe(operators.map(( /**
             * @param {?} response
             * @return {?}
             */function (response) { return _this.extractResults(response); })));
            };
        /**
         * @private
         * @param {?} term
         * @param {?} options
         * @return {?}
         */
        ILayerSearchSource.prototype.computeSearchRequestParams = /**
         * @private
         * @param {?} term
         * @param {?} options
         * @return {?}
         */
            function (term, options) {
                return new i1.HttpParams({
                    fromObject: Object.assign({
                        q: term
                    }, this.params, options.params || {})
                });
            };
        /**
         * @private
         * @param {?} response
         * @return {?}
         */
        ILayerSearchSource.prototype.extractResults = /**
         * @private
         * @param {?} response
         * @return {?}
         */
            function (response) {
                var _this = this;
                return response.items.map(( /**
                 * @param {?} data
                 * @return {?}
                 */function (data) { return _this.dataToResult(data); }));
            };
        /**
         * @private
         * @param {?} data
         * @return {?}
         */
        ILayerSearchSource.prototype.dataToResult = /**
         * @private
         * @param {?} data
         * @return {?}
         */
            function (data) {
                /** @type {?} */
                var layerOptions = this.computeLayerOptions(data);
                return {
                    source: this,
                    meta: {
                        dataType: LAYER,
                        id: [this.getId(), data.id].join('.'),
                        title: data.source.title,
                        titleHtml: data.highlight.title,
                        icon: data.source.type === 'Layer' ? 'layers' : 'map'
                    },
                    data: layerOptions
                };
            };
        /**
         * @private
         * @param {?} data
         * @return {?}
         */
        ILayerSearchSource.prototype.computeLayerOptions = /**
         * @private
         * @param {?} data
         * @return {?}
         */
            function (data) {
                /** @type {?} */
                var url = data.source.url;
                /** @type {?} */
                var queryParams = this.extractQueryParamsFromSourceUrl(url);
                return {
                    title: data.source.title,
                    sourceOptions: {
                        crossOrigin: 'anonymous',
                        type: data.source.format,
                        url: url,
                        queryable: (( /** @type {?} */(data.source))).queryable,
                        queryFormat: queryParams.format,
                        queryHtmlTarget: queryParams.htmlTarget,
                        params: {
                            layers: data.source.name
                        }
                    }
                };
            };
        /**
         * @private
         * @param {?} url
         * @return {?}
         */
        ILayerSearchSource.prototype.extractQueryParamsFromSourceUrl = /**
         * @private
         * @param {?} url
         * @return {?}
         */
            function (url) {
                var e_1, _a;
                /** @type {?} */
                var queryFormat = QueryFormat.GML2;
                /** @type {?} */
                var htmlTarget;
                /** @type {?} */
                var formatOpt = (( /** @type {?} */(this.options))).queryFormat;
                if (formatOpt) {
                    var _loop_1 = function (key) {
                        /** @type {?} */
                        var value = formatOpt[key];
                        if (value === '*') {
                            queryFormat = QueryFormat[key.toUpperCase()];
                            return "break";
                        }
                        /** @type {?} */
                        var urls = (( /** @type {?} */(( /** @type {?} */(value))))).urls;
                        if (Array.isArray(urls)) {
                            urls.forEach(( /**
                             * @param {?} urlOpt
                             * @return {?}
                             */function (urlOpt) {
                                if (url.indexOf(urlOpt) !== -1) {
                                    queryFormat = QueryFormat[key.toUpperCase()];
                                }
                            }));
                            return "break";
                        }
                    };
                    try {
                        for (var _b = __values(Object.keys(formatOpt)), _c = _b.next(); !_c.done; _c = _b.next()) {
                            var key = _c.value;
                            var state_1 = _loop_1(key);
                            if (state_1 === "break")
                                break;
                        }
                    }
                    catch (e_1_1) {
                        e_1 = { error: e_1_1 };
                    }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return))
                                _a.call(_b);
                        }
                        finally {
                            if (e_1)
                                throw e_1.error;
                        }
                    }
                }
                if (queryFormat === QueryFormat.HTML) {
                    htmlTarget = 'iframe';
                }
                return {
                    format: queryFormat,
                    htmlTarget: htmlTarget
                };
            };
        ILayerSearchSource.id = 'ilayer';
        ILayerSearchSource.type = LAYER;
        ILayerSearchSource.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        ILayerSearchSource.ctorParameters = function () {
            return [
                { type: i1.HttpClient },
                { type: i1$1.LanguageService },
                { type: undefined, decorators: [{ type: i0.Inject, args: ['options',] }] }
            ];
        };
        return ILayerSearchSource;
    }(SearchSource));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * ILayer search source factory
     * @ignore
     * @param {?} http
     * @param {?} languageService
     * @param {?} config
     * @return {?}
     */
    function ilayerSearchSourceFactory(http, languageService, config) {
        return new ILayerSearchSource(http, languageService, config.getConfig("searchSources." + ILayerSearchSource.id));
    }
    /**
     * Function that returns a provider for the ILayer search source
     * @return {?}
     */
    function provideILayerSearchSource() {
        return {
            provide: SearchSource,
            useFactory: ilayerSearchSourceFactory,
            multi: true,
            deps: [i1.HttpClient, i1$1.LanguageService, i1$1.ConfigService]
        };
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Nominatim search source
     */
    var NominatimSearchSource = /** @class */ (function (_super) {
        __extends(NominatimSearchSource, _super);
        function NominatimSearchSource(http, options) {
            var _this = _super.call(this, options) || this;
            _this.http = http;
            return _this;
        }
        /**
         * @return {?}
         */
        NominatimSearchSource.prototype.getId = /**
         * @return {?}
         */
            function () {
                return NominatimSearchSource.id;
            };
        /*
         * Source : https://wiki.openstreetmap.org/wiki/Key:amenity
        */
        /*
           * Source : https://wiki.openstreetmap.org/wiki/Key:amenity
          */
        /**
         * @protected
         * @return {?}
         */
        NominatimSearchSource.prototype.getDefaultOptions = /*
           * Source : https://wiki.openstreetmap.org/wiki/Key:amenity
          */
            /**
             * @protected
             * @return {?}
             */
            function () {
                return {
                    title: 'Nominatim (OSM)',
                    searchUrl: 'https://nominatim.openstreetmap.org/search',
                    settings: [
                        {
                            type: 'checkbox',
                            title: 'results type',
                            name: 'amenity',
                            values: [
                                {
                                    title: 'Restauration',
                                    value: 'bar,bbq,biergaten,cafe,drinking_water,fast_food,food_court,ice_cream,pub,restaurant',
                                    enabled: false
                                },
                                {
                                    title: 'Sant',
                                    value: 'baby_hatch,clinic,dentist,doctors,hospital,nursing_home,pharmacy,social_facility,veterinary',
                                    enabled: false
                                },
                                {
                                    title: 'Divertissement',
                                    value: 'arts_centre,brothel,casino,cinema,community_center_fountain,gambling,nightclub,planetarium \
                          ,public_bookcase,social_centre,stripclub,studio,swingerclub,theatre,internet_cafe',
                                    enabled: false
                                },
                                {
                                    title: 'Finance',
                                    value: 'atm,bank,bureau_de_change',
                                    enabled: false
                                }
                            ]
                        },
                        {
                            type: 'radiobutton',
                            title: 'results limit',
                            name: 'limit',
                            values: [
                                {
                                    title: '10',
                                    value: 10,
                                    enabled: true
                                },
                                {
                                    title: '20',
                                    value: 20,
                                    enabled: false
                                },
                                {
                                    title: '50',
                                    value: 50,
                                    enabled: false
                                }
                            ]
                        },
                        {
                            type: 'radiobutton',
                            title: 'country limitation',
                            name: 'countrycodes',
                            values: [
                                {
                                    title: 'Canada',
                                    value: 'CA',
                                    enabled: true
                                },
                                {
                                    title: 'Le monde',
                                    value: null,
                                    enabled: false
                                }
                            ]
                        },
                        {
                            type: 'radiobutton',
                            title: 'multiple object',
                            name: 'dedupe',
                            values: [
                                {
                                    title: 'Oui',
                                    value: 0,
                                    enabled: false
                                },
                                {
                                    title: 'Non',
                                    value: 1,
                                    enabled: true
                                }
                            ]
                        }
                    ]
                };
            };
        /**
         * Search a place by name
         * @param term Place name
         * @returns Observable of <SearchResult<Feature>[]
         */
        /**
         * Search a place by name
         * @param {?} term Place name
         * @param {?=} options
         * @return {?} Observable of <SearchResult<Feature>[]
         */
        NominatimSearchSource.prototype.search = /**
         * Search a place by name
         * @param {?} term Place name
         * @param {?=} options
         * @return {?} Observable of <SearchResult<Feature>[]
         */
            function (term, options) {
                var _this = this;
                /** @type {?} */
                var params = this.computeSearchRequestParams(term, options || {});
                return this.http
                    .get(this.searchUrl, { params: params })
                    .pipe(operators.map(( /**
             * @param {?} response
             * @return {?}
             */function (response) { return _this.extractResults(response); })));
            };
        /**
         * @private
         * @param {?} term
         * @param {?} options
         * @return {?}
         */
        NominatimSearchSource.prototype.computeSearchRequestParams = /**
         * @private
         * @param {?} term
         * @param {?} options
         * @return {?}
         */
            function (term, options) {
                return new i1.HttpParams({
                    fromObject: Object.assign({
                        q: this.computeTerm(term),
                        format: 'json'
                    }, this.params, options.params || {})
                });
            };
        /**
         * @private
         * @param {?} response
         * @return {?}
         */
        NominatimSearchSource.prototype.extractResults = /**
         * @private
         * @param {?} response
         * @return {?}
         */
            function (response) {
                var _this = this;
                return response.map(( /**
                 * @param {?} data
                 * @return {?}
                 */function (data) { return _this.dataToResult(data); }));
            };
        /**
         * @private
         * @param {?} data
         * @return {?}
         */
        NominatimSearchSource.prototype.dataToResult = /**
         * @private
         * @param {?} data
         * @return {?}
         */
            function (data) {
                /** @type {?} */
                var properties = this.computeProperties(data);
                /** @type {?} */
                var geometry = this.computeGeometry(data);
                /** @type {?} */
                var extent = this.computeExtent(data);
                /** @type {?} */
                var id = [this.getId(), 'place', data.place_id].join('.');
                return {
                    source: this,
                    meta: {
                        dataType: FEATURE,
                        id: id,
                        title: data.display_name,
                        icon: 'map-marker'
                    },
                    data: {
                        type: FEATURE,
                        projection: 'EPSG:4326',
                        geometry: geometry,
                        extent: extent,
                        properties: properties,
                        meta: {
                            id: id,
                            title: data.display_name
                        }
                    }
                };
            };
        /**
         * @private
         * @param {?} data
         * @return {?}
         */
        NominatimSearchSource.prototype.computeProperties = /**
         * @private
         * @param {?} data
         * @return {?}
         */
            function (data) {
                return {
                    display_name: data.display_name,
                    place_id: data.place_id,
                    osm_type: data.osm_type,
                    class: data.class,
                    type: data.type
                };
            };
        /**
         * @private
         * @param {?} data
         * @return {?}
         */
        NominatimSearchSource.prototype.computeGeometry = /**
         * @private
         * @param {?} data
         * @return {?}
         */
            function (data) {
                return {
                    type: 'Point',
                    coordinates: [parseFloat(data.lon), parseFloat(data.lat)]
                };
            };
        /**
         * @private
         * @param {?} data
         * @return {?}
         */
        NominatimSearchSource.prototype.computeExtent = /**
         * @private
         * @param {?} data
         * @return {?}
         */
            function (data) {
                return [
                    parseFloat(data.boundingbox[2]),
                    parseFloat(data.boundingbox[0]),
                    parseFloat(data.boundingbox[3]),
                    parseFloat(data.boundingbox[1])
                ];
            };
        /**
         * @private
         * @param {?} term
         * @return {?}
         */
        NominatimSearchSource.prototype.computeTerm = /**
         * @private
         * @param {?} term
         * @return {?}
         */
            function (term) {
                term = this.computeTermTags(term);
                return term;
            };
        /**
         * Add hashtag from query in Nominatim's format (+[])
         * @param term Query with hashtag
         */
        /**
         * Add hashtag from query in Nominatim's format (+[])
         * @private
         * @param {?} term Query with hashtag
         * @return {?}
         */
        NominatimSearchSource.prototype.computeTermTags = /**
         * Add hashtag from query in Nominatim's format (+[])
         * @private
         * @param {?} term Query with hashtag
         * @return {?}
         */
            function (term) {
                var _this = this;
                /** @type {?} */
                var tags = term.match(/(#[^\s]+)/g);
                /** @type {?} */
                var addTagsFromSettings = true;
                if (tags) {
                    tags.forEach(( /**
                     * @param {?} value
                     * @return {?}
                     */function (value) {
                        term = term.replace(value, '');
                        if (_super.prototype.hashtagValid.call(_this, _super.prototype.getSettingsValues.call(_this, 'amenity'), value)) {
                            term += '+[' + value.substring(1) + ']';
                            addTagsFromSettings = false;
                        }
                    }));
                    addTagsFromSettings = false;
                }
                if (addTagsFromSettings) {
                    term = this.computeTermSettings(term);
                }
                return term;
            };
        /**
         * Add hashtag from settings in Nominatim's format (+[])
         * @param term Query
         */
        /**
         * Add hashtag from settings in Nominatim's format (+[])
         * @private
         * @param {?} term Query
         * @return {?}
         */
        NominatimSearchSource.prototype.computeTermSettings = /**
         * Add hashtag from settings in Nominatim's format (+[])
         * @private
         * @param {?} term Query
         * @return {?}
         */
            function (term) {
                this.options.settings.forEach(( /**
                 * @param {?} settings
                 * @return {?}
                 */function (settings) {
                    if (settings.name === 'amenity') {
                        settings.values.forEach(( /**
                         * @param {?} conf
                         * @return {?}
                         */function (conf) {
                            if (conf.enabled && typeof conf.value === 'string') {
                                /** @type {?} */
                                var splitted = conf.value.split(',');
                                splitted.forEach(( /**
                                 * @param {?} value
                                 * @return {?}
                                 */function (value) {
                                    term += '+[' + value + ']';
                                }));
                            }
                        }));
                    }
                }));
                return term;
            };
        NominatimSearchSource.id = 'nominatim';
        NominatimSearchSource.type = FEATURE;
        NominatimSearchSource.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        NominatimSearchSource.ctorParameters = function () {
            return [
                { type: i1.HttpClient },
                { type: undefined, decorators: [{ type: i0.Inject, args: ['options',] }] }
            ];
        };
        return NominatimSearchSource;
    }(SearchSource));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Nominatim search source factory
     * @ignore
     * @param {?} http
     * @param {?} config
     * @return {?}
     */
    function nominatimSearchSourceFactory(http, config) {
        return new NominatimSearchSource(http, config.getConfig("searchSources." + NominatimSearchSource.id));
    }
    /**
     * Function that returns a provider for the Nominatim search source
     * @return {?}
     */
    function provideNominatimSearchSource() {
        return {
            provide: SearchSource,
            useFactory: nominatimSearchSourceFactory,
            multi: true,
            deps: [i1.HttpClient, i1$1.ConfigService]
        };
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * StoredQueries search source
     */
    var StoredQueriesSearchSource = /** @class */ (function (_super) {
        __extends(StoredQueriesSearchSource, _super);
        function StoredQueriesSearchSource(http, options) {
            var _this = _super.call(this, options) || this;
            _this.http = http;
            _this.storedQueriesOptions = ( /** @type {?} */(options));
            if (!_this.storedQueriesOptions.storedquery_id) {
                /** @type {?} */
                var err = 'Stored Queries :You have to set "storedquery_id" into StoredQueries options. ex: storedquery_id: "nameofstoredquerie"';
                throw new Error(err);
            }
            if (!_this.storedQueriesOptions.fields) {
                throw new Error('Stored Queries :You have to set "fields" into options. ex: fields: {"name": "rtss", "defaultValue": "-99"}');
            }
            _this.storedQueriesOptions.outputformat = _this.storedQueriesOptions.outputformat || 'text/xml; subtype=gml/3.1.1';
            _this.storedQueriesOptions.srsname = _this.storedQueriesOptions.srsname || 'EPSG:4326';
            /** @type {?} */
            var storedQueryId = _this.storedQueriesOptions.storedquery_id.toLowerCase();
            if (storedQueryId.includes('getfeaturebyid') && _this.storedQueriesOptions.outputformat.toLowerCase().includes('getfeaturebyid')) {
                /** @type {?} */
                var err = 'You must set a geojson format for your stored query. This is due to an openlayers issue)';
                err += ' (wfs 1.1.0 & gml 3.1.1 limitation)';
                throw new Error(err);
            }
            if (!_this.storedQueriesOptions.fields) {
                throw new Error('Stored Queries :You must set a fields definition for your stored query');
            }
            if (!(_this.storedQueriesOptions.fields instanceof Array)) {
                _this.storedQueriesOptions.fields = [_this.storedQueriesOptions.fields];
            }
            _this.multipleFieldsQuery = _this.storedQueriesOptions.fields.length > 1 ? true : false;
            _this.storedQueriesOptions.fields.forEach(( /**
             * @param {?} field
             * @param {?} index
             * @return {?}
             */function (field, index) {
                if (_this.multipleFieldsQuery && !field.splitPrefix && index !== 0) {
                    throw new Error('Stored Queries :You must set a field spliter into your field definition (optional for the first one!)');
                }
                if (!field.defaultValue) {
                    throw new Error('Stored Queries :You must set a field default value into your field definition');
                }
            }));
            _this.storedQueriesOptions.resultTitle = _this.storedQueriesOptions.resultTitle || _this.resultTitle;
            return _this;
        }
        /**
         * @return {?}
         */
        StoredQueriesSearchSource.prototype.getId = /**
         * @return {?}
         */
            function () {
                return StoredQueriesSearchSource.id;
            };
        /**
         * @protected
         * @return {?}
         */
        StoredQueriesSearchSource.prototype.getDefaultOptions = /**
         * @protected
         * @return {?}
         */
            function () {
                return {
                    title: 'Stored Queries',
                    searchUrl: 'https://ws.mapserver.transports.gouv.qc.ca/swtq'
                };
            };
        // URL CALL EXAMPLES:
        //  GetFeatureById (mandatory storedquery for wfs server) (outputformat must be in geojson)
        //  tslint:disable-next-line:max-line-length
        //  https://ws.mapserver.transports.gouv.qc.ca/swtq?service=wfs&version=2.0.0&request=GetFeature&storedquery_id=urn:ogc:def:query:OGC-WFS::GetFeatureById&srsname=epsg:4326&outputformat=geojson&ID=a_num_route.132
        //  Custom StoredQuery
        //  tslint:disable-next-line:max-line-length
        //  https://ws.mapserver.transports.gouv.qc.ca/swtq?service=wfs&version=1.1.0&request=GetFeature&storedquery_id=rtss&srsname=epsg:4326&outputformat=text/xml;%20subtype=gml/3.1.1&rtss=0013801110000c&chainage=12
        /**
         * Search a location by name or keyword
         * @param term Location name or keyword
         * @returns Observable of <SearchResult<Feature>[]
         */
        // URL CALL EXAMPLES:
        //  GetFeatureById (mandatory storedquery for wfs server) (outputformat must be in geojson)
        //  tslint:disable-next-line:max-line-length
        //  https://ws.mapserver.transports.gouv.qc.ca/swtq?service=wfs&version=2.0.0&request=GetFeature&storedquery_id=urn:ogc:def:query:OGC-WFS::GetFeatureById&srsname=epsg:4326&outputformat=geojson&ID=a_num_route.132
        //  Custom StoredQuery
        //  tslint:disable-next-line:max-line-length
        //  https://ws.mapserver.transports.gouv.qc.ca/swtq?service=wfs&version=1.1.0&request=GetFeature&storedquery_id=rtss&srsname=epsg:4326&outputformat=text/xml;%20subtype=gml/3.1.1&rtss=0013801110000c&chainage=12
        /**
         * Search a location by name or keyword
         * @param {?} term Location name or keyword
         * @param {?=} options
         * @return {?} Observable of <SearchResult<Feature>[]
         */
        StoredQueriesSearchSource.prototype.search =
            // URL CALL EXAMPLES:
            //  GetFeatureById (mandatory storedquery for wfs server) (outputformat must be in geojson)
            //  tslint:disable-next-line:max-line-length
            //  https://ws.mapserver.transports.gouv.qc.ca/swtq?service=wfs&version=2.0.0&request=GetFeature&storedquery_id=urn:ogc:def:query:OGC-WFS::GetFeatureById&srsname=epsg:4326&outputformat=geojson&ID=a_num_route.132
            //  Custom StoredQuery
            //  tslint:disable-next-line:max-line-length
            //  https://ws.mapserver.transports.gouv.qc.ca/swtq?service=wfs&version=1.1.0&request=GetFeature&storedquery_id=rtss&srsname=epsg:4326&outputformat=text/xml;%20subtype=gml/3.1.1&rtss=0013801110000c&chainage=12
            /**
             * Search a location by name or keyword
             * @param {?} term Location name or keyword
             * @param {?=} options
             * @return {?} Observable of <SearchResult<Feature>[]
             */
            function (term, options) {
                var _this = this;
                /** @type {?} */
                var storedqueriesParams = this.termSplitter(term, this.storedQueriesOptions.fields);
                /** @type {?} */
                var params = this.computeRequestParams(options || {}, storedqueriesParams);
                if (new RegExp('.*?gml.*?', 'i').test(this.storedQueriesOptions.outputformat)) {
                    return this.http
                        .get(this.searchUrl, { params: params, responseType: 'text' })
                        .pipe(operators.map(( /**
                 * @param {?} response
                 * @return {?}
                 */function (response) {
                        return _this.extractResults(_this.extractWFSData(response));
                    })));
                }
                else {
                    return this.http
                        .get(this.searchUrl, { params: params })
                        .pipe(operators.map(( /**
                 * @param {?} response
                 * @return {?}
                 */function (response) {
                        return _this.extractResults(_this.extractWFSData(response));
                    })));
                }
            };
        /**
         * @private
         * @return {?}
         */
        StoredQueriesSearchSource.prototype.getFormatFromOptions = /**
         * @private
         * @return {?}
         */
            function () {
                /** @type {?} */
                var olFormatCls;
                /** @type {?} */
                var outputFormat = this.storedQueriesOptions.outputformat;
                /** @type {?} */
                var patternGml3 = new RegExp('.*?gml.*?', 'i');
                /** @type {?} */
                var patternGeojson = new RegExp('.*?json.*?', 'i');
                if (patternGeojson.test(outputFormat)) {
                    olFormatCls = olformat.GeoJSON;
                }
                if (patternGml3.test(outputFormat)) {
                    olFormatCls = olformat.WFS;
                }
                return new olFormatCls();
            };
        /**
         * @private
         * @param {?} res
         * @return {?}
         */
        StoredQueriesSearchSource.prototype.extractWFSData = /**
         * @private
         * @param {?} res
         * @return {?}
         */
            function (res) {
                /** @type {?} */
                var olFormat = this.getFormatFromOptions();
                /** @type {?} */
                var geojson = olformat.GeoJSON;
                /** @type {?} */
                var wfsfeatures = olFormat.readFeatures(res);
                /** @type {?} */
                var features = JSON.parse(new geojson().writeFeatures(wfsfeatures));
                return features;
            };
        /**
         * @private
         * @param {?} term
         * @param {?} fields
         * @return {?}
         */
        StoredQueriesSearchSource.prototype.termSplitter = /**
         * @private
         * @param {?} term
         * @param {?} fields
         * @return {?}
         */
            function (term, fields) {
                /** @type {?} */
                var splittedTerm = {};
                /** @type {?} */
                var remainingTerm = term;
                /** @type {?} */
                var cnt = 0;
                // Used to build the default values
                fields.forEach(( /**
                 * @param {?} field
                 * @return {?}
                 */function (field) {
                    splittedTerm[field.name] = field.defaultValue;
                    /** @type {?} */
                    var splitterRegex = new RegExp(field.splitPrefix + '(.+)', 'i');
                    if (splitterRegex.test(remainingTerm)) {
                        cnt = field.splitPrefix ? cnt += 1 : cnt;
                        remainingTerm = remainingTerm.split(splitterRegex)[1];
                    }
                }));
                if (cnt === 0) {
                    splittedTerm[fields[0].name] = term;
                    return splittedTerm;
                }
                remainingTerm = term;
                /** @type {?} */
                var localFields = __spread(fields).reverse();
                localFields.forEach(( /**
                 * @param {?} field
                 * @return {?}
                 */function (field) {
                    /** @type {?} */
                    var splitterRegex = new RegExp(field.splitPrefix || '' + '(.+)', 'i');
                    if (remainingTerm || remainingTerm !== '') {
                        /** @type {?} */
                        var values = remainingTerm.split(splitterRegex);
                        remainingTerm = values[0];
                        if (values[1]) {
                            splittedTerm[field.name] = values[1].trim();
                        }
                    }
                }));
                return splittedTerm;
            };
        /**
         * @private
         * @param {?} options
         * @param {?} queryParams
         * @return {?}
         */
        StoredQueriesSearchSource.prototype.computeRequestParams = /**
         * @private
         * @param {?} options
         * @param {?} queryParams
         * @return {?}
         */
            function (options, queryParams) {
                /** @type {?} */
                var wfsversion = this.storedQueriesOptions.storedquery_id.toLowerCase().includes('getfeaturebyid') ? '2.0.0' : '1.1.0';
                return new i1.HttpParams({
                    fromObject: Object.assign({
                        service: 'wfs',
                        version: wfsversion,
                        request: 'GetFeature',
                        storedquery_id: this.storedQueriesOptions.storedquery_id,
                        srsname: this.storedQueriesOptions.srsname,
                        outputformat: this.storedQueriesOptions.outputformat
                    }, queryParams, this.params, options.params || {})
                });
            };
        /**
         * @private
         * @param {?} response
         * @return {?}
         */
        StoredQueriesSearchSource.prototype.extractResults = /**
         * @private
         * @param {?} response
         * @return {?}
         */
            function (response) {
                var _this = this;
                return response.features.map(( /**
                 * @param {?} data
                 * @return {?}
                 */function (data) {
                    return _this.dataToResult(data);
                }));
            };
        /**
         * @private
         * @param {?} data
         * @return {?}
         */
        StoredQueriesSearchSource.prototype.dataToResult = /**
         * @private
         * @param {?} data
         * @return {?}
         */
            function (data) {
                /** @type {?} */
                var properties = this.computeProperties(data);
                /** @type {?} */
                var id = [this.getId(), properties.type, data.id].join('.');
                /** @type {?} */
                var title = data.properties[this.storedQueriesOptions.resultTitle] ? this.storedQueriesOptions.resultTitle : this.resultTitle;
                return {
                    source: this,
                    data: {
                        type: FEATURE,
                        projection: 'EPSG:4326',
                        geometry: data.geometry,
                        // extent: data.bbox,
                        properties: properties,
                        meta: {
                            id: id,
                            title: data.properties[title]
                        }
                    },
                    meta: {
                        dataType: FEATURE,
                        id: id,
                        title: data.properties.title,
                        titleHtml: data.properties[title],
                        icon: 'map-marker'
                    }
                };
            };
        /**
         * @private
         * @param {?} data
         * @return {?}
         */
        StoredQueriesSearchSource.prototype.computeProperties = /**
         * @private
         * @param {?} data
         * @return {?}
         */
            function (data) {
                /** @type {?} */
                var properties = utils.ObjectUtils.removeKeys(data.properties, StoredQueriesSearchSource.propertiesBlacklist);
                return properties;
            };
        StoredQueriesSearchSource.id = 'storedqueries';
        StoredQueriesSearchSource.type = FEATURE;
        StoredQueriesSearchSource.propertiesBlacklist = [];
        StoredQueriesSearchSource.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        StoredQueriesSearchSource.ctorParameters = function () {
            return [
                { type: i1.HttpClient },
                { type: undefined, decorators: [{ type: i0.Inject, args: ['options',] }] }
            ];
        };
        return StoredQueriesSearchSource;
    }(SearchSource));
    /**
     * StoredQueriesReverse search source
     */
    // EXAMPLE CALLS
    // tslint:disable-next-line:max-line-length
    // https://ws.mapserver.transports.gouv.qc.ca/swtq?service=wfs&version=1.1.0&request=GetFeature&storedquery_id=lim_adm&srsname=epsg:4326&outputformat=text/xml;%20subtype=gml/3.1.1&long=-71.292469&lat=46.748107
    //
    var StoredQueriesReverseSearchSource = /** @class */ (function (_super) {
        __extends(StoredQueriesReverseSearchSource, _super);
        function StoredQueriesReverseSearchSource(http, options) {
            var _this = _super.call(this, options) || this;
            _this.http = http;
            _this.storedQueriesOptions = ( /** @type {?} */(options));
            if (!_this.storedQueriesOptions.storedquery_id) {
                /** @type {?} */
                var err = 'Stored Queries :You have to set "storedquery_id" into StoredQueries options. ex: storedquery_id: "nameofstoredquerie"';
                throw new Error(err);
            }
            if (!_this.storedQueriesOptions.longField) {
                throw new Error('Stored Queries :You have to set "longField" to map the longitude coordinate to the query params.');
            }
            if (!_this.storedQueriesOptions.latField) {
                throw new Error('Stored Queries :You have to set "latField" to map the latitude coordinate to the query params.');
            }
            _this.storedQueriesOptions.outputformat = _this.storedQueriesOptions.outputformat || 'text/xml; subtype=gml/3.1.1';
            _this.storedQueriesOptions.srsname = _this.storedQueriesOptions.srsname || 'EPSG:4326';
            _this.storedQueriesOptions.resultTitle = _this.storedQueriesOptions.resultTitle || _this.resultTitle;
            return _this;
        }
        /**
         * @return {?}
         */
        StoredQueriesReverseSearchSource.prototype.getId = /**
         * @return {?}
         */
            function () {
                return StoredQueriesReverseSearchSource.id;
            };
        /**
         * @protected
         * @return {?}
         */
        StoredQueriesReverseSearchSource.prototype.getDefaultOptions = /**
         * @protected
         * @return {?}
         */
            function () {
                return {
                    title: 'Stored Queries (reverse)',
                    searchUrl: 'https://ws.mapserver.transports.gouv.qc.ca/swtq'
                };
            };
        /**
         * Search a location by coordinates
         * @param lonLat Location coordinates
         * @param distance Search raidus around lonLat
         * @returns Observable of <SearchResult<Feature>[]
         */
        /**
         * Search a location by coordinates
         * @param {?} lonLat Location coordinates
         * @param {?=} options
         * @return {?} Observable of <SearchResult<Feature>[]
         */
        StoredQueriesReverseSearchSource.prototype.reverseSearch = /**
         * Search a location by coordinates
         * @param {?} lonLat Location coordinates
         * @param {?=} options
         * @return {?} Observable of <SearchResult<Feature>[]
         */
            function (lonLat, options) {
                var _this = this;
                /** @type {?} */
                var params = this.computeRequestParams(lonLat, options || {});
                if (new RegExp('.*?gml.*?', 'i').test(this.storedQueriesOptions.outputformat)) {
                    return this.http
                        .get(this.searchUrl, { params: params, responseType: 'text' })
                        .pipe(operators.map(( /**
                 * @param {?} response
                 * @return {?}
                 */function (response) {
                        return _this.extractResults(_this.extractWFSData(response));
                    })));
                }
                else {
                    return this.http
                        .get(this.searchUrl, { params: params })
                        .pipe(operators.map(( /**
                 * @param {?} response
                 * @return {?}
                 */function (response) {
                        return _this.extractResults(_this.extractWFSData(response));
                    })));
                }
            };
        /**
         * @private
         * @return {?}
         */
        StoredQueriesReverseSearchSource.prototype.getFormatFromOptions = /**
         * @private
         * @return {?}
         */
            function () {
                /** @type {?} */
                var olFormatCls;
                /** @type {?} */
                var outputFormat = this.storedQueriesOptions.outputformat;
                /** @type {?} */
                var patternGml3 = new RegExp('.*?gml.*?', 'i');
                /** @type {?} */
                var patternGeojson = new RegExp('.*?json.*?', 'i');
                if (patternGeojson.test(outputFormat)) {
                    olFormatCls = olformat.GeoJSON;
                }
                if (patternGml3.test(outputFormat)) {
                    olFormatCls = olformat.WFS;
                }
                return new olFormatCls();
            };
        /**
         * @private
         * @param {?} res
         * @return {?}
         */
        StoredQueriesReverseSearchSource.prototype.extractWFSData = /**
         * @private
         * @param {?} res
         * @return {?}
         */
            function (res) {
                /** @type {?} */
                var olFormat = this.getFormatFromOptions();
                /** @type {?} */
                var geojson = olformat.GeoJSON;
                /** @type {?} */
                var wfsfeatures = olFormat.readFeatures(res);
                /** @type {?} */
                var features = JSON.parse(new geojson().writeFeatures(wfsfeatures));
                return features;
            };
        /**
         * @private
         * @param {?} lonLat
         * @param {?=} options
         * @return {?}
         */
        StoredQueriesReverseSearchSource.prototype.computeRequestParams = /**
         * @private
         * @param {?} lonLat
         * @param {?=} options
         * @return {?}
         */
            function (lonLat, options) {
                /** @type {?} */
                var longLatParams = {};
                longLatParams[this.storedQueriesOptions.longField] = lonLat[0];
                longLatParams[this.storedQueriesOptions.latField] = lonLat[1];
                return new i1.HttpParams({
                    fromObject: Object.assign({
                        service: 'wfs',
                        version: '1.1.0',
                        request: 'GetFeature',
                        storedquery_id: this.storedQueriesOptions.storedquery_id,
                        srsname: this.storedQueriesOptions.srsname,
                        outputformat: this.storedQueriesOptions.outputformat,
                    }, longLatParams, this.params, options.params || {})
                });
            };
        /**
         * @private
         * @param {?} response
         * @return {?}
         */
        StoredQueriesReverseSearchSource.prototype.extractResults = /**
         * @private
         * @param {?} response
         * @return {?}
         */
            function (response) {
                var _this = this;
                return response.features.map(( /**
                 * @param {?} data
                 * @return {?}
                 */function (data) {
                    return _this.dataToResult(data);
                }));
            };
        /**
         * @private
         * @param {?} data
         * @return {?}
         */
        StoredQueriesReverseSearchSource.prototype.dataToResult = /**
         * @private
         * @param {?} data
         * @return {?}
         */
            function (data) {
                /** @type {?} */
                var properties = this.computeProperties(data);
                /** @type {?} */
                var id = [this.getId(), properties.type, data.id].join('.');
                /** @type {?} */
                var title = data.properties[this.storedQueriesOptions.resultTitle] ? this.storedQueriesOptions.resultTitle : this.resultTitle;
                return {
                    source: this,
                    data: {
                        type: FEATURE,
                        projection: 'EPSG:4326',
                        geometry: data.geometry,
                        properties: properties,
                        meta: {
                            id: id,
                            title: data.properties[title]
                        }
                    },
                    meta: {
                        dataType: FEATURE,
                        id: id,
                        title: data.properties[title],
                        icon: 'map-marker'
                    }
                };
            };
        /**
         * @private
         * @param {?} data
         * @return {?}
         */
        StoredQueriesReverseSearchSource.prototype.computeProperties = /**
         * @private
         * @param {?} data
         * @return {?}
         */
            function (data) {
                /** @type {?} */
                var properties = utils.ObjectUtils.removeKeys(data.properties, StoredQueriesReverseSearchSource.propertiesBlacklist);
                return Object.assign(properties, { type: data.properties.doc_type });
            };
        StoredQueriesReverseSearchSource.id = 'storedqueriesreverse';
        StoredQueriesReverseSearchSource.type = FEATURE;
        StoredQueriesReverseSearchSource.propertiesBlacklist = [];
        StoredQueriesReverseSearchSource.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        StoredQueriesReverseSearchSource.ctorParameters = function () {
            return [
                { type: i1.HttpClient },
                { type: undefined, decorators: [{ type: i0.Inject, args: ['options',] }] }
            ];
        };
        return StoredQueriesReverseSearchSource;
    }(SearchSource));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * StoredQueries search source factory
     * @ignore
     * @param {?} http
     * @param {?} config
     * @return {?}
     */
    function storedqueriesSearchSourceFactory(http, config) {
        return new StoredQueriesSearchSource(http, config.getConfig("searchSources." + StoredQueriesSearchSource.id));
    }
    /**
     * Function that returns a provider for the StoredQueries search source
     * @return {?}
     */
    function provideStoredQueriesSearchSource() {
        return {
            provide: SearchSource,
            useFactory: storedqueriesSearchSourceFactory,
            multi: true,
            deps: [i1.HttpClient, i1$1.ConfigService]
        };
    }
    /**
     * StoredQueriesReverse search source factory
     * @ignore
     * @param {?} http
     * @param {?} config
     * @return {?}
     */
    function storedqueriesReverseSearchSourceFactory(http, config) {
        return new StoredQueriesReverseSearchSource(http, config.getConfig("searchSources." + StoredQueriesReverseSearchSource.id));
    }
    /**
     * Function that returns a provider for the StoredQueriesReverse search source
     * @return {?}
     */
    function provideStoredQueriesReverseSearchSource() {
        return {
            provide: SearchSource,
            useFactory: storedqueriesReverseSearchSourceFactory,
            multi: true,
            deps: [i1.HttpClient, i1$1.ConfigService]
        };
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @enum {number} */
    var RoutingFormat = {
        GeoJSON: 0,
        JSON: 1,
    };
    RoutingFormat[RoutingFormat.GeoJSON] = 'GeoJSON';
    RoutingFormat[RoutingFormat.JSON] = 'JSON';
    /** @enum {string} */
    var SourceRoutingType = {
        Route: 'Route',
        Trip: 'Trip',
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var OsrmRoutingSource = /** @class */ (function (_super) {
        __extends(OsrmRoutingSource, _super);
        function OsrmRoutingSource(http, config) {
            var _this = _super.call(this) || this;
            _this.http = http;
            _this.config = config;
            _this.routingUrl = 'https://geoegl.msp.gouv.qc.ca/services/itineraire/route/v1/driving/';
            _this.options = _this.config.getConfig('routingSources.osrm') || {};
            _this.routingUrl = _this.options.url || _this.routingUrl;
            return _this;
        }
        Object.defineProperty(OsrmRoutingSource.prototype, "enabled", {
            get: /**
             * @return {?}
             */ function () {
                return this.options.enabled !== false;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.options.enabled = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        OsrmRoutingSource.prototype.getName = /**
         * @return {?}
         */
            function () {
                return OsrmRoutingSource._name;
            };
        /**
         * @param {?} coordinates
         * @return {?}
         */
        OsrmRoutingSource.prototype.route = /**
         * @param {?} coordinates
         * @return {?}
         */
            function (coordinates) {
                var _this = this;
                /** @type {?} */
                var routingParams = this.getRouteParams();
                return this.http
                    .get(this.routingUrl + coordinates.join(';'), {
                    params: routingParams
                })
                    .pipe(operators.map(( /**
             * @param {?} res
             * @return {?}
             */function (res) { return _this.extractRoutesData(res); })));
            };
        /**
         * @private
         * @param {?} response
         * @return {?}
         */
        OsrmRoutingSource.prototype.extractRoutesData = /**
         * @private
         * @param {?} response
         * @return {?}
         */
            function (response) {
                var _this = this;
                /** @type {?} */
                var routeResponse = [];
                response.routes.forEach(( /**
                 * @param {?} route
                 * @return {?}
                 */function (route) {
                    routeResponse.push(_this.formatRoute(route, response.waypoints));
                }));
                return routeResponse;
            };
        /**
         * @private
         * @return {?}
         */
        OsrmRoutingSource.prototype.getRouteParams = /**
         * @private
         * @return {?}
         */
            function () {
                return new i1.HttpParams({
                    fromObject: {
                        overview: 'full',
                        steps: 'true',
                        geometries: 'geojson',
                        alternatives: 'true'
                    }
                });
            };
        /**
         * @private
         * @param {?} roadNetworkRoute
         * @param {?} waypoints
         * @return {?}
         */
        OsrmRoutingSource.prototype.formatRoute = /**
         * @private
         * @param {?} roadNetworkRoute
         * @param {?} waypoints
         * @return {?}
         */
            function (roadNetworkRoute, waypoints) {
                /** @type {?} */
                var stepsUI = [];
                roadNetworkRoute.legs.forEach(( /**
                 * @param {?} leg
                 * @return {?}
                 */function (leg) {
                    leg.steps.forEach(( /**
                     * @param {?} step
                     * @return {?}
                     */function (step) {
                        stepsUI.push(step);
                    }));
                }));
                return {
                    id: utils.uuid(),
                    title: roadNetworkRoute.legs[0].summary,
                    source: OsrmRoutingSource._name,
                    sourceType: SourceRoutingType.Route,
                    order: 1,
                    format: RoutingFormat.GeoJSON,
                    icon: 'directions',
                    projection: 'EPSG:4326',
                    waypoints: waypoints,
                    distance: roadNetworkRoute.distance,
                    duration: roadNetworkRoute.duration,
                    geometry: roadNetworkRoute.geometry,
                    legs: roadNetworkRoute.legs,
                    steps: stepsUI,
                    weight: roadNetworkRoute.weight,
                    weight_name: roadNetworkRoute.weight_name
                };
            };
        OsrmRoutingSource._name = 'OSRM Qubec';
        OsrmRoutingSource.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        OsrmRoutingSource.ctorParameters = function () {
            return [
                { type: i1.HttpClient },
                { type: i1$1.ConfigService }
            ];
        };
        return OsrmRoutingSource;
    }(RoutingSource));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} http
     * @param {?} config
     * @return {?}
     */
    function osrmRoutingSourcesFactory(http, config) {
        return new OsrmRoutingSource(http, config);
    }
    /**
     * @return {?}
     */
    function provideOsrmRoutingSource() {
        return {
            provide: RoutingSource,
            useFactory: osrmRoutingSourcesFactory,
            multi: true,
            deps: [i1.HttpClient, i1$1.ConfigService]
        };
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    exports.IgoGeoModule = IgoGeoModule;
    exports.IgoCatalogModule = IgoCatalogModule;
    exports.IgoCatalogBrowserModule = IgoCatalogBrowserModule;
    exports.IgoCatalogLibraryModule = IgoCatalogLibraryModule;
    exports.IgoDataSourceModule = IgoDataSourceModule;
    exports.IgoDownloadModule = IgoDownloadModule;
    exports.IgoGeoWorkspaceModule = IgoGeoWorkspaceModule;
    exports.IgoWorkspaceSelectorModule = IgoWorkspaceSelectorModule;
    exports.IgoOgcFilterModule = IgoOgcFilterModule;
    exports.IgoFeatureModule = IgoFeatureModule;
    exports.IgoFeatureFormModule = IgoFeatureFormModule;
    exports.IgoFeatureDetailsModule = IgoFeatureDetailsModule;
    exports.IgoFilterModule = IgoFilterModule;
    exports.IgoGeometryModule = IgoGeometryModule;
    exports.IgoGeometryFormFieldModule = IgoGeometryFormFieldModule;
    exports.IgoImportExportModule = IgoImportExportModule;
    exports.IgoLayerModule = IgoLayerModule;
    exports.IgoMapModule = IgoMapModule;
    exports.IgoMeasureModule = IgoMeasureModule;
    exports.IgoMeasurerModule = IgoMeasurerModule;
    exports.IgoMetadataModule = IgoMetadataModule;
    exports.IgoOverlayModule = IgoOverlayModule;
    exports.IgoPrintModule = IgoPrintModule;
    exports.IgoQueryModule = IgoQueryModule;
    exports.IgoRoutingModule = IgoRoutingModule;
    exports.IgoSearchModule = IgoSearchModule;
    exports.IgoSearchBarModule = IgoSearchBarModule;
    exports.IgoSearchResultsModule = IgoSearchResultsModule;
    exports.IgoToastModule = IgoToastModule;
    exports.IgoWktModule = IgoWktModule;
    exports.querySearchSourceFactory = querySearchSourceFactory;
    exports.provideQuerySearchSource = provideQuerySearchSource;
    exports.defaultIChercheSearchResultFormatterFactory = defaultIChercheSearchResultFormatterFactory;
    exports.provideDefaultIChercheSearchResultFormatter = provideDefaultIChercheSearchResultFormatter;
    exports.ichercheSearchSourceFactory = ichercheSearchSourceFactory;
    exports.provideIChercheSearchSource = provideIChercheSearchSource;
    exports.ichercheReverseSearchSourceFactory = ichercheReverseSearchSourceFactory;
    exports.provideIChercheReverseSearchSource = provideIChercheReverseSearchSource;
    exports.defaultCoordinatesSearchResultFormatterFactory = defaultCoordinatesSearchResultFormatterFactory;
    exports.provideDefaultCoordinatesSearchResultFormatter = provideDefaultCoordinatesSearchResultFormatter;
    exports.CoordinatesReverseSearchSourceFactory = CoordinatesReverseSearchSourceFactory;
    exports.provideCoordinatesReverseSearchSource = provideCoordinatesReverseSearchSource;
    exports.ilayerSearchSourceFactory = ilayerSearchSourceFactory;
    exports.provideILayerSearchSource = provideILayerSearchSource;
    exports.nominatimSearchSourceFactory = nominatimSearchSourceFactory;
    exports.provideNominatimSearchSource = provideNominatimSearchSource;
    exports.storedqueriesSearchSourceFactory = storedqueriesSearchSourceFactory;
    exports.provideStoredQueriesSearchSource = provideStoredQueriesSearchSource;
    exports.storedqueriesReverseSearchSourceFactory = storedqueriesReverseSearchSourceFactory;
    exports.provideStoredQueriesReverseSearchSource = provideStoredQueriesReverseSearchSource;
    exports.osrmRoutingSourcesFactory = osrmRoutingSourcesFactory;
    exports.provideOsrmRoutingSource = provideOsrmRoutingSource;
    exports.routingSourceServiceFactory = routingSourceServiceFactory;
    exports.provideRoutingSourceService = provideRoutingSourceService;
    exports.RoutingSourceService = RoutingSourceService;
    exports.CatalogService = CatalogService;
    exports.CatalogItemType = CatalogItemType;
    exports.CatalogBrowserComponent = CatalogBrowserComponent;
    exports.CatalogLibaryComponent = CatalogLibaryComponent;
    exports.DataService = DataService;
    exports.DataSource = DataSource;
    exports.FeatureDataSource = FeatureDataSource;
    exports.OSMDataSource = OSMDataSource;
    exports.XYZDataSource = XYZDataSource;
    exports.WFSDataSource = WFSDataSource;
    exports.WFSService = WFSService;
    exports.WMSDataSource = WMSDataSource;
    exports.formatWFSQueryString = formatWFSQueryString;
    exports.checkWfsParams = checkWfsParams;
    exports.defaultEpsg = defaultEpsg;
    exports.defaultMaxFeatures = defaultMaxFeatures;
    exports.defaultWfsVersion = defaultWfsVersion;
    exports.defaultFieldNameGeometry = defaultFieldNameGeometry;
    exports.gmlRegex = gmlRegex;
    exports.jsonRegex = jsonRegex;
    exports.WMTSDataSource = WMTSDataSource;
    exports.CartoDataSource = CartoDataSource;
    exports.ArcGISRestDataSource = ArcGISRestDataSource;
    exports.TileArcGISRestDataSource = TileArcGISRestDataSource;
    exports.WebSocketDataSource = WebSocketDataSource;
    exports.MVTDataSource = MVTDataSource;
    exports.ClusterDataSource = ClusterDataSource;
    exports.DataSourceService = DataSourceService;
    exports.CapabilitiesService = CapabilitiesService;
    exports.EsriStyleGenerator = EsriStyleGenerator;
    exports.generateIdFromSourceOptions = generateIdFromSourceOptions;
    exports.generateWMSIdFromSourceOptions = generateWMSIdFromSourceOptions;
    exports.generateWMTSIdFromSourceOptions = generateWMTSIdFromSourceOptions;
    exports.generateXYZIdFromSourceOptions = generateXYZIdFromSourceOptions;
    exports.generateFeatureIdFromSourceOptions = generateFeatureIdFromSourceOptions;
    exports.generateId = generateId;
    exports.createDefaultTileGrid = createDefaultTileGrid;
    exports.DownloadService = DownloadService;
    exports.DownloadButtonComponent = DownloadButtonComponent;
    exports.FEATURE = FEATURE;
    exports.FeatureMotion = FeatureMotion;
    exports.featureToOl = featureToOl;
    exports.featureFromOl = featureFromOl;
    exports.computeOlFeatureExtent = computeOlFeatureExtent;
    exports.computeOlFeaturesExtent = computeOlFeaturesExtent;
    exports.scaleExtent = scaleExtent;
    exports.featuresAreOutOfView = featuresAreOutOfView;
    exports.featuresAreTooDeepInView = featuresAreTooDeepInView;
    exports.moveToOlFeatures = moveToOlFeatures;
    exports.hideOlFeature = hideOlFeature;
    exports.tryBindStoreLayer = tryBindStoreLayer;
    exports.tryAddLoadingStrategy = tryAddLoadingStrategy;
    exports.tryAddSelectionStrategy = tryAddSelectionStrategy;
    exports.FeatureStore = FeatureStore;
    exports.FeatureStoreLoadingStrategy = FeatureStoreLoadingStrategy;
    exports.FeatureStoreLoadingLayerStrategy = FeatureStoreLoadingLayerStrategy;
    exports.FeatureStoreSelectionStrategy = FeatureStoreSelectionStrategy;
    exports.FeatureStoreStrategy = FeatureStoreStrategy;
    exports.FilterableDataSourcePipe = FilterableDataSourcePipe;
    exports.TimeFilterService = TimeFilterService;
    exports.OgcFilterOperatorType = OgcFilterOperatorType;
    exports.OGCFilterService = OGCFilterService;
    exports.OgcFilterWriter = OgcFilterWriter;
    exports.TimeFilterFormComponent = TimeFilterFormComponent;
    exports.TimeFilterItemComponent = TimeFilterItemComponent;
    exports.TimeFilterListComponent = TimeFilterListComponent;
    exports.TimeFilterListBindingDirective = TimeFilterListBindingDirective;
    exports.OgcFilterableFormComponent = OgcFilterableFormComponent;
    exports.OgcFilterableItemComponent = OgcFilterableItemComponent;
    exports.OgcFilterableListComponent = OgcFilterableListComponent;
    exports.OgcFilterableListBindingDirective = OgcFilterableListBindingDirective;
    exports.OgcFilterFormComponent = OgcFilterFormComponent;
    exports.OgcFilterToggleButtonComponent = OgcFilterToggleButtonComponent;
    exports.OgcFilterButtonComponent = OgcFilterButtonComponent;
    exports.GeometrySliceError = GeometrySliceError;
    exports.GeometrySliceMultiPolygonError = GeometrySliceMultiPolygonError;
    exports.GeometrySliceLineStringError = GeometrySliceLineStringError;
    exports.GeometrySliceTooManyIntersectionError = GeometrySliceTooManyIntersectionError;
    exports.createDrawInteractionStyle = createDrawInteractionStyle;
    exports.createDrawHoleInteractionStyle = createDrawHoleInteractionStyle;
    exports.sliceOlGeometry = sliceOlGeometry;
    exports.sliceOlLineString = sliceOlLineString;
    exports.sliceOlPolygon = sliceOlPolygon;
    exports.addLinearRingToOlPolygon = addLinearRingToOlPolygon;
    exports.DrawControl = DrawControl;
    exports.ModifyControl = ModifyControl;
    exports.SliceControl = SliceControl;
    exports.DropGeoFileDirective = DropGeoFileDirective;
    exports.ExportError = ExportError;
    exports.ExportInvalidFileError = ExportInvalidFileError;
    exports.ExportNothingToExportError = ExportNothingToExportError;
    exports.ExportService = ExportService;
    exports.ExportFormat = ExportFormat;
    exports.exportToCSV = exportToCSV;
    exports.entitiesToRowData = entitiesToRowData;
    exports.downloadContent = downloadContent;
    exports.handleFileExportError = handleFileExportError;
    exports.handleNothingToExportError = handleNothingToExportError;
    exports.ImportError = ImportError;
    exports.ImportInvalidFileError = ImportInvalidFileError;
    exports.ImportUnreadableFileError = ImportUnreadableFileError;
    exports.ImportNothingToImportError = ImportNothingToImportError;
    exports.ImportService = ImportService;
    exports.addLayerAndFeaturesToMap = addLayerAndFeaturesToMap;
    exports.handleFileImportSuccess = handleFileImportSuccess;
    exports.handleFileImportError = handleFileImportError;
    exports.handleNothingToImportError = handleNothingToImportError;
    exports.getFileExtension = getFileExtension;
    exports.computeLayerTitleFromFile = computeLayerTitleFromFile;
    exports.ImportExportComponent = ImportExportComponent;
    exports.LayerService = LayerService;
    exports.LAYER = LAYER;
    exports.Layer = Layer;
    exports.TooltipType = TooltipType;
    exports.ImageLayer = ImageLayer;
    exports.TileLayer = TileLayer;
    exports.VectorLayer = VectorLayer;
    exports.VectorTileLayer = VectorTileLayer;
    exports.StyleService = StyleService;
    exports.LayerItemComponent = LayerItemComponent;
    exports.LayerLegendComponent = LayerLegendComponent;
    exports.LayerListComponent = LayerListComponent;
    exports.LayerListBindingDirective = LayerListBindingDirective;
    exports.LayerListControlsEnum = LayerListControlsEnum;
    exports.LayerListService = LayerListService;
    exports.ImageWatcher = ImageWatcher;
    exports.TileWatcher = TileWatcher;
    exports.VectorWatcher = VectorWatcher;
    exports.getLayersLegends = getLayersLegends;
    exports.IgoMap = IgoMap;
    exports.MapViewAction = MapViewAction;
    exports.MapService = MapService;
    exports.stringToLonLat = stringToLonLat;
    exports.viewStatesAreEqual = viewStatesAreEqual;
    exports.formatScale = formatScale;
    exports.getResolutionFromScale = getResolutionFromScale;
    exports.getScaleFromResolution = getScaleFromResolution;
    exports.ctrlKeyDown = ctrlKeyDown;
    exports.MapOfflineDirective = MapOfflineDirective;
    exports.ProjectionService = ProjectionService;
    exports.MapController = MapController;
    exports.MapViewController = MapViewController;
    exports.MapBrowserComponent = MapBrowserComponent;
    exports.ZoomButtonComponent = ZoomButtonComponent;
    exports.GeolocateButtonComponent = GeolocateButtonComponent;
    exports.BaseLayersSwitcherComponent = BaseLayersSwitcherComponent;
    exports.MiniBaseMapComponent = MiniBaseMapComponent;
    exports.RotationButtonComponent = RotationButtonComponent;
    exports.MEASURE_UNIT_AUTO = MEASURE_UNIT_AUTO;
    exports.MeasureType = MeasureType;
    exports.MeasureLengthUnit = MeasureLengthUnit;
    exports.MeasureLengthUnitAbbreviation = MeasureLengthUnitAbbreviation;
    exports.MeasureAreaUnit = MeasureAreaUnit;
    exports.MeasureAreaUnitAbbreviation = MeasureAreaUnitAbbreviation;
    exports.metersToKilometers = metersToKilometers;
    exports.metersToFeet = metersToFeet;
    exports.metersToMiles = metersToMiles;
    exports.squareMetersToSquareKilometers = squareMetersToSquareKilometers;
    exports.squareMetersToSquareMiles = squareMetersToSquareMiles;
    exports.squareMetersToSquareFeet = squareMetersToSquareFeet;
    exports.squareMetersToHectares = squareMetersToHectares;
    exports.squareMetersToAcres = squareMetersToAcres;
    exports.metersToUnit = metersToUnit;
    exports.squareMetersToUnit = squareMetersToUnit;
    exports.formatMeasure = formatMeasure;
    exports.computeBestLengthUnit = computeBestLengthUnit;
    exports.computeBestAreaUnit = computeBestAreaUnit;
    exports.createMeasureInteractionStyle = createMeasureInteractionStyle;
    exports.createMeasureLayerStyle = createMeasureLayerStyle;
    exports.measureOlGeometryLength = measureOlGeometryLength;
    exports.measureOlGeometryArea = measureOlGeometryArea;
    exports.measureOlGeometry = measureOlGeometry;
    exports.updateOlGeometryMidpoints = updateOlGeometryMidpoints;
    exports.clearOlGeometryMidpoints = clearOlGeometryMidpoints;
    exports.updateOlTooltipsAtMidpoints = updateOlTooltipsAtMidpoints;
    exports.getOlTooltipsAtMidpoints = getOlTooltipsAtMidpoints;
    exports.updateOlGeometryCenter = updateOlGeometryCenter;
    exports.updateOlTooltipAtCenter = updateOlTooltipAtCenter;
    exports.getOlTooltipAtCenter = getOlTooltipAtCenter;
    exports.getTooltipsOfOlGeometry = getTooltipsOfOlGeometry;
    exports.createOlTooltipAtPoint = createOlTooltipAtPoint;
    exports.MeasurerComponent = MeasurerComponent;
    exports.MeasureFormatPipe = MeasureFormatPipe;
    exports.MetadataService = MetadataService;
    exports.MetadataButtonComponent = MetadataButtonComponent;
    exports.Overlay = Overlay;
    exports.OverlayDirective = OverlayDirective;
    exports.OverlayService = OverlayService;
    exports.OverlayAction = OverlayAction;
    exports.createOverlayLayer = createOverlayLayer;
    exports.createOverlayMarkerStyle = createOverlayMarkerStyle;
    exports.PrintService = PrintService;
    exports.PrintOutputFormat = PrintOutputFormat;
    exports.PrintPaperFormat = PrintPaperFormat;
    exports.PrintOrientation = PrintOrientation;
    exports.PrintResolution = PrintResolution;
    exports.PrintSaveImageFormat = PrintSaveImageFormat;
    exports.PrintComponent = PrintComponent;
    exports.PrintFormComponent = PrintFormComponent;
    exports.QueryService = QueryService;
    exports.QueryDirective = QueryDirective;
    exports.QueryFormat = QueryFormat;
    exports.QueryHtmlTarget = QueryHtmlTarget;
    exports.layerIsQueryable = layerIsQueryable;
    exports.olLayerIsQueryable = olLayerIsQueryable;
    exports.QuerySearchSource = QuerySearchSource;
    exports.RoutingService = RoutingService;
    exports.RoutingFormat = RoutingFormat;
    exports.SourceRoutingType = SourceRoutingType;
    exports.RoutingSource = RoutingSource;
    exports.OsrmRoutingSource = OsrmRoutingSource;
    exports.RoutingFormComponent = RoutingFormComponent;
    exports.RoutingFormBindingDirective = RoutingFormBindingDirective;
    exports.RoutingFormService = RoutingFormService;
    exports.SEARCH_TYPES = SEARCH_TYPES;
    exports.SearchService = SearchService;
    exports.SearchSourceService = SearchSourceService;
    exports.sourceCanSearch = sourceCanSearch;
    exports.sourceCanReverseSearch = sourceCanReverseSearch;
    exports.featureToSearchResult = featureToSearchResult;
    exports.SearchSource = SearchSource;
    exports.IChercheSearchResultFormatter = IChercheSearchResultFormatter;
    exports.IChercheSearchSource = IChercheSearchSource;
    exports.IChercheReverseSearchSource = IChercheReverseSearchSource;
    exports.ILayerSearchSource = ILayerSearchSource;
    exports.NominatimSearchSource = NominatimSearchSource;
    exports.StoredQueriesSearchSource = StoredQueriesSearchSource;
    exports.StoredQueriesReverseSearchSource = StoredQueriesReverseSearchSource;
    exports.CoordinatesSearchResultFormatter = CoordinatesSearchResultFormatter;
    exports.CoordinatesReverseSearchSource = CoordinatesReverseSearchSource;
    exports.ToastComponent = ToastComponent;
    exports.GoogleLinks = GoogleLinks;
    exports.WktService = WktService;
    exports.j = CatalogBrowserGroupComponent;
    exports.k = CatalogBrowserLayerComponent;
    exports.c = CatalogBrowserComponent;
    exports.m = CatalogLibaryItemComponent;
    exports.l = CatalogLibaryComponent;
    exports.g = CapabilitiesService;
    exports.f = DataSourceService;
    exports.i = DataService;
    exports.h = WFSService;
    exports.n = DownloadButtonComponent;
    exports.o = DownloadService;
    exports.p = FeatureDetailsComponent;
    exports.q = FeatureFormComponent;
    exports.ba = OgcFilterButtonComponent;
    exports.y = OgcFilterFormComponent;
    exports.bb = OgcFilterToggleButtonComponent;
    exports.bd = OgcFilterableFormComponent;
    exports.be = OgcFilterableItemComponent;
    exports.bg = OgcFilterableListBindingDirective;
    exports.bf = OgcFilterableListComponent;
    exports.r = FilterableDataSourcePipe;
    exports.bc = OGCFilterService;
    exports.u = TimeFilterService;
    exports.s = TimeFilterFormComponent;
    exports.t = TimeFilterItemComponent;
    exports.w = TimeFilterListBindingDirective;
    exports.v = TimeFilterListComponent;
    exports.bi = GeometryFormFieldInputComponent;
    exports.bh = GeometryFormFieldComponent;
    exports.bj = ImportExportComponent;
    exports.bm = DropGeoFileDirective;
    exports.bl = ExportService;
    exports.bk = ImportService;
    exports.bo = LayerItemComponent;
    exports.bp = LayerLegendComponent;
    exports.bs = LayerListBindingDirective;
    exports.bq = LayerListComponent;
    exports.br = LayerListService;
    exports.d = LayerService;
    exports.e = StyleService;
    exports.bx = baseLayersSwitcherSlideInOut;
    exports.bw = BaseLayersSwitcherComponent;
    exports.by = MiniBaseMapComponent;
    exports.bu = GeolocateButtonComponent;
    exports.bn = MapBrowserComponent;
    exports.bv = RotationButtonComponent;
    exports.x = MapService;
    exports.bz = MapOfflineDirective;
    exports.bt = ZoomButtonComponent;
    exports.ca = MeasureFormatPipe;
    exports.cd = MeasurerDialogComponent;
    exports.cb = MeasurerItemComponent;
    exports.cc = MeasurerComponent;
    exports.a = MetadataButtonComponent;
    exports.b = MetadataService;
    exports.cf = OverlayDirective;
    exports.cg = OverlayService;
    exports.cj = PrintFormComponent;
    exports.ch = PrintComponent;
    exports.ci = PrintService;
    exports.co = QuerySearchSource;
    exports.ck = QueryDirective;
    exports.cl = QueryService;
    exports.cv = RoutingFormBindingDirective;
    exports.cp = RoutingFormComponent;
    exports.cu = RoutingFormService;
    exports.dy = OsrmRoutingSource;
    exports.cr = RoutingSource;
    exports.cq = RoutingService;
    exports.da = SearchBarComponent;
    exports.db = SearchUrlParamDirective;
    exports.dd = SearchResultsItemComponent;
    exports.dc = SearchResultsComponent;
    exports.cx = SearchSelectorComponent;
    exports.cw = IgoSearchSelectorModule;
    exports.cz = SearchSettingsComponent;
    exports.cy = IgoSearchSettingsModule;
    exports.df = provideSearchSourceService;
    exports.de = searchSourceServiceFactory;
    exports.ct = SearchSourceService;
    exports.cs = SearchService;
    exports.dk = CoordinatesReverseSearchSource;
    exports.dj = CoordinatesSearchResultFormatter;
    exports.di = IChercheReverseSearchSource;
    exports.dg = IChercheSearchResultFormatter;
    exports.dh = IChercheSearchSource;
    exports.dt = ILayerSearchSource;
    exports.dv = NominatimSearchSource;
    exports.cm = SearchSource;
    exports.dx = StoredQueriesReverseSearchSource;
    exports.dw = StoredQueriesSearchSource;
    exports.dl = ToastComponent;
    exports.z = WktService;
    exports.dn = WfsWorkspaceService;
    exports.do = WmsWorkspaceService;
    exports.dp = OgcFilterComponent;
    exports.dq = OgcFilterWidget;
    exports.dr = ogcFilterWidgetFactory;
    exports.ds = provideOgcFilterWidget;
    exports.dm = WorkspaceSelectorDirective;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=igo2-geo.umd.js.map