import { MAC } from 'ol/has';
import stylefunction from 'ol-mapbox-style/stylefunction';
import olSourceOSM from 'ol/source/OSM';
import olSourceXYZ from 'ol/source/XYZ';
import { bbox, and, between, contains, during, equalTo, greaterThan, greaterThanOrEqualTo, intersects, isNull, lessThan, lessThanOrEqualTo, like, notEqualTo, within, or, not } from 'ol/format/filter';
import olFormatWFS from 'ol/format/WFS';
import olFormatGML32 from 'ol/format/GML32';
import olFormatOSMXML from 'ol/format/OSMXML';
import olSourceImageWMS from 'ol/source/ImageWMS';
import olSourceWMTS from 'ol/source/WMTS';
import olTileGridWMTS from 'ol/tilegrid/WMTS';
import { getTopLeft, getWidth } from 'ol/extent.js';
import olSourceCarto from 'ol/source/CartoDB';
import { bbox as bbox$1 } from 'ol/loadingstrategy';
import olSourceTileArcGISRest from 'ol/source/TileArcGISRest';
import { Md5 } from 'ts-md5';
import olSourceVectorTile from 'ol/source/VectorTile';
import olFormatMVT from 'ol/format/MVT';
import olSourceCluster from 'ol/source/Cluster';
import { Cacheable } from 'ngx-cacheable';
import { optionsFromCapabilities } from 'ol/source/WMTS.js';
import olMap from 'ol/Map';
import olView from 'ol/View';
import olGeolocation from 'ol/Geolocation';
import olAttribution from 'ol/control/Attribution';
import olControlScaleLine from 'ol/control/ScaleLine';
import olCircle from 'ol/geom/Circle';
import OlGeometryLayout from 'ol/geom/GeometryLayout';
import olLayerImage from 'ol/layer/Image';
import olLayerTile from 'ol/layer/Tile';
import { asArray } from 'ol/color';
import olLayerVectorTile from 'ol/layer/VectorTile';
import { easeOut } from 'ol/easing';
import proj4 from 'proj4';
import { register } from 'ol/proj/proj4';
import { trigger, state, style, transition, animate } from '@angular/animations';
import olFormatGML2 from 'ol/format/GML2';
import olFormatGML3 from 'ol/format/GML3';
import olFormatEsriJSON from 'ol/format/EsriJSON';
import OlRenderFeature from 'ol/render/Feature';
import olProjection from 'ol/proj/Projection';
import { DomSanitizer } from '@angular/platform-browser';
import { MatDatetimepickerModule, MatNativeDatetimeModule } from '@mat-datetimepicker/core';
import 'ol/geom/GeometryType';
import OlPoint from 'ol/geom/Point';
import OlOverlay from 'ol/Overlay';
import { createEmpty, extend, boundingExtent, buffer, getCenter, getSize, containsExtent, getArea } from 'ol/extent';
import { getLength, getArea as getArea$1 } from 'ol/sphere';
import OlStyle from 'ol/style/Style';
import OlLineString from 'ol/geom/LineString';
import lineIntersect from '@turf/line-intersect';
import { lineString } from '@turf/helpers';
import OlModify from 'ol/interaction/Modify';
import OlTranslate from 'ol/interaction/Translate';
import OlDraw from 'ol/interaction/Draw';
import OlPolygon from 'ol/geom/Polygon';
import OlLinearRing from 'ol/geom/LinearRing';
import OlDragBoxInteraction from 'ol/interaction/DragBox';
import OlVectorSource from 'ol/source/Vector';
import OlVectorLayer from 'ol/layer/Vector';
import { duration } from 'moment';
import { SelectionModel } from '@angular/cdk/collections';
import { NestedTreeControl } from '@angular/cdk/tree';
import { saveAs } from 'file-saver';
import * as jsPDF from 'jspdf';
import * as _html2canvas from 'html2canvas';
import * as JSZip from 'jszip';
import { pointerMove, click } from 'ol/events/condition';
import { defaults, Select, Translate } from 'ol/interaction';
import { unByKey } from 'ol/Observable';
import { AuthInterceptor, AuthService } from '@igo2/auth';
import pointOnFeature from '@turf/point-on-feature';
import { FormsModule, FormControl, NgControl, ReactiveFormsModule, FormBuilder, Validators } from '@angular/forms';
import OlFeature from 'ol/Feature';
import { transform, get, transformExtent, fromLonLat, METERS_PER_UNIT } from 'ol/proj';
import * as olstyle from 'ol/style';
import { Style, RegularShape, Fill, Stroke, Text, Icon, Circle } from 'ol/style';
import { Point, MultiLineString, MultiPolygon, LineString, Polygon } from 'ol/geom';
import OlGeoJSON from 'ol/format/GeoJSON';
import { MatIconModule, MatButtonModule, MatTooltipModule, MatInputModule, MatFormFieldModule, MatListModule, MatSliderModule, MatBadgeModule, MatSelectModule, MatSlideToggleModule, MatDividerModule, MatMenuModule, MatCheckboxModule, MatDialogRef, MAT_DIALOG_DATA, MatDialog, MatButtonToggleModule, MatSlider, DateAdapter, MatTreeNestedDataSource, MatAutocompleteModule, MatTableModule, MatTreeModule, MatOptionModule, MatDatepickerModule, MatNativeDateModule, MAT_DATE_LOCALE, MatTabsModule, MatRadioModule } from '@angular/material';
import { CommonModule } from '@angular/common';
import { EntityStoreStrategy, getEntityId, EntityStore, getEntityTitle, getEntityRevision, getEntityIcon, getEntityProperty, EntityStoreWatcher, IgoListModule, IgoCollapsibleModule, IgoImageModule, IgoPanelModule, IgoMatBadgeIconModule, IgoKeyValueModule, IgoFormModule, FormFieldComponent, EntityTableColumnRenderer, DragAndDropDirective, IgoDrapDropModule, IgoSpinnerModule, IgoConfirmDialogModule, IgoEntityTableModule, getEntityTitleHtml, IgoStopPropagationModule, IgoFlexibleModule, WidgetService, Workspace, ActionStore, WorkspaceSelectorComponent, IgoWidgetModule } from '@igo2/common';
import olWKT from 'ol/format/WKT';
import { BehaviorSubject, combineLatest, Observable, of, ReplaySubject, EMPTY, timer, Subject, fromEvent, forkJoin, zip, throwError } from 'rxjs';
import { HttpClient, HttpParams, HttpHeaders } from '@angular/common/http';
import { map, debounce, debounceTime, skip, distinctUntilChanged, catchError, mergeMap, first, skipWhile, take } from 'rxjs/operators';
import { uuid, ObjectUtils, Watcher, SubjectStatus, downloadContent, strEnum, Clipboard } from '@igo2/utils';
import * as olformat from 'ol/format';
import { GeoJSON, KML, GML, GPX, WMSCapabilities, WMTSCapabilities, WFS, WMSGetFeatureInfo, WKT, TopoJSON, EsriJSON } from 'ol/format';
import { __extends, __read, __values, __decorate, __metadata, __spread, __assign } from 'tslib';
import { Injectable, Component, Input, ChangeDetectionStrategy, Output, EventEmitter, Directive, Self, Pipe, ChangeDetectorRef, NgModule, Injector, Inject, Optional, ApplicationRef, InjectionToken, ViewChildren, Renderer2, ElementRef, ContentChild, HostListener, APP_INITIALIZER, ViewChild, defineInjectable, inject, INJECTOR } from '@angular/core';
import { Platform } from '@ionic/angular';
import { File } from '@ionic-native/file/ngx';
import { FileOpener } from '@ionic-native/file-opener/ngx';
import { IgoLanguageModule, ActivityService, NetworkService, LanguageService, RouteService, MessageService, MediaService, ConfigService, Media } from '@igo2/core';
import { FileOpener as FileOpener$1 } from '@ionic-native/file-opener/ngx/index';
import { File as File$1 } from '@ionic-native/file/ngx/index';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * This method extracts a coordinate tuple from a string.
 * @param {?} str Any string
 * @param {?} mapProjection string Map Projection
 * @param {?=} opts
 * @return {?} object:
 *             lonLat: Coordinate,
 *             message: Message of error,
 *             radius: radius of the confience of coordinate,
 *             conf: confidence of the coordinate}
 */
function stringToLonLat(str, mapProjection, opts) {
    if (opts === void 0) { opts = {}; }
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    /** @type {?} */
    var lonLat;
    /** @type {?} */
    var coordStr;
    /** @type {?} */
    var negativeLon;
    /** @type {?} */
    var degreesLon;
    /** @type {?} */
    var minutesLon;
    /** @type {?} */
    var secondsLon;
    /** @type {?} */
    var directionLon;
    /** @type {?} */
    var decimalLon;
    /** @type {?} */
    var negativeLat;
    /** @type {?} */
    var degreesLat;
    /** @type {?} */
    var minutesLat;
    /** @type {?} */
    var secondsLat;
    /** @type {?} */
    var directionLat;
    /** @type {?} */
    var decimalLat;
    /** @type {?} */
    var zone;
    /** @type {?} */
    var radius;
    /** @type {?} */
    var conf;
    /** @type {?} */
    var lon;
    /** @type {?} */
    var lat;
    /** @type {?} */
    var projectionPattern = '(\\s*;\\s*[\\d]{4,6})';
    /** @type {?} */
    var toProjection = '4326';
    /** @type {?} */
    var projectionStr;
    /** @type {?} */
    var projectionRegex = new RegExp(projectionPattern, 'g');
    /** @type {?} */
    var lonlatCoord = '([-+])?([\\d]{1,3})([,.](\\d+))?';
    /** @type {?} */
    var lonLatPattern = lonlatCoord + "[\\s,]+" + lonlatCoord;
    /** @type {?} */
    var lonLatRegex = new RegExp("^" + lonLatPattern + "$", 'g');
    /** @type {?} */
    var dmsCoord = '([0-9]{1,2})[:|°]?\\s*([0-9]{1,2})?[:|\'|′|’]?\\s*([0-9]{1,2}(?:.[0-9]+){0,1})?\\s*["|″|”]?\\s*';
    /** @type {?} */
    var dmsCoordPattern = dmsCoord + "([N|S|E|W|O]),?\\s*" + dmsCoord + "([N|S|E|W|O])";
    /** @type {?} */
    var dmsRegex = new RegExp("^" + dmsCoordPattern, 'gi');
    /** @type {?} */
    var patternUtm = '(UTM)-?(\\d{1,2})[\\s,]*(\\d+[.,]?\\d+)[\\s,]+(\\d+[.,]?\\d+)';
    /** @type {?} */
    var utmRegex = new RegExp("^" + patternUtm, 'gi');
    /** @type {?} */
    var patternMtm = '(MTM)-?(\\d{1,2})[\\s,]*(\\d+[.,]?\\d+)[\\s,]+(\\d+[.,]?\\d+)';
    /** @type {?} */
    var mtmRegex = new RegExp("^" + patternMtm, 'gi');
    /** @type {?} */
    var ddCoord = '([-+])?(\\d{1,3})[,.](\\d+)';
    /** @type {?} */
    var patternDd = ddCoord + "\\s*[,]?\\s*" + ddCoord;
    /** @type {?} */
    var ddRegex = new RegExp("^" + patternDd, 'g');
    /** @type {?} */
    var dmdCoord = '([-+])?(\\d{1,3})[\\s,.]{1}(\\d{1,2})[\\s,.]{1}(\\d{1,2})[.,]?(\\d{1,5})?';
    /** @type {?} */
    var patternDmd = dmdCoord + "\\s*[,.]?\\s*" + dmdCoord;
    /** @type {?} */
    var dmdRegex = new RegExp("^" + patternDmd, 'g');
    // tslint:disable:max-line-length
    /** @type {?} */
    var patternBELL = 'LAT\\s*[\\s:]*\\s*([-+])?(\\d{1,2})[\\s.,]?(\\d+)?[\\s.,]?\\s*(\\d{1,2}([.,]\\d+)?)?\\s*(N|S|E|W)?\\s*LONG\\s*[\\s:]*\\s*([-+])?(\\d{1,3})[\\s.,]?(\\d+)?[\\s.,]?\\s*(\\d{1,2}([.,]\\d+)?)?\\s*(N|S|E|W)?\\s*UNC\\s*[\\s:]?\\s*(\\d+)\\s*CONF\\s*[\\s:]?\\s*(\\d{1,3})';
    /** @type {?} */
    var bellRegex = new RegExp("^" + patternBELL + "?", 'gi');
    /** @type {?} */
    var mmCoord = '([-+]?\\d+)[,.]?(\\d+)?';
    /** @type {?} */
    var mmPattern = mmCoord + "[\\s,]+" + mmCoord;
    /** @type {?} */
    var mmRegex = new RegExp("^" + mmPattern + "$", 'g');
    /** @type {?} */
    var isXYCoords = false;
    str = str.toLocaleUpperCase().trim();
    // Extract projection
    if (projectionRegex.test(str)) {
        _a = __read(str.split(';').map((/**
         * @param {?} s
         * @return {?}
         */
        function (s) { return s.trim(); })), 2), coordStr = _a[0], projectionStr = _a[1];
    }
    else {
        coordStr = str;
    }
    if (lonLatRegex.test(coordStr)) {
        _b = __read(coordStr.match(lonLatPattern), 9), negativeLon = _b[1], lon = _b[2], decimalLon = _b[4], negativeLat = _b[5], lat = _b[6], decimalLat = _b[8];
        lon = parseFloat((negativeLon ? negativeLon : '') + lon + '.' + decimalLon);
        lat = parseFloat((negativeLat ? negativeLat : '') + lat + '.' + decimalLat);
    }
    else if (dmsRegex.test(coordStr)) {
        _c = __read(coordStr.match(dmsCoordPattern), 9), degreesLon = _c[1], minutesLon = _c[2], secondsLon = _c[3], directionLon = _c[4], degreesLat = _c[5], minutesLat = _c[6], secondsLat = _c[7], directionLat = _c[8];
        if (directionLon === 'S' || directionLon === 'N') {
            degreesLon = [degreesLat, (degreesLat = degreesLon)][0];
            minutesLon = [minutesLat, (minutesLat = minutesLon)][0];
            secondsLon = [secondsLat, (secondsLat = secondsLon)][0];
            directionLon = [directionLat, (directionLat = directionLon)][0];
        }
        lon = convertDMSToDD(parseFloat(degreesLon), parseFloat(minutesLon), parseFloat(secondsLon), directionLon);
        lat = convertDMSToDD(parseFloat(degreesLat), parseFloat(minutesLat), parseFloat(secondsLat), directionLat);
    }
    else if (utmRegex.test(coordStr)) {
        isXYCoords = true;
        _d = __read(coordStr.match(patternUtm), 5), zone = _d[2], lon = _d[3], lat = _d[4];
        /** @type {?} */
        var epsgUtm = Number(zone) < 10 ? "EPSG:3260" + zone : "EPSG:326" + zone;
        _e = __read(transform([parseFloat(lon), parseFloat(lat)], epsgUtm, 'EPSG:4326'), 2), lon = _e[0], lat = _e[1];
    }
    else if (mtmRegex.test(coordStr)) {
        isXYCoords = true;
        _f = __read(coordStr.match(patternMtm), 5), zone = _f[2], lon = _f[3], lat = _f[4];
        /** @type {?} */
        var epsgMtm = Number(zone) < 10 ? "EPSG:3218" + zone : "EPSG:321" + (80 + Number(zone));
        _g = __read(transform([parseFloat(lon), parseFloat(lat)], epsgMtm, 'EPSG:4326'), 2), lon = _g[0], lat = _g[1];
    }
    else if (dmdRegex.test(coordStr)) {
        _h = __read(coordStr.match(patternDmd), 11), negativeLon = _h[1], degreesLon = _h[2], minutesLon = _h[3], secondsLon = _h[4], decimalLon = _h[5], negativeLat = _h[6], degreesLat = _h[7], minutesLat = _h[8], secondsLat = _h[9], decimalLat = _h[10];
        lon = convertDMSToDD(parseFloat((negativeLon ? negativeLon : '') + degreesLon), parseFloat(minutesLon), parseFloat(secondsLon), directionLon);
        lat = convertDMSToDD(parseFloat((negativeLat ? negativeLat : '') + degreesLat), parseFloat(minutesLat), parseFloat(secondsLat), directionLat);
    }
    else if (ddRegex.test(coordStr)) {
        _j = __read(coordStr.match(patternDd), 7), negativeLon = _j[1], degreesLon = _j[2], decimalLon = _j[3], negativeLat = _j[4], degreesLat = _j[5], decimalLat = _j[6];
        lon = convertDMSToDD(parseFloat((negativeLon ? negativeLon : '') + degreesLon), parseFloat(minutesLon), parseFloat(secondsLon), directionLon);
        lat = convertDMSToDD(parseFloat((negativeLat ? negativeLat : '') + degreesLat), parseFloat(minutesLat), parseFloat(secondsLat), directionLat);
    }
    else if (bellRegex.test(coordStr)) {
        _k = __read(coordStr.match(patternBELL), 15), negativeLat = _k[1], degreesLat = _k[2], minutesLat = _k[3], secondsLat = _k[4], directionLat = _k[6], negativeLon = _k[7], degreesLon = _k[8], minutesLon = _k[9], secondsLon = _k[10], directionLon = _k[12], radius = _k[13], conf = _k[14];
        // Set default value for North America
        if (!directionLon) {
            directionLon = 'W';
        }
        // Check if real minutes or decimals
        if (minutesLon && minutesLon.length > 2) {
            lon = parseFloat((negativeLon ? negativeLon : '') + degreesLon + '.' + minutesLon);
        }
        else {
            lon = convertDMSToDD(parseFloat(degreesLon), parseFloat(minutesLon), parseFloat(secondsLon), directionLon);
        }
        if (minutesLat && minutesLat.length > 2) {
            lat = parseFloat((negativeLat ? negativeLat : '') + degreesLat + '.' + minutesLat);
        }
        else {
            lat = convertDMSToDD(parseFloat(degreesLat), parseFloat(minutesLat), parseFloat(secondsLat), directionLat);
        }
    }
    else if (mmRegex.test(coordStr)) {
        isXYCoords = true;
        _l = __read(coordStr.match(mmPattern), 5), lon = _l[1], decimalLon = _l[2], lat = _l[3], decimalLat = _l[4];
        if (decimalLon) {
            lon = parseFloat(lon + '.' + decimalLon);
        }
        if (decimalLat) {
            lat = parseFloat(lat + '.' + decimalLat);
        }
    }
    else {
        return {
            lonLat: undefined,
            message: '',
            radius: undefined,
            conf: undefined
        };
    }
    if (opts.forceNA && !isXYCoords) {
        // Set a negative coordinate for North America zone
        if (lon > 0 && lat > 0) {
            if (lon > lat) {
                lon = -lon;
            }
            else {
                lat = -lat;
            }
        }
        // Reverse coordinate to respect lonLat convention
        if (lon > lat) {
            lon = [lat, (lat = lon)][0];
        }
    }
    lonLat = (/** @type {?} */ ([Number(lon), Number(lat)]));
    // Reproject the coordinate if projection parameter have been set and coord is not 4326
    if ((projectionStr !== undefined && projectionStr !== toProjection) ||
        (lonLat[0] > 180 || lonLat[0] < -180) ||
        (lonLat[1] > 90 || lonLat[1] < -90)) {
        /** @type {?} */
        var source = projectionStr ? 'EPSG:' + projectionStr : mapProjection;
        /** @type {?} */
        var dest = 'EPSG:' + toProjection;
        try {
            lonLat = transform(lonLat, source, dest);
        }
        catch (e) {
            return {
                lonLat: undefined,
                message: 'Projection ' + source + ' not supported',
                radius: undefined,
                conf: undefined
            };
        }
    }
    return {
        lonLat: lonLat,
        message: '',
        radius: radius ? parseInt(radius, 10) : undefined,
        conf: conf ? parseInt(conf, 10) : undefined
    };
}
/**
 * Convert degrees minutes seconds to dd
 * @param {?} degrees Degrees
 * @param {?} minutes Minutes
 * @param {?} seconds Seconds
 * @param {?} direction Direction
 * @return {?}
 */
function convertDMSToDD(degrees, minutes, seconds, direction) {
    minutes = minutes || 0;
    seconds = seconds || 0;
    /** @type {?} */
    var dd = degrees + minutes / 60 + seconds / 3600;
    if (direction === 'S' || direction === 'W') {
        dd = -dd;
    } // Don't do anything for N or E
    return dd;
}
/**
 * Return true of two view states are equal.
 * @param {?} state1 View state
 * @param {?} state2 View state
 * @return {?} True if the view states are equal
 */
function viewStatesAreEqual(state1, state2) {
    if (state1 === undefined || state2 === undefined) {
        return false;
    }
    /** @type {?} */
    var tolerance = 1 / 10000;
    return (state1.zoom === state2.zoom &&
        Math.trunc(state1.center[0] / tolerance) ===
            Math.trunc(state2.center[0] / tolerance) &&
        Math.trunc(state1.center[1] / tolerance) ===
            Math.trunc(state2.center[1] / tolerance));
}
/**
 * Format the scale to a human readable text
 * @param {?} scale
 * @return {?} Human readable scale text
 */
function formatScale(scale) {
    scale = Math.round(scale);
    if (scale < 10000) {
        return scale + '';
    }
    scale = Math.round(scale / 1000);
    if (scale < 1000) {
        return scale + 'K';
    }
    scale = Math.round(scale / 1000);
    return scale + 'M';
}
/**
 * Return the resolution from a scale denom
 * @param {?} scale Scale denom
 * @param {?=} dpi DPI
 * @return {?} Resolution
 */
function getResolutionFromScale(scale, dpi) {
    if (dpi === void 0) { dpi = 96; }
    /** @type {?} */
    var inchesPerMeter = 39.3701;
    return scale / (inchesPerMeter * dpi);
}
/**
 * Return the resolution from a scale denom
 * @param {?} resolution
 * @param {?=} unit
 * @param {?=} dpi
 * @return {?} Resolution
 */
function getScaleFromResolution(resolution, unit, dpi) {
    if (unit === void 0) { unit = 'm'; }
    if (dpi === void 0) { dpi = 96; }
    /** @type {?} */
    var inchesPerMeter = 39.3701;
    return resolution * METERS_PER_UNIT[unit] * inchesPerMeter * dpi;
}
/**
 * Returns true if the CTRL key is pushed during an Ol MapBrowserPointerEvent
 * @param {?} event OL MapBrowserPointerEvent
 * @return {?} Whether the CTRL key is pushed
 */
function ctrlKeyDown(event) {
    /** @type {?} */
    var originalEvent = event.originalEvent;
    return (!originalEvent.altKey &&
        (MAC ? originalEvent.metaKey : originalEvent.ctrlKey) &&
        !originalEvent.shiftKey);
}
/**
 * @param {?} coord
 * @param {?=} decimal
 * @return {?}
 */
function roundCoordTo(coord, decimal) {
    if (decimal === void 0) { decimal = 3; }
    return [coord[0].toFixed(decimal), coord[1].toFixed(decimal)];
}
/**
 * Returns an array of converted coordinates.
 * Conversion is done for every configured projections
 * and for the current UTM zone and MTM zone.
 * @param {?} lonLat [number, number] array of the coordinate to transform.
 * @param {?} projections  Projection[] Array of destination projection.
 * @return {?} Returns an array of converted coordinates.
 */
function lonLatConversion(lonLat, projections) {
    /** @type {?} */
    var rawCoord3857 = transform(lonLat, 'EPSG:4326', 'EPSG:3857');
    /** @type {?} */
    var convertedLonLat = [
        {
            code: 'EPSG:3857',
            alias: 'Web mercator',
            coord: rawCoord3857,
            igo2CoordFormat: roundCoordTo(rawCoord3857).join(', ') + " ; 3857"
        }
    ];
    // detect the current utm zone.
    /** @type {?} */
    var utmZone = utmZoneFromLonLat(lonLat);
    /** @type {?} */
    var epsgUtm = utmZone < 10 ? "EPSG:3260" + utmZone : "EPSG:326" + utmZone;
    /** @type {?} */
    var utmName = "UTM-" + utmZone;
    /** @type {?} */
    var rawCoordUtm = transform(lonLat, 'EPSG:4326', epsgUtm);
    convertedLonLat.push({
        code: epsgUtm,
        alias: 'UTM',
        coord: rawCoordUtm,
        igo2CoordFormat: utmName + " " + roundCoordTo(rawCoordUtm).join(', ')
    });
    // detect the current mtm zone.
    /** @type {?} */
    var mtmZone = mtmZoneFromLonLat(lonLat);
    if (mtmZone) {
        /** @type {?} */
        var epsgMtm = mtmZone < 10 ? "EPSG:3218" + mtmZone : "EPSG:321" + (80 + mtmZone);
        /** @type {?} */
        var mtmName = "MTM-" + mtmZone;
        /** @type {?} */
        var rawCoordMtm = transform(lonLat, 'EPSG:4326', epsgMtm);
        convertedLonLat.push({
            code: epsgMtm,
            alias: 'MTM',
            coord: rawCoordMtm,
            igo2CoordFormat: mtmName + " " + roundCoordTo(rawCoordMtm).join(', ')
        });
    }
    projections.forEach((/**
     * @param {?} projection
     * @return {?}
     */
    function (projection) {
        /** @type {?} */
        var rawCoord = transform(lonLat, 'EPSG:4326', projection.code);
        /** @type {?} */
        var numericEpsgCode = projection.code.split(':')[1];
        convertedLonLat.push({
            code: projection.code,
            alias: projection.alias || projection.code,
            coord: rawCoord,
            igo2CoordFormat: roundCoordTo(rawCoord).join(', ') + " ; " + numericEpsgCode
        });
    }));
    return convertedLonLat;
}
/**
 * Detect the current utm zone of the lon/lat coordinate.
 * @param {?} lonLat [number, number] array of the coordinate to detect the UTM zone.
 * @return {?} number The UTM zone.
 */
function utmZoneFromLonLat(lonLat) {
    return Math.ceil((lonLat[0] + 180) / 6);
}
/**
 * Detect the current mtm zone of the lon/lat coordinate.
 * @param {?} lonLat [number, number] array of the coordinate to detect the MTM zone.
 * @return {?} number The MTM zone. Undefined if outside of the mtm application zone.
 */
function mtmZoneFromLonLat(lonLat) {
    /** @type {?} */
    var long = lonLat[0];
    /** @type {?} */
    var mtmZone;
    if (long < -51 && long > -54) {
        mtmZone = 1;
    }
    if (long < -54 && long > -57) {
        mtmZone = 2;
    }
    if (long < -57 && long > -60) {
        mtmZone = 3;
    }
    if (long < -60 && long > -63) {
        mtmZone = 4;
    }
    if (long < -63 && long > -66) {
        mtmZone = 5;
    }
    if (long < -66 && long > -69) {
        mtmZone = 6;
    }
    if (long < -69 && long > -72) {
        mtmZone = 7;
    }
    if (long < -72 && long > -75) {
        mtmZone = 8;
    }
    if (long < -75 && long > -78) {
        mtmZone = 9;
    }
    if (long < -78 && long > -81) {
        mtmZone = 10;
    }
    return mtmZone;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
var  /**
 * @abstract
 */
Layer = /** @class */ (function () {
    function Layer(options, authInterceptor) {
        this.options = options;
        this.authInterceptor = authInterceptor;
        this.legendCollapsed = true;
        this.firstLoadComponent = true;
        this.isInResolutionsRange$ = new BehaviorSubject(false);
        this.visible$ = new BehaviorSubject(undefined);
        this.displayed$ = combineLatest([
            this.isInResolutionsRange$,
            this.visible$
        ]).pipe(map((/**
         * @param {?} bunch
         * @return {?}
         */
        function (bunch) { return bunch[0] && bunch[1]; })));
        this.dataSource = options.source;
        this.ol = this.createOlLayer();
        if (options.zIndex !== undefined) {
            this.zIndex = options.zIndex;
        }
        if (options.baseLayer && options.visible === undefined) {
            options.visible = false;
        }
        this.maxResolution = options.maxResolution || getResolutionFromScale(Number(options.maxScaleDenom));
        this.minResolution = options.minResolution || getResolutionFromScale(Number(options.minScaleDenom));
        this.visible = options.visible === undefined ? true : options.visible;
        this.opacity = options.opacity === undefined ? 1 : options.opacity;
        if (options.legendOptions &&
            (options.legendOptions.url || options.legendOptions.html)) {
            this.legend = this.dataSource.setLegend(options.legendOptions);
        }
        this.legendCollapsed = options.legendOptions
            ? options.legendOptions.collapsed
                ? options.legendOptions.collapsed
                : true
            : true;
        this.ol.set('_layer', this, true);
    }
    Object.defineProperty(Layer.prototype, "id", {
        get: /**
         * @return {?}
         */
        function () {
            return this.options.id || this.dataSource.id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Layer.prototype, "alias", {
        get: /**
         * @return {?}
         */
        function () {
            return this.options.alias;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Layer.prototype, "title", {
        get: /**
         * @return {?}
         */
        function () {
            return this.options.title;
        },
        set: /**
         * @param {?} title
         * @return {?}
         */
        function (title) {
            this.options.title = title;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Layer.prototype, "zIndex", {
        get: /**
         * @return {?}
         */
        function () {
            return this.ol.getZIndex();
        },
        set: /**
         * @param {?} zIndex
         * @return {?}
         */
        function (zIndex) {
            this.ol.setZIndex(zIndex);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Layer.prototype, "baseLayer", {
        get: /**
         * @return {?}
         */
        function () {
            return this.options.baseLayer;
        },
        set: /**
         * @param {?} baseLayer
         * @return {?}
         */
        function (baseLayer) {
            this.options.baseLayer = baseLayer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Layer.prototype, "opacity", {
        get: /**
         * @return {?}
         */
        function () {
            return this.ol.get('opacity');
        },
        set: /**
         * @param {?} opacity
         * @return {?}
         */
        function (opacity) {
            this.ol.setOpacity(opacity);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Layer.prototype, "isInResolutionsRange", {
        get: /**
         * @return {?}
         */
        function () {
            return this.isInResolutionsRange$.value;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.isInResolutionsRange$.next(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Layer.prototype, "maxResolution", {
        get: /**
         * @return {?}
         */
        function () {
            return this.ol.getMaxResolution();
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.ol.setMaxResolution(value || Infinity);
            this.updateInResolutionsRange();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Layer.prototype, "minResolution", {
        get: /**
         * @return {?}
         */
        function () {
            return this.ol.getMinResolution();
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.ol.setMinResolution(value || 0);
            this.updateInResolutionsRange();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Layer.prototype, "visible", {
        get: /**
         * @return {?}
         */
        function () {
            return this.visible$.value;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.ol.setVisible(value);
            this.visible$.next(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Layer.prototype, "displayed", {
        get: /**
         * @return {?}
         */
        function () {
            return this.visible && this.isInResolutionsRange;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Layer.prototype, "showInLayerList", {
        get: /**
         * @return {?}
         */
        function () {
            return this.options.showInLayerList !== false;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} igoMap
     * @return {?}
     */
    Layer.prototype.setMap = /**
     * @param {?} igoMap
     * @return {?}
     */
    function (igoMap) {
        this.map = igoMap;
        this.unobserveResolution();
        if (igoMap !== undefined) {
            this.observeResolution();
        }
    };
    /**
     * @private
     * @return {?}
     */
    Layer.prototype.observeResolution = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this.resolution$$ = this.map.viewController.resolution$.subscribe((/**
         * @return {?}
         */
        function () {
            return _this.updateInResolutionsRange();
        }));
    };
    /**
     * @private
     * @return {?}
     */
    Layer.prototype.unobserveResolution = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.resolution$$ !== undefined) {
            this.resolution$$.unsubscribe();
            this.resolution$$ = undefined;
        }
    };
    /**
     * @private
     * @return {?}
     */
    Layer.prototype.updateInResolutionsRange = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.map !== undefined) {
            /** @type {?} */
            var resolution = this.map.viewController.getResolution();
            /** @type {?} */
            var minResolution = this.minResolution;
            /** @type {?} */
            var maxResolution = this.maxResolution === undefined ? Infinity : this.maxResolution;
            this.isInResolutionsRange = resolution >= minResolution && resolution <= maxResolution;
        }
        else {
            this.isInResolutionsRange = false;
        }
    };
    return Layer;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var MetadataService = /** @class */ (function () {
    function MetadataService() {
    }
    /**
     * @param {?} metadata
     * @return {?}
     */
    MetadataService.prototype.open = /**
     * @param {?} metadata
     * @return {?}
     */
    function (metadata) {
        if (metadata.extern) {
            window.open(metadata.url, '_blank');
        }
    };
    MetadataService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    MetadataService.ctorParameters = function () { return []; };
    /** @nocollapse */ MetadataService.ngInjectableDef = defineInjectable({ factory: function MetadataService_Factory() { return new MetadataService(); }, token: MetadataService, providedIn: "root" });
    return MetadataService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var MetadataButtonComponent = /** @class */ (function () {
    function MetadataButtonComponent(metadataService) {
        this.metadataService = metadataService;
        this._color = 'primary';
    }
    Object.defineProperty(MetadataButtonComponent.prototype, "layer", {
        get: /**
         * @return {?}
         */
        function () {
            return this._layer;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._layer = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MetadataButtonComponent.prototype, "color", {
        get: /**
         * @return {?}
         */
        function () {
            return this._color;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._color = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} metadata
     * @return {?}
     */
    MetadataButtonComponent.prototype.openMetadata = /**
     * @param {?} metadata
     * @return {?}
     */
    function (metadata) {
        this.metadataService.open(metadata);
    };
    Object.defineProperty(MetadataButtonComponent.prototype, "options", {
        get: /**
         * @return {?}
         */
        function () {
            if (!this.layer) {
                return;
            }
            return this.layer.options;
        },
        enumerable: true,
        configurable: true
    });
    MetadataButtonComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igo-metadata-button',
                    template: "<button\r\n  *ngIf=\"options && options.metadata && options.metadata.url\"\r\n  mat-icon-button\r\n  tooltip-position=\"below\"\r\n  matTooltipShowDelay=\"500\"\r\n  [matTooltip]=\"'igo.geo.metadata.show' | translate\"\r\n  [color]=\"color\"\r\n  (click)=\"openMetadata(options.metadata)\">\r\n  <mat-icon svgIcon=\"information-outline\"></mat-icon>\r\n</button>\r\n",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: [""]
                }] }
    ];
    /** @nocollapse */
    MetadataButtonComponent.ctorParameters = function () { return [
        { type: MetadataService }
    ]; };
    MetadataButtonComponent.propDecorators = {
        layer: [{ type: Input }],
        color: [{ type: Input }]
    };
    return MetadataButtonComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgoMetadataModule = /** @class */ (function () {
    function IgoMetadataModule() {
    }
    /**
     * @return {?}
     */
    IgoMetadataModule.forRoot = /**
     * @return {?}
     */
    function () {
        return {
            ngModule: IgoMetadataModule,
            providers: []
        };
    };
    IgoMetadataModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        MatIconModule,
                        MatButtonModule,
                        MatTooltipModule,
                        IgoLanguageModule
                    ],
                    exports: [MetadataButtonComponent],
                    declarations: [MetadataButtonComponent]
                },] }
    ];
    return IgoMetadataModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
var  /**
 * @abstract
 */
DataService = /** @class */ (function () {
    function DataService() {
    }
    return DataService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Generate a id from it's datasource options.
 * @param {?} options Data source options
 * @return {?} A id
 */
function generateIdFromSourceOptions(options) {
    /** @type {?} */
    var generators = {
        wms: generateWMSIdFromSourceOptions,
        wmts: generateWMTSIdFromSourceOptions,
        xyz: generateXYZIdFromSourceOptions,
        feature: generateFeatureIdFromSourceOptions,
        osm: (/**
         * @param {?} _options
         * @return {?}
         */
        function (_options) { return 'OSM'; })
    };
    /** @type {?} */
    var generator = generators[options.type] || generateId;
    return generator(options);
}
/**
 * Generate a id from WMS data source options
 * @param {?} options WMS data source options
 * @return {?} A md5 hash of the the url and layers
 */
function generateWMSIdFromSourceOptions(options) {
    /** @type {?} */
    var layers = options.params.LAYERS;
    /** @type {?} */
    var url = options.url.charAt(0) === '/' ? window.location.origin + options.url : options.url;
    /** @type {?} */
    var chain = 'wms' + url + layers;
    return (/** @type {?} */ (Md5.hashStr(chain)));
}
/**
 * Generate a id from WMTS data source options
 * @param {?} options WMTS data source options
 * @return {?} A md5 hash of the the url and layer
 */
function generateWMTSIdFromSourceOptions(options) {
    /** @type {?} */
    var layer = options.layer;
    /** @type {?} */
    var chain = 'wmts' + options.url + layer;
    return (/** @type {?} */ (Md5.hashStr(chain)));
}
/**
 * Generate a id from XYZ data source options
 * @param {?} options XYZ data source options
 * @return {?} A md5 hash of the the url and layer
 */
function generateXYZIdFromSourceOptions(options) {
    /** @type {?} */
    var chain = 'xyz' + options.url;
    return (/** @type {?} */ (Md5.hashStr(chain)));
}
/**
 * Generate a id from feature data source options
 * @param {?} options XYZ data source options
 * @return {?} A md5 hash of the the url and layer
 */
function generateFeatureIdFromSourceOptions(options) {
    if (!options.url) {
        return generateId(options);
    }
    /** @type {?} */
    var chain = 'feature' + options.url;
    return (/** @type {?} */ (Md5.hashStr(chain)));
}
/**
 * Generate a unique id
 * @param {?} options
 * @return {?} A uuid
 */
function generateId(options) {
    return uuid();
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
var  /**
 * @abstract
 */
DataSource = /** @class */ (function () {
    function DataSource(options, dataService) {
        if (options === void 0) { options = {}; }
        this.options = options;
        this.dataService = dataService;
        this.options = options;
        this.id = this.options.id || this.generateId();
        this.ol = this.createOlSource();
    }
    /**
     * @protected
     * @return {?}
     */
    DataSource.prototype.generateId = /**
     * @protected
     * @return {?}
     */
    function () {
        return generateIdFromSourceOptions(this.options);
    };
    /**
     * @param {?=} style
     * @param {?=} scale
     * @return {?}
     */
    DataSource.prototype.getLegend = /**
     * @param {?=} style
     * @param {?=} scale
     * @return {?}
     */
    function (style$$1, scale) {
        return this.legend ? this.legend : [];
    };
    /**
     * @param {?} options
     * @return {?}
     */
    DataSource.prototype.setLegend = /**
     * @param {?} options
     * @return {?}
     */
    function (options) {
        if (options.url) {
            this.legend = [{ url: options.url }];
        }
        else if (options.html) {
            this.legend = [{ html: options.html }];
        }
        else {
            this.legend = [];
        }
        return this.legend;
    };
    return DataSource;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FeatureDataSource = /** @class */ (function (_super) {
    __extends(FeatureDataSource, _super);
    function FeatureDataSource() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @protected
     * @return {?}
     */
    FeatureDataSource.prototype.createOlSource = /**
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var sourceOptions = {
            format: this.getSourceFormatFromOptions(this.options)
        };
        return new OlVectorSource(Object.assign(sourceOptions, this.options));
    };
    /**
     * @protected
     * @param {?} options
     * @return {?}
     */
    FeatureDataSource.prototype.getSourceFormatFromOptions = /**
     * @protected
     * @param {?} options
     * @return {?}
     */
    function (options) {
        if (options.format) {
            return options.format;
        }
        /** @type {?} */
        var olFormatCls;
        /** @type {?} */
        var formatType = options.formatType;
        if (!formatType) {
            olFormatCls = GeoJSON;
        }
        else {
            olFormatCls = olformat[formatType];
            if (olFormatCls === undefined) {
                throw new Error('Invalid vector source format ${formatType}.');
            }
        }
        /** @type {?} */
        var formatOptions = options.formatOptions;
        /** @type {?} */
        var format;
        if (formatOptions) {
            format = new olFormatCls(formatOptions);
        }
        else {
            format = new olFormatCls();
        }
        return format;
    };
    /**
     * @return {?}
     */
    FeatureDataSource.prototype.onUnwatch = /**
     * @return {?}
     */
    function () { };
    Object.defineProperty(FeatureDataSource.prototype, "queryTitle", {
        get: /**
         * @return {?}
         */
        function () {
            return ((/** @type {?} */ (this.options))).queryTitle
                ? ((/** @type {?} */ (this.options))).queryTitle
                : 'title';
        },
        enumerable: true,
        configurable: true
    });
    return FeatureDataSource;
}(DataSource));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var OSMDataSource = /** @class */ (function (_super) {
    __extends(OSMDataSource, _super);
    function OSMDataSource() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @protected
     * @return {?}
     */
    OSMDataSource.prototype.createOlSource = /**
     * @protected
     * @return {?}
     */
    function () {
        this.options.url = 'https://tile.openstreetmap.org/{z}/{x}/{y}.png';
        return new olSourceOSM(this.options);
    };
    /**
     * @return {?}
     */
    OSMDataSource.prototype.onUnwatch = /**
     * @return {?}
     */
    function () { };
    return OSMDataSource;
}(DataSource));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var XYZDataSource = /** @class */ (function (_super) {
    __extends(XYZDataSource, _super);
    function XYZDataSource() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @protected
     * @return {?}
     */
    XYZDataSource.prototype.createOlSource = /**
     * @protected
     * @return {?}
     */
    function () {
        return new olSourceXYZ(this.options);
    };
    /**
     * @return {?}
     */
    XYZDataSource.prototype.onUnwatch = /**
     * @return {?}
     */
    function () { };
    return XYZDataSource;
}(DataSource));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var OgcFilterWriter = /** @class */ (function () {
    function OgcFilterWriter() {
        this.filterSequence = [];
        this.operators = {
            PropertyIsEqualTo: { spatial: false, fieldRestrict: [] },
            PropertyIsNotEqualTo: { spatial: false, fieldRestrict: [] },
            PropertyIsLike: { spatial: false, fieldRestrict: ['string'] },
            PropertyIsGreaterThan: { spatial: false, fieldRestrict: ['number'] },
            PropertyIsGreaterThanOrEqualTo: { spatial: false, fieldRestrict: ['number'] },
            PropertyIsLessThan: { spatial: false, fieldRestrict: ['number'] },
            PropertyIsLessThanOrEqualTo: { spatial: false, fieldRestrict: ['number'] },
            PropertyIsBetween: { spatial: false, fieldRestrict: ['number'] },
            During: { spatial: false, fieldRestrict: [] },
            PropertyIsNull: { spatial: false, fieldRestrict: [] },
            Intersects: { spatial: true, fieldRestrict: [] },
            Within: { spatial: true, fieldRestrict: [] },
            Contains: { spatial: true, fieldRestrict: [] }
        };
    }
    /**
     * @param {?} ogcFiltersOptions
     * @param {?} fieldNameGeometry
     * @param {?=} srcType
     * @return {?}
     */
    OgcFilterWriter.prototype.defineOgcFiltersDefaultOptions = /**
     * @param {?} ogcFiltersOptions
     * @param {?} fieldNameGeometry
     * @param {?=} srcType
     * @return {?}
     */
    function (ogcFiltersOptions, fieldNameGeometry, srcType) {
        /** @type {?} */
        var ogcFiltersDefaultValue = true;
        if (srcType && srcType === 'wms') {
            ogcFiltersDefaultValue = false;
        }
        ogcFiltersOptions = ogcFiltersOptions || {};
        ogcFiltersOptions.enabled = ogcFiltersOptions.enabled === undefined ? ogcFiltersDefaultValue : ogcFiltersOptions.enabled;
        ogcFiltersOptions.editable = ogcFiltersOptions.editable === undefined ? ogcFiltersDefaultValue : ogcFiltersOptions.editable;
        ogcFiltersOptions.geometryName = fieldNameGeometry;
        ogcFiltersOptions.advancedOgcFilters = true;
        if (ogcFiltersOptions.enabled && ogcFiltersOptions.pushButtons) {
            ogcFiltersOptions.advancedOgcFilters = false;
        }
        return ogcFiltersOptions;
    };
    /**
     * @param {?=} filters
     * @param {?=} extent
     * @param {?=} proj
     * @param {?=} fieldNameGeometry
     * @return {?}
     */
    OgcFilterWriter.prototype.buildFilter = /**
     * @param {?=} filters
     * @param {?=} extent
     * @param {?=} proj
     * @param {?=} fieldNameGeometry
     * @return {?}
     */
    function (filters, extent, proj, fieldNameGeometry) {
        /** @type {?} */
        var ourBboxFilter;
        /** @type {?} */
        var enableBbox;
        if (/intersects|contains|within/gi.test(JSON.stringify(filters))) {
            enableBbox = false;
        }
        else {
            enableBbox = true;
        }
        if (filters) {
            fieldNameGeometry =
                ((/** @type {?} */ (filters))).geometryName !== undefined
                    ? ((/** @type {?} */ (filters))).geometryName
                    : fieldNameGeometry;
        }
        if (extent && filters) {
            ourBboxFilter = bbox(fieldNameGeometry, extent, proj.getCode());
        }
        /** @type {?} */
        var filterAssembly;
        if (filters) {
            filters = this.checkIgoFiltersProperties(filters, fieldNameGeometry, proj);
            if (extent && enableBbox) {
                filterAssembly = and(ourBboxFilter, this.bundleFilter(filters));
            }
            else {
                filterAssembly = this.bundleFilter(filters);
            }
        }
        else {
            return 'bbox=' + extent.join(',') + ',' + proj.getCode();
        }
        /** @type {?} */
        var wfsOptions = {
            srsName: '',
            featureNS: '',
            featurePrefix: '',
            featureTypes: ['featureTypes'],
            filter: filterAssembly,
            outputFormat: '',
            geometryName: fieldNameGeometry
        };
        /** @type {?} */
        var query = new olFormatWFS().writeGetFeature(wfsOptions);
        /** @type {?} */
        var str = new XMLSerializer().serializeToString(query);
        /** @type {?} */
        var regexp1 = /typenames *=|typename *=\"featureTypes\" *>/gi;
        /** @type {?} */
        var regexp2 = /<\/Query><\/GetFeature>/gi;
        return 'filter=' + str.split(regexp1)[1].split(regexp2)[0];
    };
    /**
     * @private
     * @param {?} filterObject
     * @return {?}
     */
    OgcFilterWriter.prototype.bundleFilter = /**
     * @private
     * @param {?} filterObject
     * @return {?}
     */
    function (filterObject) {
        var _this = this;
        if (filterObject instanceof Array) {
            /** @type {?} */
            var logicalArray_1 = [];
            filterObject.forEach((/**
             * @param {?} element
             * @return {?}
             */
            function (element) {
                logicalArray_1.push(_this.bundleFilter(element));
            }));
            return logicalArray_1;
        }
        else {
            if (filterObject.hasOwnProperty('logical')) {
                return this.createFilter({
                    operator: filterObject.logical,
                    logicalArray: this.bundleFilter(filterObject.filters)
                });
            }
            else if (filterObject.hasOwnProperty('operator')) {
                return this.createFilter((/** @type {?} */ (filterObject)));
            }
        }
    };
    /**
     * @private
     * @param {?} filterOptions
     * @return {?}
     */
    OgcFilterWriter.prototype.createFilter = /**
     * @private
     * @param {?} filterOptions
     * @return {?}
     */
    function (filterOptions) {
        /** @type {?} */
        var operator = filterOptions.operator;
        /** @type {?} */
        var logicalArray = filterOptions.logicalArray;
        /** @type {?} */
        var wfsPropertyName = filterOptions.propertyName;
        /** @type {?} */
        var wfsPattern = filterOptions.pattern;
        /** @type {?} */
        var wfsMatchCase = filterOptions.matchCase
            ? filterOptions.matchCase
            : true;
        /** @type {?} */
        var wfsWildCard = filterOptions.wildCard ? filterOptions.wildCard : '*';
        /** @type {?} */
        var wfsSingleChar = filterOptions.singleChar
            ? filterOptions.singleChar
            : '.';
        /** @type {?} */
        var wfsEscapeChar = filterOptions.escapeChar
            ? filterOptions.escapeChar
            : '!';
        /** @type {?} */
        var wfsLowerBoundary = filterOptions.lowerBoundary;
        /** @type {?} */
        var wfsUpperBoundary = filterOptions.upperBoundary;
        /** @type {?} */
        var wfsGeometryName = filterOptions.geometryName;
        /** @type {?} */
        var wfsExtent = filterOptions.extent;
        /** @type {?} */
        var wfsWktGeometry = filterOptions.wkt_geometry;
        /** @type {?} */
        var wfsSrsName = filterOptions.srsName
            ? filterOptions.srsName
            : 'EPSG:3857';
        /** @type {?} */
        var wfsBegin = filterOptions.begin;
        /** @type {?} */
        var wfsEnd = filterOptions.end;
        /** @type {?} */
        var wfsExpression = filterOptions.expression;
        /** @type {?} */
        var geometry;
        if (wfsWktGeometry) {
            /** @type {?} */
            var wkt = new olWKT();
            geometry = wkt.readGeometry(wfsWktGeometry, {
                dataProjection: wfsSrsName,
                featureProjection: wfsSrsName || 'EPSG:3857'
            });
        }
        switch (operator) {
            case 'BBOX':
                return bbox(wfsGeometryName, wfsExtent, wfsSrsName);
            case 'PropertyIsBetween':
                return between(wfsPropertyName, wfsLowerBoundary, wfsUpperBoundary);
            case 'Contains':
                return contains(wfsGeometryName, geometry, wfsSrsName);
            case 'During':
                return during(wfsPropertyName, wfsBegin, wfsEnd);
            case 'PropertyIsEqualTo':
                return equalTo(wfsPropertyName, wfsExpression, wfsMatchCase);
            case 'PropertyIsGreaterThan':
                return greaterThan(wfsPropertyName, wfsExpression);
            case 'PropertyIsGreaterThanOrEqualTo':
                return greaterThanOrEqualTo(wfsPropertyName, wfsExpression);
            case 'Intersects':
                return intersects(wfsGeometryName, geometry, wfsSrsName);
            case 'PropertyIsNull':
                return isNull(wfsPropertyName);
            case 'PropertyIsLessThan':
                return lessThan(wfsPropertyName, wfsExpression);
            case 'PropertyIsLessThanOrEqualTo':
                return lessThanOrEqualTo(wfsPropertyName, wfsExpression);
            case 'PropertyIsLike':
                return like(wfsPropertyName, wfsPattern.replace(/[()_]/gi, wfsSingleChar), wfsWildCard, wfsSingleChar, wfsEscapeChar, wfsMatchCase);
            case 'PropertyIsNotEqualTo':
                return notEqualTo(wfsPropertyName, wfsExpression, wfsMatchCase);
            case 'Within':
                return within(wfsGeometryName, geometry, wfsSrsName);
            // LOGICAL
            case 'And':
                return and.apply(null, logicalArray);
            case 'Or':
                return or.apply(null, logicalArray);
            case 'Not':
                return not.apply(null, logicalArray);
            default:
                return undefined;
        }
    };
    /**
     * @param {?} filterObject
     * @param {?} geometryName
     * @param {?=} logical
     * @param {?=} level
     * @return {?}
     */
    OgcFilterWriter.prototype.defineInterfaceFilterSequence = /**
     * @param {?} filterObject
     * @param {?} geometryName
     * @param {?=} logical
     * @param {?=} level
     * @return {?}
     */
    function (filterObject, geometryName, logical, level) {
        var _this = this;
        if (logical === void 0) { logical = ''; }
        if (level === void 0) { level = -1; }
        if (filterObject instanceof Array) {
            filterObject.forEach((/**
             * @param {?} element
             * @return {?}
             */
            function (element) {
                _this.filterSequence.concat(_this.defineInterfaceFilterSequence(element, geometryName, logical, level));
            }));
        }
        else {
            if (filterObject.hasOwnProperty('logical')) {
                level = level + 1;
                this.filterSequence.concat(this.defineInterfaceFilterSequence(filterObject.filters, geometryName, filterObject.logical, level));
            }
            else if (filterObject.hasOwnProperty('operator')) {
                this.filterSequence.push(this.addInterfaceFilter(filterObject, geometryName, level, logical));
            }
        }
        return this.filterSequence;
    };
    /**
     * @param {?=} fields
     * @param {?=} propertyName
     * @param {?=} defaultOperatorsType
     * @return {?}
     */
    OgcFilterWriter.prototype.computeAllowedOperators = /**
     * @param {?=} fields
     * @param {?=} propertyName
     * @param {?=} defaultOperatorsType
     * @return {?}
     */
    function (fields, propertyName, defaultOperatorsType) {
        /** @type {?} */
        var effectiveOperators = {};
        /** @type {?} */
        var allowedOperators;
        if (fields && propertyName) {
            /** @type {?} */
            var srcField = fields.find((/**
             * @param {?} field
             * @return {?}
             */
            function (field) { return field.name === propertyName; }));
            allowedOperators = srcField && srcField.allowedOperatorsType ?
                srcField.allowedOperatorsType : defaultOperatorsType;
        }
        allowedOperators = allowedOperators ? allowedOperators : 'basicandspatial';
        switch (allowedOperators.toLowerCase()) {
            case 'all':
                effectiveOperators = this.operators;
                break;
            case 'spatial':
                effectiveOperators = {
                    Intersects: { spatial: true, fieldRestrict: [] },
                    Within: { spatial: true, fieldRestrict: [] },
                };
                break;
            case 'basicandspatial':
                effectiveOperators = {
                    PropertyIsEqualTo: { spatial: false, fieldRestrict: [] },
                    PropertyIsNotEqualTo: { spatial: false, fieldRestrict: [] },
                    Intersects: { spatial: true, fieldRestrict: [] },
                    Within: { spatial: true, fieldRestrict: [] },
                };
                break;
            case 'basic':
                effectiveOperators = {
                    PropertyIsEqualTo: { spatial: false, fieldRestrict: [] },
                    PropertyIsNotEqualTo: { spatial: false, fieldRestrict: [] }
                };
                break;
            case 'time':
                effectiveOperators = {
                    During: { spatial: false, fieldRestrict: [] },
                };
                break;
            case 'basicnumeric':
                effectiveOperators = {
                    PropertyIsEqualTo: { spatial: false, fieldRestrict: [] },
                    PropertyIsNotEqualTo: { spatial: false, fieldRestrict: [] },
                    PropertyIsGreaterThan: { spatial: false, fieldRestrict: ['number'] },
                    PropertyIsGreaterThanOrEqualTo: { spatial: false, fieldRestrict: ['number'] },
                    PropertyIsLessThan: { spatial: false, fieldRestrict: ['number'] },
                    PropertyIsLessThanOrEqualTo: { spatial: false, fieldRestrict: ['number'] },
                };
                break;
            default:
                effectiveOperators = {
                    PropertyIsEqualTo: { spatial: false, fieldRestrict: [] },
                    PropertyIsNotEqualTo: { spatial: false, fieldRestrict: [] },
                    Intersects: { spatial: true, fieldRestrict: [] },
                    Within: { spatial: true, fieldRestrict: [] },
                };
        }
        return effectiveOperators;
    };
    /**
     * @param {?=} igoOgcFilterObject
     * @param {?=} geometryName
     * @param {?=} level
     * @param {?=} parentLogical
     * @return {?}
     */
    OgcFilterWriter.prototype.addInterfaceFilter = /**
     * @param {?=} igoOgcFilterObject
     * @param {?=} geometryName
     * @param {?=} level
     * @param {?=} parentLogical
     * @return {?}
     */
    function (igoOgcFilterObject, geometryName, level, parentLogical) {
        if (level === void 0) { level = 0; }
        if (parentLogical === void 0) { parentLogical = 'Or'; }
        if (!igoOgcFilterObject) {
            igoOgcFilterObject = { operator: 'PropertyIsEqualTo' };
        }
        /** @type {?} */
        var f = {
            propertyName: '',
            operator: '',
            active: '',
            filterid: uuid(),
            begin: '',
            end: '',
            lowerBoundary: '',
            upperBoundary: '',
            expression: '',
            pattern: '',
            wildCard: '*',
            singleChar: '.',
            escapeChar: '!',
            matchCase: true,
            igoSpatialSelector: '',
            geometryName: '',
            geometry: '',
            wkt_geometry: '',
            extent: '',
            srsName: '',
            parentLogical: '',
            level: 0
        };
        return Object.assign(f, {
            parentLogical: parentLogical,
            level: level,
            geometryName: geometryName
        }, igoOgcFilterObject);
    };
    /**
     * @param {?} filterObject
     * @param {?} fieldNameGeometry
     * @param {?} proj
     * @param {?=} active
     * @return {?}
     */
    OgcFilterWriter.prototype.checkIgoFiltersProperties = /**
     * @param {?} filterObject
     * @param {?} fieldNameGeometry
     * @param {?} proj
     * @param {?=} active
     * @return {?}
     */
    function (filterObject, fieldNameGeometry, proj, active) {
        var _this = this;
        if (active === void 0) { active = false; }
        /** @type {?} */
        var filterArray = [];
        if (filterObject instanceof Array) {
            filterObject.forEach((/**
             * @param {?} element
             * @return {?}
             */
            function (element) {
                filterArray.push(_this.checkIgoFiltersProperties(element, fieldNameGeometry, proj, active));
            }));
            return filterArray;
        }
        else {
            if (filterObject.hasOwnProperty('logical')) {
                return Object.assign({}, {
                    logical: filterObject.logical,
                    filters: this.checkIgoFiltersProperties(filterObject.filters, fieldNameGeometry, proj, active)
                });
            }
            else if (filterObject.hasOwnProperty('operator')) {
                return this.addFilterProperties((/** @type {?} */ (filterObject)), fieldNameGeometry, proj, active);
            }
        }
    };
    /**
     * @private
     * @param {?} igoOgcFilterObject
     * @param {?} fieldNameGeometry
     * @param {?} proj
     * @param {?=} active
     * @return {?}
     */
    OgcFilterWriter.prototype.addFilterProperties = /**
     * @private
     * @param {?} igoOgcFilterObject
     * @param {?} fieldNameGeometry
     * @param {?} proj
     * @param {?=} active
     * @return {?}
     */
    function (igoOgcFilterObject, fieldNameGeometry, proj, active) {
        if (active === void 0) { active = false; }
        /** @type {?} */
        var filterid = igoOgcFilterObject.hasOwnProperty('filterid')
            ? igoOgcFilterObject.filterid
            : uuid();
        /** @type {?} */
        var status = igoOgcFilterObject.hasOwnProperty('active')
            ? igoOgcFilterObject.active
            : active;
        /** @type {?} */
        var srsName = igoOgcFilterObject.hasOwnProperty('srsName')
            ? igoOgcFilterObject.srsName
            : proj ? proj.getCode() : 'EPSG:3857';
        return Object.assign({}, {
            filterid: filterid,
            active: status,
            igoSpatialSelector: 'fixedExtent',
            srsName: srsName
        }, igoOgcFilterObject, { geometryName: fieldNameGeometry });
    };
    /**
     * @param {?} sequence
     * @return {?}
     */
    OgcFilterWriter.prototype.rebuiltIgoOgcFilterObjectFromSequence = /**
     * @param {?} sequence
     * @return {?}
     */
    function (sequence) {
        if (sequence instanceof Array) {
            if (sequence.length >= 1) {
                /** @type {?} */
                var lastParentLogical_1 = sequence[0].parentLogical;
                /** @type {?} */
                var nextElement_1;
                /** @type {?} */
                var logicalArray_2 = [];
                /** @type {?} */
                var lastProcessedFilter_1;
                sequence.forEach((/**
                 * @param {?} uiFilter
                 * @return {?}
                 */
                function (uiFilter) {
                    /** @type {?} */
                    var element = Object.assign({}, uiFilter);
                    /** @type {?} */
                    var index = sequence.indexOf(uiFilter);
                    if (index >= 0 && index < sequence.length - 1) {
                        nextElement_1 = sequence[index + 1];
                    }
                    else {
                        nextElement_1 = element;
                    }
                    delete element.active;
                    delete element.filterid;
                    delete element.parentLogical;
                    logicalArray_2.push(element);
                    if (sequence.length === 1) {
                        lastProcessedFilter_1 = element;
                    }
                    else if (lastParentLogical_1 !== nextElement_1.parentLogical) {
                        if (logicalArray_2.length === 1) {
                            console.log('You must set at ' +
                                'least two operator in a logical (' +
                                lastParentLogical_1 +
                                ')');
                        }
                        else {
                            lastProcessedFilter_1 = Object.assign({}, { logical: lastParentLogical_1, filters: logicalArray_2 });
                            logicalArray_2 = [lastProcessedFilter_1];
                            lastParentLogical_1 = nextElement_1.parentLogical;
                        }
                    }
                }));
                return lastProcessedFilter_1;
            }
            else {
                return undefined;
            }
        }
        else {
            return undefined;
        }
    };
    /**
     * @private
     * @param {?} pushButtons
     * @return {?}
     */
    OgcFilterWriter.prototype.computeIgoPushButton = /**
     * @private
     * @param {?} pushButtons
     * @return {?}
     */
    function (pushButtons) {
        if (pushButtons.groups.every((/**
         * @param {?} group
         * @return {?}
         */
        function (group) { return group.computedButtons !== undefined; }))) {
            return pushButtons;
        }
        /** @type {?} */
        var pb;
        if (pushButtons.groups && pushButtons.bundles) {
            if (!pushButtons.bundles.every((/**
             * @param {?} bundle
             * @return {?}
             */
            function (bundle) { return bundle.id !== undefined; }))) {
                throw new Error('You must set an id for each of your pushButtons bundles');
            }
            pb = ObjectUtils.copyDeep(pushButtons);
            pb.groups.forEach((/**
             * @param {?} group
             * @return {?}
             */
            function (group) {
                group.title = group.title ? group.title : group.name;
                group.enabled = group.enabled ? group.enabled : false;
                group.computedButtons = ObjectUtils.copyDeep(pb.bundles.filter((/**
                 * @param {?} b
                 * @return {?}
                 */
                function (b) { return group.ids.includes(b.id); })));
            }));
        }
        else if (!pushButtons.groups && pushButtons.bundles) {
            pb = ObjectUtils.copyDeep(pushButtons);
            pb.groups = [(/** @type {?} */ ({ title: 'group1', name: 'group1', computedButtons: ObjectUtils.copyDeep(pb.bundles) }))];
        }
        else {
            pb = {
                bundles: (/** @type {?} */ (pushButtons)),
                groups: [
                    (/** @type {?} */ ({
                        title: 'group1', name: 'group1',
                        computedButtons: (/** @type {?} */ (ObjectUtils.copyDeep(pushButtons)))
                    }))
                ]
            };
        }
        if (!pb.groups.find((/**
         * @param {?} pbGroup
         * @return {?}
         */
        function (pbGroup) { return pbGroup.enabled; }))) {
            pb.groups[0].enabled = true;
        }
        return pb;
    };
    /**
     * @param {?} options
     * @param {?} fieldNameGeometry
     * @param {?=} extent
     * @param {?=} proj
     * @return {?}
     */
    OgcFilterWriter.prototype.handleOgcFiltersAppliedValue = /**
     * @param {?} options
     * @param {?} fieldNameGeometry
     * @param {?=} extent
     * @param {?=} proj
     * @return {?}
     */
    function (options, fieldNameGeometry, extent, proj) {
        /** @type {?} */
        var ogcFilters = options.ogcFilters;
        if (!ogcFilters) {
            return;
        }
        /** @type {?} */
        var filterQueryStringPushButton = '';
        /** @type {?} */
        var filterQueryStringAdvancedFilters = '';
        if (ogcFilters.enabled && ogcFilters.pushButtons) {
            ogcFilters.pushButtons = this.computeIgoPushButton(ogcFilters.pushButtons);
            /** @type {?} */
            var pushButtonBundle = ogcFilters.pushButtons.groups.find((/**
             * @param {?} g
             * @return {?}
             */
            function (g) { return g.enabled; })).computedButtons;
            /** @type {?} */
            var conditions_1 = [];
            pushButtonBundle.map((/**
             * @param {?} buttonBundle
             * @return {?}
             */
            function (buttonBundle) {
                /** @type {?} */
                var bundleCondition = [];
                buttonBundle.buttons
                    .filter((/**
                 * @param {?} ogcpb
                 * @return {?}
                 */
                function (ogcpb) { return ogcpb.enabled === true; }))
                    .forEach((/**
                 * @param {?} enabledPb
                 * @return {?}
                 */
                function (enabledPb) { return bundleCondition.push(enabledPb.filters); }));
                if (bundleCondition.length === 1) {
                    conditions_1.push(bundleCondition[0]);
                }
                else if (bundleCondition.length > 1) {
                    conditions_1.push({ logical: buttonBundle.logical, filters: bundleCondition });
                }
            }));
            if (conditions_1.length >= 1) {
                filterQueryStringPushButton = this.buildFilter(conditions_1.length === 1 ? conditions_1[0] : { logical: 'And', filters: conditions_1 }, extent, proj, ogcFilters.geometryName);
            }
        }
        if (ogcFilters.enabled && ogcFilters.filters) {
            ogcFilters.geometryName = ogcFilters.geometryName || fieldNameGeometry;
            /** @type {?} */
            var igoFilters = ogcFilters.filters;
            filterQueryStringAdvancedFilters = this.buildFilter(igoFilters, extent, proj, ogcFilters.geometryName);
        }
        /** @type {?} */
        var filterQueryString = ogcFilters.advancedOgcFilters ? filterQueryStringAdvancedFilters : filterQueryStringPushButton;
        if (options.type === 'wms') {
            filterQueryString = this.formatProcessedOgcFilter(filterQueryString, ((/** @type {?} */ (options))).params.LAYERS);
        }
        if (options.type === 'wfs') {
            filterQueryString = this.formatProcessedOgcFilter(filterQueryString, ((/** @type {?} */ (options))).params.featureTypes);
        }
        return filterQueryString;
    };
    /**
     * @param {?} processedFilter
     * @param {?} layersOrTypenames
     * @return {?}
     */
    OgcFilterWriter.prototype.formatProcessedOgcFilter = /**
     * @param {?} processedFilter
     * @param {?} layersOrTypenames
     * @return {?}
     */
    function (processedFilter, layersOrTypenames) {
        /** @type {?} */
        var appliedFilter = '';
        if (processedFilter.length === 0 && layersOrTypenames.indexOf(',') === -1) {
            appliedFilter = processedFilter;
        }
        else {
            layersOrTypenames.split(',').forEach((/**
             * @param {?} layerOrTypenames
             * @return {?}
             */
            function (layerOrTypenames) {
                appliedFilter = appliedFilter + "(" + processedFilter.replace('filter=', '') + ")";
            }));
        }
        appliedFilter = appliedFilter.replace(/\(\)/g, '');
        /** @type {?} */
        var filterValue = appliedFilter.length > 0 ? appliedFilter.replace('filter=', '') : undefined;
        return filterValue;
    };
    return OgcFilterWriter;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var defaultEpsg = 'EPSG:3857';
/** @type {?} */
var defaultMaxFeatures = 5000;
/** @type {?} */
var defaultWfsVersion = '2.0.0';
/** @type {?} */
var defaultFieldNameGeometry = 'geometry';
/** @type {?} */
var gmlRegex = new RegExp(/(.*)?gml(.*)?/gi);
/** @type {?} */
var jsonRegex = new RegExp(/(.*)?json(.*)?/gi);
/**
 * This method build/standardize WFS call query params based on the layer property.
 * @param {?} dataSourceOptions
 * @param {?=} count  Number: Used to control the number of feature. Used to bypass whe wfs datasource options interface (maxFeatures)
 * @param {?=} epsg  String: Used to control the EPSG code (es: 'EPSG3857'). Used to bypass whe wfs datasource options interface (srsName)
 * @param {?=} properties  String: Used to control the queried fields  (WFS service).
 * @return {?} An array array of {name: '', value: ''} of predefined query params.
 */
function formatWFSQueryString(dataSourceOptions, count, epsg, properties) {
    /** @type {?} */
    var versionWfs200 = '2.0.0';
    // not the same usage as defaultWfsVersion.
    /** @type {?} */
    var url = dataSourceOptions.urlWfs;
    /** @type {?} */
    var paramsWFS = dataSourceOptions.paramsWFS;
    /** @type {?} */
    var effectiveCount = count || defaultMaxFeatures;
    /** @type {?} */
    var epsgCode = epsg || defaultEpsg;
    /** @type {?} */
    var outputFormat = paramsWFS.outputFormat
        ? "outputFormat=" + paramsWFS.outputFormat
        : '';
    /** @type {?} */
    var version = paramsWFS.version
        ? "version=" + paramsWFS.version
        : "version=" + defaultWfsVersion;
    /** @type {?} */
    var paramTypename = paramsWFS.version === versionWfs200 ? 'typenames' : 'typename';
    /** @type {?} */
    var featureTypes = paramTypename + "=" + paramsWFS.featureTypes;
    /** @type {?} */
    var paramMaxFeatures = paramsWFS.version === versionWfs200 ? 'count' : 'maxFeatures';
    /** @type {?} */
    var cnt = count
        ? paramMaxFeatures + "=" + effectiveCount
        : paramsWFS.maxFeatures
            ? paramMaxFeatures + "=" + paramsWFS.maxFeatures
            : paramMaxFeatures + "=" + effectiveCount;
    /** @type {?} */
    var srs = epsg
        ? "srsname=" + epsgCode
        : paramsWFS.srsName
            ? 'srsname=' + paramsWFS.srsName
            : "srsname=" + epsgCode;
    /** @type {?} */
    var propertyName = '';
    /** @type {?} */
    var valueReference = '';
    if (properties) {
        propertyName = "propertyName=" + properties;
        valueReference = "valueReference=" + properties;
    }
    /** @type {?} */
    var sourceFields = dataSourceOptions.sourceFields;
    if (!propertyName && sourceFields && sourceFields.length > 0) {
        /** @type {?} */
        var fieldsNames_1 = [];
        dataSourceOptions.sourceFields.forEach((/**
         * @param {?} sourcefield
         * @return {?}
         */
        function (sourcefield) {
            fieldsNames_1.push(sourcefield.name);
        }));
        propertyName = "propertyName=" + fieldsNames_1.join(',') + "," + paramsWFS.fieldNameGeometry;
    }
    /** @type {?} */
    var getCapabilities = url + "?service=WFS&request=GetCapabilities&" + version;
    /** @type {?} */
    var getFeature = url + "?service=WFS&request=GetFeature&" + version + "&" + featureTypes + "&";
    getFeature += outputFormat + "&" + srs + "&" + cnt + "&" + propertyName;
    /** @type {?} */
    var getpropertyvalue = url + "?service=WFS&request=GetPropertyValue&version=" + versionWfs200 + "&" + featureTypes + "&";
    getpropertyvalue += "&" + cnt + "&" + valueReference;
    return [
        { name: 'outputformat', value: outputFormat },
        { name: 'version', value: version },
        { name: 'typename', value: featureTypes },
        { name: 'count', value: cnt },
        { name: 'srsname', value: srs },
        { name: 'propertyname', value: propertyName },
        { name: 'valuereference', value: valueReference },
        { name: 'getcapabilities', value: getCapabilities.replace(/&&/g, '&') },
        { name: 'getfeature', value: getFeature.replace(/&&/g, '&') },
        { name: 'getpropertyvalue', value: getpropertyvalue.replace(/&&/g, '&') }
    ];
}
/**
 * Validate/Modify layer's wfs options based on :
 * 1- an Openlayers's issue with GML provided from WFS. Refer to
 * https://github.com/openlayers/openlayers/pull/6400
 * 2- Set default values for optionals parameters.
 * @param {?} wfsDataSourceOptions  WFSDataSourceOptions The common wfs datasource options interface
 * @param {?=} srcType
 * @return {?} An array array of {name: '', value: ''} of predefined query params.
 */
function checkWfsParams(wfsDataSourceOptions, srcType) {
    if (srcType && srcType === 'wfs') {
        // reassignation of params to paramsWFS and url to urlWFS to have a common interface with wms-wfs datasources
        wfsDataSourceOptions.paramsWFS = wfsDataSourceOptions.params;
    }
    /** @type {?} */
    var paramsWFS = wfsDataSourceOptions.paramsWFS;
    wfsDataSourceOptions.urlWfs =
        wfsDataSourceOptions.urlWfs || wfsDataSourceOptions.url;
    paramsWFS.version = paramsWFS.version || defaultWfsVersion;
    paramsWFS.fieldNameGeometry =
        paramsWFS.fieldNameGeometry || defaultFieldNameGeometry;
    paramsWFS.maxFeatures = paramsWFS.maxFeatures || defaultMaxFeatures;
    /** @type {?} */
    var outputFormat;
    if (paramsWFS.outputFormat) {
        outputFormat = paramsWFS.outputFormat;
    }
    if (gmlRegex.test(outputFormat) || !outputFormat) {
        paramsWFS.version = '1.1.0';
    }
    return Object.assign({}, wfsDataSourceOptions);
}
/**
 * @param {?} options
 * @return {?}
 */
function getFormatFromOptions(options) {
    /** @type {?} */
    var wfsOptions = (/** @type {?} */ (options));
    /** @type {?} */
    var olFormatCls = WFS;
    /** @type {?} */
    var outputFormat = wfsOptions.paramsWFS.outputFormat
        ? wfsOptions.paramsWFS.outputFormat
        : undefined;
    if (!outputFormat) {
        return new olFormatCls(wfsOptions.formatOptions);
    }
    if (olformat[outputFormat]) {
        olFormatCls = olformat[outputFormat];
        return new olFormatCls(wfsOptions.formatOptions);
    }
    else if (outputFormat.toLowerCase().match('gml2')) {
        olFormatCls = WFS;
        return new olFormatCls(__assign({}, wfsOptions.formatOptions, { gmlFormat: olFormatGML2 }));
    }
    else if (outputFormat.toLowerCase().match('gml32')) {
        olFormatCls = WFS;
        return new olFormatCls(__assign({}, wfsOptions.formatOptions, { gmlFormat: olFormatGML32 }));
    }
    else if (outputFormat.toLowerCase().match('gml3')) {
        olFormatCls = WFS;
        return new olFormatCls(__assign({}, wfsOptions.formatOptions, { gmlFormat: olFormatGML3 }));
    }
    else if (outputFormat.toLowerCase().match('topojson')) {
        olFormatCls = TopoJSON;
        return new olFormatCls(wfsOptions.formatOptions);
    }
    else if (outputFormat.toLowerCase().match('geojson')) {
        olFormatCls = GeoJSON;
        return new olFormatCls(wfsOptions.formatOptions);
    }
    else if (outputFormat.toLowerCase().match('esrijson')) {
        olFormatCls = EsriJSON;
        return new olFormatCls(wfsOptions.formatOptions);
    }
    else if (outputFormat.toLowerCase().match('json')) {
        olFormatCls = GeoJSON;
        return new olFormatCls(wfsOptions.formatOptions);
    }
    else if (outputFormat.toLowerCase().match('gpx')) {
        olFormatCls = GPX;
        return new olFormatCls(wfsOptions.formatOptions);
    }
    else if (outputFormat.toLowerCase().match('WKT')) {
        olFormatCls = WKT;
        return new olFormatCls(wfsOptions.formatOptions);
    }
    else if (outputFormat.toLowerCase().match('osmxml')) {
        olFormatCls = olFormatOSMXML;
        return new olFormatCls(wfsOptions.formatOptions);
    }
    else if (outputFormat.toLowerCase().match('kml')) {
        olFormatCls = KML;
        return new olFormatCls(wfsOptions.formatOptions);
    }
    return new olFormatCls();
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var WFSDataSource = /** @class */ (function (_super) {
    __extends(WFSDataSource, _super);
    function WFSDataSource(options, wfsService) {
        var _this = _super.call(this, checkWfsParams(options, 'wfs')) || this;
        _this.options = options;
        _this.wfsService = wfsService;
        /** @type {?} */
        var ogcFilters = ((/** @type {?} */ (_this.options))).ogcFilters;
        /** @type {?} */
        var fieldNameGeometry = _this.options.paramsWFS.fieldNameGeometry || defaultFieldNameGeometry;
        /** @type {?} */
        var ogcFilterWriter = new OgcFilterWriter();
        ((/** @type {?} */ (_this.options))).ogcFilters =
            ogcFilterWriter.defineOgcFiltersDefaultOptions(ogcFilters, fieldNameGeometry);
        if (((/** @type {?} */ (_this.options))).ogcFilters.enabled &&
            ((/** @type {?} */ (_this.options))).ogcFilters.editable) {
            _this.wfsService.getSourceFieldsFromWFS(_this.options);
        }
        return _this;
    }
    /**
     * @protected
     * @return {?}
     */
    WFSDataSource.prototype.createOlSource = /**
     * @protected
     * @return {?}
     */
    function () {
        var _this = this;
        return new OlVectorSource({
            format: getFormatFromOptions(this.options),
            overlaps: false,
            url: (/**
             * @param {?} extent
             * @param {?} resolution
             * @param {?} proj
             * @return {?}
             */
            function (extent, resolution, proj) {
                _this.options.paramsWFS.srsName = _this.options.paramsWFS.srsName || proj.getCode();
                return _this.buildUrl(extent, proj, ((/** @type {?} */ (_this.options))).ogcFilters);
            }),
            strategy: bbox$1
        });
    };
    /**
     * @private
     * @param {?} extent
     * @param {?} proj
     * @param {?} ogcFilters
     * @return {?}
     */
    WFSDataSource.prototype.buildUrl = /**
     * @private
     * @param {?} extent
     * @param {?} proj
     * @param {?} ogcFilters
     * @return {?}
     */
    function (extent, proj, ogcFilters) {
        /** @type {?} */
        var paramsWFS = this.options.paramsWFS;
        /** @type {?} */
        var queryStringValues = formatWFSQueryString(this.options, undefined, this.options.paramsWFS.srsName);
        /** @type {?} */
        var igoFilters;
        if (ogcFilters && ogcFilters.enabled) {
            igoFilters = ogcFilters.filters;
        }
        /** @type {?} */
        var ogcFilterWriter = new OgcFilterWriter();
        /** @type {?} */
        var filterOrBox = ogcFilterWriter.buildFilter(igoFilters, extent, proj, ogcFilters.geometryName);
        /** @type {?} */
        var filterOrPush = ogcFilterWriter.handleOgcFiltersAppliedValue(this.options, ogcFilters.geometryName);
        /** @type {?} */
        var prefix = 'filter';
        if (!filterOrPush) {
            prefix = 'bbox';
            filterOrPush = extent.join(',') + ',' + proj.getCode();
        }
        paramsWFS.xmlFilter = ogcFilters.advancedOgcFilters ? filterOrBox : prefix + "=" + filterOrPush;
        /** @type {?} */
        var baseUrl = queryStringValues.find((/**
         * @param {?} f
         * @return {?}
         */
        function (f) { return f.name === 'getfeature'; })).value;
        /** @type {?} */
        var patternFilter = /(filter|bbox)=.*/gi;
        baseUrl = patternFilter.test(paramsWFS.xmlFilter) ? baseUrl + "&" + paramsWFS.xmlFilter : baseUrl;
        this.options.download = Object.assign({}, this.options.download, { dynamicUrl: baseUrl });
        return baseUrl.replace(/&&/g, '&');
    };
    /**
     * @return {?}
     */
    WFSDataSource.prototype.onUnwatch = /**
     * @return {?}
     */
    function () { };
    return WFSDataSource;
}(DataSource));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var WFSService = /** @class */ (function (_super) {
    __extends(WFSService, _super);
    function WFSService(http) {
        var _this = _super.call(this) || this;
        _this.http = http;
        return _this;
    }
    /**
     * @return {?}
     */
    WFSService.prototype.getData = /**
     * @return {?}
     */
    function () {
        console.log('This is defining a data service.');
        return 'This is defining a data service.';
    };
    /**
     * @param {?} dataSourceOptions
     * @return {?}
     */
    WFSService.prototype.getSourceFieldsFromWFS = /**
     * @param {?} dataSourceOptions
     * @return {?}
     */
    function (dataSourceOptions) {
        if (!dataSourceOptions.sourceFields || dataSourceOptions.sourceFields.length === 0) {
            dataSourceOptions.sourceFields = [];
            this.defineFieldAndValuefromWFS(dataSourceOptions).subscribe((/**
             * @param {?} getfeatureSourceField
             * @return {?}
             */
            function (getfeatureSourceField) {
                dataSourceOptions.sourceFields = getfeatureSourceField;
            }));
        }
        else {
            this.defineFieldAndValuefromWFS(dataSourceOptions).subscribe((/**
             * @param {?} getfeatureSourceField
             * @return {?}
             */
            function (getfeatureSourceField) {
                dataSourceOptions.sourceFields.forEach((/**
                 * @param {?} sourcefield
                 * @return {?}
                 */
                function (sourcefield) {
                    if (sourcefield.alias === undefined) {
                        sourcefield.alias = sourcefield.name; // to allow only a list of sourcefield with names
                    }
                    if (sourcefield.values === undefined || sourcefield.values.length === 0) {
                        sourcefield.values = getfeatureSourceField.find((/**
                         * @param {?} sf
                         * @return {?}
                         */
                        function (sf) { return sf.name === sourcefield.name; })).values;
                    }
                }));
            }));
        }
    };
    /**
     * @private
     * @param {?} dataSourceOptions
     * @param {?=} nb
     * @param {?=} epsgCode
     * @param {?=} propertyName
     * @return {?}
     */
    WFSService.prototype.wfsGetFeature = /**
     * @private
     * @param {?} dataSourceOptions
     * @param {?=} nb
     * @param {?=} epsgCode
     * @param {?=} propertyName
     * @return {?}
     */
    function (dataSourceOptions, nb, epsgCode, propertyName) {
        if (nb === void 0) { nb = defaultMaxFeatures; }
        if (epsgCode === void 0) { epsgCode = defaultEpsg; }
        /** @type {?} */
        var queryStringValues = formatWFSQueryString(dataSourceOptions, nb, epsgCode, propertyName);
        /** @type {?} */
        var baseUrl = queryStringValues.find((/**
         * @param {?} f
         * @return {?}
         */
        function (f) { return f.name === 'getfeature'; })).value;
        /** @type {?} */
        var outputFormat = dataSourceOptions.paramsWFS.outputFormat;
        if (gmlRegex.test(outputFormat) || !outputFormat) {
            return this.http.get(baseUrl, { responseType: 'text' });
        }
        else {
            return this.http.get(baseUrl);
        }
    };
    /**
     * @param {?} dataSourceOptions
     * @return {?}
     */
    WFSService.prototype.defineFieldAndValuefromWFS = /**
     * @param {?} dataSourceOptions
     * @return {?}
     */
    function (dataSourceOptions) {
        var _this = this;
        return new Observable((/**
         * @param {?} d
         * @return {?}
         */
        function (d) {
            /** @type {?} */
            var sourceFields = [];
            /** @type {?} */
            var fieldList;
            /** @type {?} */
            var fieldListWoGeom;
            /** @type {?} */
            var fieldListWoGeomStr;
            /** @type {?} */
            var olFormats;
            olFormats = getFormatFromOptions(dataSourceOptions);
            _this.wfsGetFeature(dataSourceOptions, 1).subscribe((/**
             * @param {?} oneFeature
             * @return {?}
             */
            function (oneFeature) {
                /** @type {?} */
                var features = olFormats.readFeatures(oneFeature);
                fieldList = features[0].getKeys();
                fieldListWoGeom = fieldList.filter((/**
                 * @param {?} field
                 * @return {?}
                 */
                function (field) {
                    return field !== features[0].getGeometryName() &&
                        !field.match(/boundedby/gi);
                }));
                fieldListWoGeomStr = fieldListWoGeom.join(',');
                _this.wfsGetFeature(dataSourceOptions, dataSourceOptions.paramsWFS.maxFeatures || defaultMaxFeatures, dataSourceOptions.paramsWFS.srsName, fieldListWoGeomStr).subscribe((/**
                 * @param {?} manyFeatures
                 * @return {?}
                 */
                function (manyFeatures) {
                    /** @type {?} */
                    var mfeatures = olFormats.readFeatures(manyFeatures);
                    _this.built_properties_value(mfeatures).forEach((/**
                     * @param {?} element
                     * @return {?}
                     */
                    function (element) {
                        sourceFields.push(element);
                    }));
                    d.next(sourceFields);
                    d.complete();
                }));
            }));
        }));
    };
    /**
     * @private
     * @param {?} features
     * @return {?}
     */
    WFSService.prototype.built_properties_value = /**
     * @private
     * @param {?} features
     * @return {?}
     */
    function (features) {
        /** @type {?} */
        var kv = Object.assign({}, features[0].getProperties());
        delete kv[features[0].getGeometryName()];
        delete kv.boundedBy;
        /** @type {?} */
        var sourceFields = [];
        for (var property in kv) {
            if (kv.hasOwnProperty(property)) {
                /** @type {?} */
                var fieldType = typeof features[0].get(property) === 'object'
                    ? undefined
                    : typeof features[0].get(property);
                sourceFields.push({
                    name: property,
                    alias: property,
                    type: fieldType,
                    values: [kv[property]]
                });
            }
        }
        features.every((/**
         * @param {?} element
         * @return {?}
         */
        function (element) {
            /** @type {?} */
            var featureProperties = element.getProperties();
            var _loop_1 = function (key) {
                if (featureProperties.hasOwnProperty(key) && key in kv) {
                    sourceFields.filter((/**
                     * @param {?} f
                     * @return {?}
                     */
                    function (f) { return f.name === key; })).forEach((/**
                     * @param {?} v
                     * @return {?}
                     */
                    function (v) {
                        if (v.values.indexOf(featureProperties[key]) === -1) {
                            v.values.push(featureProperties[key]);
                        }
                    }));
                }
            };
            for (var key in featureProperties) {
                _loop_1(key);
            }
            return true;
        }));
        return sourceFields;
    };
    WFSService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    WFSService.ctorParameters = function () { return [
        { type: HttpClient }
    ]; };
    /** @nocollapse */ WFSService.ngInjectableDef = defineInjectable({ factory: function WFSService_Factory() { return new WFSService(inject(HttpClient)); }, token: WFSService, providedIn: "root" });
    return WFSService;
}(DataService));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
var QueryFormat = {
    GML2: 'gml2',
    GML3: 'gml3',
    JSON: 'json',
    GEOJSON: 'geojson',
    GEOJSON2: 'geojson2',
    ESRIJSON: 'esrijson',
    TEXT: 'text',
    HTML: 'html',
    HTMLGML2: 'htmlgml2',
};
/** @enum {string} */
var QueryFormatMimeType = {
    GML2: 'application/vnd.ogc.gml',
    GML3: 'application/vnd.ogc.gml/3.1.1',
    JSON: 'application/json',
    GEOJSON: 'application/geojson',
    GEOJSON2: 'geojson',
    ESRIJSON: 'application/json',
    TEXT: 'text/plain',
    HTML: 'text/html',
    HTMLGML2: 'text/html',
};
/** @enum {string} */
var QueryHtmlTarget = {
    IFRAME: 'iframe',
    BLANK: '_blank',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var WMSDataSource = /** @class */ (function (_super) {
    __extends(WMSDataSource, _super);
    function WMSDataSource(options, wfsService) {
        var _this = _super.call(this, options) || this;
        _this.options = options;
        _this.wfsService = wfsService;
        /** @type {?} */
        var sourceParams = options.params;
        /** @type {?} */
        var dpi = sourceParams.DPI || 96;
        sourceParams.DPI = dpi;
        sourceParams.MAP_RESOLUTION = dpi;
        sourceParams.FORMAT_OPTIONS = 'dpi:' + dpi;
        if (options.refreshIntervalSec && options.refreshIntervalSec > 0) {
            setInterval((/**
             * @return {?}
             */
            function () {
                _this.refresh();
            }), options.refreshIntervalSec * 1000); // Convert seconds to MS
        }
        /** @type {?} */
        var fieldNameGeometry = defaultFieldNameGeometry;
        // ####   START if paramsWFS
        if (options.paramsWFS) {
            /** @type {?} */
            var wfsCheckup = checkWfsParams(options, 'wms');
            ObjectUtils.mergeDeep(options.paramsWFS, wfsCheckup.paramsWFS);
            fieldNameGeometry =
                options.paramsWFS.fieldNameGeometry || fieldNameGeometry;
            options.download = Object.assign({}, options.download, {
                dynamicUrl: _this.buildDynamicDownloadUrlFromParamsWFS(options)
            });
        } //  ####   END  if paramsWFS
        if (!options.sourceFields || options.sourceFields.length === 0) {
            options.sourceFields = [];
        }
        else {
            options.sourceFields.forEach((/**
             * @param {?} sourceField
             * @return {?}
             */
            function (sourceField) {
                sourceField.alias = sourceField.alias
                    ? sourceField.alias
                    : sourceField.name;
                // to allow only a list of sourcefield with names
            }));
        }
        /** @type {?} */
        var initOgcFilters = ((/** @type {?} */ (options)))
            .ogcFilters;
        /** @type {?} */
        var ogcFilterWriter = new OgcFilterWriter();
        if (!initOgcFilters) {
            ((/** @type {?} */ (options))).ogcFilters = ogcFilterWriter.defineOgcFiltersDefaultOptions(initOgcFilters, fieldNameGeometry, 'wms');
        }
        else {
            initOgcFilters.advancedOgcFilters = initOgcFilters.pushButtons
                ? false
                : true;
        }
        if (sourceParams.LAYERS.split(',').length > 1 &&
            initOgcFilters &&
            initOgcFilters.enabled) {
            console.log('*******************************');
            console.log('BE CAREFULL, YOUR WMS LAYERS (' +
                sourceParams.LAYERS +
                ') MUST SHARE THE SAME FIELDS TO ALLOW ogcFilters TO WORK !! ');
            console.log('*******************************');
        }
        if (options.paramsWFS && initOgcFilters && initOgcFilters.enabled && initOgcFilters.editable) {
            _this.wfsService.getSourceFieldsFromWFS(options);
        }
        /** @type {?} */
        var filterQueryString = ogcFilterWriter.handleOgcFiltersAppliedValue(options, fieldNameGeometry);
        sourceParams.FILTER = filterQueryString;
        return _this;
    }
    Object.defineProperty(WMSDataSource.prototype, "params", {
        get: /**
         * @return {?}
         */
        function () {
            return (/** @type {?} */ (this.options.params));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WMSDataSource.prototype, "queryTitle", {
        get: /**
         * @return {?}
         */
        function () {
            return ((/** @type {?} */ (this.options))).queryTitle
                ? ((/** @type {?} */ (this.options))).queryTitle
                : 'title';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WMSDataSource.prototype, "mapLabel", {
        get: /**
         * @return {?}
         */
        function () {
            return ((/** @type {?} */ (this.options))).mapLabel;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WMSDataSource.prototype, "queryHtmlTarget", {
        get: /**
         * @return {?}
         */
        function () {
            return ((/** @type {?} */ (this.options))).queryHtmlTarget
                ? ((/** @type {?} */ (this.options))).queryHtmlTarget
                : QueryHtmlTarget.BLANK;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    WMSDataSource.prototype.refresh = /**
     * @return {?}
     */
    function () {
        this.ol.updateParams({ igoRefresh: Math.random() });
    };
    /**
     * @private
     * @param {?} asWFSDataSourceOptions
     * @return {?}
     */
    WMSDataSource.prototype.buildDynamicDownloadUrlFromParamsWFS = /**
     * @private
     * @param {?} asWFSDataSourceOptions
     * @return {?}
     */
    function (asWFSDataSourceOptions) {
        /** @type {?} */
        var queryStringValues = formatWFSQueryString(asWFSDataSourceOptions);
        /** @type {?} */
        var downloadUrl = queryStringValues.find((/**
         * @param {?} f
         * @return {?}
         */
        function (f) { return f.name === 'getfeature'; }))
            .value;
        return downloadUrl;
    };
    /**
     * @protected
     * @return {?}
     */
    WMSDataSource.prototype.createOlSource = /**
     * @protected
     * @return {?}
     */
    function () {
        return new olSourceImageWMS(this.options);
    };
    /**
     * @param {?=} style
     * @param {?=} scale
     * @return {?}
     */
    WMSDataSource.prototype.getLegend = /**
     * @param {?=} style
     * @param {?=} scale
     * @return {?}
     */
    function (style$$1, scale) {
        /** @type {?} */
        var legend = _super.prototype.getLegend.call(this);
        if (legend.length > 0 && (style$$1 === undefined && !scale)) {
            return legend;
        }
        /** @type {?} */
        var sourceParams = this.params;
        /** @type {?} */
        var layers = [];
        if (sourceParams.LAYERS !== undefined) {
            layers = sourceParams.LAYERS.split(',');
        }
        /** @type {?} */
        var baseUrl = this.options.url.replace(/\?$/, '');
        /** @type {?} */
        var params = [
            'REQUEST=GetLegendGraphic',
            'SERVICE=WMS',
            'FORMAT=image/png',
            'SLD_VERSION=1.1.0',
            "VERSION=" + (sourceParams.VERSION || '1.3.0')
        ];
        if (style$$1 !== undefined) {
            params.push("STYLE=" + style$$1);
        }
        if (scale !== undefined) {
            params.push("SCALE=" + scale);
        }
        legend = layers.map((/**
         * @param {?} layer
         * @return {?}
         */
        function (layer) {
            /** @type {?} */
            var separator = baseUrl.match(/\?/) ? '&' : '?';
            return {
                url: "" + baseUrl + separator + params.join('&') + "&LAYER=" + layer,
                title: layers.length > 1 ? layer : undefined,
                currentStyle: style$$1 === undefined ? undefined : (/** @type {?} */ (style$$1))
            };
        }));
        return legend;
    };
    /**
     * @return {?}
     */
    WMSDataSource.prototype.onUnwatch = /**
     * @return {?}
     */
    function () { };
    return WMSDataSource;
}(DataSource));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?=} epsg
 * @return {?}
 */
function createDefaultTileGrid(epsg) {
    /** @type {?} */
    var projection = epsg ? get(epsg) : get('EPSG:3857');
    /** @type {?} */
    var projectionExtent = projection.getExtent();
    /** @type {?} */
    var size = getWidth(projectionExtent) / 256;
    /** @type {?} */
    var resolutions = new Array(20);
    /** @type {?} */
    var matrixIds = new Array(20);
    for (var z = 0; z < 20; ++z) {
        resolutions[z] = size / Math.pow(2, z);
        matrixIds[z] = z;
    }
    return new olTileGridWMTS({
        origin: getTopLeft(projectionExtent),
        resolutions: resolutions,
        matrixIds: matrixIds
    });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var WMTSDataSource = /** @class */ (function (_super) {
    __extends(WMTSDataSource, _super);
    function WMTSDataSource(options) {
        return _super.call(this, options) || this;
    }
    /**
     * @protected
     * @return {?}
     */
    WMTSDataSource.prototype.createOlSource = /**
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var sourceOptions = Object.assign({
            tileGrid: createDefaultTileGrid((/** @type {?} */ (this.options.projection)))
        }, this.options);
        return new olSourceWMTS(sourceOptions);
    };
    /**
     * @return {?}
     */
    WMTSDataSource.prototype.onUnwatch = /**
     * @return {?}
     */
    function () { };
    return WMTSDataSource;
}(DataSource));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var CartoDataSource = /** @class */ (function (_super) {
    __extends(CartoDataSource, _super);
    function CartoDataSource() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(CartoDataSource.prototype, "params", {
        get: /**
         * @return {?}
         */
        function () {
            return (/** @type {?} */ (this.options.params));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CartoDataSource.prototype, "queryTitle", {
        get: /**
         * @return {?}
         */
        function () {
            return ((/** @type {?} */ (this.options))).queryTitle
                ? ((/** @type {?} */ (this.options))).queryTitle
                : 'title';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CartoDataSource.prototype, "mapLabel", {
        get: /**
         * @return {?}
         */
        function () {
            return ((/** @type {?} */ (this.options))).mapLabel;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CartoDataSource.prototype, "queryHtmlTarget", {
        get: /**
         * @return {?}
         */
        function () {
            return ((/** @type {?} */ (this.options))).queryHtmlTarget
                ? ((/** @type {?} */ (this.options))).queryHtmlTarget
                : QueryHtmlTarget.BLANK;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @protected
     * @return {?}
     */
    CartoDataSource.prototype.createOlSource = /**
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var crossOrigin = this.options.crossOrigin
            ? this.options.crossOrigin
            : 'anonymous';
        /** @type {?} */
        var sourceOptions = Object.assign({
            crossOrigin: crossOrigin
        }, this.options);
        return new olSourceCarto(sourceOptions);
    };
    /**
     * @return {?}
     */
    CartoDataSource.prototype.getLegend = /**
     * @return {?}
     */
    function () {
        var e_1, _a;
        /** @type {?} */
        var legend = _super.prototype.getLegend.call(this);
        if (legend.length > 0) {
            return legend;
        }
        /** @type {?} */
        var htmlString = '<table>';
        if (this.options.config.layers[0].legend != null) {
            this.options.config.layers[0].legend.items.forEach((/**
             * @param {?} f
             * @return {?}
             */
            function (f) {
                if (f.visible === true) {
                    htmlString +=
                        '<tr><td>' +
                            '<p><font size="5" color="' +
                            f.value +
                            '"> &#9679</font></p></td>' +
                            '<td>' +
                            f.name +
                            '</td></tr>';
                }
            }));
            htmlString += '</table>';
            return [{ html: htmlString }];
        }
        else {
            // Try to build the legend from the cartocss options
            /** @type {?} */
            var layerOptions = this.options.config.layers[0].options;
            // All available cartocss style options
            /** @type {?} */
            var types = [
                'polygon-fill:',
                'marker-fill:',
                'shield-fill:',
                'building-fill:',
                'line-color:'
            ];
            try {
                for (var types_1 = __values(types), types_1_1 = types_1.next(); !types_1_1.done; types_1_1 = types_1.next()) {
                    var oneType = types_1_1.value;
                    if (layerOptions.cartocss.includes(oneType)) {
                        /** @type {?} */
                        var type = layerOptions.cartocss.split(oneType).pop();
                        /** @type {?} */
                        var color = type.substr(0, type.indexOf(';'));
                        if (color.includes('ramp')) {
                            /** @type {?} */
                            var colors = color.split(', (')[1].split(',');
                            /** @type {?} */
                            var data = color.split(', (')[2].split(',');
                            for (var j = 0; j < colors.length; j++) {
                                colors[j] = colors[j].replace(/("|\))/g, '');
                                data[j] = data[j].replace(/("|\))/g, '');
                                if (data[j].replace(/\s+/g, '') === '=') {
                                    data[j] = 'Autres';
                                }
                                htmlString +=
                                    '<tr><td>' +
                                        '<p><font size="5" color="' +
                                        colors[j] +
                                        '"> &#9679</font></p></td>' +
                                        '<td>' +
                                        data[j] +
                                        '</td></tr>';
                            }
                            break;
                        }
                        else {
                            /** @type {?} */
                            var title = layerOptions.layer_name
                                ? layerOptions.layer_name
                                : '';
                            htmlString +=
                                '<tr><td>' +
                                    '<p><font size="5" color="' +
                                    color +
                                    '"> &#9679</font></p>' +
                                    '</td><td>' +
                                    title +
                                    '</td></tr>';
                            break;
                        }
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (types_1_1 && !types_1_1.done && (_a = types_1.return)) _a.call(types_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            htmlString += '</table>';
            return [{ html: htmlString }];
        }
    };
    /**
     * @return {?}
     */
    CartoDataSource.prototype.onUnwatch = /**
     * @return {?}
     */
    function () { };
    return CartoDataSource;
}(DataSource));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ArcGISRestDataSource = /** @class */ (function (_super) {
    __extends(ArcGISRestDataSource, _super);
    function ArcGISRestDataSource() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @protected
     * @return {?}
     */
    ArcGISRestDataSource.prototype.createOlSource = /**
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var esrijsonFormat = new olFormatEsriJSON();
        return new OlVectorSource({
            attributions: this.options.params.attributions,
            overlaps: false,
            format: esrijsonFormat,
            url: (/**
             * @param {?} extent
             * @param {?} resolution
             * @param {?} proj
             * @return {?}
             */
            function (extent, resolution, proj) {
                /** @type {?} */
                var baseUrl = this.options.url + '/' + this.options.layer + '/query/';
                /** @type {?} */
                var geometry = encodeURIComponent('{"xmin":' +
                    extent[0] +
                    ',"ymin":' +
                    extent[1] +
                    ',"xmax":' +
                    extent[2] +
                    ',"ymax":' +
                    extent[3] +
                    ',"spatialReference":{"wkid":102100}}');
                /** @type {?} */
                var params = [
                    'f=json',
                    "geometry=" + geometry,
                    'geometryType=esriGeometryEnvelope',
                    'inSR=102100',
                    'spatialRel=esriSpatialRelIntersects',
                    'outFields=*',
                    'returnGeometry=true',
                    'outSR=102100'
                ];
                if (this.options.params.timeFilter) {
                    /** @type {?} */
                    var time = "time=" + this.options.params.timeExtent;
                    params.push(time);
                }
                if (this.options.params.customParams) {
                    this.options.params.customParams.forEach((/**
                     * @param {?} element
                     * @return {?}
                     */
                    function (element) {
                        params.push(element);
                    }));
                }
                return baseUrl + "?" + params.join('&');
            }).bind(this),
            strategy: bbox$1
        });
    };
    /**
     * @return {?}
     */
    ArcGISRestDataSource.prototype.getLegend = /**
     * @return {?}
     */
    function () {
        var e_1, _a;
        /** @type {?} */
        var legendInfo = this.options.params.legendInfo;
        /** @type {?} */
        var legend = _super.prototype.getLegend.call(this);
        if (legendInfo === undefined || legend.length > 0) {
            return legend;
        }
        /** @type {?} */
        var id = parseInt(this.options.layer, 10);
        /** @type {?} */
        var lyr = legendInfo.layers[id];
        /** @type {?} */
        var htmlString = '<table><tr><td>' + lyr.layerName + '</td></tr>';
        try {
            for (var _b = __values(lyr.legend), _c = _b.next(); !_c.done; _c = _b.next()) {
                var lyrLegend = _c.value;
                /** @type {?} */
                var modifiedUrl = this.options.url.replace('FeatureServer', 'MapServer');
                /** @type {?} */
                var src = modifiedUrl + "/" + lyr.layerId + "/images/" + lyrLegend.url;
                /** @type {?} */
                var label = lyrLegend.label.replace('<Null>', 'Null');
                htmlString +=
                    "<tr><td align='left'><img src=\"" +
                        src +
                        "\" alt ='' /></td><td>" +
                        label +
                        '</td></tr>';
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        htmlString += '</table>';
        return [{ html: htmlString }];
    };
    /**
     * @return {?}
     */
    ArcGISRestDataSource.prototype.onUnwatch = /**
     * @return {?}
     */
    function () { };
    return ArcGISRestDataSource;
}(DataSource));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var TileArcGISRestDataSource = /** @class */ (function (_super) {
    __extends(TileArcGISRestDataSource, _super);
    function TileArcGISRestDataSource() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(TileArcGISRestDataSource.prototype, "params", {
        get: /**
         * @return {?}
         */
        function () {
            return (/** @type {?} */ (this.options.params));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TileArcGISRestDataSource.prototype, "queryTitle", {
        get: /**
         * @return {?}
         */
        function () {
            return ((/** @type {?} */ (this.options))).queryTitle
                ? ((/** @type {?} */ (this.options))).queryTitle
                : 'title';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TileArcGISRestDataSource.prototype, "mapLabel", {
        get: /**
         * @return {?}
         */
        function () {
            return ((/** @type {?} */ (this.options))).mapLabel;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TileArcGISRestDataSource.prototype, "queryHtmlTarget", {
        get: /**
         * @return {?}
         */
        function () {
            return ((/** @type {?} */ (this.options))).queryHtmlTarget
                ? ((/** @type {?} */ (this.options))).queryHtmlTarget
                : QueryHtmlTarget.BLANK;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @protected
     * @return {?}
     */
    TileArcGISRestDataSource.prototype.createOlSource = /**
     * @protected
     * @return {?}
     */
    function () {
        return new olSourceTileArcGISRest(this.options);
    };
    /**
     * @return {?}
     */
    TileArcGISRestDataSource.prototype.getLegend = /**
     * @return {?}
     */
    function () {
        var e_1, _a;
        /** @type {?} */
        var legend = _super.prototype.getLegend.call(this);
        if (this.options.legendInfo === undefined || legend.length > 0) {
            return legend;
        }
        /** @type {?} */
        var id = parseInt(this.options.layer, 10);
        /** @type {?} */
        var lyr = this.options.legendInfo.layers[id];
        /** @type {?} */
        var htmlString = '<table><tr><td>' + lyr.layerName + '</td></tr>';
        try {
            for (var _b = __values(lyr.legend), _c = _b.next(); !_c.done; _c = _b.next()) {
                var lyrLegend = _c.value;
                /** @type {?} */
                var src = this.options.url + "/" + lyr.layerId + "/images/" + lyrLegend.url;
                /** @type {?} */
                var label = lyrLegend.label.replace('<Null>', 'Null');
                htmlString +=
                    "<tr><td align='left'><img src=\"" +
                        src +
                        "\" alt ='' /></td><td>" +
                        label +
                        '</td></tr>';
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        htmlString += '</table>';
        return [{ html: htmlString }];
    };
    /**
     * @return {?}
     */
    TileArcGISRestDataSource.prototype.onUnwatch = /**
     * @return {?}
     */
    function () { };
    return TileArcGISRestDataSource;
}(DataSource));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var WebSocketDataSource = /** @class */ (function (_super) {
    __extends(WebSocketDataSource, _super);
    function WebSocketDataSource() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @protected
     * @return {?}
     */
    WebSocketDataSource.prototype.createOlSource = /**
     * @protected
     * @return {?}
     */
    function () {
        this.createWebSocket();
        this.options.format = this.getSourceFormatFromOptions(this.options);
        return _super.prototype.createOlSource.call(this);
    };
    /**
     * @private
     * @return {?}
     */
    WebSocketDataSource.prototype.createWebSocket = /**
     * @private
     * @return {?}
     */
    function () {
        this.ws = new WebSocket(this.options.url);
        this.ws.onmessage = this.onMessage.bind(this);
        if (this.options.onclose) {
            this.ws.onclose = this.onClose.bind(this);
        }
        if (this.options.onerror) {
            this.ws.onerror = this.onError.bind(this);
        }
        if (this.options.onopen) {
            this.ws.onopen = this.onOpen.bind(this);
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    WebSocketDataSource.prototype.onMessage = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var featureAdded = this.options.format.readFeature(event.data);
        switch (this.options.onmessage) {
            case 'update':
                // ol don't add if same ID
                /** @type {?} */
                var featureToRemove = this.ol.getFeatureById(featureAdded.getId());
                if (featureToRemove) {
                    this.ol.removeFeature(featureToRemove);
                }
                this.ol.addFeature(featureAdded);
                break;
            case 'delete':
                this.ol.clear(true);
                this.ol.addFeature(featureAdded);
                break;
            case 'add':
            default:
                this.ol.addFeature(featureAdded);
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    WebSocketDataSource.prototype.onClose = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        // thrown message to user
    };
    /**
     * @param {?} event
     * @return {?}
     */
    WebSocketDataSource.prototype.onError = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        // thrown message to user
    };
    /**
     * @param {?} event
     * @return {?}
     */
    WebSocketDataSource.prototype.onOpen = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        // thrown message to user ?
    };
    /**
     * @return {?}
     */
    WebSocketDataSource.prototype.onUnwatch = /**
     * @return {?}
     */
    function () {
        this.ws.close();
    };
    return WebSocketDataSource;
}(FeatureDataSource));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var MVTDataSource = /** @class */ (function (_super) {
    __extends(MVTDataSource, _super);
    function MVTDataSource() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @protected
     * @return {?}
     */
    MVTDataSource.prototype.createOlSource = /**
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var mvtFormat;
        if (this.options.featureClass === 'feature') {
            mvtFormat = new olFormatMVT({ featureClass: OlFeature });
        }
        else if (this.options.featureClass === undefined) {
            mvtFormat = new olFormatMVT();
        }
        this.options.format = mvtFormat;
        return new olSourceVectorTile(this.options);
    };
    /**
     * @protected
     * @return {?}
     */
    MVTDataSource.prototype.generateId = /**
     * @protected
     * @return {?}
     */
    function () {
        if (!this.options.url) {
            return uuid();
        }
        /** @type {?} */
        var chain = 'mvt' + this.options.url;
        return (/** @type {?} */ (Md5.hashStr(chain)));
    };
    /**
     * @return {?}
     */
    MVTDataSource.prototype.onUnwatch = /**
     * @return {?}
     */
    function () { };
    return MVTDataSource;
}(DataSource));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ClusterDataSource = /** @class */ (function (_super) {
    __extends(ClusterDataSource, _super);
    function ClusterDataSource() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @protected
     * @return {?}
     */
    ClusterDataSource.prototype.createOlSource = /**
     * @protected
     * @return {?}
     */
    function () {
        this.options.format = this.getSourceFormatFromOptions(this.options);
        this.options.source = _super.prototype.createOlSource.call(this);
        return new olSourceCluster(this.options);
    };
    /**
     * @protected
     * @return {?}
     */
    ClusterDataSource.prototype.generateId = /**
     * @protected
     * @return {?}
     */
    function () {
        return uuid();
    };
    /**
     * @return {?}
     */
    ClusterDataSource.prototype.onUnwatch = /**
     * @return {?}
     */
    function () { };
    return ClusterDataSource;
}(FeatureDataSource));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var FEATURE = 'Feature';
/** @enum {number} */
var FeatureMotion = {
    None: 0,
    Move: 1,
    Zoom: 2,
    Default: 3,
};
FeatureMotion[FeatureMotion.None] = 'None';
FeatureMotion[FeatureMotion.Move] = 'Move';
FeatureMotion[FeatureMotion.Zoom] = 'Zoom';
FeatureMotion[FeatureMotion.Default] = 'Default';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var LAYER = 'Layer';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
var TooltipType = {
    TITLE: 'title',
    ABSTRACT: 'abstract',
    CUSTOM: 'custom',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ImageWatcher = /** @class */ (function (_super) {
    __extends(ImageWatcher, _super);
    function ImageWatcher(layer) {
        var _this = _super.call(this) || this;
        _this.loaded = 0;
        _this.loading = 0;
        _this.source = layer.options.source.ol;
        _this.id = uuid();
        return _this;
    }
    /**
     * @protected
     * @return {?}
     */
    ImageWatcher.prototype.watch = /**
     * @protected
     * @return {?}
     */
    function () {
        var _this = this;
        this.source.on("imageloadstart", (/**
         * @param {?} e
         * @return {?}
         */
        function (e) { return _this.handleLoadStart(e); }));
        this.source.on("imageloadend", (/**
         * @param {?} e
         * @return {?}
         */
        function (e) { return _this.handleLoadEnd(e); }));
        this.source.on("imageloaderror", (/**
         * @param {?} e
         * @return {?}
         */
        function (e) { return _this.handleLoadEnd(e); }));
    };
    /**
     * @protected
     * @return {?}
     */
    ImageWatcher.prototype.unwatch = /**
     * @protected
     * @return {?}
     */
    function () {
        var _this = this;
        this.source.un("imageloadstart", (/**
         * @param {?} e
         * @return {?}
         */
        function (e) { return _this.handleLoadStart(e); }));
        this.source.un("imageloadend", (/**
         * @param {?} e
         * @return {?}
         */
        function (e) { return _this.handleLoadEnd(e); }));
        this.source.un("imageloaderror", (/**
         * @param {?} e
         * @return {?}
         */
        function (e) { return _this.handleLoadEnd(e); }));
    };
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    ImageWatcher.prototype.handleLoadStart = /**
     * @private
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (!event.image.__watchers__) {
            event.image.__watchers__ = [];
        }
        event.image.__watchers__.push(this.id);
        this.loading += 1;
        this.status = SubjectStatus.Working;
    };
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    ImageWatcher.prototype.handleLoadEnd = /**
     * @private
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (!event.image.__watchers__) {
            return;
        }
        /** @type {?} */
        var watcherIndex = event.image.__watchers__.indexOf(this.id);
        if (watcherIndex < 0) {
            return;
        }
        event.image.__watchers__.splice(watcherIndex, 1);
        this.loaded += 1;
        /** @type {?} */
        var loading = this.loading;
        if (this.loaded >= loading) {
            if (loading === this.loading) {
                this.status = SubjectStatus.Done;
                this.loaded = this.loading = 0;
            }
        }
    };
    return ImageWatcher;
}(Watcher));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var TileWatcher = /** @class */ (function (_super) {
    __extends(TileWatcher, _super);
    function TileWatcher(layer) {
        var _this = _super.call(this) || this;
        _this.loaded = 0;
        _this.loading = 0;
        _this.source = layer.options.source.ol;
        _this.id = uuid();
        return _this;
    }
    /**
     * @protected
     * @return {?}
     */
    TileWatcher.prototype.watch = /**
     * @protected
     * @return {?}
     */
    function () {
        var _this = this;
        this.source.on("tileloadstart", (/**
         * @param {?} e
         * @return {?}
         */
        function (e) { return _this.handleLoadStart(e); }));
        this.source.on("tileloadend", (/**
         * @param {?} e
         * @return {?}
         */
        function (e) { return _this.handleLoadEnd(e); }));
        this.source.on("tileloaderror", (/**
         * @param {?} e
         * @return {?}
         */
        function (e) { return _this.handleLoadEnd(e); }));
    };
    /**
     * @protected
     * @return {?}
     */
    TileWatcher.prototype.unwatch = /**
     * @protected
     * @return {?}
     */
    function () {
        var _this = this;
        this.source.un("tileloadstart", (/**
         * @param {?} e
         * @return {?}
         */
        function (e) { return _this.handleLoadStart(e); }));
        this.source.un("tileloadend", (/**
         * @param {?} e
         * @return {?}
         */
        function (e) { return _this.handleLoadEnd(e); }));
        this.source.un("tileloaderror", (/**
         * @param {?} e
         * @return {?}
         */
        function (e) { return _this.handleLoadEnd(e); }));
    };
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    TileWatcher.prototype.handleLoadStart = /**
     * @private
     * @param {?} event
     * @return {?}
     */
    function (event) {
        // This is to avoid increasing
        // the number of loaded tiles if a tile was loading
        // before subscribing to this watcher
        if (!event.tile.__watchers__) {
            event.tile.__watchers__ = [];
        }
        event.tile.__watchers__.push(this.id);
        this.loading += 1;
        this.status = SubjectStatus.Working;
    };
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    TileWatcher.prototype.handleLoadEnd = /**
     * @private
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (!event.tile.__watchers__) {
            return;
        }
        /** @type {?} */
        var watcherIndex = event.tile.__watchers__.indexOf(this.id);
        if (watcherIndex < 0) {
            return;
        }
        event.tile.__watchers__.splice(watcherIndex, 1);
        this.loaded += 1;
        /** @type {?} */
        var loading = this.loading;
        if (this.loaded >= loading) {
            if (loading === this.loading) {
                this.status = SubjectStatus.Done;
                this.loaded = this.loading = 0;
            }
        }
    };
    return TileWatcher;
}(Watcher));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Get all the layers legend
 * @param {?} layers
 * @param {?=} scale
 * @return {?} Array of legend
 */
function getLayersLegends(layers, scale) {
    var e_1, _a, e_2, _b;
    /** @type {?} */
    var legends = [];
    /** @type {?} */
    var newCanvas = document.createElement('canvas');
    /** @type {?} */
    var newContext = newCanvas.getContext('2d');
    newContext.font = '20px Calibri';
    /** @type {?} */
    var heightPos = 0;
    try {
        for (var layers_1 = __values(layers), layers_1_1 = layers_1.next(); !layers_1_1.done; layers_1_1 = layers_1.next()) {
            var layer = layers_1_1.value;
            if (layer.visible === false) {
                continue;
            }
            /** @type {?} */
            var legendUrls = layer.dataSource.getLegend(undefined, scale) || [];
            var _loop_1 = function (legendUrl) {
                if (legendUrl.url === undefined) {
                    return "continue";
                }
                /** @type {?} */
                var title = layer.title;
                // Create an image for the legend
                /** @type {?} */
                var legendImage = new Image();
                legendImage.crossOrigin = 'anonymous';
                legendImage.src = legendUrl.url;
                legendImage.onload = (/**
                 * @return {?}
                 */
                function () {
                    newContext.fillText(title, 0, heightPos);
                    newContext.drawImage(legendImage, 0, heightPos + 20);
                    heightPos += legendImage.height + 5;
                });
                // Add legend info to the list
                legends.push({
                    title: title,
                    url: legendUrl.url,
                    image: legendImage
                });
            };
            try {
                for (var legendUrls_1 = __values(legendUrls), legendUrls_1_1 = legendUrls_1.next(); !legendUrls_1_1.done; legendUrls_1_1 = legendUrls_1.next()) {
                    var legendUrl = legendUrls_1_1.value;
                    _loop_1(legendUrl);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (legendUrls_1_1 && !legendUrls_1_1.done && (_b = legendUrls_1.return)) _b.call(legendUrls_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (layers_1_1 && !layers_1_1.done && (_a = layers_1.return)) _a.call(layers_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return legends;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var VectorWatcher = /** @class */ (function (_super) {
    __extends(VectorWatcher, _super);
    function VectorWatcher(layer) {
        var _this = _super.call(this) || this;
        _this.loaded = 0;
        _this.loading = 0;
        _this.layer = layer;
        _this.id = uuid();
        return _this;
    }
    /**
     * @protected
     * @return {?}
     */
    VectorWatcher.prototype.watch = /**
     * @protected
     * @return {?}
     */
    function () {
    };
    /**
     * @protected
     * @return {?}
     */
    VectorWatcher.prototype.unwatch = /**
     * @protected
     * @return {?}
     */
    function () {
        this.layer.onUnwatch();
    };
    return VectorWatcher;
}(Watcher));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ImageLayer = /** @class */ (function (_super) {
    __extends(ImageLayer, _super);
    function ImageLayer(options, authInterceptor) {
        var _this = _super.call(this, options, authInterceptor) || this;
        _this.authInterceptor = authInterceptor;
        _this.watcher = new ImageWatcher(_this);
        _this.status$ = _this.watcher.status$;
        return _this;
    }
    /**
     * @protected
     * @return {?}
     */
    ImageLayer.prototype.createOlLayer = /**
     * @protected
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var olOptions = Object.assign({}, this.options, {
            source: (/** @type {?} */ (this.options.source.ol))
        });
        /** @type {?} */
        var image = new olLayerImage(olOptions);
        if (this.authInterceptor) {
            ((/** @type {?} */ (image.getSource()))).setImageLoadFunction((/**
             * @param {?} tile
             * @param {?} src
             * @return {?}
             */
            function (tile, src) {
                _this.customLoader(tile, src);
            }));
        }
        return image;
    };
    /**
     * @param {?} map
     * @return {?}
     */
    ImageLayer.prototype.setMap = /**
     * @param {?} map
     * @return {?}
     */
    function (map$$1) {
        if (map$$1 === undefined) {
            this.watcher.unsubscribe();
        }
        else {
            this.watcher.subscribe((/**
             * @return {?}
             */
            function () { }));
        }
        _super.prototype.setMap.call(this, map$$1);
    };
    /**
     * @private
     * @param {?} tile
     * @param {?} src
     * @return {?}
     */
    ImageLayer.prototype.customLoader = /**
     * @private
     * @param {?} tile
     * @param {?} src
     * @return {?}
     */
    function (tile, src) {
        /** @type {?} */
        var xhr = new XMLHttpRequest();
        xhr.open('GET', src);
        /** @type {?} */
        var intercepted = this.authInterceptor.interceptXhr(xhr, src);
        if (!intercepted) {
            xhr.abort();
            tile.getImage().src = src;
            return;
        }
        xhr.responseType = 'arraybuffer';
        xhr.onload = (/**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var arrayBufferView = new Uint8Array(((/** @type {?} */ (this))).response);
            /** @type {?} */
            var blob = new Blob([arrayBufferView], { type: 'image/png' });
            /** @type {?} */
            var urlCreator = window.URL;
            /** @type {?} */
            var imageUrl = urlCreator.createObjectURL(blob);
            tile.getImage().src = imageUrl;
        });
        xhr.send();
    };
    return ImageLayer;
}(Layer));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var TileLayer = /** @class */ (function (_super) {
    __extends(TileLayer, _super);
    function TileLayer(options) {
        var _this = _super.call(this, options) || this;
        _this.watcher = new TileWatcher(_this);
        _this.status$ = _this.watcher.status$;
        return _this;
    }
    /**
     * @protected
     * @return {?}
     */
    TileLayer.prototype.createOlLayer = /**
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var olOptions = Object.assign({}, this.options, {
            source: (/** @type {?} */ (this.options.source.ol))
        });
        return new olLayerTile(olOptions);
    };
    /**
     * @param {?} map
     * @return {?}
     */
    TileLayer.prototype.setMap = /**
     * @param {?} map
     * @return {?}
     */
    function (map$$1) {
        if (map$$1 === undefined) {
            this.watcher.unsubscribe();
        }
        else {
            this.watcher.subscribe((/**
             * @return {?}
             */
            function () { }));
        }
        _super.prototype.setMap.call(this, map$$1);
    };
    return TileLayer;
}(Layer));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var VectorLayer = /** @class */ (function (_super) {
    __extends(VectorLayer, _super);
    function VectorLayer(options) {
        var _this = _super.call(this, options) || this;
        _this.watcher = new VectorWatcher(_this);
        _this.status$ = _this.watcher.status$;
        return _this;
    }
    Object.defineProperty(VectorLayer.prototype, "browsable", {
        get: /**
         * @return {?}
         */
        function () {
            return this.options.browsable !== false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VectorLayer.prototype, "exportable", {
        get: /**
         * @return {?}
         */
        function () {
            return this.options.exportable !== false;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @protected
     * @return {?}
     */
    VectorLayer.prototype.createOlLayer = /**
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var olOptions = Object.assign({}, this.options, {
            source: (/** @type {?} */ (this.options.source.ol))
        });
        if (this.options.animation) {
            this.dataSource.ol.on('addfeature', (/**
             * @param {?} e
             * @return {?}
             */
            function (e) {
                this.flash(e.feature);
            }).bind(this));
        }
        if (this.options.trackFeature) {
            this.enableTrackFeature(this.options.trackFeature);
        }
        return new OlVectorLayer(olOptions);
    };
    /**
     * @protected
     * @param {?} feature
     * @return {?}
     */
    VectorLayer.prototype.flash = /**
     * @protected
     * @param {?} feature
     * @return {?}
     */
    function (feature) {
        /** @type {?} */
        var start = new Date().getTime();
        /** @type {?} */
        var listenerKey = this.map.ol.on('postcompose', animate$$1.bind(this));
        /**
         * @param {?} event
         * @return {?}
         */
        function animate$$1(event) {
            /** @type {?} */
            var vectorContext = event.vectorContext;
            /** @type {?} */
            var frameState = event.frameState;
            /** @type {?} */
            var flashGeom = feature.getGeometry().clone();
            /** @type {?} */
            var elapsed = frameState.time - start;
            /** @type {?} */
            var elapsedRatio = elapsed / this.options.animation.duration;
            /** @type {?} */
            var opacity = easeOut(1 - elapsedRatio);
            /** @type {?} */
            var newColor = asArray(this.options.animation.color || 'red');
            newColor[3] = opacity;
            /** @type {?} */
            var style$$1 = this.ol
                .getStyleFunction()
                .call(this, feature)
                .find((/**
             * @param {?} style2
             * @return {?}
             */
            function (style2) {
                return style2.getImage();
            }));
            if (!style$$1) {
                style$$1 = this.ol.getStyleFunction().call(this, feature)[0];
            }
            /** @type {?} */
            var styleClone = style$$1.clone();
            switch (feature.getGeometry().getType()) {
                case 'Point':
                    /** @type {?} */
                    var radius = easeOut(elapsedRatio) * (styleClone.getImage().getRadius() * 3);
                    styleClone.getImage().setRadius(radius);
                    styleClone.getImage().setOpacity(opacity);
                    break;
                case 'LineString':
                    // TODO
                    if (styleClone.getImage()) {
                        styleClone
                            .getImage()
                            .getStroke()
                            .setColor(newColor);
                        styleClone
                            .getImage()
                            .getStroke()
                            .setWidth(easeOut(elapsedRatio) *
                            (styleClone
                                .getImage()
                                .getStroke()
                                .getWidth() *
                                3));
                    }
                    if (styleClone.getStroke()) {
                        styleClone.getStroke().setColor(newColor);
                        styleClone
                            .getStroke()
                            .setWidth(easeOut(elapsedRatio) * (styleClone.getStroke().getWidth() * 3));
                    }
                    break;
                case 'Polygon':
                    // TODO
                    if (styleClone.getImage()) {
                        styleClone
                            .getImage()
                            .getFill()
                            .setColor(newColor);
                    }
                    if (styleClone.getFill()) {
                        styleClone.getFill().setColor(newColor);
                    }
                    break;
            }
            styleClone.setText('');
            vectorContext.setStyle(styleClone);
            vectorContext.drawGeometry(flashGeom);
            if (elapsed > this.options.animation.duration) {
                unByKey(listenerKey);
                // remove last geometry
                // there is a little flash before feature disappear, better solution ?
                this.map.ol.render();
                return;
            }
            // tell OpenLayers to continue postcompose animation
            this.map.ol.render();
        }
    };
    /**
     * @param {?} map
     * @return {?}
     */
    VectorLayer.prototype.setMap = /**
     * @param {?} map
     * @return {?}
     */
    function (map$$1) {
        if (map$$1 === undefined) {
            this.watcher.unsubscribe();
        }
        else {
            this.watcher.subscribe((/**
             * @return {?}
             */
            function () { }));
        }
        _super.prototype.setMap.call(this, map$$1);
    };
    /**
     * @return {?}
     */
    VectorLayer.prototype.onUnwatch = /**
     * @return {?}
     */
    function () {
        this.dataSource.onUnwatch();
        this.stopAnimation();
    };
    /**
     * @return {?}
     */
    VectorLayer.prototype.stopAnimation = /**
     * @return {?}
     */
    function () {
        this.dataSource.ol.un('addfeature', (/**
         * @param {?} e
         * @return {?}
         */
        function (e) {
            if (this.visible) {
                this.flash(e.feature);
            }
        }).bind(this));
    };
    /**
     * @param {?} id
     * @return {?}
     */
    VectorLayer.prototype.enableTrackFeature = /**
     * @param {?} id
     * @return {?}
     */
    function (id) {
        this.trackFeatureListenerId = this.dataSource.ol.on('addfeature', this.trackFeature.bind(this, id));
    };
    /**
     * @param {?} id
     * @return {?}
     */
    VectorLayer.prototype.centerMapOnFeature = /**
     * @param {?} id
     * @return {?}
     */
    function (id) {
        /** @type {?} */
        var feat = this.dataSource.ol.getFeatureById(id);
        if (feat) {
            this.map.ol.getView().setCenter(feat.getGeometry().getCoordinates());
        }
    };
    /**
     * @param {?} id
     * @param {?} feat
     * @return {?}
     */
    VectorLayer.prototype.trackFeature = /**
     * @param {?} id
     * @param {?} feat
     * @return {?}
     */
    function (id, feat) {
        if (feat.feature.getId() === id && this.visible) {
            this.centerMapOnFeature(id);
        }
    };
    /**
     * @param {?=} id
     * @return {?}
     */
    VectorLayer.prototype.disableTrackFeature = /**
     * @param {?=} id
     * @return {?}
     */
    function (id) {
        unByKey(this.trackFeatureListenerId);
    };
    return VectorLayer;
}(Layer));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var VectorTileLayer = /** @class */ (function (_super) {
    __extends(VectorTileLayer, _super);
    function VectorTileLayer(options) {
        var _this = _super.call(this, options) || this;
        _this.watcher = new TileWatcher(_this);
        _this.status$ = _this.watcher.status$;
        return _this;
    }
    /**
     * @protected
     * @return {?}
     */
    VectorTileLayer.prototype.createOlLayer = /**
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var olOptions = Object.assign({}, this.options, {
            source: (/** @type {?} */ (this.options.source.ol))
        });
        return new olLayerVectorTile(olOptions);
    };
    return VectorTileLayer;
}(Layer));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var MapBrowserComponent = /** @class */ (function () {
    function MapBrowserComponent(activityService) {
        this.activityService = activityService;
        this.id = "igo-map-target-" + new Date().getTime();
    }
    Object.defineProperty(MapBrowserComponent.prototype, "view", {
        get: /**
         * @return {?}
         */
        function () { return this._view; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._view = value;
            if (this.map !== undefined) {
                this.map.updateView(value);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    MapBrowserComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.status$$ = this.map.status$.subscribe((/**
         * @param {?} status
         * @return {?}
         */
        function (status) {
            return _this.handleStatusChange(status);
        }));
    };
    /**
     * @return {?}
     */
    MapBrowserComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        this.map.setTarget(this.id);
    };
    /**
     * @return {?}
     */
    MapBrowserComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.map.setTarget(undefined);
        this.activityService.unregister(this.activityId);
        this.status$$.unsubscribe();
    };
    /**
     * @private
     * @param {?} status
     * @return {?}
     */
    MapBrowserComponent.prototype.handleStatusChange = /**
     * @private
     * @param {?} status
     * @return {?}
     */
    function (status) {
        if (status === SubjectStatus.Working && this.activityId === undefined) {
            this.activityId = this.activityService.register();
        }
        else if (status === SubjectStatus.Done && this.activityId !== undefined) {
            this.activityService.unregister(this.activityId);
            this.activityId = undefined;
        }
    };
    MapBrowserComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igo-map-browser',
                    template: "<div [id]=\"id\" class=\"igo-map-browser-target\"></div>\r\n<ng-content></ng-content>\r\n",
                    styles: [":host{position:relative;display:block}.igo-map-browser-target,:host{width:100%;height:100%}:host>>>igo-zoom-button{position:absolute;bottom:5px;right:5px}:host>>>igo-offline-button{position:absolute;bottom:15px;right:5px}:host>>>igo-geolocate-button{position:absolute;bottom:5px;right:5px}:host>>>igo-rotation-button{position:absolute;top:calc(40px + 5px + 5px);right:5px}:host>>>igo-user-button{position:absolute;bottom:5px;right:calc(5px + 50px)}@media only screen and (orientation:portrait) and (max-width:599px),only screen and (orientation:landscape) and (max-width:959px){:host>>>igo-zoom-button{display:none}:host>>>igo-offline-button{bottom:5px}:host>>>igo-geolocate-button{bottom:5px}:host>>>igo-rotation-button{top:calc(40px + 5px + 5px)}:host>>>igo-user-button{right:calc(5px + 90px)}}:host>>>igo-baselayers-switcher{position:absolute;bottom:5px;left:5px}:host>>>.ol-attribution{left:5px;bottom:5px;text-align:left;padding:0;margin-right:90px;background-color:rgba(255,255,255,0);width:calc(100% - 100px)}:host>>>.ol-attribution.ol-logo-only{height:inherit}:host>>>.ol-attribution.ol-collapsed{background:0 0}:host>>>.ol-attribution.ol-collapsed button{-webkit-transform:none;transform:none}:host>>>.ol-attribution button{-webkit-transform:rotate(180deg);transform:rotate(180deg);background-color:#fff;cursor:pointer;outline:0}:host>>>.ol-scale-line-inner{color:#000;border-color:#000;text-shadow:#fff -1px -1px 3px,#fff 1px -1px 3px,#fff -1px 1px 3px,#fff 1px 1px 4px;box-shadow:0 1px 0 1px rgba(255,255,255,.6)}:host>>>.ol-scale-line{background-color:rgba(255,255,255,0);bottom:4px;-webkit-transform:translate(-50%);transform:translate(-50%);left:50%}:host>>>canvas{display:block}"]
                }] }
    ];
    /** @nocollapse */
    MapBrowserComponent.ctorParameters = function () { return [
        { type: ActivityService }
    ]; };
    MapBrowserComponent.propDecorators = {
        map: [{ type: Input }],
        view: [{ type: Input }]
    };
    return MapBrowserComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
var OverlayAction = {
    None: 0,
    Move: 1,
    Zoom: 2,
    ZoomIfOutMapExtent: 3,
};
OverlayAction[OverlayAction.None] = 'None';
OverlayAction[OverlayAction.Move] = 'Move';
OverlayAction[OverlayAction.Zoom] = 'Zoom';
OverlayAction[OverlayAction.ZoomIfOutMapExtent] = 'ZoomIfOutMapExtent';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var OverlayService = /** @class */ (function () {
    function OverlayService() {
        this.features$ = new BehaviorSubject([
            [],
            undefined
        ]);
    }
    /**
     * @param {?} features
     * @param {?=} action
     * @return {?}
     */
    OverlayService.prototype.setFeatures = /**
     * @param {?} features
     * @param {?=} action
     * @return {?}
     */
    function (features, action) {
        if (action === void 0) { action = OverlayAction.None; }
        this.features$.next([features, action]);
    };
    /**
     * @return {?}
     */
    OverlayService.prototype.clear = /**
     * @return {?}
     */
    function () {
        this.features$.next([[], OverlayAction.None]);
    };
    OverlayService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    OverlayService.ctorParameters = function () { return []; };
    /** @nocollapse */ OverlayService.ngInjectableDef = defineInjectable({ factory: function OverlayService_Factory() { return new OverlayService(); }, token: OverlayService, providedIn: "root" });
    return OverlayService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var OverlayDirective = /** @class */ (function () {
    function OverlayDirective(component, overlayService) {
        this.component = component;
        this.overlayService = overlayService;
        this.format = new OlGeoJSON();
    }
    Object.defineProperty(OverlayDirective.prototype, "map", {
        get: /**
         * @return {?}
         */
        function () {
            return this.component.map;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OverlayDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.features$$ = this.overlayService.features$.subscribe((/**
         * @param {?} res
         * @return {?}
         */
        function (res) {
            return _this.handleFeatures(res[0], res[1]);
        }));
    };
    /**
     * @return {?}
     */
    OverlayDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.features$$.unsubscribe();
    };
    /**
     * @private
     * @param {?} features
     * @param {?} action
     * @return {?}
     */
    OverlayDirective.prototype.handleFeatures = /**
     * @private
     * @param {?} features
     * @param {?} action
     * @return {?}
     */
    function (features, action) { };
    OverlayDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igoOverlay]'
                },] }
    ];
    /** @nocollapse */
    OverlayDirective.ctorParameters = function () { return [
        { type: MapBrowserComponent, decorators: [{ type: Self }] },
        { type: OverlayService }
    ]; };
    return OverlayDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Create an overlay layer and it's source
 * @return {?} Overlay layer
 */
function createOverlayLayer() {
    /** @type {?} */
    var overlayDataSource = new FeatureDataSource();
    return new VectorLayer({
        title: 'Overlay',
        zIndex: 300,
        source: overlayDataSource,
        style: createOverlayLayerStyle()
    });
}
/**
 * Create an overlay style with markers for points and a basic stroke/fill
 * combination for lines and polygons
 * @return {?} Style function
 */
function createOverlayLayerStyle() {
    /** @type {?} */
    var defaultStyle = createOverlayDefaultStyle();
    /** @type {?} */
    var markerStyle = createOverlayMarkerStyle();
    /** @type {?} */
    var style$$1;
    return (/**
     * @param {?} olFeature
     * @return {?}
     */
    function (olFeature) {
        if (olFeature.getId() === 'bufferFeature') {
            style$$1 = createBufferStyle(olFeature.get('bufferStroke'), 2, olFeature.get('bufferFill'), olFeature.get('bufferText'));
            return style$$1;
        }
        else {
            /** @type {?} */
            var customStyle = olFeature.get('_style');
            if (customStyle) {
                /** @type {?} */
                var styleService = new StyleService();
                return styleService.createStyle(customStyle);
            }
            /** @type {?} */
            var geometryType = olFeature.getGeometry().getType();
            style$$1 = geometryType === 'Point' ? markerStyle : defaultStyle;
            style$$1.getText().setText(olFeature.get('_mapTitle'));
            return style$$1;
        }
    });
}
/**
 * Create a basic style for lines and polygons
 * @param {?=} __0
 * @return {?} Style
 */
function createOverlayDefaultStyle(_a) {
    var _b = _a === void 0 ? {} : _a, text = _b.text, fillOpacity = _b.fillOpacity, _c = _b.strokeWidth, strokeWidth = _c === void 0 ? 2 : _c, strokeOpacity = _b.strokeOpacity, _d = _b.color, color = _d === void 0 ? [0, 161, 222, 0.3] : _d, strokeColor = _b.strokeColor;
    /** @type {?} */
    var fillWithOpacity = color.slice(0);
    /** @type {?} */
    var strokeWithOpacity = color.slice(0);
    strokeWithOpacity[3] = 1;
    if (fillOpacity) {
        fillWithOpacity[3] = fillOpacity;
    }
    if (strokeOpacity) {
        strokeWithOpacity[3] = strokeOpacity;
    }
    if (strokeColor) {
        strokeWithOpacity[0] = strokeColor[0];
        strokeWithOpacity[1] = strokeColor[1];
        strokeWithOpacity[2] = strokeColor[2];
    }
    /** @type {?} */
    var stroke = new Stroke({
        width: strokeWidth,
        color: strokeWithOpacity
    });
    /** @type {?} */
    var fill = new Fill({
        color: fillWithOpacity
    });
    return new Style({
        stroke: stroke,
        fill: fill,
        image: new Circle({
            radius: 5,
            stroke: stroke,
            fill: fill
        }),
        text: new Text({
            text: text,
            font: '12px Calibri,sans-serif',
            fill: new Fill({ color: '#000' }),
            stroke: new Stroke({ color: '#fff', width: 3 }),
            overflow: true
        })
    });
}
/**
 * Create a marker style for points
 * @param {?=} __0
 * @return {?} Style
 */
function createOverlayMarkerStyle(_a) {
    var _b = _a === void 0 ? {} : _a, text = _b.text, _c = _b.opacity, opacity = _c === void 0 ? 1 : _c, _d = _b.color, color = _d === void 0 ? 'blue' : _d, outlineColor = _b.outlineColor;
    /** @type {?} */
    var iconColor;
    /** @type {?} */
    var svgIconColor;
    /** @type {?} */
    var svgOutlineColor;
    /** @type {?} */
    var svg;
    /** @type {?} */
    var isIE = /msie\s|trident\/|edge\//i.test(window.navigator.userAgent);
    switch (color) {
        case 'blue':
            svgIconColor = '"rgb(0,161,222)"';
            iconColor = color;
            break;
        case 'red':
            svgIconColor = '"rgb(246,65,57)"';
            iconColor = color;
            break;
        case 'yellow':
            svgIconColor = '"rgb(255,215,0)"';
            iconColor = color;
            break;
        case 'green':
            svgIconColor = '"rgb(0,128,0)"';
            iconColor = color;
            break;
        default:
            svgIconColor = '"rgb(0,161,222)"';
            iconColor = 'blue';
            break;
    }
    if (outlineColor) {
        if (outlineColor instanceof Array) {
            svgOutlineColor = 'rgb(' + outlineColor[0] + ',' + outlineColor[1] + ',' + outlineColor[2] + ')';
        }
        switch (outlineColor) {
            case 'blue':
                svgOutlineColor = 'rgb(0,161,222)';
                break;
            case 'red':
                svgOutlineColor = 'rgb(246,65,57)';
                break;
            case 'yellow':
                svgOutlineColor = 'rgb(255,215,0)';
                break;
            case 'green':
                svgOutlineColor = 'rgb(0,128,0)';
                break;
        }
        svg = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" height="36" width="36" viewBox="0 0 36 36">' +
            '<path fill=' + svgIconColor + ' stroke="' + svgOutlineColor + '" stroke-width="2" d="M 17.692635,32.565644 C 15.71852,30.330584 13.290925,27.058065 11.6766,24.455732 9.3398623,20.688851 7.8905694,17.205334 7.6297492,14.728733 7.5616025,14.081649 7.5739557,12.528552 7.6513363,12.014724 8.1013861,9.0262716 9.8047068,6.3655569 12.310675,4.7364878 c 1.113691,-0.7239832 2.508083,-1.2834131 3.776687,-1.5152052 0.242945,-0.044389 0.451656,-0.09393 0.463804,-0.1100911 0.01215,-0.016161 0.638282,-0.025502 1.391411,-0.02076 1.088235,0.00685 1.450932,0.024316 1.766871,0.085071 2.650763,0.5097353 4.947142,1.8701891 6.498786,3.8501033 0.628018,0.8013587 1.297046,2.0200608 1.640967,2.9891872 0.191065,0.538399 0.427644,1.447408 0.477391,1.834287 0.0164,0.127546 0.0434,0.231902 0.06,0.231902 0.0166,0 0.03122,0.626135 0.03249,1.391411 0.0013,0.765276 -0.011,1.391411 -0.02726,1.391411 -0.01626,0 -0.05449,0.154049 -0.08495,0.342331 -0.08815,0.544879 -0.387235,1.721449 -0.604837,2.379406 -1.209421,3.656888 -4.014463,8.349762 -7.849521,13.132357 -0.790496,0.985807 -1.795217,2.167992 -1.842543,2.167992 -0.01896,0 -0.161766,-0.144111 -0.317336,-0.320246 z m 1.066937,-15.36525 c 0.133519,-0.02121 0.248766,-0.05657 0.256105,-0.07859 0.0073,-0.02202 0.04918,-0.03066 0.09298,-0.0192 0.0438,0.01145 0.107628,-0.0072 0.141834,-0.04137 0.03421,-0.03421 0.08456,-0.05474 0.111888,-0.04563 0.02733,0.0091 0.07703,-0.01077 0.110429,-0.04417 0.03341,-0.03341 0.08416,-0.05293 0.112796,-0.04338 0.02863,0.0095 0.08974,-0.01867 0.135802,-0.06271 0.04606,-0.04403 0.111902,-0.08625 0.146319,-0.09381 0.204084,-0.04483 0.762371,-0.519108 1.079463,-0.917027 0.26749,-0.335672 0.570987,-0.878795 0.529019,-0.946701 -0.01496,-0.0242 -0.0067,-0.044 0.01835,-0.044 0.05645,0 0.196809,-0.467982 0.158801,-0.529481 -0.01521,-0.02461 -0.0043,-0.04475 0.02427,-0.04475 0.03157,0 0.04365,-0.04329 0.03082,-0.11043 -0.01161,-0.06074 -0.0066,-0.110429 0.01124,-0.110429 0.01779,0 0.03235,-0.258405 0.03235,-0.574233 0,-0.315829 -0.01545,-0.574234 -0.03434,-0.574234 -0.01889,0 -0.02437,-0.03811 -0.01219,-0.08469 0.04412,-0.168712 -0.336329,-1.152668 -0.481536,-1.245401 -0.02327,-0.01486 -0.04022,-0.03992 -0.03765,-0.05568 0.01222,-0.07498 -0.156557,-0.318365 -0.406379,-0.586027 -0.295921,-0.317054 -0.773059,-0.690104 -0.83427,-0.652274 -0.0206,0.01273 -0.03745,0.0024 -0.03745,-0.02289 0,-0.06107 -0.433076,-0.2789369 -0.487546,-0.245273 -0.02338,0.01445 -0.04251,0.0068 -0.04251,-0.01695 0,-0.056281 -0.393995,-0.1865457 -0.613804,-0.2029397 -0.0943,-0.00703 -0.188579,-0.023183 -0.209503,-0.035888 -0.02092,-0.012705 -0.276571,-0.023337 -0.568105,-0.023627 -0.534044,-5.301e-4 -1.12638,0.091025 -1.12638,0.1741017 0,0.023781 -0.01713,0.032648 -0.03808,0.019705 -0.05054,-0.031232 -0.403641,0.1088602 -0.403641,0.1601422 0,0.02204 -0.01988,0.02779 -0.04417,0.01278 -0.0243,-0.01501 -0.04417,-0.0051 -0.04417,0.02209 0,0.02716 -0.01988,0.0371 -0.04417,0.02209 -0.0243,-0.01501 -0.04417,-0.0051 -0.04417,0.02209 0,0.02716 -0.01915,0.03755 -0.04256,0.02308 -0.02341,-0.01447 -0.08138,0.01252 -0.128834,0.05997 -0.04745,0.04745 -0.0974,0.07515 -0.111001,0.06155 -0.0136,-0.0136 -0.03722,0.0078 -0.05248,0.0476 -0.01526,0.03978 -0.0411,0.06408 -0.0574,0.054 -0.03277,-0.02025 -0.462299,0.323995 -0.491977,0.394291 -0.01026,0.02429 -0.07454,0.0912 -0.142856,0.148686 -0.248033,0.208705 -0.730279,0.974169 -0.672565,1.067553 0.0145,0.02346 0.0059,0.04266 -0.01914,0.04266 -0.05907,0 -0.241471,0.599428 -0.208527,0.685278 0.01385,0.0361 0.0044,0.06564 -0.02098,0.06564 -0.02539,0 -0.04169,0.0646 -0.03622,0.143558 0.0055,0.07896 -0.0042,0.213129 -0.02144,0.29816 -0.04741,0.233576 0.0511,1.055502 0.167516,1.397721 0.126048,0.370516 0.310099,0.740163 0.426484,0.856548 0.04776,0.04776 0.07554,0.08684 0.06174,0.08684 -0.0138,0 0.01516,0.05653 0.06436,0.125632 0.131301,0.184396 0.499365,0.587266 0.518785,0.567846 0.0092,-0.0092 0.09821,0.06081 0.197812,0.155562 0.09961,0.09475 0.190589,0.162786 0.202187,0.151188 0.0116,-0.0116 0.05991,0.01774 0.107361,0.06519 0.04745,0.04745 0.105426,0.07444 0.128834,0.05997 0.02341,-0.01447 0.04256,-0.0057 0.04256,0.01958 0,0.06106 0.344664,0.23496 0.399061,0.201341 0.02346,-0.0145 0.04266,-0.0059 0.04266,0.01914 0,0.05907 0.599429,0.241471 0.685279,0.208527 0.0361,-0.01385 0.06564,-0.0065 0.06564,0.01645 0,0.05196 1.079115,0.04833 1.413314,-0.0048 z"></path>'
            + '</svg>';
    }
    if (!isIE) {
        return new Style({
            image: new Icon({
                src: svg ? 'data:image/svg+xml;utf8,' + svg : './assets/igo2/geo/icons/place_' + iconColor + '_36px.svg',
                opacity: opacity,
                imgSize: [36, 36],
                // for ie
                anchor: [0.5, 0.92]
            }),
            text: new Text({
                text: text,
                font: '12px Calibri,sans-serif',
                fill: new Fill({ color: '#000' }),
                stroke: new Stroke({ color: '#fff', width: 3 }),
                overflow: true
            })
        });
    }
    else {
        return new Style({
            image: new Icon({
                src: './assets/igo2/geo/icons/place_' + iconColor + '_36px.svg',
                opacity: opacity,
                imgSize: [36, 36],
                // for ie
                anchor: [0.5, 0.92]
            }),
            text: new Text({
                text: text,
                font: '12px Calibri,sans-serif',
                fill: new Fill({ color: '#000' }),
                stroke: new Stroke({ color: '#fff', width: 3 }),
                overflow: true
            })
        });
    }
}
/**
 * @param {?=} strokeRGBA
 * @param {?=} strokeWidth
 * @param {?=} fillRGBA
 * @param {?=} bufferRadius
 * @return {?}
 */
function createBufferStyle(strokeRGBA, strokeWidth, fillRGBA, bufferRadius) {
    if (strokeRGBA === void 0) { strokeRGBA = [0, 161, 222, 1]; }
    if (strokeWidth === void 0) { strokeWidth = 2; }
    if (fillRGBA === void 0) { fillRGBA = [0, 161, 222, 0.15]; }
    /** @type {?} */
    var stroke = new Stroke({
        width: strokeWidth,
        color: strokeRGBA
    });
    /** @type {?} */
    var fill = new Stroke({
        color: fillRGBA
    });
    return new Style({
        stroke: stroke,
        fill: fill,
        image: new Circle({
            radius: 5,
            stroke: stroke,
            fill: fill
        }),
        text: new Text({
            font: '12px Calibri,sans-serif',
            text: bufferRadius,
            fill: new Fill({ color: '#000' }),
            stroke: new Stroke({ color: '#fff', width: 3 }),
            overflow: true
        })
    });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var StyleService = /** @class */ (function () {
    function StyleService() {
    }
    /**
     * @param {?} options
     * @return {?}
     */
    StyleService.prototype.createStyle = /**
     * @param {?} options
     * @return {?}
     */
    function (options) {
        if (!options) {
            return createOverlayMarkerStyle();
        }
        if (typeof options === 'function' || options instanceof Style) {
            return options;
        }
        return this.parseStyle('style', options);
    };
    /**
     * @private
     * @param {?} key
     * @param {?} value
     * @return {?}
     */
    StyleService.prototype.parseStyle = /**
     * @private
     * @param {?} key
     * @param {?} value
     * @return {?}
     */
    function (key, value) {
        var _this = this;
        /** @type {?} */
        var styleOptions = {};
        /** @type {?} */
        var olCls = this.getOlCls(key);
        if (olCls && value instanceof Object) {
            Object.keys(value).forEach((/**
             * @param {?} _key
             * @return {?}
             */
            function (_key) {
                /** @type {?} */
                var olKey = _this.getOlKey(_key);
                styleOptions[olKey] = _this.parseStyle(_key, value[_key]);
            }));
            return new olCls(styleOptions);
        }
        else {
            return value;
        }
    };
    /**
     * @private
     * @param {?} key
     * @return {?}
     */
    StyleService.prototype.getOlKey = /**
     * @private
     * @param {?} key
     * @return {?}
     */
    function (key) {
        /** @type {?} */
        var olKey;
        switch (key.toLowerCase()) {
            case 'circle':
            case 'regularshape':
            case 'icon':
                olKey = 'image';
                break;
            default:
                break;
        }
        return olKey || key;
    };
    /**
     * @private
     * @param {?} key
     * @return {?}
     */
    StyleService.prototype.getOlCls = /**
     * @private
     * @param {?} key
     * @return {?}
     */
    function (key) {
        /** @type {?} */
        var olCls = olstyle[key.charAt(0).toUpperCase() + key.slice(1)];
        if (key === 'regularshape') {
            olCls = RegularShape;
        }
        if (key === 'backgroundFill') {
            olCls = Fill;
        }
        if (key === 'backgroundStroke') {
            olCls = Stroke;
        }
        return olCls;
    };
    /**
     * @param {?} feature
     * @param {?} styleByAttribute
     * @return {?}
     */
    StyleService.prototype.createStyleByAttribute = /**
     * @param {?} feature
     * @param {?} styleByAttribute
     * @return {?}
     */
    function (feature, styleByAttribute) {
        /** @type {?} */
        var style$$1;
        /** @type {?} */
        var type = styleByAttribute.type;
        /** @type {?} */
        var attribute = styleByAttribute.attribute;
        /** @type {?} */
        var data = styleByAttribute.data;
        /** @type {?} */
        var stroke = styleByAttribute.stroke;
        /** @type {?} */
        var width = styleByAttribute.width;
        /** @type {?} */
        var fill = styleByAttribute.fill;
        /** @type {?} */
        var radius = styleByAttribute.radius;
        /** @type {?} */
        var icon = styleByAttribute.icon;
        /** @type {?} */
        var scale = styleByAttribute.scale;
        /** @type {?} */
        var size = data.length;
        /** @type {?} */
        var label = styleByAttribute.label.attribute || styleByAttribute.label;
        /** @type {?} */
        var labelStyle = this.parseStyle('text', styleByAttribute.label.style) ||
            new Text();
        labelStyle.setText(this.getLabel(feature, label));
        /** @type {?} */
        var baseStyle = styleByAttribute.baseStyle;
        if (type === 'circle') {
            for (var i = 0; i < size; i++) {
                /** @type {?} */
                var val = typeof feature.get(attribute) !== 'undefined'
                    ? feature.get(attribute)
                    : '';
                if (val === data[i] || val.toString().match(data[i])) {
                    if (icon) {
                        style$$1 = [
                            new Style({
                                image: new Icon({
                                    src: icon[i],
                                    scale: scale ? scale[i] : 1
                                })
                            })
                        ];
                        return style$$1;
                    }
                    style$$1 = [
                        new Style({
                            image: new Circle({
                                radius: radius ? radius[i] : 4,
                                stroke: new Stroke({
                                    color: stroke ? stroke[i] : 'black',
                                    width: width ? width[i] : 1
                                }),
                                fill: new Fill({
                                    color: fill ? fill[i] : 'black'
                                })
                            }),
                            text: labelStyle
                        })
                    ];
                    return style$$1;
                }
            }
            if (!feature.getStyle()) {
                style$$1 = [
                    new Style({
                        image: new Circle({
                            radius: 4,
                            stroke: new Stroke({
                                color: 'black'
                            }),
                            fill: new Fill({
                                color: '#bbbbf2'
                            })
                        })
                    })
                ];
                return style$$1;
            }
        }
        else if (type === 'regular') {
            for (var i = 0; i < size; i++) {
                /** @type {?} */
                var val = typeof feature.get(attribute) !== 'undefined'
                    ? feature.get(attribute)
                    : '';
                if (val === data[i] || val.toString().match(data[i])) {
                    style$$1 = [
                        new Style({
                            stroke: new Stroke({
                                color: stroke ? stroke[i] : 'black',
                                width: width ? width[i] : 1
                            }),
                            fill: new Fill({
                                color: fill ? fill[i] : 'rgba(255,255,255,0.4)'
                            }),
                            text: labelStyle
                        })
                    ];
                    return style$$1;
                }
            }
            if (feature instanceof OlFeature) {
                if (!feature.getStyle()) {
                    if (baseStyle) {
                        style$$1 = this.createStyle(baseStyle);
                        return style$$1;
                    }
                    style$$1 = [
                        new Style({
                            stroke: new Stroke({
                                color: 'black'
                            }),
                            fill: new Fill({
                                color: '#bbbbf2'
                            })
                        })
                    ];
                    return style$$1;
                }
            }
        }
    };
    /**
     * @param {?} feature
     * @param {?=} clusterParam
     * @param {?=} layerStyle
     * @return {?}
     */
    StyleService.prototype.createClusterStyle = /**
     * @param {?} feature
     * @param {?=} clusterParam
     * @param {?=} layerStyle
     * @return {?}
     */
    function (feature, clusterParam, layerStyle) {
        if (clusterParam === void 0) { clusterParam = {}; }
        var e_1, _a;
        /** @type {?} */
        var style$$1;
        /** @type {?} */
        var size = feature.get('features').length;
        if (size !== 1) {
            if (clusterParam.clusterRanges) {
                try {
                    for (var _b = __values(clusterParam.clusterRanges), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var r = _c.value;
                        if ((!r.minRadius || r.minRadius <= size) &&
                            (!r.maxRadius || r.maxRadius >= size)) {
                            style$$1 = this.createStyle(r.style);
                            if (r.showRange) {
                                /** @type {?} */
                                var text = new Text({
                                    text: size.toString(),
                                    fill: new Fill({
                                        color: '#fff'
                                    })
                                });
                                style$$1.setText(text);
                            }
                            if (r.dynamicRadius) {
                                /** @type {?} */
                                var clusterRadius = void 0;
                                /** @type {?} */
                                var radiusMin = style$$1.image_.getRadius();
                                clusterRadius = 5 * Math.log(size);
                                if (clusterRadius < radiusMin) {
                                    clusterRadius = radiusMin;
                                }
                                style$$1.image_.setRadius(clusterRadius);
                            }
                            break;
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            if (!style$$1) {
                /** @type {?} */
                var clusterRadius = void 0;
                if (clusterParam.radiusCalc) {
                    clusterRadius = clusterParam.radiusCalc(size);
                }
                else {
                    /** @type {?} */
                    var radiusMin = 6;
                    clusterRadius = 5 * Math.log(size);
                    if (clusterRadius < radiusMin) {
                        clusterRadius = radiusMin;
                    }
                }
                style$$1 = [
                    new Style({
                        image: new Circle({
                            radius: clusterRadius,
                            opacity: 0.4,
                            stroke: new Stroke({
                                color: 'black'
                            }),
                            fill: new Fill({
                                color: 'rgba(24, 134, 45, 0.5)'
                            })
                        }),
                        text: new Text({
                            text: size.toString(),
                            fill: new Fill({
                                color: '#fff'
                            })
                        })
                    })
                ];
            }
        }
        else {
            style$$1 = this.createStyle(layerStyle);
        }
        return style$$1;
    };
    /**
     * @param {?} feature
     * @param {?} labelMatch
     * @return {?}
     */
    StyleService.prototype.getLabel = /**
     * @param {?} feature
     * @param {?} labelMatch
     * @return {?}
     */
    function (feature, labelMatch) {
        /** @type {?} */
        var label = labelMatch;
        /** @type {?} */
        var labelToGet = Array.from(labelMatch.matchAll(/\$\{([^\{\}]+)\}/g));
        labelToGet.forEach((/**
         * @param {?} v
         * @return {?}
         */
        function (v) {
            label = label.replace(v[0], feature.get(v[1]));
        }));
        // Nothing done? check feature's attribute
        if (labelToGet.length === 0 && label === labelMatch) {
            label = feature.get(labelMatch) || labelMatch;
        }
        return label;
    };
    StyleService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */ StyleService.ngInjectableDef = defineInjectable({ factory: function StyleService_Factory() { return new StyleService(); }, token: StyleService, providedIn: "root" });
    return StyleService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Whether a layer is queryable
 * @param {?} layer Layer
 * @return {?} True if the layer s squeryable
 */
function layerIsQueryable(layer) {
    /** @type {?} */
    var dataSource = (/** @type {?} */ (layer.dataSource));
    return dataSource.options.queryable === true;
}
/**
 * Whether an OL layer is queryable
 * @param {?} olLayer
 * @return {?} True if the ol layer is queryable
 */
function olLayerIsQueryable(olLayer) {
    /** @type {?} */
    var layer = olLayer.get('_layer');
    return layer === undefined ? false : layerIsQueryable(layer);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var LayerItemComponent = /** @class */ (function () {
    function LayerItemComponent(networkService, renderer, elRef) {
        this.networkService = networkService;
        this.renderer = renderer;
        this.elRef = elRef;
        this.focusedCls = 'igo-layer-item-focused';
        this.layerTool$ = new BehaviorSubject(false);
        this.showLegend$ = new BehaviorSubject(true);
        this.inResolutionRange$ = new BehaviorSubject(true);
        this.queryBadgeHidden$ = new BehaviorSubject(true);
        this._selectAll = false;
        this.layers$ = new BehaviorSubject(undefined);
        this.toggleLegendOnVisibilityChange = false;
        this.expandLegendIfVisible = false;
        this.updateLegendOnResolutionChange = false;
        this.orderable = true;
        this.lowerDisabled = false;
        this.raiseDisabled = false;
        this.queryBadge = false;
        this.action = new EventEmitter(undefined);
        this.checkbox = new EventEmitter();
    }
    Object.defineProperty(LayerItemComponent.prototype, "activeLayer", {
        get: /**
         * @return {?}
         */
        function () {
            return this._activeLayer;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value && this.layer && value.id === this.layer.id && !this.selectionMode) {
                this.layerTool$.next(true);
                this.renderer.addClass(this.elRef.nativeElement, this.focusedCls);
            }
            else {
                this.renderer.removeClass(this.elRef.nativeElement, this.focusedCls);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LayerItemComponent.prototype, "selectAll", {
        get: /**
         * @return {?}
         */
        function () {
            return this._selectAll;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._selectAll = value;
            if (value === true) {
                this.layerCheck = true;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LayerItemComponent.prototype, "layer", {
        get: /**
         * @return {?}
         */
        function () {
            return this._layer;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._layer = value;
            this.layers$.next(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LayerItemComponent.prototype, "removable", {
        get: /**
         * @return {?}
         */
        function () {
            return this.layer.options.removable !== false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LayerItemComponent.prototype, "opacity", {
        get: /**
         * @return {?}
         */
        function () {
            return this.layer.opacity * 100;
        },
        set: /**
         * @param {?} opacity
         * @return {?}
         */
        function (opacity) {
            this.layer.opacity = opacity / 100;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    LayerItemComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.layer.visible &&
            this.expandLegendIfVisible &&
            this.layer.firstLoadComponent === true) {
            this.layer.firstLoadComponent = false;
            this.layer.legendCollapsed = false;
        }
        this.toggleLegend(this.layer.legendCollapsed);
        this.updateQueryBadge();
        /** @type {?} */
        var resolution$ = this.layer.map.viewController.resolution$;
        this.resolution$$ = resolution$.subscribe((/**
         * @return {?}
         */
        function () {
            _this.onResolutionChange();
        }));
        this.tooltipText = this.computeTooltip();
        this.networkService.currentState().subscribe((/**
         * @param {?} state
         * @return {?}
         */
        function (state$$1) {
            _this.state = state$$1;
            _this.onResolutionChange();
        }));
        this.layers$.subscribe((/**
         * @return {?}
         */
        function () {
            if (_this.layer && _this.layer.options.active) {
                _this.layerTool$.next(true);
                _this.renderer.addClass(_this.elRef.nativeElement, _this.focusedCls);
            }
        }));
    };
    /**
     * @return {?}
     */
    LayerItemComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.resolution$$.unsubscribe();
    };
    /**
     * @param {?} collapsed
     * @return {?}
     */
    LayerItemComponent.prototype.toggleLegend = /**
     * @param {?} collapsed
     * @return {?}
     */
    function (collapsed) {
        this.layer.legendCollapsed = collapsed;
        this.showLegend$.next(!collapsed);
    };
    /**
     * @return {?}
     */
    LayerItemComponent.prototype.toggleLegendOnClick = /**
     * @return {?}
     */
    function () {
        this.toggleLegend(this.showLegend$.value);
    };
    /**
     * @return {?}
     */
    LayerItemComponent.prototype.toggleVisibility = /**
     * @return {?}
     */
    function () {
        this.layer.visible = !this.layer.visible;
        if (this.toggleLegendOnVisibilityChange) {
            this.toggleLegend(!this.layer.visible);
        }
        this.updateQueryBadge();
    };
    /**
     * @return {?}
     */
    LayerItemComponent.prototype.computeTooltip = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var layerOptions = this.layer.options;
        if (!layerOptions.tooltip) {
            return this.layer.title;
        }
        /** @type {?} */
        var layerTooltip = layerOptions.tooltip;
        /** @type {?} */
        var layerMetadata = ((/** @type {?} */ (layerOptions))).metadata;
        switch (layerOptions.tooltip.type) {
            case TooltipType.TITLE:
                return this.layer.title;
            case TooltipType.ABSTRACT:
                if (layerMetadata && layerMetadata.abstract) {
                    return layerMetadata.abstract;
                }
                else {
                    return this.layer.title;
                }
            case TooltipType.CUSTOM:
                if (layerTooltip && layerTooltip.text) {
                    return layerTooltip.text;
                }
                else {
                    return this.layer.title;
                }
            default:
                return this.layer.title;
        }
    };
    /**
     * @private
     * @return {?}
     */
    LayerItemComponent.prototype.onResolutionChange = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var inResolutionRange = this.layer.isInResolutionsRange;
        if (inResolutionRange === false &&
            this.updateLegendOnResolutionChange === true) {
            this.toggleLegend(true);
        }
        this.inResolutionRange$.next(inResolutionRange);
    };
    /**
     * @private
     * @return {?}
     */
    LayerItemComponent.prototype.updateQueryBadge = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var hidden = this.queryBadge === false ||
            this.layer.visible === false ||
            !layerIsQueryable(this.layer);
        this.queryBadgeHidden$.next(hidden);
    };
    /**
     * @return {?}
     */
    LayerItemComponent.prototype.toggleLayerTool = /**
     * @return {?}
     */
    function () {
        this.layerTool$.next(!this.layerTool$.getValue());
        if (this.layerTool$.getValue() === true) {
            this.renderer.addClass(this.elRef.nativeElement, this.focusedCls);
        }
        else {
            this.renderer.removeClass(this.elRef.nativeElement, this.focusedCls);
        }
        this.action.emit(this.layer);
    };
    /**
     * @return {?}
     */
    LayerItemComponent.prototype.check = /**
     * @return {?}
     */
    function () {
        this.layerCheck = !this.layerCheck;
        this.checkbox.emit({ layer: this.layer, check: this.layerCheck });
    };
    LayerItemComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igo-layer-item',
                    template: "<mat-list-item class= \"igo-layer-list-item\">\r\n  <mat-checkbox *ngIf=\"selectionMode\"\r\n    class=\"layerCheck\"\r\n    mat-list-icon\r\n    (change)=\"check()\"\r\n    [checked]=\"layerCheck\">\r\n  </mat-checkbox>\r\n  <h4 (click)=\"toggleLegendOnClick()\" matLine class=\"igo-layer-title\" [matTooltip]=\"tooltipText\" matTooltipShowDelay=\"500\">{{layer.title}}</h4>\r\n\r\n  <button *ngIf=\"!selectionMode\"\r\n    mat-icon-button\r\n    [color]=\"layer.visible ? 'primary' : 'default'\"\r\n    collapsibleButton\r\n    tooltip-position=\"below\"\r\n    matTooltipShowDelay=\"500\"\r\n    [matTooltip]=\"layer.visible ?\r\n                  ('igo.geo.layer.hideLayer' | translate) :\r\n                  ('igo.geo.layer.showLayer' | translate)\"\r\n    (click)=\"toggleVisibility()\">\r\n    <mat-icon\r\n      matBadge=\"?\"\r\n      matBadgeColor=\"accent\"\r\n      matBadgeSize=\"small\"\r\n      matBadgePosition=\"after\"\r\n      [matBadgeHidden]=\"queryBadgeHidden$ | async\"\r\n      [ngClass]=\"{disabled: !(inResolutionRange$ | async)}\"\r\n      [svgIcon]=\"layer.visible ? 'eye' : 'eye-off'\">\r\n    </mat-icon>\r\n  </button>\r\n\r\n  <button *ngIf=\"selectionMode\" class=\"selection-eye\"\r\n  mat-icon-button\r\n  [color]=\"layer.visible ? 'primary' : 'default'\"\r\n  collapsibleButton\r\n  tooltip-position=\"below\"\r\n  matTooltipShowDelay=\"500\"\r\n  [matTooltip]=\"layer.visible ?\r\n                ('igo.geo.layer.hideLayer' | translate) :\r\n                ('igo.geo.layer.showLayer' | translate)\"\r\n  (click)=\"toggleVisibility()\">\r\n  <mat-icon\r\n    matBadge=\"?\"\r\n    matBadgeColor=\"accent\"\r\n    matBadgeSize=\"small\"\r\n    matBadgePosition=\"after\"\r\n    [matBadgeHidden]=\"queryBadgeHidden$ | async\"\r\n    [ngClass]=\"{disabled: !(inResolutionRange$ | async)}\"\r\n    [svgIcon]=\"layer.visible ? 'eye' : 'eye-off'\">\r\n  </mat-icon>\r\n</button>\r\n\r\n  <button *ngIf=\"!selectionMode\"\r\n    tooltip-position=\"below\"\r\n    matTooltipShowDelay=\"500\"\r\n    [matTooltip]= \"'igo.geo.layer.moreOptions' | translate\"\r\n    mat-icon-button\r\n    color=\"primary\"\r\n    (click)=\"toggleLayerTool()\">\r\n    <mat-icon svgIcon=\"dots-horizontal\"></mat-icon>\r\n  </button>\r\n</mat-list-item>\r\n\r\n<div #legend class=\"igo-layer-legend-container\">\r\n  <igo-layer-legend\r\n    *ngIf=\"showLegend$ | async\"\r\n    [layer]=\"layer\"\r\n    [updateLegendOnResolutionChange]=\"updateLegendOnResolutionChange\">\r\n  </igo-layer-legend>\r\n</div>\r\n",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: [":host{overflow:hidden}mat-list-item ::ng-deep .mat-list-item-content .layerCheck{align-self:baseline;width:16px;padding-right:0}.igo-layer-list-item{height:46px;clear:both}.igo-layer-title{cursor:pointer}.igo-layer-legend-container{padding-left:18px;width:calc(100% - 18px)}mat-icon.disabled{color:rgba(0,0,0,.38)}.mat-badge-small .mat-badge-content{font-size:12px}.selection-eye{padding-right:45px}"]
                }] }
    ];
    /** @nocollapse */
    LayerItemComponent.ctorParameters = function () { return [
        { type: NetworkService },
        { type: Renderer2 },
        { type: ElementRef }
    ]; };
    LayerItemComponent.propDecorators = {
        activeLayer: [{ type: Input }],
        selectAll: [{ type: Input }],
        layerCheck: [{ type: Input }],
        layer: [{ type: Input }],
        toggleLegendOnVisibilityChange: [{ type: Input }],
        expandLegendIfVisible: [{ type: Input }],
        updateLegendOnResolutionChange: [{ type: Input }],
        orderable: [{ type: Input }],
        lowerDisabled: [{ type: Input }],
        raiseDisabled: [{ type: Input }],
        queryBadge: [{ type: Input }],
        selectionMode: [{ type: Input }],
        action: [{ type: Output }],
        checkbox: [{ type: Output }]
    };
    return LayerItemComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var LayerLegendComponent = /** @class */ (function () {
    function LayerLegendComponent(capabilitiesService, languageService) {
        this.capabilitiesService = capabilitiesService;
        this.languageService = languageService;
        this.updateLegendOnResolutionChange = false;
        /**
         * Observable of the legend items
         */
        this.legendItems$ = new BehaviorSubject([]);
        /**
         * The scale used to make the legend
         */
        this.scale = undefined;
        /**
         * List of size of images displayed
         */
        this.imagesHeight = {};
    }
    /**
     * On init, subscribe to the map's resolution and update the legend accordingly
     */
    /**
     * On init, subscribe to the map's resolution and update the legend accordingly
     * @return {?}
     */
    LayerLegendComponent.prototype.ngOnInit = /**
     * On init, subscribe to the map's resolution and update the legend accordingly
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var lastlLegend = this.layer.legend;
        this.styles = this.listStyles();
        /** @type {?} */
        var sourceOptions = (/** @type {?} */ (this.layer.options.source.options));
        if (sourceOptions &&
            sourceOptions.params &&
            sourceOptions.params.STYLES) {
            // if a styles is provided into the layers wms params
            this.currentStyle = this.styles.find((/**
             * @param {?} style
             * @return {?}
             */
            function (style$$1) { return style$$1.name === sourceOptions.params.STYLES; })).name;
        }
        else if (!this.layer.legend) {
            // if no legend is manually provided
            if (this.styles && this.styles.length > 1) {
                this.currentStyle = this.styles[0].name;
            }
        }
        else if (this.styles && this.styles.length > 1) {
            this.currentStyle = lastlLegend[0].currentStyle;
        }
        lastlLegend = this.layer.dataSource.getLegend(this.currentStyle, this.scale);
        if (this.updateLegendOnResolutionChange === true) {
            /** @type {?} */
            var resolution$ = this.layer.map.viewController.resolution$;
            this.resolution$$ = resolution$.subscribe((/**
             * @param {?} resolution
             * @return {?}
             */
            function (resolution) { return _this.onResolutionChange(resolution); }));
        }
        else if (lastlLegend.length !== 0) {
            this.legendItems$.next(lastlLegend);
        }
    };
    /**
     * On destroy, unsubscribe to the map,s resolution
     */
    /**
     * On destroy, unsubscribe to the map,s resolution
     * @return {?}
     */
    LayerLegendComponent.prototype.ngOnDestroy = /**
     * On destroy, unsubscribe to the map,s resolution
     * @return {?}
     */
    function () {
        if (this.resolution$$ !== undefined) {
            this.resolution$$.unsubscribe();
        }
    };
    /**
     * @param {?} collapsed
     * @param {?} item
     * @return {?}
     */
    LayerLegendComponent.prototype.toggleLegendItem = /**
     * @param {?} collapsed
     * @param {?} item
     * @return {?}
     */
    function (collapsed, item) {
        item.collapsed = collapsed;
    };
    /**
     * @private
     * @param {?} newLegends
     * @return {?}
     */
    LayerLegendComponent.prototype.transfertToggleLegendItem = /**
     * @private
     * @param {?} newLegends
     * @return {?}
     */
    function (newLegends) {
        /** @type {?} */
        var outLegends = newLegends;
        /** @type {?} */
        var lastLegends = this.layer.legend;
        for (var i = 0; i < lastLegends.length; i++) {
            outLegends[i].collapsed = lastLegends[i].collapsed;
        }
        return outLegends;
    };
    /**
     * @param {?} layerLegend
     * @return {?}
     */
    LayerLegendComponent.prototype.computeItemTitle = /**
     * @param {?} layerLegend
     * @return {?}
     */
    function (layerLegend) {
        /** @type {?} */
        var layerOptions = (/** @type {?} */ (this.layer.dataSource.options));
        if (layerOptions.type !== 'wms') {
            return of(layerLegend.title);
        }
        /** @type {?} */
        var layers = layerOptions.params.LAYERS.split(',');
        /** @type {?} */
        var localLayerOptions = JSON.parse(JSON.stringify(layerOptions));
        localLayerOptions.params.LAYERS = layers.find((/**
         * @param {?} layer
         * @return {?}
         */
        function (layer) { return layer === layerLegend.title; }));
        return this.capabilitiesService
            .getWMSOptions(localLayerOptions)
            .pipe(map((/**
         * @param {?} wmsDataSourceOptions
         * @return {?}
         */
        function (wmsDataSourceOptions) {
            return wmsDataSourceOptions._layerOptionsFromSource.title;
        })));
    };
    /**
     * On resolution change, compute the effective scale level and update the
     * legend accordingly.
     * @param resolution Map resolution
     */
    /**
     * On resolution change, compute the effective scale level and update the
     * legend accordingly.
     * @private
     * @param {?} resolution Map resolution
     * @return {?}
     */
    LayerLegendComponent.prototype.onResolutionChange = /**
     * On resolution change, compute the effective scale level and update the
     * legend accordingly.
     * @private
     * @param {?} resolution Map resolution
     * @return {?}
     */
    function (resolution) {
        this.scale = this.layer.map.viewController.getScale();
        this.updateLegend();
    };
    /**
     * Update the legend with scale level and style define
     */
    /**
     * Update the legend with scale level and style define
     * @private
     * @return {?}
     */
    LayerLegendComponent.prototype.updateLegend = /**
     * Update the legend with scale level and style define
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var legendItems = this.layer.dataSource.getLegend(this.currentStyle, this.scale);
        if (this.layer.legend && this.layer.legend.length > 1) {
            legendItems = this.transfertToggleLegendItem(legendItems);
        }
        this.layer.legend = legendItems;
        if (legendItems.length === 0 && this.legendItems$.value.length === 0) {
            return;
        }
        this.legendItems$.next(legendItems);
    };
    /**
     * @private
     * @return {?}
     */
    LayerLegendComponent.prototype.listStyles = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var layerOptions = this.layer.options;
        if (layerOptions && layerOptions.legendOptions) {
            /** @type {?} */
            var translate = this.languageService.translate;
            /** @type {?} */
            var title = translate.instant('igo.geo.layer.legend.default');
            /** @type {?} */
            var stylesAvailable = [(/** @type {?} */ ({ name: '', title: title }))]
                .concat(layerOptions.legendOptions.stylesAvailable.filter((/**
             * @param {?} sA
             * @return {?}
             */
            function (sA) { return (sA.name.normalize('NFD').replace(/[\u0300-\u036f]/gi, '') !== 'default' &&
                sA.name.normalize('NFD').replace(/[\u0300-\u036f]/gi, '') !== 'defaut'); })));
            stylesAvailable.map((/**
             * @param {?} s
             * @return {?}
             */
            function (s) { return s.title = s.title.charAt(0).toUpperCase() + s.title.slice(1).replace(/_/g, ' '); }));
            return stylesAvailable;
        }
        return;
    };
    /**
     * @return {?}
     */
    LayerLegendComponent.prototype.onChangeStyle = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.updateLegend();
        /** @type {?} */
        var STYLES = '';
        this.layer.dataSource.ol.getParams().LAYERS.split(',').map((/**
         * @param {?} layer
         * @return {?}
         */
        function (layer) {
            return STYLES += _this.currentStyle + ',';
        }));
        STYLES = STYLES.slice(0, -1);
        this.layer.dataSource.ol.updateParams({ STYLES: STYLES });
    };
    /**
     * @param {?} id
     * @return {?}
     */
    LayerLegendComponent.prototype.onLoadImage = /**
     * @param {?} id
     * @return {?}
     */
    function (id) {
        /** @type {?} */
        var elemRef;
        if (this.renderedLegends.length === 1) {
            elemRef = (/** @type {?} */ (this.renderedLegends.first.nativeElement));
        }
        else {
            elemRef = (/** @type {?} */ (this.renderedLegends.find((/**
             * @param {?} renderedLegend
             * @return {?}
             */
            function (renderedLegend) { return renderedLegend.nativeElement.id === id; })).nativeElement));
        }
        this.imagesHeight[id] = elemRef.height;
    };
    LayerLegendComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igo-layer-legend',
                    template: "<ng-container *ngIf=\"legendItems$ | async as items\">\r\n  <ng-container *ngIf=\"items.length; else noItems\">\r\n    <ng-container *ngFor=\"let item of items.slice().reverse()\" #renderedLegends >\r\n      <mat-list-item *ngIf=\"item.title\">\r\n        <mat-icon\r\n          id=\"legend-toggle\"\r\n          class=\"igo-chevron\"\r\n          mat-list-avatar\r\n          igoCollapse\r\n          [target]=\"legend\"\r\n          [collapsed]=\"(item.collapsed)\"\r\n          (toggle)=\"toggleLegendItem($event, item)\"\r\n          svgIcon=\"chevron-up\">\r\n        </mat-icon>\r\n        <h4 matLine>{{computeItemTitle(item) | async}} </h4>\r\n      </mat-list-item>  \r\n      <div #legend class=\"igo-layer-legend\" [ngClass]=\"{'with-title': item.title}\">\r\n        <div *ngIf=\"currentStyle !== undefined\">\r\n            <mat-form-field>\r\n              <mat-select tooltip-position=\"below\" matTooltipShowDelay=\"500\"\r\n                [matTooltip]=\"'igo.geo.layer.legend.selectStyle' | translate\" [(ngModel)]=\"currentStyle\"\r\n                (selectionChange)=\"onChangeStyle()\">\r\n                <mat-option *ngFor=\"let style of styles\" [value]=\"style.name\">{{style.title}}</mat-option>\r\n              </mat-select>\r\n          </mat-form-field>\r\n        </div>\r\n        <div *ngIf=\"!(item.collapsed)\">\r\n          <div *ngIf=\"item.url\">\r\n            <img #renderedLegend id=\"{{item.title}}\" (load)=\"onLoadImage(item.title)\"\r\n              src=\"{{(item.url | secureImage) |\u00A0async}}\"\r\n              alt=\"{{'igo.geo.layer.legend.loadingLegendText' | translate}}\"\r\n            >\r\n            <small *ngIf=\"imagesHeight[item.title]<16\">\r\n                {{'igo.geo.layer.legend.noLegendScale' | translate}}\r\n            </small>\r\n          </div>\r\n          <div\r\n            [ngStyle]=\"item.style\"\r\n            [innerHTML]=\"item.html\"\r\n            *ngIf=\"item.html\">\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </ng-container>\r\n  </ng-container>\r\n\r\n  <ng-template #noItems>\r\n    <small>\r\n      {{'igo.geo.layer.legend.noLegendText' | translate}}\r\n    </small>\r\n  </ng-template>\r\n\r\n</ng-container>\r\n",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: [".igo-layer-legend.with-title{padding-left:18px}img:after{content:' ';position:relative;height:17px;float:left;width:17px;top:-3px;right:19px;background-color:#fff;border:3px solid #f3f3f3;border-radius:50%;-webkit-animation:2s linear infinite spin;animation:2s linear infinite spin}@-moz-document url-prefix(){img:after{margin-left:19px}}@-webkit-keyframes spin{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes spin{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}"]
                }] }
    ];
    /** @nocollapse */
    LayerLegendComponent.ctorParameters = function () { return [
        { type: CapabilitiesService },
        { type: LanguageService }
    ]; };
    LayerLegendComponent.propDecorators = {
        updateLegendOnResolutionChange: [{ type: Input }],
        renderedLegends: [{ type: ViewChildren, args: ['renderedLegend',] }],
        layer: [{ type: Input }]
    };
    return LayerLegendComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var LayerLegendItemComponent = /** @class */ (function () {
    function LayerLegendItemComponent(networkService) {
        this.networkService = networkService;
        this.inResolutionRange$ = new BehaviorSubject(true);
        this.updateLegendOnResolutionChange = false;
    }
    /**
     * @return {?}
     */
    LayerLegendItemComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.layer.legendCollapsed = true;
        /** @type {?} */
        var resolution$ = this.layer.map.viewController.resolution$;
        this.resolution$$ = resolution$.subscribe((/**
         * @return {?}
         */
        function () {
            _this.onResolutionChange();
        }));
        this.tooltipText = this.computeTooltip();
        this.networkService.currentState().subscribe((/**
         * @param {?} state
         * @return {?}
         */
        function (state$$1) {
            _this.state = state$$1;
            _this.onResolutionChange();
        }));
    };
    /**
     * @return {?}
     */
    LayerLegendItemComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.resolution$$.unsubscribe();
    };
    /**
     * @return {?}
     */
    LayerLegendItemComponent.prototype.computeTooltip = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var layerOptions = this.layer.options;
        if (!layerOptions.tooltip) {
            return this.layer.title;
        }
        /** @type {?} */
        var layerTooltip = layerOptions.tooltip;
        /** @type {?} */
        var layerMetadata = ((/** @type {?} */ (layerOptions))).metadata;
        switch (layerOptions.tooltip.type) {
            case TooltipType.TITLE:
                return this.layer.title;
            case TooltipType.ABSTRACT:
                if (layerMetadata && layerMetadata.abstract) {
                    return layerMetadata.abstract;
                }
                else {
                    return this.layer.title;
                }
            case TooltipType.CUSTOM:
                if (layerTooltip && layerTooltip.text) {
                    return layerTooltip.text;
                }
                else {
                    return this.layer.title;
                }
            default:
                return this.layer.title;
        }
    };
    /**
     * @private
     * @return {?}
     */
    LayerLegendItemComponent.prototype.onResolutionChange = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var inResolutionRange = this.layer.isInResolutionsRange;
        this.inResolutionRange$.next(inResolutionRange);
    };
    LayerLegendItemComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igo-layer-legend-item',
                    template: "<mat-list-item class= \"igo-layer-list-item\">\r\n  <h4 matLine class=\"igo-layer-title\" [matTooltip]=\"tooltipText\" matTooltipShowDelay=\"500\">{{layer.title}}</h4>\r\n</mat-list-item>\r\n\r\n<div #legend class=\"igo-layer-legend-container\">\r\n  <igo-layer-legend\r\n    [layer]=\"layer\"\r\n    [updateLegendOnResolutionChange]=\"updateLegendOnResolutionChange\">\r\n  </igo-layer-legend>\r\n</div>\r\n",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: [":host{overflow:hidden}.igo-layer-list-item{height:46px;clear:both}.igo-layer-actions-container{width:100%;display:inline-block;padding-left:10px}.igo-layer-actions-container>div{text-align:center}.igo-layer-legend-container{padding-left:18px;width:calc(100% - 18px)}#opacity-slider{float:left}.igo-layer-button-group{text-align:right;padding:0 10px 0 0;width:100%}mat-icon.disabled{color:rgba(0,0,0,.38)}.mat-badge-small .mat-badge-content{font-size:12px}"]
                }] }
    ];
    /** @nocollapse */
    LayerLegendItemComponent.ctorParameters = function () { return [
        { type: NetworkService }
    ]; };
    LayerLegendItemComponent.propDecorators = {
        layer: [{ type: Input }],
        updateLegendOnResolutionChange: [{ type: Input }]
    };
    return LayerLegendItemComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var LayerLegendListComponent = /** @class */ (function () {
    function LayerLegendListComponent() {
        this.orderable = true;
        this.hasVisibleOrInRangeLayers$ = new BehaviorSubject(true);
        this.hasVisibleAndNotInRangeLayers$ = new BehaviorSubject(true);
        this.layersInUi$ = new BehaviorSubject([]);
        this.layers$ = new BehaviorSubject([]);
        this.showAllLegend = false;
        this.change$ = new ReplaySubject(1);
        this.excludeBaseLayers = false;
        this.updateLegendOnResolutionChange = false;
        this.allowShowAllLegends = false;
        this.showAllLegendsValue = false;
        this.allLegendsShown = new EventEmitter(false);
    }
    Object.defineProperty(LayerLegendListComponent.prototype, "layers", {
        get: /**
         * @return {?}
         */
        function () {
            return this._layers;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._layers = value;
            this.next();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    LayerLegendListComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.change$$ = this.change$
            .pipe(debounce((/**
         * @return {?}
         */
        function () {
            return _this.layers.length === 0 ? EMPTY : timer(50);
        })))
            .subscribe((/**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var layers = _this.computeShownLayers(_this.layers.slice(0));
            _this.layers$.next(layers);
            _this.hasVisibleOrInRangeLayers$.next(_this.layers.slice(0)
                .filter((/**
             * @param {?} layer
             * @return {?}
             */
            function (layer) { return layer.baseLayer !== true; }))
                .filter((/**
             * @param {?} layer
             * @return {?}
             */
            function (layer) { return layer.visible$.value && layer.isInResolutionsRange$.value; })).length > 0);
            _this.hasVisibleAndNotInRangeLayers$.next(_this.layers.slice(0)
                .filter((/**
             * @param {?} layer
             * @return {?}
             */
            function (layer) { return layer.baseLayer !== true; }))
                .filter((/**
             * @param {?} layer
             * @return {?}
             */
            function (layer) { return layer.visible$.value && !layer.isInResolutionsRange$.value; })).length > 0);
            _this.layersInUi$.next(_this.layers.slice(0).filter((/**
             * @param {?} layer
             * @return {?}
             */
            function (layer) { return layer.showInLayerList !== false && (!_this.excludeBaseLayers || !layer.baseLayer); })));
        }));
    };
    /**
     * @return {?}
     */
    LayerLegendListComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.change$$.unsubscribe();
    };
    /**
     * @private
     * @return {?}
     */
    LayerLegendListComponent.prototype.next = /**
     * @private
     * @return {?}
     */
    function () {
        this.change$.next();
    };
    /**
     * @private
     * @param {?} layers
     * @return {?}
     */
    LayerLegendListComponent.prototype.computeShownLayers = /**
     * @private
     * @param {?} layers
     * @return {?}
     */
    function (layers) {
        /** @type {?} */
        var shownLayers = layers.filter((/**
         * @param {?} layer
         * @return {?}
         */
        function (layer) { return layer.visible && layer.isInResolutionsRange; }));
        if (this.showAllLegendsValue) {
            shownLayers = layers;
        }
        return this.sortLayersByZindex(shownLayers);
    };
    /**
     * @private
     * @param {?} layers
     * @return {?}
     */
    LayerLegendListComponent.prototype.sortLayersByZindex = /**
     * @private
     * @param {?} layers
     * @return {?}
     */
    function (layers) {
        return layers.sort((/**
         * @param {?} layer1
         * @param {?} layer2
         * @return {?}
         */
        function (layer1, layer2) { return layer2.zIndex - layer1.zIndex; }));
    };
    /**
     * @param {?} toggle
     * @return {?}
     */
    LayerLegendListComponent.prototype.toggleShowAllLegends = /**
     * @param {?} toggle
     * @return {?}
     */
    function (toggle) {
        this.showAllLegendsValue = toggle;
        this.next();
        this.allLegendsShown.emit(toggle);
    };
    LayerLegendListComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igo-layer-legend-list',
                    template: "\r\n<mat-slide-toggle \r\ntooltip-position=\"above\"\r\nmatTooltipShowDelay=\"500\"\r\n[matTooltip]=\"'igo.geo.layer.legend.showAll' | translate\"\r\n[checked]=\"showAllLegendsValue\" class=\"mat-typography\" \r\n*ngIf=\"(layersInUi$ | async).length && allowShowAllLegends\" [labelPosition]=\"'before'\" (change)=\"toggleShowAllLegends($event.checked)\">\r\n  {{'igo.geo.layer.legend.showAll' | translate}}\r\n</mat-slide-toggle>\r\n<mat-divider *ngIf=\"(layersInUi$ | async).length && allowShowAllLegends\"></mat-divider>\r\n<igo-list [navigation]=\"false\" [selection]=\"false\">\r\n  <ng-template ngFor let-layer let-i=\"index\" [ngForOf]=\"layers$ | async\">\r\n    <igo-layer-legend-item *ngIf=\"!(excludeBaseLayers && layer.baseLayer)\"\r\n        igoListItem [layer]=\"layer\"\r\n        [updateLegendOnResolutionChange]=\"updateLegendOnResolutionChange\">\r\n    </igo-layer-legend-item>\r\n  </ng-template>\r\n</igo-list>\r\n\r\n<p class=\"layers-empty mat-typography\" \r\n  *ngIf=\"(layersInUi$ | async).length && !(hasVisibleOrInRangeLayers$ | async) && !(hasVisibleAndNotInRangeLayers$ | async) && allowShowAllLegends\">\r\n  {{'igo.geo.layer.legend.noLayersVisibleWithShowAllButton' | translate}} \r\n</p>\r\n<p class=\"layers-empty mat-typography\" \r\n  *ngIf=\"(layersInUi$ | async).length && !(hasVisibleOrInRangeLayers$ | async) && (hasVisibleAndNotInRangeLayers$ | async) && allowShowAllLegends\">\r\n  {{'igo.geo.layer.legend.noLayersVisibleWithShowAllButtonButZoom' | translate}} \r\n</p>\r\n<p class=\"layers-empty mat-typography\"\r\n  *ngIf=\"(layersInUi$ | async).length && !(hasVisibleOrInRangeLayers$ | async) && !(hasVisibleAndNotInRangeLayers$ | async) && !allowShowAllLegends\">\r\n  {{'igo.geo.layer.legend.noLayersVisible' | translate}} \r\n</p>\r\n<p class=\"layers-empty mat-typography\"\r\n  *ngIf=\"(layersInUi$ | async).length && !(hasVisibleOrInRangeLayers$ | async) && (hasVisibleAndNotInRangeLayers$ | async) && !allowShowAllLegends\">\r\n  {{'igo.geo.layer.legend.noLayersVisibleButZoom' | translate}} \r\n</p>\r\n",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: ["mat-slide-toggle{width:100%;margin:10px}mat-slide-toggle ::ng-deep .mat-slide-toggle-content{width:calc(100% - 60px)}igo-list{display:contents}.layers-empty{text-align:justify;margin:10px}"]
                }] }
    ];
    /** @nocollapse */
    LayerLegendListComponent.ctorParameters = function () { return []; };
    LayerLegendListComponent.propDecorators = {
        layers: [{ type: Input }],
        excludeBaseLayers: [{ type: Input }],
        updateLegendOnResolutionChange: [{ type: Input }],
        allowShowAllLegends: [{ type: Input }],
        showAllLegendsValue: [{ type: Input }],
        allLegendsShown: [{ type: Output }]
    };
    return LayerLegendListComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
var LayerListControlsEnum = {
    always: 'always',
    never: 'never',
    default: 'default',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// TODO: This class could use a clean up. Also, some methods could be moved ealsewhere
var LayerListComponent = /** @class */ (function () {
    function LayerListComponent(elRef) {
        this.elRef = elRef;
        this.orderable = true;
        this.thresholdToFilterAndSort = 5;
        this.layers$ = new BehaviorSubject([]);
        this.change$ = new ReplaySubject(1);
        this.showToolbar$ = new BehaviorSubject(false);
        this.activeLayer$ = new BehaviorSubject(undefined);
        this.layersChecked = [];
        this.layersAreAllVisible = true;
        this.ogcButton = true;
        this.timeButton = true;
        this.floatLabel = 'auto';
        this.layerFilterAndSortOptions = {};
        this.excludeBaseLayers = false;
        this.toggleLegendOnVisibilityChange = false;
        this.expandLegendOfVisibleLayers = false;
        this.updateLegendOnResolutionChange = false;
        this.queryBadge = false;
        this.appliedFilterAndSort = new EventEmitter();
        this._keyword = undefined;
        this._onlyVisible = false;
        this._sortedAlpha = false;
        this.toggleOpacity = false;
        this.selectAllCheck$ = new BehaviorSubject(undefined);
    }
    Object.defineProperty(LayerListComponent.prototype, "map", {
        get: /**
         * @return {?}
         */
        function () {
            return this._map;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._map = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LayerListComponent.prototype, "layers", {
        get: /**
         * @return {?}
         */
        function () {
            return this._layers;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._layers = value;
            this.next();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LayerListComponent.prototype, "activeLayer", {
        get: /**
         * @return {?}
         */
        function () {
            return this._activeLayer;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._activeLayer = value;
            this.activeLayer$.next(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LayerListComponent.prototype, "keyword", {
        get: /**
         * @return {?}
         */
        function () {
            return this._keyword;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._keyword = value;
            this.next();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LayerListComponent.prototype, "onlyVisible", {
        get: /**
         * @return {?}
         */
        function () {
            return this._onlyVisible;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._onlyVisible = value;
            this.next();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LayerListComponent.prototype, "sortAlpha", {
        get: /**
         * @return {?}
         */
        function () {
            return this._sortedAlpha;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._sortedAlpha = value;
            this.next();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LayerListComponent.prototype, "opacity", {
        get: /**
         * @return {?}
         */
        function () {
            return Math.round(this.activeLayer$.getValue().opacity * 100);
        },
        set: /**
         * @param {?} opacity
         * @return {?}
         */
        function (opacity) {
            this.activeLayer$.getValue().opacity = opacity / 100;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LayerListComponent.prototype, "badgeOpacity", {
        get: /**
         * @return {?}
         */
        function () {
            if (this.opacity === 100) {
                return;
            }
            return this.opacity;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LayerListComponent.prototype, "raiseDisabled", {
        get: /**
         * @return {?}
         */
        function () {
            if (!this.orderable || this.activeLayer.baseLayer || this.getUpperLayer().id === this.activeLayer.id ||
                this.isUpperBaselayer(this.activeLayer)) {
                return true;
            }
            return false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LayerListComponent.prototype, "lowerDisabled", {
        get: /**
         * @return {?}
         */
        function () {
            if (!this.orderable || this.activeLayer.baseLayer || this.getLowerLayer().id === this.activeLayer.id ||
                this.isLowerBaselayer(this.activeLayer)) {
                return true;
            }
            return false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LayerListComponent.prototype, "raiseDisabledSelection", {
        get: /**
         * @return {?}
         */
        function () {
            if (this.layersChecked.length === 0 || !this.orderable || !this.raisableLayers(this.layersChecked) || this.selectAllCheck === true) {
                return true;
            }
            return false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LayerListComponent.prototype, "lowerDisabledSelection", {
        get: /**
         * @return {?}
         */
        function () {
            if (this.layersChecked.length === 0 || !this.orderable || !this.lowerableLayers(this.layersChecked) || this.selectAllCheck === true) {
                return true;
            }
            return false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LayerListComponent.prototype, "checkOpacity", {
        get: /**
         * @return {?}
         */
        function () {
            return this.layersCheckedOpacity() * 100;
        },
        set: /**
         * @param {?} opacity
         * @return {?}
         */
        function (opacity) {
            var e_1, _a;
            try {
                for (var _b = __values(this.layersChecked), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var layer = _c.value;
                    layer.opacity = opacity / 100;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Subscribe to the search term stream and trigger researches
     * @internal
     */
    /**
     * Subscribe to the search term stream and trigger researches
     * \@internal
     * @return {?}
     */
    LayerListComponent.prototype.ngOnInit = /**
     * Subscribe to the search term stream and trigger researches
     * \@internal
     * @return {?}
     */
    function () {
        var _this = this;
        this.change$$ = this.change$
            .pipe(debounce((/**
         * @return {?}
         */
        function () {
            return _this.layers.length === 0 ? EMPTY : timer(50);
        })))
            .subscribe((/**
         * @return {?}
         */
        function () {
            _this.showToolbar$.next(_this.computeShowToolbar());
            _this.layers$.next(_this.computeLayers(_this.layers.slice(0)));
            _this.appliedFilterAndSort.emit({
                keyword: _this.keyword,
                sortAlpha: _this.sortAlpha,
                onlyVisible: _this.onlyVisible
            });
        }));
        this.selectAllCheck$$ = this.selectAllCheck$.subscribe((/**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            _this.selectAllCheck = value;
        }));
        this.layers$.subscribe((/**
         * @return {?}
         */
        function () {
            var e_2, _a;
            if (_this.layers) {
                /** @type {?} */
                var checks = 0;
                try {
                    for (var _b = __values(_this.layers), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var layer = _c.value;
                        if (layer.options.active) {
                            _this.activeLayer = layer;
                            _this.layerTool = true;
                        }
                        if (layer.options.check) {
                            checks += 1;
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
                if (_this.excludeBaseLayers) {
                    _this.selectAllCheck = checks === _this.layers.filter((/**
                     * @param {?} lay
                     * @return {?}
                     */
                    function (lay) { return lay.baseLayer !== true && lay.showInLayerList; })).length ? true : false;
                }
                else {
                    _this.selectAllCheck = checks === _this.layers.filter((/**
                     * @param {?} lay
                     * @return {?}
                     */
                    function (lay) { return lay.showInLayerList; })).length ? true : false;
                }
            }
        }));
    };
    /**
     * @return {?}
     */
    LayerListComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.change$$.unsubscribe();
    };
    /**
     * @return {?}
     */
    LayerListComponent.prototype.clearKeyword = /**
     * @return {?}
     */
    function () {
        this.keyword = undefined;
    };
    /**
     * @return {?}
     */
    LayerListComponent.prototype.getLowerLayer = /**
     * @return {?}
     */
    function () {
        return this.layers
            .filter((/**
         * @param {?} l
         * @return {?}
         */
        function (l) { return !l.baseLayer; }))
            .reduce((/**
         * @param {?} prev
         * @param {?} current
         * @return {?}
         */
        function (prev, current) {
            return prev.zIndex < current.zIndex ? prev : current;
        }), { zIndex: undefined, id: undefined });
    };
    /**
     * @param {?} layer
     * @return {?}
     */
    LayerListComponent.prototype.isLowerBaselayer = /**
     * @param {?} layer
     * @return {?}
     */
    function (layer) {
        /** @type {?} */
        var index = this.layers.findIndex((/**
         * @param {?} lay
         * @return {?}
         */
        function (lay) { return layer.id === lay.id; }));
        if (this.layers && this.layers[index + 1] && this.layers[index + 1].baseLayer === true) {
            return true;
        }
        return false;
    };
    /**
     * @return {?}
     */
    LayerListComponent.prototype.getUpperLayer = /**
     * @return {?}
     */
    function () {
        return this.layers
            .filter((/**
         * @param {?} l
         * @return {?}
         */
        function (l) { return !l.baseLayer; }))
            .reduce((/**
         * @param {?} prev
         * @param {?} current
         * @return {?}
         */
        function (prev, current) {
            return prev.zIndex > current.zIndex ? prev : current;
        }), { zIndex: undefined, id: undefined });
    };
    /**
     * @param {?} layer
     * @return {?}
     */
    LayerListComponent.prototype.isUpperBaselayer = /**
     * @param {?} layer
     * @return {?}
     */
    function (layer) {
        /** @type {?} */
        var index = this.layers.findIndex((/**
         * @param {?} lay
         * @return {?}
         */
        function (lay) { return layer.id === lay.id; }));
        if (this.layers && this.layers[index - 1] && this.layers[index - 1].baseLayer === true) {
            return true;
        }
        return false;
    };
    /*
     * For selection mode disabled attribute
     */
    /*
       * For selection mode disabled attribute
       */
    /**
     * @param {?} layers
     * @return {?}
     */
    LayerListComponent.prototype.raisableLayers = /*
       * For selection mode disabled attribute
       */
    /**
     * @param {?} layers
     * @return {?}
     */
    function (layers) {
        var e_3, _a;
        /** @type {?} */
        var response = false;
        /** @type {?} */
        var base = 0;
        var _loop_1 = function (layer) {
            /** @type {?} */
            var mapIndex = this_1.layers.findIndex((/**
             * @param {?} lay
             * @return {?}
             */
            function (lay) { return layer.id === lay.id; }));
            /** @type {?} */
            var currentLayer = this_1.layers[mapIndex];
            if (currentLayer.baseLayer) {
                base += 1;
            }
            /** @type {?} */
            var previousLayer = this_1.layers[mapIndex - 1];
            if (previousLayer && previousLayer.baseLayer !== true && !layers.find((/**
             * @param {?} lay
             * @return {?}
             */
            function (lay) { return previousLayer.id === lay.id; })) &&
                currentLayer.baseLayer !== true) {
                response = true;
            }
        };
        var this_1 = this;
        try {
            for (var layers_1 = __values(layers), layers_1_1 = layers_1.next(); !layers_1_1.done; layers_1_1 = layers_1.next()) {
                var layer = layers_1_1.value;
                _loop_1(layer);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (layers_1_1 && !layers_1_1.done && (_a = layers_1.return)) _a.call(layers_1);
            }
            finally { if (e_3) throw e_3.error; }
        }
        if ((this.layersChecked.length === 1 && this.layersChecked[0].baseLayer) || base === this.layersChecked.length) {
            response = false;
        }
        return response;
    };
    /*
     * When multiple layers is selected but some may be allow to move
     */
    /*
       * When multiple layers is selected but some may be allow to move
       */
    /**
     * @param {?} index
     * @return {?}
     */
    LayerListComponent.prototype.raisableLayer = /*
       * When multiple layers is selected but some may be allow to move
       */
    /**
     * @param {?} index
     * @return {?}
     */
    function (index) {
        if (index < 1) {
            return false;
        }
        if (this.layers[index - 1].options.check) {
            return this.raisableLayer(index - 1);
        }
        return true;
    };
    /**
     * @param {?} layers
     * @return {?}
     */
    LayerListComponent.prototype.raiseLayers = /**
     * @param {?} layers
     * @return {?}
     */
    function (layers) {
        var _this = this;
        var e_4, _a;
        /** @type {?} */
        var layersToRaise = [];
        var _loop_2 = function (layer) {
            /** @type {?} */
            var index = this_2.layers.findIndex((/**
             * @param {?} lay
             * @return {?}
             */
            function (lay) { return lay.id === layer.id; }));
            if (this_2.raisableLayer(index)) {
                layersToRaise.push(layer);
            }
        };
        var this_2 = this;
        try {
            for (var layers_2 = __values(layers), layers_2_1 = layers_2.next(); !layers_2_1.done; layers_2_1 = layers_2.next()) {
                var layer = layers_2_1.value;
                _loop_2(layer);
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (layers_2_1 && !layers_2_1.done && (_a = layers_2.return)) _a.call(layers_2);
            }
            finally { if (e_4) throw e_4.error; }
        }
        this.map.raiseLayers(layersToRaise);
        setTimeout((/**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var elements = _this.computeElementRef();
            if (!_this.isScrolledIntoView(elements[0], elements[1].offsetParent)) {
                elements[0].scrollTop = elements[1].offsetParent.offsetTop;
            }
        }), 100);
    };
    /*
     * For selection mode disabled attribute
     */
    /*
       * For selection mode disabled attribute
       */
    /**
     * @param {?} layers
     * @return {?}
     */
    LayerListComponent.prototype.lowerableLayers = /*
       * For selection mode disabled attribute
       */
    /**
     * @param {?} layers
     * @return {?}
     */
    function (layers) {
        var e_5, _a;
        /** @type {?} */
        var response = false;
        /** @type {?} */
        var base = 0;
        var _loop_3 = function (layer) {
            /** @type {?} */
            var mapIndex = this_3.layers.findIndex((/**
             * @param {?} lay
             * @return {?}
             */
            function (lay) { return layer.id === lay.id; }));
            /** @type {?} */
            var currentLayer = this_3.layers[mapIndex];
            if (currentLayer.baseLayer) {
                base += 1;
            }
            /** @type {?} */
            var nextLayer = this_3.layers[mapIndex + 1];
            if (nextLayer && nextLayer.baseLayer !== true && !layers.find((/**
             * @param {?} lay
             * @return {?}
             */
            function (lay) { return nextLayer.id === lay.id; }))) {
                response = true;
            }
        };
        var this_3 = this;
        try {
            for (var layers_3 = __values(layers), layers_3_1 = layers_3.next(); !layers_3_1.done; layers_3_1 = layers_3.next()) {
                var layer = layers_3_1.value;
                _loop_3(layer);
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (layers_3_1 && !layers_3_1.done && (_a = layers_3.return)) _a.call(layers_3);
            }
            finally { if (e_5) throw e_5.error; }
        }
        if ((this.layersChecked.length === 1 && this.layersChecked[0].baseLayer) || base === this.layersChecked.length) {
            response = false;
        }
        return response;
    };
    /*
     * When multiple layers is selected but some may be allow to move
     */
    /*
       * When multiple layers is selected but some may be allow to move
       */
    /**
     * @param {?} index
     * @return {?}
     */
    LayerListComponent.prototype.lowerableLayer = /*
       * When multiple layers is selected but some may be allow to move
       */
    /**
     * @param {?} index
     * @return {?}
     */
    function (index) {
        if (index > this.layers.filter((/**
         * @param {?} lay
         * @return {?}
         */
        function (lay) { return lay.baseLayer !== true; })).length - 2) {
            return false;
        }
        if (this.layers[index + 1].options.check) {
            return this.lowerableLayer(index + 1);
        }
        return true;
    };
    /**
     * @param {?} layers
     * @return {?}
     */
    LayerListComponent.prototype.lowerLayers = /**
     * @param {?} layers
     * @return {?}
     */
    function (layers) {
        var _this = this;
        var e_6, _a;
        /** @type {?} */
        var layersToLower = [];
        var _loop_4 = function (layer) {
            /** @type {?} */
            var index = this_4.layers.findIndex((/**
             * @param {?} lay
             * @return {?}
             */
            function (lay) { return lay.id === layer.id; }));
            if (this_4.lowerableLayer(index)) {
                layersToLower.push(layer);
            }
        };
        var this_4 = this;
        try {
            for (var layers_4 = __values(layers), layers_4_1 = layers_4.next(); !layers_4_1.done; layers_4_1 = layers_4.next()) {
                var layer = layers_4_1.value;
                _loop_4(layer);
            }
        }
        catch (e_6_1) { e_6 = { error: e_6_1 }; }
        finally {
            try {
                if (layers_4_1 && !layers_4_1.done && (_a = layers_4.return)) _a.call(layers_4);
            }
            finally { if (e_6) throw e_6.error; }
        }
        this.map.lowerLayers(layersToLower);
        setTimeout((/**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var elements = _this.computeElementRef('lower');
            if (!_this.isScrolledIntoView(elements[0], elements[1].offsetParent)) {
                elements[0].scrollTop = elements[1].offsetParent.offsetTop + elements[1].offsetParent.offsetHeight - elements[0].clientHeight;
            }
        }), 100);
    };
    /**
     * @private
     * @return {?}
     */
    LayerListComponent.prototype.next = /**
     * @private
     * @return {?}
     */
    function () {
        this.change$.next();
    };
    /**
     * @private
     * @param {?} layers
     * @return {?}
     */
    LayerListComponent.prototype.computeLayers = /**
     * @private
     * @param {?} layers
     * @return {?}
     */
    function (layers) {
        /** @type {?} */
        var layersOut = this.filterLayers(layers);
        if (this.sortAlpha) {
            layersOut = this.sortLayersByTitle(layersOut);
        }
        else {
            layersOut = this.sortLayersByZindex(layersOut);
        }
        return layersOut;
    };
    /**
     * @param {?} term
     * @return {?}
     */
    LayerListComponent.prototype.onKeywordChange = /**
     * @param {?} term
     * @return {?}
     */
    function (term) {
        this.keyword = term;
    };
    /**
     * @param {?} appliedFilter
     * @return {?}
     */
    LayerListComponent.prototype.onAppliedFilterAndSortChange = /**
     * @param {?} appliedFilter
     * @return {?}
     */
    function (appliedFilter) {
        this.keyword = appliedFilter.keyword;
        this.onlyVisible = appliedFilter.onlyVisible;
        this.sortAlpha = appliedFilter.sortAlpha;
    };
    /**
     * @private
     * @param {?} layers
     * @return {?}
     */
    LayerListComponent.prototype.filterLayers = /**
     * @private
     * @param {?} layers
     * @return {?}
     */
    function (layers) {
        var _this = this;
        if (this.layerFilterAndSortOptions.showToolbar === LayerListControlsEnum.never) {
            return layers;
        }
        if (!this.keyword && !this.onlyVisible) {
            return layers;
        }
        /** @type {?} */
        var keepLayerIds = layers.map((/**
         * @param {?} layer
         * @return {?}
         */
        function (layer) { return layer.id; }));
        layers.forEach((/**
         * @param {?} layer
         * @return {?}
         */
        function (layer) {
            /** @type {?} */
            var layerOptions = ((/** @type {?} */ (layer.options))) || {};
            /** @type {?} */
            var dataSourceOptions = layer.dataSource.options || {};
            /** @type {?} */
            var metadata = layerOptions.metadata || ((/** @type {?} */ ({})));
            /** @type {?} */
            var keywords = metadata.keywordList || [];
            /** @type {?} */
            var layerKeywords = keywords.map((/**
             * @param {?} kw
             * @return {?}
             */
            function (kw) {
                return kw.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
            }));
            if (_this.keyword && layer.title) {
                /** @type {?} */
                var localKeyword = _this.keyword
                    .normalize('NFD')
                    .replace(/[\u0300-\u036f]/g, '');
                /** @type {?} */
                var layerTitle = layer.title
                    .normalize('NFD')
                    .replace(/[\u0300-\u036f]/g, '');
                /** @type {?} */
                var dataSourceType = dataSourceOptions.type || '';
                /** @type {?} */
                var keywordRegex_1 = new RegExp(localKeyword, 'gi');
                /** @type {?} */
                var keywordInList = layerKeywords.find((/**
                 * @param {?} kw
                 * @return {?}
                 */
                function (kw) { return keywordRegex_1.test(kw); })) !==
                    undefined;
                if (!keywordRegex_1.test(layerTitle) &&
                    !(_this.keyword.toLowerCase() === dataSourceType.toLowerCase()) &&
                    !keywordInList) {
                    /** @type {?} */
                    var index = keepLayerIds.indexOf(layer.id);
                    if (index > -1) {
                        keepLayerIds.splice(index, 1);
                    }
                }
            }
            if (_this.onlyVisible && layer.visible === false) {
                /** @type {?} */
                var index = keepLayerIds.indexOf(layer.id);
                if (index > -1) {
                    keepLayerIds.splice(index, 1);
                }
            }
        }));
        return layers.filter((/**
         * @param {?} layer
         * @return {?}
         */
        function (layer) { return keepLayerIds.indexOf(layer.id) !== -1; }));
    };
    /**
     * @private
     * @param {?} layers
     * @return {?}
     */
    LayerListComponent.prototype.sortLayersByZindex = /**
     * @private
     * @param {?} layers
     * @return {?}
     */
    function (layers) {
        return layers.sort((/**
         * @param {?} layer1
         * @param {?} layer2
         * @return {?}
         */
        function (layer1, layer2) { return layer2.zIndex - layer1.zIndex; }));
    };
    /**
     * @private
     * @param {?} layers
     * @return {?}
     */
    LayerListComponent.prototype.sortLayersByTitle = /**
     * @private
     * @param {?} layers
     * @return {?}
     */
    function (layers) {
        var _this = this;
        return layers.sort((/**
         * @param {?} a
         * @param {?} b
         * @return {?}
         */
        function (a, b) {
            if (_this.normalize(a.title) < _this.normalize(b.title)) {
                return -1;
            }
            if (_this.normalize(a.title) > _this.normalize(b.title)) {
                return 1;
            }
            return 0;
        }));
    };
    /**
     * @private
     * @param {?} str
     * @return {?}
     */
    LayerListComponent.prototype.normalize = /**
     * @private
     * @param {?} str
     * @return {?}
     */
    function (str) {
        return str.normalize('NFD').replace(/[\u0300-\u036f]/g, '').toLowerCase();
    };
    /**
     * @private
     * @return {?}
     */
    LayerListComponent.prototype.computeShowToolbar = /**
     * @private
     * @return {?}
     */
    function () {
        switch (this.layerFilterAndSortOptions.showToolbar) {
            case LayerListControlsEnum.always:
                return true;
            case LayerListControlsEnum.never:
                return false;
            default:
                if (this.layers.length >= this.thresholdToFilterAndSort ||
                    this.keyword ||
                    this.onlyVisible) {
                    return true;
                }
                return false;
        }
    };
    /**
     * @param {?} layer
     * @return {?}
     */
    LayerListComponent.prototype.toggleLayerTool = /**
     * @param {?} layer
     * @return {?}
     */
    function (layer) {
        var e_7, _a;
        this.toggleOpacity = false;
        if (this.layerTool && layer === this.activeLayer) {
            this.layerTool = false;
        }
        else {
            this.layerTool = true;
        }
        try {
            for (var _b = __values(this.layers), _c = _b.next(); !_c.done; _c = _b.next()) {
                var lay = _c.value;
                lay.options.active = false;
            }
        }
        catch (e_7_1) { e_7 = { error: e_7_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_7) throw e_7.error; }
        }
        layer.options.active = true;
        this.activeLayer = layer;
        return;
    };
    /**
     * @param {?=} layers
     * @return {?}
     */
    LayerListComponent.prototype.removeLayers = /**
     * @param {?=} layers
     * @return {?}
     */
    function (layers) {
        var e_8, _a;
        if (layers && layers.length > 0) {
            try {
                for (var layers_5 = __values(layers), layers_5_1 = layers_5.next(); !layers_5_1.done; layers_5_1 = layers_5.next()) {
                    var layer = layers_5_1.value;
                    layer.map.removeLayer(layer);
                }
            }
            catch (e_8_1) { e_8 = { error: e_8_1 }; }
            finally {
                try {
                    if (layers_5_1 && !layers_5_1.done && (_a = layers_5.return)) _a.call(layers_5);
                }
                finally { if (e_8) throw e_8.error; }
            }
            this.layersChecked = [];
        }
        else if (!layers) {
            this.activeLayer.map.removeLayer(this.activeLayer);
            this.layerTool = false;
        }
        return;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    LayerListComponent.prototype.layersCheck = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var e_9, _a;
        event.layer.options.check = event.check;
        if (event.check === true) {
            /** @type {?} */
            var eventMapIndex = this.layers.findIndex((/**
             * @param {?} layer
             * @return {?}
             */
            function (layer) { return event.layer.id === layer.id; }));
            var _loop_5 = function (layer) {
                /** @type {?} */
                var mapIndex = this_5.layers.findIndex((/**
                 * @param {?} lay
                 * @return {?}
                 */
                function (lay) { return layer.id === lay.id; }));
                if (eventMapIndex < mapIndex) {
                    this_5.layersChecked.splice(this_5.layersChecked.findIndex((/**
                     * @param {?} lay
                     * @return {?}
                     */
                    function (lay) { return layer.id === lay.id; })), 0, event.layer);
                    if (this_5.excludeBaseLayers) {
                        if (this_5.layersChecked.length === this_5.layers.filter((/**
                         * @param {?} lay
                         * @return {?}
                         */
                        function (lay) { return (lay.baseLayer !== true && lay.showInLayerList); })).length) {
                            this_5.selectAllCheck = true;
                        }
                        else {
                            this_5.selectAllCheck = false;
                        }
                    }
                    else if (!this_5.excludeBaseLayers) {
                        if (this_5.layersChecked.length === this_5.layers.filter((/**
                         * @param {?} lay
                         * @return {?}
                         */
                        function (lay) { return lay.showInLayerList; })).length) {
                            this_5.selectAllCheck = true;
                        }
                        else {
                            this_5.selectAllCheck = false;
                        }
                    }
                    return { value: void 0 };
                }
            };
            var this_5 = this;
            try {
                for (var _b = __values(this.layersChecked), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var layer = _c.value;
                    var state_1 = _loop_5(layer);
                    if (typeof state_1 === "object")
                        return state_1.value;
                }
            }
            catch (e_9_1) { e_9 = { error: e_9_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_9) throw e_9.error; }
            }
            this.layersChecked.push(event.layer);
        }
        else {
            /** @type {?} */
            var index = this.layersChecked.findIndex((/**
             * @param {?} layer
             * @return {?}
             */
            function (layer) { return event.layer.id === layer.id; }));
            this.layersChecked.splice(index, 1);
        }
        if (this.excludeBaseLayers) {
            if (this.layersChecked.length === this.layers.filter((/**
             * @param {?} lay
             * @return {?}
             */
            function (lay) { return (lay.baseLayer !== true && lay.showInLayerList); })).length) {
                this.selectAllCheck = true;
            }
            else {
                this.selectAllCheck = false;
            }
        }
        else if (!this.excludeBaseLayers) {
            if (this.layersChecked.length === this.layers.filter((/**
             * @param {?} lay
             * @return {?}
             */
            function (lay) { return lay.showInLayerList; })).length) {
                this.selectAllCheck = true;
            }
            else {
                this.selectAllCheck = false;
            }
        }
    };
    /**
     * @param {?} value
     * @return {?}
     */
    LayerListComponent.prototype.toggleSelectionMode = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        var e_10, _a;
        this.selection = value;
        this.activeLayer = undefined;
        if (value === true) {
            this.layerTool = false;
            try {
                for (var _b = __values(this.layers), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var layer = _c.value;
                    if (layer.options.check) {
                        this.layersChecked.push(layer);
                    }
                }
            }
            catch (e_10_1) { e_10 = { error: e_10_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_10) throw e_10.error; }
            }
        }
    };
    /**
     * @return {?}
     */
    LayerListComponent.prototype.layersCheckedOpacity = /**
     * @return {?}
     */
    function () {
        var e_11, _a;
        if (this.layersChecked.length > 1) {
            return 1;
        }
        else {
            /** @type {?} */
            var opacity = [];
            try {
                for (var _b = __values(this.layersChecked), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var layer = _c.value;
                    opacity.push(layer.opacity);
                }
            }
            catch (e_11_1) { e_11 = { error: e_11_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_11) throw e_11.error; }
            }
            return opacity;
        }
    };
    /**
     * @return {?}
     */
    LayerListComponent.prototype.selectAll = /**
     * @return {?}
     */
    function () {
        var e_12, _a, e_13, _b;
        if (!this.selectAllCheck) {
            try {
                for (var _c = __values(this.layers), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var layer = _d.value;
                    if (this.excludeBaseLayers && layer.baseLayer !== true && layer.showInLayerList) {
                        layer.options.check = true;
                        this.layersChecked.push(layer);
                    }
                    else if (!this.excludeBaseLayers && layer.showInLayerList) {
                        layer.options.check = true;
                        this.layersChecked.push(layer);
                    }
                }
            }
            catch (e_12_1) { e_12 = { error: e_12_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_12) throw e_12.error; }
            }
            this.selectAllCheck$.next(true);
        }
        else {
            try {
                for (var _e = __values(this.layers), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var layer = _f.value;
                    layer.options.check = false;
                }
            }
            catch (e_13_1) { e_13 = { error: e_13_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                }
                finally { if (e_13) throw e_13.error; }
            }
            this.layersChecked = [];
            this.selectAllCheck$.next(false);
        }
    };
    /**
     * @param {?} elemSource
     * @param {?} elem
     * @return {?}
     */
    LayerListComponent.prototype.isScrolledIntoView = /**
     * @param {?} elemSource
     * @param {?} elem
     * @return {?}
     */
    function (elemSource, elem) {
        /** @type {?} */
        var docViewTop = elemSource.scrollTop;
        /** @type {?} */
        var docViewBottom = docViewTop + elemSource.clientHeight;
        /** @type {?} */
        var elemTop = elem.offsetTop;
        /** @type {?} */
        var elemBottom = elemTop + elem.clientHeight;
        return ((elemBottom <= docViewBottom) && (elemTop >= docViewTop));
    };
    /**
     * @param {?=} type
     * @return {?}
     */
    LayerListComponent.prototype.computeElementRef = /**
     * @param {?=} type
     * @return {?}
     */
    function (type) {
        /** @type {?} */
        var checkItems = this.elRef.nativeElement.getElementsByClassName('mat-checkbox-checked');
        /** @type {?} */
        var checkItem = type === 'lower' ? this.elRef.nativeElement.getElementsByClassName('mat-checkbox-checked')[checkItems.length - 1] :
            this.elRef.nativeElement.getElementsByClassName('mat-checkbox-checked')[0];
        /** @type {?} */
        var igoList = this.elRef.nativeElement.getElementsByTagName('igo-list')[0];
        return [igoList, checkItem];
    };
    LayerListComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igo-layer-list',
                    template: "<igo-list #igoList [ngClass]=\"(layerTool || selection) ? 'igo-list-min-height': 'igo-list-max-height'\" [navigation]=\"false\" [selection]=\"false\">\r\n  <igo-layer-list-tool *ngIf=\"showToolbar$ | async\"\r\n      floatLabel=\"auto\"\r\n      [layersAreAllVisible]=\"layersAreAllVisible\"\r\n      [term]=\"layerFilterAndSortOptions.keyword\"\r\n      [onlyVisible]=\"layerFilterAndSortOptions.onlyVisible\"\r\n      [sortAlpha]=\"layerFilterAndSortOptions.sortAlpha\"\r\n      (appliedFilterAndSort)=\"onAppliedFilterAndSortChange($event)\"\r\n      (selection)=\"toggleSelectionMode($event)\">\r\n    </igo-layer-list-tool>\r\n\r\n  <ng-template ngFor let-layer let-i=\"index\" [ngForOf]=\"layers$ | async\">\r\n    <igo-layer-item *ngIf=\"!(excludeBaseLayers && layer.baseLayer)\"\r\n        igoListItem\r\n        [layer]=\"layer\"\r\n        [activeLayer]=\"activeLayer\"\r\n        [orderable]=\"orderable && !layer.baseLayer\"\r\n        [lowerDisabled]=\"getLowerLayer().id === layer.id\"\r\n        [raiseDisabled]=\"getUpperLayer().id === layer.id\"\r\n        [queryBadge]=\"queryBadge\"\r\n        [expandLegendIfVisible]=\"expandLegendOfVisibleLayers\"\r\n        [updateLegendOnResolutionChange]=\"updateLegendOnResolutionChange\"\r\n        [toggleLegendOnVisibilityChange]=\"toggleLegendOnVisibilityChange\"\r\n        [selectionMode]=\"selection\"\r\n        [selectAll]=\"selectAllCheck\"\r\n        [layerCheck]=\"layer.options.check\"\r\n        (action)=\"toggleLayerTool($event)\"\r\n        (checkbox)=\"layersCheck($event)\">\r\n    </igo-layer-item>\r\n  </ng-template>\r\n</igo-list>\r\n\r\n<igo-panel *ngIf=\"!selection && layerTool && activeLayer\" class=\"igo-layer-actions-container\" [title]=\"activeLayer.title\">\r\n  <div class=\"igo-layer-button-group\">\r\n  <ng-container igoLayerItemToolbar\r\n    [ngTemplateOutlet]=\"templateLayerToolbar\"\r\n    [ngTemplateOutletContext]=\"{layer: activeLayer}\">\r\n  </ng-container>\r\n\r\n  <ng-content select=\"[igoLayerItemToolbar]\"></ng-content>\r\n    <!-- <label>{{ 'igo.geo.layer.opacity' | translate }} </label> -->\r\n    <button\r\n      color=\"primary\"\r\n      mat-icon-button\r\n      tooltip-position=\"below\"\r\n      matTooltipShowDelay=\"500\"\r\n      [matMenuTriggerFor]=\"opacityMenu\"\r\n      [matTooltip]=\"'igo.geo.layer.opacity' | translate\">\r\n      <mat-icon [matBadge]=\"badgeOpacity\" matBadgeColor=\"primary\" matBadgeSize=\"medium\" svgIcon=\"opacity\"></mat-icon>\r\n    </button>\r\n\r\n    <mat-menu #opacityMenu=\"matMenu\" class=\"mat-menu-opacity-slider\">\r\n      <div id=\"opacity-menu\">\r\n        <mat-slider\r\n          id=\"opacity-slider\"\r\n          color=\"primary\"\r\n          thumbLabel\r\n          tickInterval=\"5\"\r\n          step=\"5\"\r\n          [min]=\"0\"\r\n          [max]=\"100\"\r\n          [(ngModel)]=\"opacity\"\r\n          [matTooltip]=\"'igo.geo.layer.opacity' | translate\"\r\n          (click) = \"$event.stopPropagation()\"\r\n          matTooltipShowDelay=\"500\"\r\n          tooltip-position=\"below\">\r\n        </mat-slider>\r\n      </div>\r\n    </mat-menu>\r\n\r\n    <button\r\n      color=\"primary\"\r\n      mat-icon-button\r\n      tooltip-position=\"below\"\r\n      matTooltipShowDelay=\"500\"\r\n      [matTooltip]=\"(sortAlpha || onlyVisible || keyword) ? ('igo.geo.layer.filterRaiseLayer' | translate) : ('igo.geo.layer.raiseLayer' | translate)\"\r\n      [disabled]=\"raiseDisabled\"\r\n      (click)=\"activeLayer.map.raiseLayer(activeLayer)\">\r\n      <mat-icon [matBadge]=\"(sortAlpha || onlyVisible || keyword) ? '!' : ''\" matBadgeColor=\"warn\" matBadgeSize=\"medium\" [matBadgeHidden]=\"raiseDisabled\"\r\n                svgIcon=\"arrow-up\"></mat-icon>\r\n    </button>\r\n\r\n    <button\r\n      mat-icon-button\r\n      color=\"primary\"\r\n      tooltip-position=\"below\"\r\n      matTooltipShowDelay=\"500\"\r\n      [matTooltip]=\"(sortAlpha || onlyVisible || keyword) ? ('igo.geo.layer.filterLowerLayer' | translate) : ('igo.geo.layer.lowerLayer' | translate)\"\r\n      [disabled]=\"lowerDisabled\"\r\n      (click)=\"activeLayer.map.lowerLayer(activeLayer)\">\r\n      <mat-icon [matBadge]=\"(sortAlpha || onlyVisible || keyword) ? '!' : ''\" matBadgeColor=\"warn\" matBadgeSize=\"medium\" [matBadgeHidden]=\"lowerDisabled\"\r\n                svgIcon=\"arrow-down\"></mat-icon>\r\n    </button>\r\n\r\n    <button\r\n      mat-icon-button\r\n      color=\"warn\"\r\n      tooltip-position=\"below\"\r\n      matTooltipShowDelay=\"500\"\r\n      [matTooltip]=\"'igo.geo.layer.removeLayer' | translate\"\r\n      (click)=\"removeLayers()\">\r\n      <mat-icon svgIcon=\"delete\"></mat-icon>\r\n    </button>\r\n  </div>\r\n</igo-panel>\r\n\r\n<igo-panel *ngIf=\"selection && layers.length > 0\" class=\"igo-layer-actions-container\" [title]=\"'igo.geo.layer.tools' | translate\">\r\n  <div class=\"igo-layer-button-group\">\r\n\r\n    <button\r\n      mat-stroked-button\r\n      tooltip-position=\"below\"\r\n      matTooltipShowDelay=\"500\"\r\n      [disabled]=\"layers.length === 0\"\r\n      [matTooltip]=\"selectAllCheck ?\r\n                    ('igo.geo.layer.deselectAll' | translate) :\r\n                    ('igo.geo.layer.selectAll' | translate)\"\r\n      (click)=\"selectAll()\">\r\n      {{selectAllCheck ? ('igo.geo.layer.deselectAll' | translate) :\r\n                    ('igo.geo.layer.selectAll' | translate)}}\r\n    </button>\r\n\r\n    <!-- <label>{{ 'igo.geo.layer.opacity' | translate }} </label> -->\r\n    <button\r\n      color=\"primary\"\r\n      mat-icon-button\r\n      tooltip-position=\"below\"\r\n      matTooltipShowDelay=\"500\"\r\n      [disabled]=\"layersChecked.length === 0\"\r\n      [matMenuTriggerFor]=\"opacityMenu\"\r\n      [matTooltip]=\"'igo.geo.layer.opacity' | translate\">\r\n      <mat-icon svgIcon=\"opacity\"></mat-icon>\r\n    </button>\r\n\r\n    <mat-menu #opacityMenu=\"matMenu\"  class=\"mat-menu-opacity-slider\">\r\n      <div id=\"opacity-menu\">\r\n        <mat-slider *ngIf=\"layersChecked.length\"\r\n          id=\"opacity-slider\"\r\n          color=\"primary\"\r\n          thumbLabel\r\n          tickInterval=\"5\"\r\n          step=\"5\"\r\n          [min]=\"0\"\r\n          [max]=\"100\"\r\n          [(ngModel)]=\"checkOpacity\"\r\n          [matTooltip]=\"'igo.geo.layer.opacity' | translate\"\r\n          matTooltipShowDelay=\"500\"\r\n          tooltip-position=\"below\"\r\n          (click) = \"$event.stopPropagation()\">\r\n        </mat-slider>\r\n      </div>\r\n    </mat-menu>\r\n\r\n    <button\r\n      color=\"primary\"\r\n      mat-icon-button\r\n      tooltip-position=\"below\"\r\n      matTooltipShowDelay=\"500\"\r\n      [matTooltip]=\"(sortAlpha || onlyVisible || keyword) ? ('igo.geo.layer.filterRaiseLayer' | translate) : ('igo.geo.layer.raiseLayer' | translate)\"\r\n      [disabled]=\"raiseDisabledSelection\"\r\n      (click)=\"raiseLayers(layersChecked)\">\r\n      <mat-icon [matBadge]=\"(sortAlpha || onlyVisible || keyword) ? '!' : ''\" matBadgeColor=\"warn\" matBadgeSize=\"medium\" [matBadgeHidden]=\"raiseDisabledSelection\"\r\n                svgIcon=\"arrow-up\"></mat-icon>\r\n    </button>\r\n\r\n    <button\r\n      mat-icon-button\r\n      color=\"primary\"\r\n      tooltip-position=\"below\"\r\n      matTooltipShowDelay=\"500\"\r\n      [matTooltip]=\"(sortAlpha || onlyVisible || keyword) ? ('igo.geo.layer.filterLowerLayer' | translate) : ('igo.geo.layer.lowerLayer' | translate)\"\r\n      [disabled]=\"lowerDisabledSelection\"\r\n      (click)=\"lowerLayers(layersChecked)\">\r\n      <mat-icon [matBadge]=\"(sortAlpha || onlyVisible || keyword) ? '!' : ''\" matBadgeColor=\"warn\" matBadgeSize=\"medium\" [matBadgeHidden]=\"lowerDisabledSelection\"\r\n                svgIcon=\"arrow-down\"></mat-icon>\r\n    </button>\r\n\r\n    <button\r\n      mat-icon-button\r\n      color=\"warn\"\r\n      tooltip-position=\"below\"\r\n      matTooltipShowDelay=\"500\"\r\n      [disabled]=\"layersChecked.length === 0\"\r\n      [matTooltip]=\"'igo.geo.layer.removeLayer' | translate\"\r\n      (click)=\"removeLayers(layersChecked)\">\r\n      <mat-icon svgIcon=\"delete\"></mat-icon>\r\n    </button>\r\n  </div>\r\n</igo-panel>\r\n",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: [":host .igo-list-min-height{height:calc(100% - 91px);padding-top:8px}:host .igo-list-max-height{padding-top:8px}mat-form-field.inputFilter{width:calc(100% - 100px);max-width:200px}.igo-layer-actions-container{width:calc(100% - 5px);padding-left:5px}.igo-layer-actions-container>div{text-align:center}#opacity-slider{float:left;min-width:unset;width:110px;left:10px;top:10px}.igo-layer-button-group{display:-webkit-box;display:flex;float:right;padding-top:5px}:host igo-panel{height:unset}#opacity-menu{max-width:unset;width:132px;height:50px}#opacity-menu .mat-menu-content:not(:empty){padding-top:20px}"]
                }] }
    ];
    /** @nocollapse */
    LayerListComponent.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    LayerListComponent.propDecorators = {
        templateLayerToolbar: [{ type: ContentChild, args: ['igoLayerItemToolbar',] }],
        layersAreAllVisible: [{ type: Input }],
        ogcButton: [{ type: Input }],
        timeButton: [{ type: Input }],
        map: [{ type: Input }],
        layers: [{ type: Input }],
        floatLabel: [{ type: Input }],
        layerFilterAndSortOptions: [{ type: Input }],
        excludeBaseLayers: [{ type: Input }],
        toggleLegendOnVisibilityChange: [{ type: Input }],
        expandLegendOfVisibleLayers: [{ type: Input }],
        updateLegendOnResolutionChange: [{ type: Input }],
        queryBadge: [{ type: Input }],
        appliedFilterAndSort: [{ type: Output }]
    };
    return LayerListComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * MapService
 *
 * This service tracks the IgoMap instance, if any.
 * Currently, only one map instance is supported
 * but support for multiple maps may be added in the future.
 * This will impact other services such as the OverlayService
 * because these maps won't be sharing overlayed features.
 */
var MapService = /** @class */ (function () {
    function MapService() {
    }
    /**
     * @return {?}
     */
    MapService.prototype.getMap = /**
     * @return {?}
     */
    function () {
        return this.map;
    };
    /**
     * @param {?} map
     * @return {?}
     */
    MapService.prototype.setMap = /**
     * @param {?} map
     * @return {?}
     */
    function (map$$1) {
        this.map = map$$1;
    };
    MapService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    MapService.ctorParameters = function () { return []; };
    /** @nocollapse */ MapService.ngInjectableDef = defineInjectable({ factory: function MapService_Factory() { return new MapService(); }, token: MapService, providedIn: "root" });
    return MapService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var LayerListBindingDirective = /** @class */ (function () {
    function LayerListBindingDirective(component, mapService, route) {
        this.mapService = mapService;
        this.route = route;
        this.component = component;
    }
    /**
     * @return {?}
     */
    LayerListBindingDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // Override input layers
        // this.component.layers = [];
        this.layersOrResolutionChange$$ = combineLatest([
            this.mapService.getMap().layers$,
            this.mapService.getMap().viewController.resolution$
        ]).pipe(debounceTime(10)).subscribe((/**
         * @param {?} bunch
         * @return {?}
         */
        function (bunch) {
            /** @type {?} */
            var shownLayers = bunch[0].filter((/**
             * @param {?} layer
             * @return {?}
             */
            function (layer) {
                return layer.showInLayerList === true;
            }));
            _this.component.layers = shownLayers;
            _this.setLayersVisibilityStatus(shownLayers, _this.component.excludeBaseLayers);
        }));
    };
    /**
     * @private
     * @param {?} layers
     * @param {?} excludeBaseLayers
     * @return {?}
     */
    LayerListBindingDirective.prototype.setLayersVisibilityStatus = /**
     * @private
     * @param {?} layers
     * @param {?} excludeBaseLayers
     * @return {?}
     */
    function (layers, excludeBaseLayers) {
        var _this = this;
        if (this.layersVisibility$$ !== undefined) {
            this.layersVisibility$$.unsubscribe();
            this.layersVisibility$$ = undefined;
        }
        this.layersVisibility$$ = combineLatest(layers
            .filter((/**
         * @param {?} layer
         * @return {?}
         */
        function (layer) { return layer.baseLayer !== excludeBaseLayers; }))
            .map((/**
         * @param {?} layer
         * @return {?}
         */
        function (layer) { return layer.visible$; })))
            .pipe(map((/**
         * @param {?} visibles
         * @return {?}
         */
        function (visibles) { return visibles.every(Boolean); })))
            .subscribe((/**
         * @param {?} allLayersAreVisible
         * @return {?}
         */
        function (allLayersAreVisible) {
            return _this.component.layersAreAllVisible = allLayersAreVisible;
        }));
    };
    /**
     * @return {?}
     */
    LayerListBindingDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.layersOrResolutionChange$$.unsubscribe();
        if (this.layersVisibility$$ !== undefined) {
            this.layersVisibility$$.unsubscribe();
            this.layersVisibility$$ = undefined;
        }
    };
    LayerListBindingDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igoLayerListBinding]'
                },] }
    ];
    /** @nocollapse */
    LayerListBindingDirective.ctorParameters = function () { return [
        { type: LayerListComponent, decorators: [{ type: Self }] },
        { type: MapService },
        { type: RouteService, decorators: [{ type: Optional }] }
    ]; };
    return LayerListBindingDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var LayerListToolComponent = /** @class */ (function () {
    function LayerListToolComponent() {
        this.onlyVisible$ = new BehaviorSubject(false);
        this.sortAlpha$ = new BehaviorSubject(false);
        this.term$ = new BehaviorSubject(undefined);
        this.layersAreAllVisible = true;
        this.floatLabel = 'auto';
        this.selectionMode = false;
        this.appliedFilterAndSort = new EventEmitter();
        this.selection = new EventEmitter();
    }
    Object.defineProperty(LayerListToolComponent.prototype, "onlyVisible", {
        get: /**
         * @return {?}
         */
        function () {
            return this.onlyVisible$.value;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.onlyVisible$.next(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LayerListToolComponent.prototype, "sortAlpha", {
        get: /**
         * @return {?}
         */
        function () {
            return this.sortAlpha$.value;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.sortAlpha$.next(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LayerListToolComponent.prototype, "term", {
        get: /**
         * @return {?}
         */
        function () {
            return this.term$.value;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.term$.next(value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    LayerListToolComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.term$$ = this.term$.subscribe((/**
         * @param {?} keyword
         * @return {?}
         */
        function (keyword) {
            _this.appliedFilterAndSort.emit({
                keyword: keyword,
                onlyVisible: _this.onlyVisible,
                sortAlpha: _this.sortAlpha
            });
        }));
        this.onlyVisible$$ = this.onlyVisible$.subscribe((/**
         * @param {?} onlyVisible
         * @return {?}
         */
        function (onlyVisible) {
            _this.appliedFilterAndSort.emit({
                keyword: _this.term,
                onlyVisible: onlyVisible,
                sortAlpha: _this.sortAlpha
            });
        }));
        this.sortAlpha$$ = this.sortAlpha$.subscribe((/**
         * @param {?} sortAlpha
         * @return {?}
         */
        function (sortAlpha) {
            _this.appliedFilterAndSort.emit({
                keyword: _this.term,
                onlyVisible: _this.onlyVisible,
                sortAlpha: sortAlpha
            });
        }));
    };
    /**
     * @return {?}
     */
    LayerListToolComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.onlyVisible$$.unsubscribe();
        this.sortAlpha$$.unsubscribe();
        this.term$$.unsubscribe();
    };
    /**
     * @return {?}
     */
    LayerListToolComponent.prototype.clearTerm = /**
     * @return {?}
     */
    function () {
        this.term = undefined;
    };
    /**
     * @return {?}
     */
    LayerListToolComponent.prototype.toggleSortAlpha = /**
     * @return {?}
     */
    function () {
        this.sortAlpha = !this.sortAlpha;
    };
    /**
     * @return {?}
     */
    LayerListToolComponent.prototype.toggleOnlyVisible = /**
     * @return {?}
     */
    function () {
        this.onlyVisible = !this.onlyVisible;
    };
    /**
     * @return {?}
     */
    LayerListToolComponent.prototype.toggleSelectionMode = /**
     * @return {?}
     */
    function () {
        this.selectionMode = !this.selectionMode;
        this.selection.emit(this.selectionMode);
    };
    LayerListToolComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igo-layer-list-tool',
                    template: "\r\n\r\n  <mat-list-item>\r\n      <mat-form-field class=\"inputFilter\" [floatLabel]=\"floatLabel\">\r\n        <input\r\n          matInput\r\n          [placeholder]=\"'igo.geo.layer.filterPlaceholder' | translate\"\r\n          [matTooltip]=\"'igo.geo.layer.subsetLayersListKeyword' | translate\"\r\n          matTooltipShowDelay=\"500\"\r\n          type=\"text\" [(ngModel)]=\"term\">\r\n        <button\r\n          mat-button\r\n          *ngIf=\"term\"\r\n          matSuffix\r\n          mat-icon-button\r\n          aria-label=\"Clear\"\r\n          color=\"warn\"\r\n          (click)=\"clearTerm()\">\r\n          <mat-icon svgIcon=\"close\"></mat-icon>\r\n        </button>\r\n      </mat-form-field>\r\n\r\n      <div [matTooltip]=\"sortAlpha ?\r\n      ('igo.geo.layer.sortAlphabetically' | translate) :\r\n      ('igo.geo.layer.sortMapOrder' | translate)\" matTooltipShowDelay=\"500\">\r\n        <button [color]=\"sortAlpha ? 'warn' : 'primary'\" mat-icon-button (click)=\"toggleSortAlpha()\">\r\n          <mat-icon [svgIcon]=\"sortAlpha ? 'sort-variant-remove' : 'sort-alphabetical'\"></mat-icon>\r\n        </button>\r\n      </div>\r\n\r\n\r\n       <div [matTooltip]=\"onlyVisible ?\r\n        ('igo.geo.layer.resetLayersList' | translate) :\r\n        ('igo.geo.layer.subsetLayersListOnlyVisible' | translate)\" matTooltipShowDelay=\"500\">\r\n         <button mat-icon-button [disabled]=\"layersAreAllVisible && !onlyVisible\"\r\n           [color]=\"onlyVisible ? 'warn' : 'primary'\" (click)=\"toggleOnlyVisible()\">\r\n           <mat-icon [svgIcon]=\"onlyVisible ? 'sort-variant-remove' : 'eye'\"></mat-icon>\r\n         </button>\r\n       </div>\r\n\r\n       <div [matTooltip]=\"selectionMode ?\r\n        ('igo.geo.layer.deactivateSelectionMode' | translate) :\r\n        ('igo.geo.layer.activateSelectionMode' | translate)\" matTooltipShowDelay=\"500\">\r\n         <button mat-icon-button\r\n           color=\"primary\" (click)=\"toggleSelectionMode()\">\r\n           <mat-icon [svgIcon]=\"selectionMode ? 'checkbox-multiple-marked-outline' : 'checkbox-multiple-blank-outline'\"></mat-icon>\r\n         </button>\r\n       </div>\r\n\r\n</mat-list-item>",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: ["mat-form-field.inputFilter{width:calc(100% - 100px);max-width:200px}"]
                }] }
    ];
    LayerListToolComponent.propDecorators = {
        layersAreAllVisible: [{ type: Input }],
        floatLabel: [{ type: Input }],
        onlyVisible: [{ type: Input }],
        sortAlpha: [{ type: Input }],
        term: [{ type: Input }],
        appliedFilterAndSort: [{ type: Output }],
        selection: [{ type: Output }]
    };
    return LayerListToolComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
var LayerListToolControlsEnum = {
    always: 'always',
    never: 'never',
    default: 'default',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var LayerListToolService = /** @class */ (function () {
    function LayerListToolService() {
        this.sortAlpha = false;
        this.onlyVisible = false;
        this.onlyInRange = false;
        this.keywordInitialized = false;
        this.sortedAlphaInitialized = false;
        this.onlyVisibleInitialized = false;
        this.onlyInRangeInitialized = false;
    }
    LayerListToolService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    LayerListToolService.ctorParameters = function () { return []; };
    /** @nocollapse */ LayerListToolService.ngInjectableDef = defineInjectable({ factory: function LayerListToolService_Factory() { return new LayerListToolService(); }, token: LayerListToolService, providedIn: "root" });
    return LayerListToolService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var TrackFeatureButtonComponent = /** @class */ (function () {
    function TrackFeatureButtonComponent() {
        this.trackFeature = false;
        this.color = 'primary';
    }
    Object.defineProperty(TrackFeatureButtonComponent.prototype, "options", {
        get: /**
         * @return {?}
         */
        function () {
            if (!this.layer) {
                return;
            }
            return this.layer.options;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    TrackFeatureButtonComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.color = this.trackFeature ? 'primary' : 'basic';
    };
    /**
     * @return {?}
     */
    TrackFeatureButtonComponent.prototype.toggleTrackFeature = /**
     * @return {?}
     */
    function () {
        if (this.trackFeature) {
            this.layer.disableTrackFeature(this.layer.options.trackFeature);
            this.color = 'basic';
        }
        else {
            this.layer.enableTrackFeature(this.layer.options.trackFeature);
            this.color = 'primary';
        }
        this.trackFeature = !this.trackFeature;
    };
    TrackFeatureButtonComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igo-track-feature-button',
                    template: "<button *ngIf=\"options.trackFeature\"\r\n  mat-icon-button\r\n  collapsibleButton\r\n  tooltip-position=\"below\"\r\n  matTooltipShowDelay=\"500\"\r\n  [matTooltip]=\"'igo.geo.layer.trackFeature' | translate\"\r\n  [color]=\"color\"\r\n  (click)=\"toggleTrackFeature()\">\r\n  <mat-icon svgIcon=\"crosshairs-gps\"></mat-icon>\r\n</button>\r\n",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: [""]
                }] }
    ];
    /** @nocollapse */
    TrackFeatureButtonComponent.ctorParameters = function () { return []; };
    TrackFeatureButtonComponent.propDecorators = {
        layer: [{ type: Input }],
        trackFeature: [{ type: Input }]
    };
    return TrackFeatureButtonComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * This strategy loads a store's features into it's layer counterpart.
 * The store -> layer binding is a one-way binding. That means any entity
 * added to the store will be added to the layer but the opposite is false.
 *
 * Important: This strategy observes filtered entities, not raw entities. This
 * is not configurable yet.
 */
var  /**
 * This strategy loads a store's features into it's layer counterpart.
 * The store -> layer binding is a one-way binding. That means any entity
 * added to the store will be added to the layer but the opposite is false.
 *
 * Important: This strategy observes filtered entities, not raw entities. This
 * is not configurable yet.
 */
FeatureStoreLoadingStrategy = /** @class */ (function (_super) {
    __extends(FeatureStoreLoadingStrategy, _super);
    function FeatureStoreLoadingStrategy(options) {
        var _this = _super.call(this, options) || this;
        _this.options = options;
        /**
         * Subscription to the store's features
         */
        _this.stores$$ = new Map();
        _this.setMotion(options.motion);
        return _this;
    }
    /**
     * Bind this strategy to a store and start watching for entities changes
     * @param store Feature store
     */
    /**
     * Bind this strategy to a store and start watching for entities changes
     * @param {?} store Feature store
     * @return {?}
     */
    FeatureStoreLoadingStrategy.prototype.bindStore = /**
     * Bind this strategy to a store and start watching for entities changes
     * @param {?} store Feature store
     * @return {?}
     */
    function (store) {
        _super.prototype.bindStore.call(this, store);
        if (this.active === true) {
            this.watchStore(store);
        }
    };
    /**
     * Unbind this strategy from a store and stop watching for entities changes
     * @param store Feature store
     */
    /**
     * Unbind this strategy from a store and stop watching for entities changes
     * @param {?} store Feature store
     * @return {?}
     */
    FeatureStoreLoadingStrategy.prototype.unbindStore = /**
     * Unbind this strategy from a store and stop watching for entities changes
     * @param {?} store Feature store
     * @return {?}
     */
    function (store) {
        _super.prototype.unbindStore.call(this, store);
        if (this.active === true) {
            this.unwatchStore(store);
        }
    };
    /**
     * Define the motion to apply on load
     * @param motion Feature motion
     */
    /**
     * Define the motion to apply on load
     * @param {?} motion Feature motion
     * @return {?}
     */
    FeatureStoreLoadingStrategy.prototype.setMotion = /**
     * Define the motion to apply on load
     * @param {?} motion Feature motion
     * @return {?}
     */
    function (motion) {
        this.motion = motion;
    };
    /**
     * Start watching all stores already bound to that strategy at once.
     * @internal
     */
    /**
     * Start watching all stores already bound to that strategy at once.
     * \@internal
     * @protected
     * @return {?}
     */
    FeatureStoreLoadingStrategy.prototype.doActivate = /**
     * Start watching all stores already bound to that strategy at once.
     * \@internal
     * @protected
     * @return {?}
     */
    function () {
        var _this = this;
        this.stores.forEach((/**
         * @param {?} store
         * @return {?}
         */
        function (store) { return _this.watchStore(store); }));
    };
    /**
     * Stop watching all stores bound to that strategy
     * @internal
     */
    /**
     * Stop watching all stores bound to that strategy
     * \@internal
     * @protected
     * @return {?}
     */
    FeatureStoreLoadingStrategy.prototype.doDeactivate = /**
     * Stop watching all stores bound to that strategy
     * \@internal
     * @protected
     * @return {?}
     */
    function () {
        this.unwatchAll();
    };
    /**
     * Watch for entities changes in a store.
     * Important: Never observe a store's sorted entities. It makes no sense
     * to display sorted entities (instead of unsorted) on a layer and it
     * would potentially result in a lot of useless computation.
     * @param store Feature store
     */
    /**
     * Watch for entities changes in a store.
     * Important: Never observe a store's sorted entities. It makes no sense
     * to display sorted entities (instead of unsorted) on a layer and it
     * would potentially result in a lot of useless computation.
     * @private
     * @param {?} store Feature store
     * @return {?}
     */
    FeatureStoreLoadingStrategy.prototype.watchStore = /**
     * Watch for entities changes in a store.
     * Important: Never observe a store's sorted entities. It makes no sense
     * to display sorted entities (instead of unsorted) on a layer and it
     * would potentially result in a lot of useless computation.
     * @private
     * @param {?} store Feature store
     * @return {?}
     */
    function (store) {
        var _this = this;
        if (this.stores$$.has(store)) {
            return;
        }
        /** @type {?} */
        var subscription = store.view.all$()
            .subscribe((/**
         * @param {?} features
         * @return {?}
         */
        function (features) { return _this.onFeaturesChange(features, store); }));
        this.stores$$.set(store, subscription);
    };
    /**
     * Stop watching for entities changes in a store.
     * @param store Feature store
     */
    /**
     * Stop watching for entities changes in a store.
     * @private
     * @param {?} store Feature store
     * @return {?}
     */
    FeatureStoreLoadingStrategy.prototype.unwatchStore = /**
     * Stop watching for entities changes in a store.
     * @private
     * @param {?} store Feature store
     * @return {?}
     */
    function (store) {
        /** @type {?} */
        var subscription = this.stores$$.get(store);
        if (subscription !== undefined) {
            subscription.unsubscribe();
            this.stores$$.delete(store);
        }
    };
    /**
     * Stop watching for entities changes in all stores.
     */
    /**
     * Stop watching for entities changes in all stores.
     * @private
     * @return {?}
     */
    FeatureStoreLoadingStrategy.prototype.unwatchAll = /**
     * Stop watching for entities changes in all stores.
     * @private
     * @return {?}
     */
    function () {
        Array.from(this.stores$$.entries()).forEach((/**
         * @param {?} entries
         * @return {?}
         */
        function (entries) {
            entries[1].unsubscribe();
        }));
        this.stores$$.clear();
    };
    /**
     * Load features into a layer or clear the layer if the array of features is empty.
     * @param features Store filtered features
     * @param store Feature store
     */
    /**
     * Load features into a layer or clear the layer if the array of features is empty.
     * @private
     * @param {?} features Store filtered features
     * @param {?} store Feature store
     * @return {?}
     */
    FeatureStoreLoadingStrategy.prototype.onFeaturesChange = /**
     * Load features into a layer or clear the layer if the array of features is empty.
     * @private
     * @param {?} features Store filtered features
     * @param {?} store Feature store
     * @return {?}
     */
    function (features, store) {
        if (features.length === 0) {
            store.clearLayer();
        }
        else {
            store.setLayerFeatures(features, this.selectMotion(store), this.options.viewScale, this.options.areaRatio, this.options.getFeatureId);
        }
    };
    /**
     * Selects the best motion
     * @param store A FeatureStore to apply the motion
     * @returns The motion selected
     */
    /**
     * Selects the best motion
     * @private
     * @param {?} store A FeatureStore to apply the motion
     * @return {?} The motion selected
     */
    FeatureStoreLoadingStrategy.prototype.selectMotion = /**
     * Selects the best motion
     * @private
     * @param {?} store A FeatureStore to apply the motion
     * @return {?} The motion selected
     */
    function (store) {
        if (this.motion !== undefined) {
            return this.motion;
        }
        if (store.pristine === true) {
            // If features have just been loaded into the store, move/zoom on them
            return FeatureMotion.Default;
        }
        else if (store.count > store.view.count) {
            // If features have been filtered, move/zoom on the remaining ones
            return FeatureMotion.Default;
        }
        else {
            // On insert, update or delete, do nothing
            return FeatureMotion.None;
        }
    };
    return FeatureStoreLoadingStrategy;
}(EntityStoreStrategy));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * This strategy loads a layer's features into it's store counterpart.
 * The layer -> store binding is a one-way binding. That means any OL feature
 * added to the layer will be added to the store but the opposite is false.
 *
 * Important: In it's current state, this strategy is to meant to be combined
 * with a standard Loading strategy and it would probably cause recursion issues.
 */
var  /**
 * This strategy loads a layer's features into it's store counterpart.
 * The layer -> store binding is a one-way binding. That means any OL feature
 * added to the layer will be added to the store but the opposite is false.
 *
 * Important: In it's current state, this strategy is to meant to be combined
 * with a standard Loading strategy and it would probably cause recursion issues.
 */
FeatureStoreLoadingLayerStrategy = /** @class */ (function (_super) {
    __extends(FeatureStoreLoadingLayerStrategy, _super);
    function FeatureStoreLoadingLayerStrategy(options) {
        var _this = _super.call(this, options) || this;
        _this.options = options;
        /**
         * Subscription to the store's OL source changes
         */
        _this.stores$$ = new Map();
        return _this;
    }
    /**
     * Bind this strategy to a store and start watching for Ol source changes
     * @param store Feature store
     */
    /**
     * Bind this strategy to a store and start watching for Ol source changes
     * @param {?} store Feature store
     * @return {?}
     */
    FeatureStoreLoadingLayerStrategy.prototype.bindStore = /**
     * Bind this strategy to a store and start watching for Ol source changes
     * @param {?} store Feature store
     * @return {?}
     */
    function (store) {
        _super.prototype.bindStore.call(this, store);
        if (this.active === true) {
            this.watchStore(store);
        }
    };
    /**
     * Unbind this strategy from a store and stop watching for Ol source changes
     * @param store Feature store
     */
    /**
     * Unbind this strategy from a store and stop watching for Ol source changes
     * @param {?} store Feature store
     * @return {?}
     */
    FeatureStoreLoadingLayerStrategy.prototype.unbindStore = /**
     * Unbind this strategy from a store and stop watching for Ol source changes
     * @param {?} store Feature store
     * @return {?}
     */
    function (store) {
        _super.prototype.unbindStore.call(this, store);
        if (this.active === true) {
            this.unwatchStore(store);
        }
    };
    /**
     * Start watching all stores already bound to that strategy at once.
     * @internal
     */
    /**
     * Start watching all stores already bound to that strategy at once.
     * \@internal
     * @protected
     * @return {?}
     */
    FeatureStoreLoadingLayerStrategy.prototype.doActivate = /**
     * Start watching all stores already bound to that strategy at once.
     * \@internal
     * @protected
     * @return {?}
     */
    function () {
        var _this = this;
        this.stores.forEach((/**
         * @param {?} store
         * @return {?}
         */
        function (store) { return _this.watchStore(store); }));
    };
    /**
     * Stop watching all stores bound to that strategy
     * @internal
     */
    /**
     * Stop watching all stores bound to that strategy
     * \@internal
     * @protected
     * @return {?}
     */
    FeatureStoreLoadingLayerStrategy.prototype.doDeactivate = /**
     * Stop watching all stores bound to that strategy
     * \@internal
     * @protected
     * @return {?}
     */
    function () {
        this.unwatchAll();
    };
    /**
     * Watch for a store's  OL source changes
     * @param store Feature store
     */
    /**
     * Watch for a store's  OL source changes
     * @private
     * @param {?} store Feature store
     * @return {?}
     */
    FeatureStoreLoadingLayerStrategy.prototype.watchStore = /**
     * Watch for a store's  OL source changes
     * @private
     * @param {?} store Feature store
     * @return {?}
     */
    function (store) {
        var _this = this;
        if (this.stores$$.has(store)) {
            return;
        }
        this.onSourceChanges(store);
        /** @type {?} */
        var olSource = store.layer.ol.getSource();
        olSource.on('change', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            _this.onSourceChanges(store);
        }));
    };
    /**
     * Stop watching for a store's OL source changes
     * @param store Feature store
     */
    /**
     * Stop watching for a store's OL source changes
     * @private
     * @param {?} store Feature store
     * @return {?}
     */
    FeatureStoreLoadingLayerStrategy.prototype.unwatchStore = /**
     * Stop watching for a store's OL source changes
     * @private
     * @param {?} store Feature store
     * @return {?}
     */
    function (store) {
        /** @type {?} */
        var key = this.stores$$.get(store);
        if (key !== undefined) {
            unByKey(key);
            this.stores$$.delete(store);
        }
    };
    /**
     * Stop watching for OL source changes in all stores.
     */
    /**
     * Stop watching for OL source changes in all stores.
     * @private
     * @return {?}
     */
    FeatureStoreLoadingLayerStrategy.prototype.unwatchAll = /**
     * Stop watching for OL source changes in all stores.
     * @private
     * @return {?}
     */
    function () {
        Array.from(this.stores$$.entries()).forEach((/**
         * @param {?} entries
         * @return {?}
         */
        function (entries) {
            unByKey(entries[1]);
        }));
        this.stores$$.clear();
    };
    /**
     * Load features from an OL source into a  store or clear the store if the source is empty
     * @param features Store filtered features
     * @param store Feature store
     */
    /**
     * Load features from an OL source into a  store or clear the store if the source is empty
     * @private
     * @param {?} store Feature store
     * @return {?}
     */
    FeatureStoreLoadingLayerStrategy.prototype.onSourceChanges = /**
     * Load features from an OL source into a  store or clear the store if the source is empty
     * @private
     * @param {?} store Feature store
     * @return {?}
     */
    function (store) {
        /** @type {?} */
        var olFeatures = store.layer.ol.getSource().getFeatures();
        if (olFeatures.length === 0) {
            store.clear();
        }
        else {
            store.setStoreOlFeatures(olFeatures);
        }
    };
    return FeatureStoreLoadingLayerStrategy;
}(EntityStoreStrategy));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * The class is a specialized version of an EntityStore that stores
 * features and the map layer to display them on. Synchronization
 * between the store and the layer is handled by strategies.
 * @template T
 */
var  /**
 * The class is a specialized version of an EntityStore that stores
 * features and the map layer to display them on. Synchronization
 * between the store and the layer is handled by strategies.
 * @template T
 */
FeatureStore = /** @class */ (function (_super) {
    __extends(FeatureStore, _super);
    function FeatureStore(entities, options) {
        var _this = _super.call(this, entities, options) || this;
        _this.map = options.map;
        return _this;
    }
    Object.defineProperty(FeatureStore.prototype, "source", {
        /**
         * The layer's data source
         */
        get: /**
         * The layer's data source
         * @return {?}
         */
        function () {
            return this.layer ? (/** @type {?} */ (this.layer.dataSource)) : undefined;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Bind this store to a vector layer
     * @param layer Vector layer
     * @returns Feature store
     */
    /**
     * Bind this store to a vector layer
     * @param {?} layer Vector layer
     * @return {?} Feature store
     */
    FeatureStore.prototype.bindLayer = /**
     * Bind this store to a vector layer
     * @param {?} layer Vector layer
     * @return {?} Feature store
     */
    function (layer) {
        this.layer = layer;
        return this;
    };
    /**
     * Set the layer's features and perform a motion to make them visible. Strategies
     * make extensive use of that method.
     * @param features Features
     * @param motion Optional: The type of motion to perform
     */
    /**
     * Set the layer's features and perform a motion to make them visible. Strategies
     * make extensive use of that method.
     * @param {?} features Features
     * @param {?=} motion Optional: The type of motion to perform
     * @param {?=} viewScale
     * @param {?=} areaRatio
     * @param {?=} getId
     * @return {?}
     */
    FeatureStore.prototype.setLayerFeatures = /**
     * Set the layer's features and perform a motion to make them visible. Strategies
     * make extensive use of that method.
     * @param {?} features Features
     * @param {?=} motion Optional: The type of motion to perform
     * @param {?=} viewScale
     * @param {?=} areaRatio
     * @param {?=} getId
     * @return {?}
     */
    function (features, motion, viewScale, areaRatio, getId) {
        var _this = this;
        if (motion === void 0) { motion = FeatureMotion.Default; }
        getId = getId ? getId : getEntityId;
        this.checkLayer();
        /** @type {?} */
        var olFeatures = features
            .map((/**
         * @param {?} feature
         * @return {?}
         */
        function (feature) { return featureToOl(feature, _this.map.projection, getId); }));
        this.setLayerOlFeatures(olFeatures, motion, viewScale, areaRatio);
    };
    /**
     * Set the store's features from an array of OL features.
     * @param olFeatures Ol features
     */
    /**
     * Set the store's features from an array of OL features.
     * @param {?} olFeatures Ol features
     * @return {?}
     */
    FeatureStore.prototype.setStoreOlFeatures = /**
     * Set the store's features from an array of OL features.
     * @param {?} olFeatures Ol features
     * @return {?}
     */
    function (olFeatures) {
        var _this = this;
        this.checkLayer();
        /** @type {?} */
        var features = olFeatures.map((/**
         * @param {?} olFeature
         * @return {?}
         */
        function (olFeature) {
            olFeature.set('_featureStore', _this, true);
            return featureFromOl(olFeature, _this.layer.map.projection);
        }));
        this.load((/** @type {?} */ (features)));
    };
    /**
     * Remove all features from the layer
     */
    /**
     * Remove all features from the layer
     * @return {?}
     */
    FeatureStore.prototype.clearLayer = /**
     * Remove all features from the layer
     * @return {?}
     */
    function () {
        this.checkLayer();
        this.source.ol.clear();
    };
    /**
     * Check wether a layer is bound or not and throw an error if not.
     */
    /**
     * Check wether a layer is bound or not and throw an error if not.
     * @private
     * @return {?}
     */
    FeatureStore.prototype.checkLayer = /**
     * Check wether a layer is bound or not and throw an error if not.
     * @private
     * @return {?}
     */
    function () {
        if (this.layer === undefined) {
            throw new Error('This FeatureStore is not bound to a layer.');
        }
    };
    /**
     * Set the layer's features and perform a motion to make them visible.
     * @param features Openlayers feature objects
     * @param motion Optional: The type of motion to perform
     */
    /**
     * Set the layer's features and perform a motion to make them visible.
     * @private
     * @param {?} olFeatures
     * @param {?=} motion Optional: The type of motion to perform
     * @param {?=} viewScale
     * @param {?=} areaRatio
     * @return {?}
     */
    FeatureStore.prototype.setLayerOlFeatures = /**
     * Set the layer's features and perform a motion to make them visible.
     * @private
     * @param {?} olFeatures
     * @param {?=} motion Optional: The type of motion to perform
     * @param {?=} viewScale
     * @param {?=} areaRatio
     * @return {?}
     */
    function (olFeatures, motion, viewScale, areaRatio) {
        if (motion === void 0) { motion = FeatureMotion.Default; }
        /** @type {?} */
        var olSource = this.layer.ol.getSource();
        /** @type {?} */
        var diff = computeOlFeaturesDiff(olSource.getFeatures(), olFeatures);
        if (diff.remove.length > 0) {
            this.removeOlFeaturesFromLayer(diff.remove);
        }
        if (diff.add.length > 0) {
            this.addOlFeaturesToLayer(diff.add);
        }
        if (diff.add.length > 0) {
            // If features are added, do a motion toward the newly added features
            moveToOlFeatures(this.map, diff.add, motion, viewScale, areaRatio);
        }
        else if (diff.remove.length > 0) {
            // Else, do a motion toward all the features
            moveToOlFeatures(this.map, olFeatures, motion, viewScale, areaRatio);
        }
    };
    /**
     * Add features to the the layer
     * @param features Openlayers feature objects
     */
    /**
     * Add features to the the layer
     * @private
     * @param {?} olFeatures
     * @return {?}
     */
    FeatureStore.prototype.addOlFeaturesToLayer = /**
     * Add features to the the layer
     * @private
     * @param {?} olFeatures
     * @return {?}
     */
    function (olFeatures) {
        var _this = this;
        olFeatures.forEach((/**
         * @param {?} olFeature
         * @return {?}
         */
        function (olFeature) {
            olFeature.set('_featureStore', _this, true);
        }));
        this.source.ol.addFeatures(olFeatures);
    };
    /**
     * Remove features from the the layer
     * @param features Openlayers feature objects
     */
    /**
     * Remove features from the the layer
     * @private
     * @param {?} olFeatures
     * @return {?}
     */
    FeatureStore.prototype.removeOlFeaturesFromLayer = /**
     * Remove features from the the layer
     * @private
     * @param {?} olFeatures
     * @return {?}
     */
    function (olFeatures) {
        var _this = this;
        olFeatures.forEach((/**
         * @param {?} olFeature
         * @return {?}
         */
        function (olFeature) {
            _this.source.ol.removeFeature(olFeature);
        }));
    };
    return FeatureStore;
}(EntityStore));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var OlDragSelectInteraction = /** @class */ (function (_super) {
    __extends(OlDragSelectInteraction, _super);
    function OlDragSelectInteraction(options) {
        return _super.call(this, options) || this;
    }
    return OlDragSelectInteraction;
}(OlDragBoxInteraction));
/**
 * This strategy synchronizes a store and a layer selected entities.
 * The store <-> layer binding is a two-way binding.
 *
 * In many cases, a single strategy bound to multiple stores
 * will yield better results that multiple strategies with each their
 * own store. In the latter scenario, a click on overlapping features
 * would trigger the strategy of each layer and they would cancel
 * each other as well as move the map view around needlessly.
 */
var  /**
 * This strategy synchronizes a store and a layer selected entities.
 * The store <-> layer binding is a two-way binding.
 *
 * In many cases, a single strategy bound to multiple stores
 * will yield better results that multiple strategies with each their
 * own store. In the latter scenario, a click on overlapping features
 * would trigger the strategy of each layer and they would cancel
 * each other as well as move the map view around needlessly.
 */
FeatureStoreSelectionStrategy = /** @class */ (function (_super) {
    __extends(FeatureStoreSelectionStrategy, _super);
    function FeatureStoreSelectionStrategy(options) {
        var _this = _super.call(this, options) || this;
        _this.options = options;
        _this.setMotion(options.motion);
        _this._overlayStore = _this.createOverlayStore();
        return _this;
    }
    Object.defineProperty(FeatureStoreSelectionStrategy.prototype, "map", {
        /**
         * The map the layers belong to
         */
        get: /**
         * The map the layers belong to
         * @return {?}
         */
        function () { return this.options.map; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FeatureStoreSelectionStrategy.prototype, "overlayStore", {
        /**
         * A feature store that'll contain the selected features. It has it's own
         * layer, shared by all the stores this staretgy is bound to.
         */
        get: /**
         * A feature store that'll contain the selected features. It has it's own
         * layer, shared by all the stores this staretgy is bound to.
         * @return {?}
         */
        function () { return this._overlayStore; },
        enumerable: true,
        configurable: true
    });
    /**
     * Bind this strategy to a store and force this strategy's
     * reactivation to properly setup watchers.
     * @param store Feature store
     */
    /**
     * Bind this strategy to a store and force this strategy's
     * reactivation to properly setup watchers.
     * @param {?} store Feature store
     * @return {?}
     */
    FeatureStoreSelectionStrategy.prototype.bindStore = /**
     * Bind this strategy to a store and force this strategy's
     * reactivation to properly setup watchers.
     * @param {?} store Feature store
     * @return {?}
     */
    function (store) {
        _super.prototype.bindStore.call(this, store);
        if (this.active === true) {
            // Force reactivation
            this.activate();
        }
    };
    /**
     * Unbind this strategy from a store and force this strategy's
     * reactivation to properly setup watchers.
     * @param store Feature store
     */
    /**
     * Unbind this strategy from a store and force this strategy's
     * reactivation to properly setup watchers.
     * @param {?} store Feature store
     * @return {?}
     */
    FeatureStoreSelectionStrategy.prototype.unbindStore = /**
     * Unbind this strategy from a store and force this strategy's
     * reactivation to properly setup watchers.
     * @param {?} store Feature store
     * @return {?}
     */
    function (store) {
        _super.prototype.unbindStore.call(this, store);
        if (this.active === true) {
            // Force reactivation
            this.activate();
        }
    };
    /**
     * Define the motion to apply on select
     * @param motion Feature motion
     */
    /**
     * Define the motion to apply on select
     * @param {?} motion Feature motion
     * @return {?}
     */
    FeatureStoreSelectionStrategy.prototype.setMotion = /**
     * Define the motion to apply on select
     * @param {?} motion Feature motion
     * @return {?}
     */
    function (motion) {
        this.motion = motion;
    };
    /**
     * Unselect all entities, from all stores
     */
    /**
     * Unselect all entities, from all stores
     * @return {?}
     */
    FeatureStoreSelectionStrategy.prototype.unselectAll = /**
     * Unselect all entities, from all stores
     * @return {?}
     */
    function () {
        this.stores.forEach((/**
         * @param {?} store
         * @return {?}
         */
        function (store) {
            store.state.updateAll({ selected: false });
        }));
    };
    /**
     * Clear the overlay
     */
    /**
     * Clear the overlay
     * @return {?}
     */
    FeatureStoreSelectionStrategy.prototype.clear = /**
     * Clear the overlay
     * @return {?}
     */
    function () {
        this.overlayStore.source.ol.clear();
        this.overlayStore.clear();
    };
    /**
     * Deactivate the selection without removing the selection
     * overlay.
     */
    /**
     * Deactivate the selection without removing the selection
     * overlay.
     * @return {?}
     */
    FeatureStoreSelectionStrategy.prototype.deactivateSelection = /**
     * Deactivate the selection without removing the selection
     * overlay.
     * @return {?}
     */
    function () {
        this.unlistenToMapClick();
        this.removeDragBoxInteraction();
        this.unwatchAll();
    };
    /**
     * Add the overlay layer, setup the map click lsitener and
     * start watching for stores selection
     * @internal
     */
    /**
     * Add the overlay layer, setup the map click lsitener and
     * start watching for stores selection
     * \@internal
     * @protected
     * @return {?}
     */
    FeatureStoreSelectionStrategy.prototype.doActivate = /**
     * Add the overlay layer, setup the map click lsitener and
     * start watching for stores selection
     * \@internal
     * @protected
     * @return {?}
     */
    function () {
        this.addOverlayLayer();
        this.listenToMapClick();
        if (this.options.dragBox === true) {
            this.addDragBoxInteraction();
        }
        this.watchAll();
    };
    /**
     * Remove the overlay layer, remove the map click lsitener and
     * stop watching for stores selection
     * @internal
     */
    /**
     * Remove the overlay layer, remove the map click lsitener and
     * stop watching for stores selection
     * \@internal
     * @protected
     * @return {?}
     */
    FeatureStoreSelectionStrategy.prototype.doDeactivate = /**
     * Remove the overlay layer, remove the map click lsitener and
     * stop watching for stores selection
     * \@internal
     * @protected
     * @return {?}
     */
    function () {
        this.deactivateSelection();
        this.removeOverlayLayer();
    };
    /**
     * Create a single observable of all the stores. With a single observable,
     * features can be added all at once to the overlay layer and a single
     * motion can be performed. Multiple observable would have
     * a cancelling effect on each other.
     */
    /**
     * Create a single observable of all the stores. With a single observable,
     * features can be added all at once to the overlay layer and a single
     * motion can be performed. Multiple observable would have
     * a cancelling effect on each other.
     * @private
     * @return {?}
     */
    FeatureStoreSelectionStrategy.prototype.watchAll = /**
     * Create a single observable of all the stores. With a single observable,
     * features can be added all at once to the overlay layer and a single
     * motion can be performed. Multiple observable would have
     * a cancelling effect on each other.
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this.unwatchAll();
        /** @type {?} */
        var stores$ = this.stores.map((/**
         * @param {?} store
         * @return {?}
         */
        function (store) {
            return store.stateView.manyBy$((/**
             * @param {?} record
             * @return {?}
             */
            function (record) {
                return record.state.selected === true;
            })).pipe(map((/**
             * @param {?} records
             * @return {?}
             */
            function (records) { return records.map((/**
             * @param {?} record
             * @return {?}
             */
            function (record) { return record.entity; })); })));
        }));
        this.stores$$ = combineLatest(stores$)
            .pipe(debounceTime(5), skip(1), // Skip intial selection
        map((/**
         * @param {?} features
         * @return {?}
         */
        function (features) { return features.reduce((/**
         * @param {?} a
         * @param {?} b
         * @return {?}
         */
        function (a, b) { return a.concat(b); })); }))).subscribe((/**
         * @param {?} features
         * @return {?}
         */
        function (features) { return _this.onSelectFromStore(features); }));
    };
    /**
     * Stop watching for selection in all stores.
     */
    /**
     * Stop watching for selection in all stores.
     * @private
     * @return {?}
     */
    FeatureStoreSelectionStrategy.prototype.unwatchAll = /**
     * Stop watching for selection in all stores.
     * @private
     * @return {?}
     */
    function () {
        if (this.stores$$ !== undefined) {
            this.stores$$.unsubscribe();
        }
    };
    /**
     * Add a 'singleclick' listener to the map that'll allow selecting
     * features by clicking on the map. The selection will be performed
     * only on the layers bound to this strategy.
     */
    /**
     * Add a 'singleclick' listener to the map that'll allow selecting
     * features by clicking on the map. The selection will be performed
     * only on the layers bound to this strategy.
     * @private
     * @return {?}
     */
    FeatureStoreSelectionStrategy.prototype.listenToMapClick = /**
     * Add a 'singleclick' listener to the map that'll allow selecting
     * features by clicking on the map. The selection will be performed
     * only on the layers bound to this strategy.
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this.mapClickListener = this.map.ol.on('singleclick', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            _this.onMapClick(event);
        }));
    };
    /**
     * Remove the map click listener
     */
    /**
     * Remove the map click listener
     * @private
     * @return {?}
     */
    FeatureStoreSelectionStrategy.prototype.unlistenToMapClick = /**
     * Remove the map click listener
     * @private
     * @return {?}
     */
    function () {
        if (this.mapClickListener !== undefined) {
            this.map.ol.un(this.mapClickListener.type, this.mapClickListener.listener);
        }
    };
    /**
     * On map click, select feature at pixel
     * @param event OL MapBrowserPointerEvent
     */
    /**
     * On map click, select feature at pixel
     * @private
     * @param {?} event OL MapBrowserPointerEvent
     * @return {?}
     */
    FeatureStoreSelectionStrategy.prototype.onMapClick = /**
     * On map click, select feature at pixel
     * @private
     * @param {?} event OL MapBrowserPointerEvent
     * @return {?}
     */
    function (event) {
        var _this = this;
        /** @type {?} */
        var exclusive = !ctrlKeyDown(event);
        /** @type {?} */
        var reverse = !exclusive;
        /** @type {?} */
        var olFeatures = event.map.getFeaturesAtPixel(event.pixel, {
            hitTolerance: this.options.hitTolerance || 0,
            layerFilter: (/**
             * @param {?} olLayer
             * @return {?}
             */
            function (olLayer) {
                /** @type {?} */
                var storeOlLayer = _this.stores.find((/**
                 * @param {?} store
                 * @return {?}
                 */
                function (store) {
                    return store.layer.ol === olLayer;
                }));
                return storeOlLayer !== undefined;
            })
        });
        this.onSelectFromMap(olFeatures, exclusive, reverse);
    };
    /**
     * Add a drag box interaction and, on drag box end, select features
     */
    /**
     * Add a drag box interaction and, on drag box end, select features
     * @private
     * @return {?}
     */
    FeatureStoreSelectionStrategy.prototype.addDragBoxInteraction = /**
     * Add a drag box interaction and, on drag box end, select features
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        var e_1, _a;
        /** @type {?} */
        var olDragSelectInteraction;
        /** @type {?} */
        var olInteractions = this.map.ol.getInteractions().getArray();
        try {
            // There can only be one dragbox interaction, so find the current one, if any
            // Don't keep a reference to the current dragbox because we don't want
            // to remove it when this startegy is deactivated
            for (var olInteractions_1 = __values(olInteractions), olInteractions_1_1 = olInteractions_1.next(); !olInteractions_1_1.done; olInteractions_1_1 = olInteractions_1.next()) {
                var olInteraction = olInteractions_1_1.value;
                if (olInteraction instanceof OlDragSelectInteraction) {
                    olDragSelectInteraction = olInteraction;
                    break;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (olInteractions_1_1 && !olInteractions_1_1.done && (_a = olInteractions_1.return)) _a.call(olInteractions_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        // If no drag box interaction is found, create a new one and add it to the map
        if (olDragSelectInteraction === undefined) {
            olDragSelectInteraction = new OlDragSelectInteraction({
                condition: ctrlKeyDown
            });
            this.map.ol.addInteraction(olDragSelectInteraction);
            this.olDragSelectInteraction = olDragSelectInteraction;
        }
        this.olDragSelectInteractionEndKey = olDragSelectInteraction.on('boxend', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.onDragBoxEnd(event); }));
    };
    /**
     * Remove drag box interaction
     */
    /**
     * Remove drag box interaction
     * @private
     * @return {?}
     */
    FeatureStoreSelectionStrategy.prototype.removeDragBoxInteraction = /**
     * Remove drag box interaction
     * @private
     * @return {?}
     */
    function () {
        if (this.olDragSelectInteractionEndKey !== undefined) {
            unByKey(this.olDragSelectInteractionEndKey);
        }
        if (this.olDragSelectInteraction !== undefined) {
            this.map.ol.removeInteraction(this.olDragSelectInteraction);
        }
        this.olDragSelectInteraction = undefined;
    };
    /**
     * On dragbox end, select features in drag box
     * @param event OL MapBrowserPointerEvent
     */
    /**
     * On dragbox end, select features in drag box
     * @private
     * @param {?} event OL MapBrowserPointerEvent
     * @return {?}
     */
    FeatureStoreSelectionStrategy.prototype.onDragBoxEnd = /**
     * On dragbox end, select features in drag box
     * @private
     * @param {?} event OL MapBrowserPointerEvent
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var exclusive = !ctrlKeyDown(event.mapBrowserEvent);
        /** @type {?} */
        var extent = event.target.getGeometry().getExtent();
        /** @type {?} */
        var olFeatures = this.stores.reduce((/**
         * @param {?} acc
         * @param {?} store
         * @return {?}
         */
        function (acc, store) {
            /** @type {?} */
            var olSource = store.layer.ol.getSource();
            acc.push.apply(acc, __spread(olSource.getFeaturesInExtent(extent)));
            return acc;
        }), []);
        this.onSelectFromMap(olFeatures, exclusive, false);
    };
    /**
     * When features are selected from the store, add
     * them to this startegy's overlay layer (select on map)
     * @param features Store features
     */
    /**
     * When features are selected from the store, add
     * them to this startegy's overlay layer (select on map)
     * @private
     * @param {?} features Store features
     * @return {?}
     */
    FeatureStoreSelectionStrategy.prototype.onSelectFromStore = /**
     * When features are selected from the store, add
     * them to this startegy's overlay layer (select on map)
     * @private
     * @param {?} features Store features
     * @return {?}
     */
    function (features) {
        /** @type {?} */
        var motion = this.motion;
        /** @type {?} */
        var olOverlayFeatures = this.overlayStore.layer.ol.getSource().getFeatures();
        /** @type {?} */
        var overlayFeaturesKeys = olOverlayFeatures.map((/**
         * @param {?} olFeature
         * @return {?}
         */
        function (olFeature) { return olFeature.getId(); }));
        /** @type {?} */
        var featuresKeys = features.map(this.overlayStore.getKey);
        /** @type {?} */
        var doMotion;
        if (features.length === 0) {
            doMotion = false;
        }
        else {
            doMotion = overlayFeaturesKeys.length !== featuresKeys.length ||
                !overlayFeaturesKeys.every((/**
                 * @param {?} key
                 * @return {?}
                 */
                function (key) { return featuresKeys.indexOf(key) >= 0; }));
        }
        this.overlayStore.setLayerFeatures(features, doMotion ? motion : FeatureMotion.None, this.options.viewScale, this.options.areaRatio, this.options.getFeatureId);
    };
    /**
     * When features are selected from the map, also select them
     * in their store.
     * @param olFeatures OL feature objects
     */
    /**
     * When features are selected from the map, also select them
     * in their store.
     * @private
     * @param {?} olFeatures OL feature objects
     * @param {?} exclusive
     * @param {?} reverse
     * @return {?}
     */
    FeatureStoreSelectionStrategy.prototype.onSelectFromMap = /**
     * When features are selected from the map, also select them
     * in their store.
     * @private
     * @param {?} olFeatures OL feature objects
     * @param {?} exclusive
     * @param {?} reverse
     * @return {?}
     */
    function (olFeatures, exclusive, reverse) {
        var _this = this;
        /** @type {?} */
        var groupedFeatures = this.groupFeaturesByStore(olFeatures);
        this.stores.forEach((/**
         * @param {?} store
         * @return {?}
         */
        function (store) {
            /** @type {?} */
            var features = groupedFeatures.get(store);
            if (features === undefined && exclusive === true) {
                _this.unselectAllFeaturesFromStore(store);
            }
            else if (features === undefined && exclusive === false) ;
            else {
                _this.selectFeaturesFromStore(store, features, exclusive, reverse);
            }
        }));
    };
    /**
     * Select features in store
     * @param store: Feature store
     * @param features Features
     */
    /**
     * Select features in store
     * @private
     * @param {?} store
     * @param {?} features Features
     * @param {?} exclusive
     * @param {?} reverse
     * @return {?}
     */
    FeatureStoreSelectionStrategy.prototype.selectFeaturesFromStore = /**
     * Select features in store
     * @private
     * @param {?} store
     * @param {?} features Features
     * @param {?} exclusive
     * @param {?} reverse
     * @return {?}
     */
    function (store, features, exclusive, reverse) {
        if (reverse === true) {
            store.state.reverseMany(features, ['selected']);
        }
        else {
            store.state.updateMany(features, { selected: true }, exclusive);
        }
    };
    /**
     * Unselect all features from store
     * @param store: Feature store
     */
    /**
     * Unselect all features from store
     * @private
     * @param {?} store
     * @return {?}
     */
    FeatureStoreSelectionStrategy.prototype.unselectAllFeaturesFromStore = /**
     * Unselect all features from store
     * @private
     * @param {?} store
     * @return {?}
     */
    function (store) {
        store.state.updateAll({ selected: false });
    };
    /**
     * This method returns a store -> features mapping from a list
     * of OL selected features. OL features keep a reference to the store
     * they are from.
     * @param olFeatures: OL feature objects
     * @returns Store -> features mapping
     */
    /**
     * This method returns a store -> features mapping from a list
     * of OL selected features. OL features keep a reference to the store
     * they are from.
     * @private
     * @param {?} olFeatures
     * @return {?} Store -> features mapping
     */
    FeatureStoreSelectionStrategy.prototype.groupFeaturesByStore = /**
     * This method returns a store -> features mapping from a list
     * of OL selected features. OL features keep a reference to the store
     * they are from.
     * @private
     * @param {?} olFeatures
     * @return {?} Store -> features mapping
     */
    function (olFeatures) {
        /** @type {?} */
        var groupedFeatures = new Map();
        if (olFeatures === null || olFeatures === undefined) {
            return groupedFeatures;
        }
        olFeatures.forEach((/**
         * @param {?} olFeature
         * @return {?}
         */
        function (olFeature) {
            /** @type {?} */
            var store = olFeature.get('_featureStore');
            if (store === undefined) {
                return;
            }
            /** @type {?} */
            var features = groupedFeatures.get(store);
            if (features === undefined) {
                features = [];
                groupedFeatures.set(store, features);
            }
            /** @type {?} */
            var feature = store.get(olFeature.getId());
            if (feature !== undefined) {
                features.push(feature);
            }
        }));
        return groupedFeatures;
    };
    /**
     * Create an overlay store that'll contain the selected features.
     * @returns Overlay store
     */
    /**
     * Create an overlay store that'll contain the selected features.
     * @private
     * @return {?} Overlay store
     */
    FeatureStoreSelectionStrategy.prototype.createOverlayStore = /**
     * Create an overlay store that'll contain the selected features.
     * @private
     * @return {?} Overlay store
     */
    function () {
        /** @type {?} */
        var overlayLayer = this.options.layer
            ? this.options.layer
            : this.createOverlayLayer();
        return new FeatureStore([], { map: this.map }).bindLayer(overlayLayer);
    };
    /**
     * Create an overlay store that'll contain the selected features.
     * @returns Overlay layer
     */
    /**
     * Create an overlay store that'll contain the selected features.
     * @private
     * @return {?} Overlay layer
     */
    FeatureStoreSelectionStrategy.prototype.createOverlayLayer = /**
     * Create an overlay store that'll contain the selected features.
     * @private
     * @return {?} Overlay layer
     */
    function () {
        return new VectorLayer({
            zIndex: 300,
            source: new FeatureDataSource(),
            style: undefined,
            showInLayerList: false,
            exportable: false,
            browsable: false
        });
    };
    /**
     * Add the overlay store's layer to the map to display the selected
     * features.
     */
    /**
     * Add the overlay store's layer to the map to display the selected
     * features.
     * @private
     * @return {?}
     */
    FeatureStoreSelectionStrategy.prototype.addOverlayLayer = /**
     * Add the overlay store's layer to the map to display the selected
     * features.
     * @private
     * @return {?}
     */
    function () {
        if (this.overlayStore.layer.map === undefined) {
            this.map.addLayer(this.overlayStore.layer);
        }
    };
    /**
     * Remove the overlay layer from the map
     */
    /**
     * Remove the overlay layer from the map
     * @private
     * @return {?}
     */
    FeatureStoreSelectionStrategy.prototype.removeOverlayLayer = /**
     * Remove the overlay layer from the map
     * @private
     * @return {?}
     */
    function () {
        this.overlayStore.source.ol.clear();
        this.map.removeLayer(this.overlayStore.layer);
    };
    return FeatureStoreSelectionStrategy;
}(EntityStoreStrategy));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Create an Openlayers feature object out of a feature definition.
 * The output object has a reference to the feature id.
 * @param {?} feature Feature definition
 * @param {?} projectionOut Feature object projection
 * @param {?=} getId
 * @return {?} OpenLayers feature object
 */
function featureToOl(feature, projectionOut, getId) {
    getId = getId ? getId : getEntityId;
    /** @type {?} */
    var olFormat = new OlGeoJSON();
    /** @type {?} */
    var olFeature = olFormat.readFeature(feature, {
        dataProjection: feature.projection,
        featureProjection: projectionOut
    });
    olFeature.setId(getId(feature));
    /** @type {?} */
    var title = getEntityTitle(feature);
    if (title !== undefined) {
        olFeature.set('_title', title, true);
    }
    if (feature.extent !== undefined) {
        olFeature.set('_extent', feature.extent, true);
    }
    if (feature.projection !== undefined) {
        olFeature.set('_projection', feature.projection, true);
    }
    /** @type {?} */
    var mapTitle = getEntityProperty(feature, 'meta.mapTitle');
    if (mapTitle !== undefined) {
        olFeature.set('_mapTitle', mapTitle, true);
    }
    olFeature.set('_entityRevision', getEntityRevision(feature), true);
    /** @type {?} */
    var icon = getEntityIcon(feature);
    if (icon !== undefined) {
        olFeature.set('_icon', icon, true);
    }
    if (feature.meta && feature.meta.style) {
        olFeature.set('_style', feature.meta.style, true);
    }
    if (feature.sourceId) {
        olFeature.set('_sourceId', feature.sourceId, true);
    }
    return olFeature;
}
/**
 * @param {?} olRenderFeature
 * @param {?} projectionIn
 * @param {?=} olLayer
 * @param {?=} projectionOut
 * @return {?}
 */
function renderFeatureFromOl(olRenderFeature, projectionIn, olLayer, projectionOut) {
    if (projectionOut === void 0) { projectionOut = 'EPSG:4326'; }
    /** @type {?} */
    var geom;
    /** @type {?} */
    var title;
    /** @type {?} */
    var exclude;
    /** @type {?} */
    var excludeOffline;
    if (olLayer) {
        title = olLayer.get('title');
        if (olLayer.get('sourceOptions')) {
            exclude = olLayer.get('sourceOptions').excludeAttribute;
            excludeOffline = olLayer.get('sourceOptions').excludeAttributeOffline;
        }
    }
    else {
        title = olRenderFeature.get('_title');
    }
    /** @type {?} */
    var olFormat = new OlGeoJSON();
    /** @type {?} */
    var properties = olRenderFeature.getProperties();
    /** @type {?} */
    var geometryType = olRenderFeature.getType();
    if (geometryType === 'Polygon') {
        /** @type {?} */
        var ends = olRenderFeature.ends_;
        geom = new OlPolygon(olRenderFeature.flatCoordinates_, OlGeometryLayout.XY, ends);
    }
    else if (geometryType === 'Point') {
        geom = new OlPoint(olRenderFeature.flatCoordinates_, OlGeometryLayout.XY);
    }
    else if (geometryType === 'LineString') {
        geom = new OlLineString(olRenderFeature.flatCoordinates_, OlGeometryLayout.XY);
    }
    /** @type {?} */
    var geometry = olFormat.writeGeometryObject(geom, {
        dataProjection: projectionOut,
        featureProjection: projectionIn
    });
    /** @type {?} */
    var id = olRenderFeature.getId() ? olRenderFeature.getId() : uuid();
    /** @type {?} */
    var mapTitle = olRenderFeature.get('_mapTitle');
    return {
        type: FEATURE,
        projection: projectionOut,
        extent: olRenderFeature.getExtent(),
        meta: {
            id: id,
            title: title ? title : mapTitle ? mapTitle : id,
            mapTitle: mapTitle,
            excludeAttribute: exclude,
            excludeAttributeOffline: excludeOffline
        },
        properties: properties,
        geometry: geometry,
        ol: olRenderFeature
    };
}
/**
 * Create a feature object out of an OL feature
 * The output object has a reference to the feature id.
 * @param {?} olFeature OL Feature
 * @param {?} projectionIn OL feature projection
 * @param {?=} olLayer OL Layer
 * @param {?=} projectionOut Feature projection
 * @return {?} Feature
 */
function featureFromOl(olFeature, projectionIn, olLayer, projectionOut) {
    if (projectionOut === void 0) { projectionOut = 'EPSG:4326'; }
    /** @type {?} */
    var title;
    /** @type {?} */
    var exclude;
    /** @type {?} */
    var excludeOffline;
    /** @type {?} */
    var olFormat = new OlGeoJSON();
    /** @type {?} */
    var keys = olFeature.getKeys().filter((/**
     * @param {?} key
     * @return {?}
     */
    function (key) {
        return !key.startsWith('_') && key !== 'geometry';
    }));
    /** @type {?} */
    var properties = keys.reduce((/**
     * @param {?} acc
     * @param {?} key
     * @return {?}
     */
    function (acc, key) {
        acc[key] = olFeature.get(key);
        return acc;
    }), {});
    /** @type {?} */
    var geometry = olFormat.writeGeometryObject(olFeature.getGeometry(), {
        dataProjection: projectionOut,
        featureProjection: projectionIn
    });
    if (olLayer) {
        title = olLayer.get('title');
        if (olLayer.get('sourceOptions')) {
            exclude = olLayer.get('sourceOptions').excludeAttribute;
            excludeOffline = olLayer.get('sourceOptions').excludeAttributeOffline;
        }
    }
    else {
        title = olFeature.get('_title');
    }
    /** @type {?} */
    var mapTitle = olFeature.get('_mapTitle');
    /** @type {?} */
    var id = olFeature.getId() ? olFeature.getId() : uuid();
    return {
        type: FEATURE,
        projection: projectionOut,
        extent: olFeature.get('_extent'),
        meta: {
            id: id,
            title: title ? title : mapTitle ? mapTitle : id,
            mapTitle: mapTitle,
            revision: olFeature.getRevision(),
            style: olFeature.get('_style'),
            excludeAttribute: exclude,
            excludeAttributeOffline: excludeOffline
        },
        properties: properties,
        geometry: geometry,
        ol: olFeature
    };
}
/**
 * Compute an OL feature extent in it's map projection
 * @param {?} map Map
 * @param {?} olFeature OL feature
 * @return {?} Extent in the map projection
 */
function computeOlFeatureExtent(map$$1, olFeature) {
    /** @type {?} */
    var olExtent = createEmpty();
    /** @type {?} */
    var olFeatureExtent = olFeature.get('_extent');
    /** @type {?} */
    var olFeatureProjection = olFeature.get('_projection');
    if (olFeatureExtent !== undefined && olFeatureProjection !== undefined) {
        olExtent = transformExtent(olFeatureExtent, olFeatureProjection, map$$1.projection);
    }
    else {
        /** @type {?} */
        var olGeometry = olFeature.getGeometry();
        if (olGeometry !== null) {
            olExtent = olGeometry.getExtent();
        }
    }
    return olExtent;
}
/**
 * Compute a multiple OL features extent in their map projection
 * @param {?} map Map
 * @param {?} olFeatures OL features
 * @return {?} Extent in the map projection
 */
function computeOlFeaturesExtent(map$$1, olFeatures) {
    /** @type {?} */
    var extent = createEmpty();
    olFeatures.forEach((/**
     * @param {?} olFeature
     * @return {?}
     */
    function (olFeature) {
        /** @type {?} */
        var featureExtent = computeOlFeatureExtent(map$$1, olFeature);
        extend(extent, featureExtent);
    }));
    return extent;
}
/**
 * Scale an extent.
 * @param {?} extent Extent
 * @param {?} scale
 * @return {?} Scaled extent
 */
function scaleExtent(extent, scale) {
    var _a = __read(getSize(extent), 2), width = _a[0], height = _a[1];
    return [
        scale[3] ? extent[0] - width * scale[3] : extent[0],
        scale[2] ? extent[1] - height * scale[2] : extent[1],
        scale[1] ? extent[2] + width * scale[1] : extent[2],
        scale[0] ? extent[3] + height * scale[0] : extent[3]
    ];
}
/**
 * Return true if features are out of view.
 * If features are too close to the edge, they are considered out of view.
 * We define the edge as 5% of the extent size.
 * @param {?} map Map
 * @param {?} featuresExtent The features's extent
 * @return {?} Return true if features are out of view
 */
function featuresAreOutOfView(map$$1, featuresExtent) {
    /** @type {?} */
    var mapExtent = map$$1.viewController.getExtent();
    /** @type {?} */
    var edgeRatio = 0.05;
    /** @type {?} */
    var scale = [-1, -1, -1, -1].map((/**
     * @param {?} x
     * @return {?}
     */
    function (x) { return x * edgeRatio; }));
    /** @type {?} */
    var viewExtent = scaleExtent(mapExtent, (/** @type {?} */ (scale)));
    return !containsExtent(viewExtent, featuresExtent);
}
/**
 * Return true if features are too deep into the view. This results
 * in features being too small.
 * Features are considered too small if their extent occupies less than
 * 1% of the map extent.
 * @param {?} map Map
 * @param {?} featuresExtent The features's extent
 * @param {?=} areaRatio The features extent to view extent acceptable ratio
 * @return {?} Return true if features are too deep in the view
 */
function featuresAreTooDeepInView(map$$1, featuresExtent, areaRatio) {
    // An area ratio of 0.004 means that the feature extent's width and height
    // should be about 1/16 of the map extent's width and height
    areaRatio = areaRatio ? areaRatio : 0.004;
    /** @type {?} */
    var mapExtent = map$$1.viewController.getExtent();
    /** @type {?} */
    var mapExtentArea = getArea(mapExtent);
    /** @type {?} */
    var featuresExtentArea = getArea(featuresExtent);
    if (featuresExtentArea === 0 && map$$1.viewController.getZoom() > 13) { // In case it's a point
        return false;
    }
    return featuresExtentArea / mapExtentArea < areaRatio;
}
/**
 * Fit view to include the features extent.
 * By default, this method will let the features occupy about 50% of the viewport.
 * @param {?} map Map
 * @param {?} olFeatures OL features
 * @param {?=} motion To motion to the new map view
 * @param {?=} scale If this is defined, the original view will be scaled
 *  by that factor before any logic is applied.
 * @param {?=} areaRatio
 * @return {?}
 */
function moveToOlFeatures(map$$1, olFeatures, motion, scale, areaRatio) {
    if (motion === void 0) { motion = FeatureMotion.Default; }
    /** @type {?} */
    var featuresExtent = computeOlFeaturesExtent(map$$1, olFeatures);
    /** @type {?} */
    var viewExtent = featuresExtent;
    if (scale !== undefined) {
        viewExtent = scaleExtent(viewExtent, scale);
    }
    if (motion === FeatureMotion.Zoom) {
        map$$1.viewController.zoomToExtent(viewExtent);
    }
    else if (motion === FeatureMotion.Move) {
        map$$1.viewController.moveToExtent(viewExtent);
    }
    else if (motion === FeatureMotion.Default) {
        if (featuresAreOutOfView(map$$1, featuresExtent) ||
            featuresAreTooDeepInView(map$$1, featuresExtent, areaRatio)) {
            map$$1.viewController.zoomToExtent(viewExtent);
        }
    }
}
/**
 * Hide an OL feature
 * @param {?} olFeature OL feature
 * @return {?}
 */
function hideOlFeature(olFeature) {
    olFeature.setStyle(new Style({}));
}
/**
 * Try to bind a layer to a store if none is bound already.
 * The layer will also be added to the store's map.
 * If no layer is given to that function, a basic one will be created.
 * @param {?} store The store to bind the layer
 * @param {?=} layer An optional VectorLayer
 * @return {?}
 */
function tryBindStoreLayer(store, layer) {
    if (store.layer !== undefined) {
        if (store.layer.map === undefined) {
            store.map.addLayer(store.layer);
        }
        return;
    }
    layer = layer
        ? layer
        : new VectorLayer({
            source: new FeatureDataSource()
        });
    store.bindLayer(layer);
    if (store.layer.map === undefined) {
        store.map.addLayer(store.layer);
    }
}
/**
 * Try to add a loading strategy to a store and activate it.
 * If no strategy is given to that function, a basic one will be created.
 * @param {?} store The store to bind the loading strategy
 * @param {?=} strategy An optional loading strategy
 * @return {?}
 */
function tryAddLoadingStrategy(store, strategy) {
    if (store.getStrategyOfType(FeatureStoreLoadingStrategy) !== undefined) {
        store.activateStrategyOfType(FeatureStoreLoadingStrategy);
        return;
    }
    strategy = strategy ? strategy : new FeatureStoreLoadingStrategy({});
    store.addStrategy(strategy);
    strategy.activate();
}
/**
 * Try to add a selection strategy to a store and activate it.
 * If no strategy is given to that function, a basic one will be created.
 * @param {?} store The store to bind the selection strategy
 * @param {?=} strategy
 * @return {?}
 */
function tryAddSelectionStrategy(store, strategy) {
    if (store.getStrategyOfType(FeatureStoreSelectionStrategy) !== undefined) {
        store.activateStrategyOfType(FeatureStoreSelectionStrategy);
        return;
    }
    strategy = strategy
        ? strategy
        : new FeatureStoreSelectionStrategy({
            map: store.map
        });
    store.addStrategy(strategy);
    strategy.activate();
}
/**
 * Compute a diff between a source array of Ol features and a target array
 * @param {?} source Source array of OL features
 * @param {?} target
 * @return {?} Features to add and remove
 */
function computeOlFeaturesDiff(source, target) {
    /** @type {?} */
    var olFeaturesMap = new Map();
    target.forEach((/**
     * @param {?} olFeature
     * @return {?}
     */
    function (olFeature) {
        olFeaturesMap.set(olFeature.getId(), olFeature);
    }));
    /** @type {?} */
    var olFeaturesToRemove = [];
    source.forEach((/**
     * @param {?} olFeature
     * @return {?}
     */
    function (olFeature) {
        /** @type {?} */
        var newOlFeature = olFeaturesMap.get(olFeature.getId());
        if (newOlFeature === undefined) {
            olFeaturesToRemove.push(olFeature);
        }
        else if (newOlFeature.get('_entityRevision') !== olFeature.get('_entityRevision')) {
            olFeaturesToRemove.push(olFeature);
        }
        else {
            olFeaturesMap.delete(newOlFeature.getId());
        }
    }));
    /** @type {?} */
    var olFeaturesToAddIds = Array.from(olFeaturesMap.keys());
    /** @type {?} */
    var olFeaturesToAdd = target.filter((/**
     * @param {?} olFeature
     * @return {?}
     */
    function (olFeature) {
        return olFeaturesToAddIds.indexOf(olFeature.getId()) >= 0;
    }));
    return {
        add: olFeaturesToAdd,
        remove: olFeaturesToRemove
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * A configurable form, optionnally bound to a feature.
 * This component creates an entity form and, on submit,
 * returns a feature made out of the submitted data. It also
 * does things like managing the feature visibility while it's being updated
 * as well as disabling the selection of another feature.
 */
var FeatureFormComponent = /** @class */ (function () {
    function FeatureFormComponent() {
        this.feature$ = new BehaviorSubject(undefined);
        /**
         * Event emitted when the form is submitted
         */
        this.submitForm = new EventEmitter();
    }
    Object.defineProperty(FeatureFormComponent.prototype, "feature", {
        get: /**
         * @return {?}
         */
        function () { return this.feature$.value; },
        /**
         * Feature to update
         */
        set: /**
         * Feature to update
         * @param {?} value
         * @return {?}
         */
        function (value) { this.feature$.next(value); },
        enumerable: true,
        configurable: true
    });
    /**
     * Transform the form data to a feature and emit an event
     * @param event Form submit event
     * @internal
     */
    /**
     * Transform the form data to a feature and emit an event
     * \@internal
     * @param {?} data
     * @return {?}
     */
    FeatureFormComponent.prototype.onSubmit = /**
     * Transform the form data to a feature and emit an event
     * \@internal
     * @param {?} data
     * @return {?}
     */
    function (data) {
        /** @type {?} */
        var feature = this.formDataToFeature(data);
        this.submitForm.emit(feature);
    };
    /**
     * @return {?}
     */
    FeatureFormComponent.prototype.getData = /**
     * @return {?}
     */
    function () {
        return this.formDataToFeature(this.igoForm.getData());
    };
    /**
     * Transform the form data to a feature
     * @param data Form data
     * @returns A feature
     */
    /**
     * Transform the form data to a feature
     * @private
     * @param {?} data Form data
     * @return {?} A feature
     */
    FeatureFormComponent.prototype.formDataToFeature = /**
     * Transform the form data to a feature
     * @private
     * @param {?} data Form data
     * @return {?} A feature
     */
    function (data) {
        /** @type {?} */
        var properties = {};
        /** @type {?} */
        var meta = {};
        if (this.feature === undefined) {
            ((/** @type {?} */ (meta))).id = uuid();
        }
        else {
            Object.assign(properties, this.feature.properties);
            Object.assign(meta, this.feature.meta, {
                revision: getEntityRevision(this.feature) + 1
            });
        }
        /** @type {?} */
        var propertyPrefix = 'properties.';
        Object.entries(data).forEach((/**
         * @param {?} entry
         * @return {?}
         */
        function (entry) {
            var _a = __read(entry, 2), key = _a[0], value = _a[1];
            if (key.startsWith(propertyPrefix)) {
                /** @type {?} */
                var property = key.substr(propertyPrefix.length);
                properties[property] = value;
            }
        }));
        /** @type {?} */
        var geometry = data.geometry;
        if (geometry === undefined && this.feature !== undefined) {
            geometry = this.feature.geometry;
        }
        return {
            meta: (/** @type {?} */ (meta)),
            type: FEATURE,
            geometry: geometry,
            projection: 'EPSG:4326',
            properties: properties
        };
    };
    FeatureFormComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igo-feature-form',
                    template: "\r\n<igo-form\r\n  #igoForm\r\n  [form]=\"form\"\r\n  [formData]=\"feature$ | async\"\r\n  (submitForm)=\"onSubmit($event)\">\r\n\r\n  <ng-content></ng-content>\r\n  \r\n  <ng-content select=\"[formButtons]\" formButtons></ng-content>\r\n  \r\n</igo-form>\r\n",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: [":host{display:block}igo-form{height:100%}"]
                }] }
    ];
    /** @nocollapse */
    FeatureFormComponent.ctorParameters = function () { return []; };
    FeatureFormComponent.propDecorators = {
        form: [{ type: Input }],
        feature: [{ type: Input }],
        submitForm: [{ type: Output }],
        igoForm: [{ type: ViewChild, args: ['igoForm',] }]
    };
    return FeatureFormComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * This class is simply a shortcut for adding features to a map.
 * It does nothing more than a standard layer but it's shipped with
 * a defautl style based on the geometry type of the features it contains.
 * \@todo Enhance that by using a FeatureStore and strategies.
 */
var  /**
 * This class is simply a shortcut for adding features to a map.
 * It does nothing more than a standard layer but it's shipped with
 * a defautl style based on the geometry type of the features it contains.
 * \@todo Enhance that by using a FeatureStore and strategies.
 */
Overlay = /** @class */ (function () {
    function Overlay(map$$1) {
        this.layer = createOverlayLayer();
        this.setMap(map$$1);
    }
    Object.defineProperty(Overlay.prototype, "dataSource", {
        /**
         * Overlay layer's data source
         */
        get: /**
         * Overlay layer's data source
         * @return {?}
         */
        function () {
            return (/** @type {?} */ (this.layer.dataSource));
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Bind this to a map and add the overlay layer to that map
     * @param map Map
     */
    /**
     * Bind this to a map and add the overlay layer to that map
     * @param {?} map Map
     * @return {?}
     */
    Overlay.prototype.setMap = /**
     * Bind this to a map and add the overlay layer to that map
     * @param {?} map Map
     * @return {?}
     */
    function (map$$1) {
        if (map$$1 === undefined) {
            if (this.map !== undefined) {
                this.map.ol.removeLayer(this.layer.ol);
            }
        }
        else {
            map$$1.ol.addLayer(this.layer.ol);
        }
        this.map = map$$1;
    };
    /**
     * Set the overlay features and, optionally, move to them
     * @param features Features
     * @param motion Optional: Apply this motion to the map view
     * @param sourceId Optional: Remove features of certain sourceId (ex: 'Map' for query features)
     */
    /**
     * Set the overlay features and, optionally, move to them
     * @param {?} features Features
     * @param {?=} motion Optional: Apply this motion to the map view
     * @param {?=} sourceId Optional: Remove features of certain sourceId (ex: 'Map' for query features)
     * @return {?}
     */
    Overlay.prototype.setFeatures = /**
     * Set the overlay features and, optionally, move to them
     * @param {?} features Features
     * @param {?=} motion Optional: Apply this motion to the map view
     * @param {?=} sourceId Optional: Remove features of certain sourceId (ex: 'Map' for query features)
     * @return {?}
     */
    function (features, motion, sourceId) {
        if (motion === void 0) { motion = FeatureMotion.Default; }
        var e_1, _a;
        if (sourceId) {
            try {
                for (var _b = __values(this.dataSource.ol.getFeatures()), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var olFeature = _c.value;
                    if (olFeature.get('_sourceId') === sourceId) {
                        this.removeOlFeature(olFeature);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        else {
            this.clear();
        }
        this.addFeatures(features, motion);
    };
    /**
     * Add a feature to the  overlay and, optionally, move to it
     * @param feature Feature
     * @param motion Optional: Apply this motion to the map view
     */
    /**
     * Add a feature to the  overlay and, optionally, move to it
     * @param {?} feature Feature
     * @param {?=} motion Optional: Apply this motion to the map view
     * @return {?}
     */
    Overlay.prototype.addFeature = /**
     * Add a feature to the  overlay and, optionally, move to it
     * @param {?} feature Feature
     * @param {?=} motion Optional: Apply this motion to the map view
     * @return {?}
     */
    function (feature, motion) {
        if (motion === void 0) { motion = FeatureMotion.Default; }
        this.addFeatures([feature], motion);
    };
    /**
     * Add features to the  overlay and, optionally, move to them
     * @param features Features
     * @param motion Optional: Apply this motion to the map view
     */
    /**
     * Add features to the  overlay and, optionally, move to them
     * @param {?} features Features
     * @param {?=} motion Optional: Apply this motion to the map view
     * @return {?}
     */
    Overlay.prototype.addFeatures = /**
     * Add features to the  overlay and, optionally, move to them
     * @param {?} features Features
     * @param {?=} motion Optional: Apply this motion to the map view
     * @return {?}
     */
    function (features, motion) {
        var _this = this;
        if (motion === void 0) { motion = FeatureMotion.Default; }
        /** @type {?} */
        var olFeatures = [];
        features.forEach((/**
         * @param {?} feature
         * @return {?}
         */
        function (feature) {
            /** @type {?} */
            var olFeature = featureToOl(feature, _this.map.projection);
            /** @type {?} */
            var olGeometry = olFeature.getGeometry();
            if (olGeometry === null) {
                return;
            }
            olFeatures.push(olFeature);
        }));
        this.addOlFeatures(olFeatures, motion);
    };
    /**
     * Add a OpenLayers feature to the  overlay and, optionally, move to it
     * @param olFeature OpenLayers Feature
     * @param motion Optional: Apply this motion to the map view
     */
    /**
     * Add a OpenLayers feature to the  overlay and, optionally, move to it
     * @param {?} olFeature OpenLayers Feature
     * @param {?=} motion Optional: Apply this motion to the map view
     * @return {?}
     */
    Overlay.prototype.addOlFeature = /**
     * Add a OpenLayers feature to the  overlay and, optionally, move to it
     * @param {?} olFeature OpenLayers Feature
     * @param {?=} motion Optional: Apply this motion to the map view
     * @return {?}
     */
    function (olFeature, motion) {
        if (motion === void 0) { motion = FeatureMotion.Default; }
        this.addOlFeatures([olFeature], motion);
    };
    /**
     * Add OpenLayers features to the overlay and, optionally, move to them
     * @param olFeatures OpenLayers Features
     * @param motion Optional: Apply this motion to the map view
     */
    /**
     * Add OpenLayers features to the overlay and, optionally, move to them
     * @param {?} olFeatures OpenLayers Features
     * @param {?=} motion Optional: Apply this motion to the map view
     * @return {?}
     */
    Overlay.prototype.addOlFeatures = /**
     * Add OpenLayers features to the overlay and, optionally, move to them
     * @param {?} olFeatures OpenLayers Features
     * @param {?=} motion Optional: Apply this motion to the map view
     * @return {?}
     */
    function (olFeatures, motion) {
        if (motion === void 0) { motion = FeatureMotion.Default; }
        this.dataSource.ol.addFeatures(olFeatures);
        moveToOlFeatures(this.map, olFeatures, motion);
    };
    /**
     * Remove a feature from the overlay
     * @param feature Feature
     */
    /**
     * Remove a feature from the overlay
     * @param {?} feature Feature
     * @return {?}
     */
    Overlay.prototype.removeFeature = /**
     * Remove a feature from the overlay
     * @param {?} feature Feature
     * @return {?}
     */
    function (feature) {
        this.removeFeatures([feature]);
    };
    /**
     * Remove features from the overlay
     * @param features Features
     */
    /**
     * Remove features from the overlay
     * @param {?} features Features
     * @return {?}
     */
    Overlay.prototype.removeFeatures = /**
     * Remove features from the overlay
     * @param {?} features Features
     * @return {?}
     */
    function (features) {
        var _this = this;
        features.forEach((/**
         * @param {?} feature
         * @return {?}
         */
        function (feature) {
            if (feature.meta) {
                if (_this.dataSource.ol.getFeatureById(feature.meta.id)) {
                    _this.removeOlFeature(_this.dataSource.ol.getFeatureById(feature.meta.id));
                }
            }
        }));
    };
    /**
     * Remove an OpenLayers feature from the overlay
     * @param olFeature OpenLayers Feature
     */
    /**
     * Remove an OpenLayers feature from the overlay
     * @param {?} olFeature OpenLayers Feature
     * @return {?}
     */
    Overlay.prototype.removeOlFeature = /**
     * Remove an OpenLayers feature from the overlay
     * @param {?} olFeature OpenLayers Feature
     * @return {?}
     */
    function (olFeature) {
        this.dataSource.ol.removeFeature(olFeature);
    };
    /**
     * Clear the overlay
     */
    /**
     * Clear the overlay
     * @return {?}
     */
    Overlay.prototype.clear = /**
     * Clear the overlay
     * @return {?}
     */
    function () {
        this.dataSource.ol.clear();
    };
    return Overlay;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var LayerWatcher = /** @class */ (function (_super) {
    __extends(LayerWatcher, _super);
    function LayerWatcher() {
        var _this = _super.call(this) || this;
        _this.loaded = 0;
        _this.loading = 0;
        _this.layers = [];
        _this.subscriptions = [];
        return _this;
    }
    /**
     * @return {?}
     */
    LayerWatcher.prototype.watch = /**
     * @return {?}
     */
    function () { };
    /**
     * @return {?}
     */
    LayerWatcher.prototype.unwatch = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.layers.forEach((/**
         * @param {?} layer
         * @return {?}
         */
        function (layer) { return _this.unwatchLayer(layer); }), this);
    };
    /**
     * @param {?} layer
     * @return {?}
     */
    LayerWatcher.prototype.watchLayer = /**
     * @param {?} layer
     * @return {?}
     */
    function (layer) {
        var _this = this;
        if (layer.status$ === undefined) {
            return;
        }
        this.layers.push(layer);
        /** @type {?} */
        var layer$$ = layer.status$
            .pipe(distinctUntilChanged())
            .subscribe((/**
         * @param {?} status
         * @return {?}
         */
        function (status) {
            if (status === SubjectStatus.Working) {
                _this.loading += 1;
            }
            else if (status === SubjectStatus.Done) {
                _this.loaded += 1;
            }
            if (_this.loaded >= _this.loading) {
                _this.loading = _this.loaded = 0;
                _this.status = SubjectStatus.Done;
            }
            else if (_this.loading > 0) {
                _this.status = SubjectStatus.Working;
            }
        }));
        this.subscriptions.push(layer$$);
    };
    /**
     * @param {?} layer
     * @return {?}
     */
    LayerWatcher.prototype.unwatchLayer = /**
     * @param {?} layer
     * @return {?}
     */
    function (layer) {
        layer.status$.next(SubjectStatus.Done);
        /** @type {?} */
        var index = this.layers.indexOf(layer);
        if (index >= 0) {
            /** @type {?} */
            var status_1 = ((/** @type {?} */ (layer))).watcher.status;
            if ([SubjectStatus.Working, SubjectStatus.Waiting].indexOf(status_1) !== -1) {
                this.loaded += 1;
            }
            this.subscriptions[index].unsubscribe();
            this.subscriptions.splice(index, 1);
            this.layers.splice(index, 1);
            ((/** @type {?} */ (layer))).watcher.unwatch();
        }
    };
    return LayerWatcher;
}(Watcher));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
var MapViewAction = {
    Move: 0,
    Zoom: 1,
};
MapViewAction[MapViewAction.Move] = 'Move';
MapViewAction[MapViewAction.Zoom] = 'Zoom';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Base map controller
 */
var  /**
 * Base map controller
 */
MapController = /** @class */ (function () {
    function MapController() {
        /**
         * Array of observer keys
         */
        this.observerKeys = [];
    }
    /**
     * Return the OL map this controller is bound to
     * @returns OL Map
     */
    /**
     * Return the OL map this controller is bound to
     * @return {?} OL Map
     */
    MapController.prototype.getOlMap = /**
     * Return the OL map this controller is bound to
     * @return {?} OL Map
     */
    function () {
        return this.olMap;
    };
    /**
     * Add or remove this controller to/from a map.
     * @param map OL Map
     */
    /**
     * Add or remove this controller to/from a map.
     * @param {?} olMap
     * @return {?}
     */
    MapController.prototype.setOlMap = /**
     * Add or remove this controller to/from a map.
     * @param {?} olMap
     * @return {?}
     */
    function (olMap$$1) {
        if (olMap$$1 !== undefined && this.getOlMap() !== undefined) {
            throw new Error('This controller is already bound to a map.');
        }
        if (olMap$$1 === undefined) {
            this.teardownObservers();
            this.olMap = olMap$$1;
            return;
        }
        this.olMap = olMap$$1;
    };
    /**
     * Teardown any observers
     */
    /**
     * Teardown any observers
     * @return {?}
     */
    MapController.prototype.teardownObservers = /**
     * Teardown any observers
     * @return {?}
     */
    function () {
        this.observerKeys.forEach((/**
         * @param {?} key
         * @return {?}
         */
        function (key) { return unByKey(key); }));
        this.observerKeys = [];
    };
    return MapController;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Controller to handle map view interactions
 */
var  /**
 * Controller to handle map view interactions
 */
MapViewController = /** @class */ (function (_super) {
    __extends(MapViewController, _super);
    function MapViewController(options) {
        var _this = _super.call(this) || this;
        _this.options = options;
        /**
         * Observable of the current resolution
         */
        _this.resolution$ = new BehaviorSubject(undefined);
        /**
         * Observable of the current state
         */
        _this.state$ = new BehaviorSubject(undefined);
        /**
         * View Padding
         */
        _this.padding = [0, 0, 0, 0];
        /**
         * Max zoom after set extent
         */
        _this.maxZoomOnExtent = 19;
        /**
         * Extent stream
         */
        _this.extent$ = new Subject();
        /**
         * History of states
         */
        _this.states = [];
        /**
         * Current state index
         */
        _this.stateIndex = 0;
        return _this;
    }
    Object.defineProperty(MapViewController.prototype, "stateHistory", {
        /**
         * Whether the view controller should keep the view's state history
         */
        get: /**
         * Whether the view controller should keep the view's state history
         * @return {?}
         */
        function () {
            return this.options ? this.options.stateHistory === true : false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MapViewController.prototype, "olView", {
        /**
         * OL View
         */
        get: /**
         * OL View
         * @return {?}
         */
        function () {
            return this.olMap.getView();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Add or remove this controller to/from a map.
     * @param map OL Map
     */
    /**
     * Add or remove this controller to/from a map.
     * @param {?} olMap
     * @return {?}
     */
    MapViewController.prototype.setOlMap = /**
     * Add or remove this controller to/from a map.
     * @param {?} olMap
     * @return {?}
     */
    function (olMap$$1) {
        _super.prototype.setOlMap.call(this, olMap$$1);
        this.setupObservers();
    };
    /**
     * Observe move moveend and subscribe to the extent stream
     */
    /**
     * Observe move moveend and subscribe to the extent stream
     * @return {?}
     */
    MapViewController.prototype.setupObservers = /**
     * Observe move moveend and subscribe to the extent stream
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.stateHistory === true) {
            this.observerKeys.push(this.olMap.on('moveend', (/**
             * @param {?} event
             * @return {?}
             */
            function (event) { return _this.onMoveEnd(event); })));
        }
        this.extent$$ = this.extent$
            .pipe(debounceTime(25))
            .subscribe((/**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            _this.setExtent(value.extent, value.action);
        }));
    };
    /**
     * Teardown any observers
     */
    /**
     * Teardown any observers
     * @return {?}
     */
    MapViewController.prototype.teardownObservers = /**
     * Teardown any observers
     * @return {?}
     */
    function () {
        _super.prototype.teardownObservers.call(this);
        if (this.extent$$ !== undefined) {
            this.extent$$.unsubscribe();
            this.extent$$ = undefined;
        }
    };
    /**
     * Get the view's OL projection
     * @returns OL projection
     */
    /**
     * Get the view's OL projection
     * @return {?} OL projection
     */
    MapViewController.prototype.getOlProjection = /**
     * Get the view's OL projection
     * @return {?} OL projection
     */
    function () {
        return this.olView.getProjection();
    };
    /**
     * Get the current map view center
     * @param projection Output projection
     * @returns Center
     */
    /**
     * Get the current map view center
     * @param {?=} projection Output projection
     * @return {?} Center
     */
    MapViewController.prototype.getCenter = /**
     * Get the current map view center
     * @param {?=} projection Output projection
     * @return {?} Center
     */
    function (projection) {
        /** @type {?} */
        var center = this.olView.getCenter();
        if (projection && center) {
            center = transform(center, this.getOlProjection(), projection);
        }
        return center;
    };
    /**
     * Get the current view extent
     * @param projection Output projection
     * @returns Extent
     */
    /**
     * Get the current view extent
     * @param {?=} projection Output projection
     * @return {?} Extent
     */
    MapViewController.prototype.getExtent = /**
     * Get the current view extent
     * @param {?=} projection Output projection
     * @return {?} Extent
     */
    function (projection) {
        /** @type {?} */
        var extent = this.olView.calculateExtent(this.olMap.getSize());
        if (projection && extent) {
            extent = transformExtent(extent, this.getOlProjection(), projection);
        }
        return extent;
    };
    /**
     * Get the current scale
     * @param dpi Dot per inches
     * @returns View scale
     */
    /**
     * Get the current scale
     * @param {?=} dpi Dot per inches
     * @return {?} View scale
     */
    MapViewController.prototype.getScale = /**
     * Get the current scale
     * @param {?=} dpi Dot per inches
     * @return {?} View scale
     */
    function (dpi) {
        if (dpi === void 0) { dpi = 96; }
        return getScaleFromResolution(this.getResolution(), this.getOlProjection().getUnits(), dpi);
    };
    /**
     * Get the current resolution
     * @returns Projection denominator
     */
    /**
     * Get the current resolution
     * @return {?} Projection denominator
     */
    MapViewController.prototype.getResolution = /**
     * Get the current resolution
     * @return {?} Projection denominator
     */
    function () {
        return this.olView.getResolution();
    };
    /**
     * Get the current zoom level
     * @returns Zoom level
     */
    /**
     * Get the current zoom level
     * @return {?} Zoom level
     */
    MapViewController.prototype.getZoom = /**
     * Get the current zoom level
     * @return {?} Zoom level
     */
    function () {
        return Math.round(this.olView.getZoom());
    };
    /**
     * Zoom in
     */
    /**
     * Zoom in
     * @return {?}
     */
    MapViewController.prototype.zoomIn = /**
     * Zoom in
     * @return {?}
     */
    function () {
        this.zoomTo(this.olView.getZoom() + 1);
    };
    /**
     * Zoom out
     */
    /**
     * Zoom out
     * @return {?}
     */
    MapViewController.prototype.zoomOut = /**
     * Zoom out
     * @return {?}
     */
    function () {
        this.zoomTo(this.olView.getZoom() - 1);
    };
    /**
     * Zoom to specific zoom level
     * @param zoom Zoom level
     */
    /**
     * Zoom to specific zoom level
     * @param {?} zoom Zoom level
     * @return {?}
     */
    MapViewController.prototype.zoomTo = /**
     * Zoom to specific zoom level
     * @param {?} zoom Zoom level
     * @return {?}
     */
    function (zoom) {
        this.olView.cancelAnimations();
        this.olView.animate({
            zoom: zoom,
            duration: 250,
            easing: easeOut
        });
    };
    /**
     * Move to extent after a short delay (100ms) unless
     * a new movement gets registered in the meantime.
     * @param extent Extent to move to
     */
    /**
     * Move to extent after a short delay (100ms) unless
     * a new movement gets registered in the meantime.
     * @param {?} extent Extent to move to
     * @return {?}
     */
    MapViewController.prototype.moveToExtent = /**
     * Move to extent after a short delay (100ms) unless
     * a new movement gets registered in the meantime.
     * @param {?} extent Extent to move to
     * @return {?}
     */
    function (extent) {
        this.extent$.next({ extent: extent, action: MapViewAction.Move });
    };
    /**
     * Zoom to extent after a short delay (100ms) unless
     * a new movement gets registered in the meantime.
     * @param extent Extent to zoom to
     */
    /**
     * Zoom to extent after a short delay (100ms) unless
     * a new movement gets registered in the meantime.
     * @param {?} extent Extent to zoom to
     * @return {?}
     */
    MapViewController.prototype.zoomToExtent = /**
     * Zoom to extent after a short delay (100ms) unless
     * a new movement gets registered in the meantime.
     * @param {?} extent Extent to zoom to
     * @return {?}
     */
    function (extent) {
        this.extent$.next({ extent: extent, action: MapViewAction.Zoom });
    };
    /**
     * Return the current view rotation
     * @returns Rotation angle in degrees
     */
    /**
     * Return the current view rotation
     * @return {?} Rotation angle in degrees
     */
    MapViewController.prototype.getRotation = /**
     * Return the current view rotation
     * @return {?} Rotation angle in degrees
     */
    function () {
        return this.olView.getRotation();
    };
    /**
     * Reset the view rotation to 0
     */
    /**
     * Reset the view rotation to 0
     * @return {?}
     */
    MapViewController.prototype.resetRotation = /**
     * Reset the view rotation to 0
     * @return {?}
     */
    function () {
        this.olView.animate({ rotation: 0 });
    };
    /**
     * Whether the view has a previous state
     * @returns True if the view has a previous state
     */
    /**
     * Whether the view has a previous state
     * @return {?} True if the view has a previous state
     */
    MapViewController.prototype.hasPreviousState = /**
     * Whether the view has a previous state
     * @return {?} True if the view has a previous state
     */
    function () {
        return this.states.length > 1 && this.stateIndex > 0;
    };
    /**
     * Whether the view has a next state
     * @returns True if the view has a next state
     */
    /**
     * Whether the view has a next state
     * @return {?} True if the view has a next state
     */
    MapViewController.prototype.hasNextState = /**
     * Whether the view has a next state
     * @return {?} True if the view has a next state
     */
    function () {
        return this.states.length > 1 && this.stateIndex < this.states.length - 1;
    };
    /**
     * Restore the previous view state
     */
    /**
     * Restore the previous view state
     * @return {?}
     */
    MapViewController.prototype.previousState = /**
     * Restore the previous view state
     * @return {?}
     */
    function () {
        if (this.hasPreviousState()) {
            this.setStateIndex(this.stateIndex - 1);
        }
    };
    /**
     * Restore the next view state
     */
    /**
     * Restore the next view state
     * @return {?}
     */
    MapViewController.prototype.nextState = /**
     * Restore the next view state
     * @return {?}
     */
    function () {
        if (this.hasNextState()) {
            this.setStateIndex(this.stateIndex + 1);
        }
    };
    /**
     * Clear the state history
     */
    /**
     * Clear the state history
     * @return {?}
     */
    MapViewController.prototype.clearStateHistory = /**
     * Clear the state history
     * @return {?}
     */
    function () {
        this.states = [];
        this.stateIndex = 0;
    };
    /**
     * Update the the view to it's intial state
     */
    /**
     * Update the the view to it's intial state
     * @return {?}
     */
    MapViewController.prototype.setInitialState = /**
     * Update the the view to it's intial state
     * @return {?}
     */
    function () {
        if (this.states.length > 0) {
            this.setStateIndex(0);
        }
    };
    /**
     * Move to the extent retrieved from the stream
     * @param extent Extent
     * @param action Either zoom or move
     * @param animation With or without animation to the target extent.
     */
    /**
     * Move to the extent retrieved from the stream
     * @private
     * @param {?} extent Extent
     * @param {?} action Either zoom or move
     * @param {?=} animation With or without animation to the target extent.
     * @return {?}
     */
    MapViewController.prototype.setExtent = /**
     * Move to the extent retrieved from the stream
     * @private
     * @param {?} extent Extent
     * @param {?} action Either zoom or move
     * @param {?=} animation With or without animation to the target extent.
     * @return {?}
     */
    function (extent, action, animation) {
        if (animation === void 0) { animation = true; }
        /** @type {?} */
        var olView$$1 = this.olView;
        olView$$1.cancelAnimations();
        /** @type {?} */
        var duration$$1 = animation ? 500 : 0;
        /** @type {?} */
        var zoom = olView$$1.getZoom();
        /** @type {?} */
        var fromCenter = olView$$1.getCenter();
        /** @type {?} */
        var toCenter = [
            extent[0] + (extent[2] - extent[0]) / 2,
            extent[1] + (extent[3] - extent[1]) / 2
        ];
        /** @type {?} */
        var distCenter = Math.sqrt(Math.pow(fromCenter[0] - toCenter[0], 2) +
            Math.pow(fromCenter[1] - toCenter[1], 2));
        /** @type {?} */
        var fromExtent = olView$$1.calculateExtent();
        /** @type {?} */
        var fromSize = Math.sqrt(Math.pow(fromExtent[2] - fromExtent[0], 2) +
            Math.pow(fromExtent[3] - fromExtent[1], 2));
        /** @type {?} */
        var toSize = Math.sqrt(Math.pow(extent[2] - extent[0], 2) + Math.pow(extent[3] - extent[1], 2));
        /** @type {?} */
        var moySize = (toSize + fromSize) / 2;
        /** @type {?} */
        var xSize = distCenter / moySize;
        /** @type {?} */
        var maxZoom = action === MapViewAction.Move || zoom > this.maxZoomOnExtent
            ? zoom
            : this.maxZoomOnExtent;
        olView$$1.fit(extent, {
            maxZoom: maxZoom,
            padding: this.padding,
            duration: xSize > 4 ? 0 : duration$$1
        });
    };
    /**
     * Set the view state index
     * @param index State index
     */
    /**
     * Set the view state index
     * @private
     * @param {?} index State index
     * @return {?}
     */
    MapViewController.prototype.setStateIndex = /**
     * Set the view state index
     * @private
     * @param {?} index State index
     * @return {?}
     */
    function (index) {
        this.stateIndex = index;
        this.setState(this.states[index]);
    };
    /**
     * Set the view state
     * @param state View state
     */
    /**
     * Set the view state
     * @private
     * @param {?} state View state
     * @return {?}
     */
    MapViewController.prototype.setState = /**
     * Set the view state
     * @private
     * @param {?} state View state
     * @return {?}
     */
    function (state$$1) {
        this.olView.animate({
            resolution: state$$1.resolution,
            center: state$$1.center,
            duration: 0
        });
    };
    /**
     * On move end, get the view state and record it.
     * @param event Map event
     */
    /**
     * On move end, get the view state and record it.
     * @private
     * @param {?} event Map event
     * @return {?}
     */
    MapViewController.prototype.onMoveEnd = /**
     * On move end, get the view state and record it.
     * @private
     * @param {?} event Map event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var resolution = this.getResolution();
        if (this.resolution$.value !== resolution) {
            this.resolution$.next(resolution);
        }
        /** @type {?} */
        var state$$1 = {
            resolution: resolution,
            center: this.getCenter(),
            zoom: this.getZoom()
        };
        if (this.stateHistory === true) {
            /** @type {?} */
            var stateIndex = this.stateIndex;
            /** @type {?} */
            var stateAtIndex = this.states.length === 0 ? undefined : this.states[stateIndex];
            if (!viewStatesAreEqual(state$$1, stateAtIndex)) {
                this.states = this.states.slice(0, stateIndex + 1).concat([state$$1]);
                this.stateIndex = this.states.length - 1;
            }
        }
        this.state$.next(state$$1);
    };
    return MapViewController;
}(MapController));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// TODO: This class is messy. Clearly define it's scope and the map browser's.
// Move some stuff into controllers.
var  
// TODO: This class is messy. Clearly define it's scope and the map browser's.
// Move some stuff into controllers.
IgoMap = /** @class */ (function () {
    function IgoMap(options) {
        this.offlineButtonToggle$ = new BehaviorSubject(false);
        this.layers$ = new BehaviorSubject([]);
        this.positionFollower = true;
        this.geolocation$ = new BehaviorSubject(undefined);
        this.defaultOptions = {
            controls: { attribution: false }
        };
        this.options = Object.assign({}, this.defaultOptions, options);
        this.layerWatcher = new LayerWatcher();
        this.status$ = this.layerWatcher.status$;
        register(proj4);
        this.init();
    }
    Object.defineProperty(IgoMap.prototype, "layers", {
        get: /**
         * @return {?}
         */
        function () {
            return this.layers$.value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgoMap.prototype, "projection", {
        get: /**
         * @return {?}
         */
        function () {
            return this.viewController.getOlProjection().getCode();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    IgoMap.prototype.init = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var controls = [];
        if (this.options.controls) {
            if (this.options.controls.attribution) {
                /** @type {?} */
                var attributionOpt = (/** @type {?} */ ((this.options.controls.attribution === true
                    ? {}
                    : this.options.controls.attribution)));
                controls.push(new olAttribution(attributionOpt));
            }
            if (this.options.controls.scaleLine) {
                /** @type {?} */
                var scaleLineOpt = (/** @type {?} */ ((this.options.controls.scaleLine === true
                    ? {}
                    : this.options.controls.scaleLine)));
                controls.push(new olControlScaleLine(scaleLineOpt));
            }
        }
        /** @type {?} */
        var interactions = {};
        if (this.options.interactions === false) {
            interactions = {
                altShiftDragRotate: false,
                doubleClickZoom: false,
                keyboard: false,
                mouseWheelZoom: false,
                shiftDragZoom: false,
                dragPan: false,
                pinchRotate: false,
                pinchZoom: false
            };
        }
        this.ol = new olMap({
            interactions: defaults(interactions),
            controls: controls
        });
        this.setView(this.options.view || {});
        this.viewController = new MapViewController({
            stateHistory: true
        });
        this.viewController.setOlMap(this.ol);
        this.overlay = new Overlay(this);
        this.buffer = new Overlay(this);
    };
    /**
     * @param {?} id
     * @return {?}
     */
    IgoMap.prototype.setTarget = /**
     * @param {?} id
     * @return {?}
     */
    function (id) {
        this.ol.setTarget(id);
        if (id !== undefined) {
            this.layerWatcher.subscribe((/**
             * @return {?}
             */
            function () { }), null);
        }
        else {
            this.layerWatcher.unsubscribe();
        }
    };
    /**
     * @param {?} options
     * @return {?}
     */
    IgoMap.prototype.updateView = /**
     * @param {?} options
     * @return {?}
     */
    function (options) {
        /** @type {?} */
        var currentView = this.ol.getView();
        /** @type {?} */
        var viewOptions = Object.assign({
            zoom: currentView.getZoom()
        }, currentView.getProperties());
        this.setView(Object.assign(viewOptions, options));
        if (options.maxZoomOnExtent) {
            this.viewController.maxZoomOnExtent = options.maxZoomOnExtent;
        }
    };
    /**
     * Set the map view
     * @param options Map view options
     */
    /**
     * Set the map view
     * @param {?} options Map view options
     * @return {?}
     */
    IgoMap.prototype.setView = /**
     * Set the map view
     * @param {?} options Map view options
     * @return {?}
     */
    function (options) {
        if (this.viewController !== undefined) {
            this.viewController.clearStateHistory();
        }
        /** @type {?} */
        var view = new olView(options);
        this.ol.setView(view);
        this.unsubscribeGeolocate();
        if (options) {
            if (options.center) {
                /** @type {?} */
                var projection = view.getProjection().getCode();
                /** @type {?} */
                var center = fromLonLat(options.center, projection);
                view.setCenter(center);
            }
            if (options.geolocate) {
                this.geolocate(true);
            }
            if (options.alwaysTracking) {
                this.alwaysTracking = true;
            }
        }
    };
    /**
     * Deprecated
     * TODO: Move to ViewController and update every place it's used
     */
    /**
     * Deprecated
     * TODO: Move to ViewController and update every place it's used
     * @param {?=} projection
     * @return {?}
     */
    IgoMap.prototype.getCenter = /**
     * Deprecated
     * TODO: Move to ViewController and update every place it's used
     * @param {?=} projection
     * @return {?}
     */
    function (projection) {
        return this.viewController.getCenter(projection);
    };
    /**
     * Deprecated
     * TODO: Move to ViewController and update every place it's used
     */
    /**
     * Deprecated
     * TODO: Move to ViewController and update every place it's used
     * @param {?=} projection
     * @return {?}
     */
    IgoMap.prototype.getExtent = /**
     * Deprecated
     * TODO: Move to ViewController and update every place it's used
     * @param {?=} projection
     * @return {?}
     */
    function (projection) {
        return this.viewController.getExtent(projection);
    };
    // TODO: Move to ViewController and update every place it's used
    // TODO: Move to ViewController and update every place it's used
    /**
     * @return {?}
     */
    IgoMap.prototype.getZoom = 
    // TODO: Move to ViewController and update every place it's used
    /**
     * @return {?}
     */
    function () {
        return this.viewController.getZoom();
    };
    /**
     * @param {?} baseLayer
     * @return {?}
     */
    IgoMap.prototype.changeBaseLayer = /**
     * @param {?} baseLayer
     * @return {?}
     */
    function (baseLayer) {
        var e_1, _a;
        if (!baseLayer) {
            return;
        }
        try {
            for (var _b = __values(this.getBaseLayers()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var bl = _c.value;
                bl.visible = false;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        baseLayer.visible = true;
        this.viewController.olView.setMinZoom(baseLayer.dataSource.options.minZoom || (this.options.view || {}).minZoom);
        this.viewController.olView.setMaxZoom(baseLayer.dataSource.options.maxZoom || (this.options.view || {}).maxZoom);
    };
    /**
     * @return {?}
     */
    IgoMap.prototype.getBaseLayers = /**
     * @return {?}
     */
    function () {
        return this.layers.filter((/**
         * @param {?} layer
         * @return {?}
         */
        function (layer) { return layer.baseLayer === true; }));
    };
    /**
     * @param {?} id
     * @return {?}
     */
    IgoMap.prototype.getLayerById = /**
     * @param {?} id
     * @return {?}
     */
    function (id) {
        return this.layers.find((/**
         * @param {?} layer
         * @return {?}
         */
        function (layer) { return layer.id && layer.id === id; }));
    };
    /**
     * @param {?} alias
     * @return {?}
     */
    IgoMap.prototype.getLayerByAlias = /**
     * @param {?} alias
     * @return {?}
     */
    function (alias) {
        return this.layers.find((/**
         * @param {?} layer
         * @return {?}
         */
        function (layer) { return layer.alias && layer.alias === alias; }));
    };
    /**
     * Add a single layer
     * @param layer Layer to add
     * @param push DEPRECATED
     */
    /**
     * Add a single layer
     * @param {?} layer Layer to add
     * @param {?=} push DEPRECATED
     * @return {?}
     */
    IgoMap.prototype.addLayer = /**
     * Add a single layer
     * @param {?} layer Layer to add
     * @param {?=} push DEPRECATED
     * @return {?}
     */
    function (layer, push) {
        if (push === void 0) { push = true; }
        this.addLayers([layer]);
    };
    /**
     * Add many layers
     * @param layers Layers to add
     * @param push DEPRECATED
     */
    /**
     * Add many layers
     * @param {?} layers Layers to add
     * @param {?=} push DEPRECATED
     * @return {?}
     */
    IgoMap.prototype.addLayers = /**
     * Add many layers
     * @param {?} layers Layers to add
     * @param {?=} push DEPRECATED
     * @return {?}
     */
    function (layers, push) {
        var _this = this;
        if (push === void 0) { push = true; }
        /** @type {?} */
        var offsetZIndex = 0;
        /** @type {?} */
        var offsetBaseLayerZIndex = 0;
        /** @type {?} */
        var addedLayers = layers
            .map((/**
         * @param {?} layer
         * @return {?}
         */
        function (layer) {
            /** @type {?} */
            var offset = layer.zIndex
                ? 0
                : layer.baseLayer
                    ? offsetBaseLayerZIndex++
                    : offsetZIndex++;
            return _this.doAddLayer(layer, offset);
        }))
            .filter((/**
         * @param {?} layer
         * @return {?}
         */
        function (layer) { return layer !== undefined; }));
        this.setLayers([].concat(this.layers, addedLayers));
    };
    /**
     * Remove a single layer
     * @param layer Layer to remove
     */
    /**
     * Remove a single layer
     * @param {?} layer Layer to remove
     * @return {?}
     */
    IgoMap.prototype.removeLayer = /**
     * Remove a single layer
     * @param {?} layer Layer to remove
     * @return {?}
     */
    function (layer) {
        this.removeLayers([layer]);
    };
    /**
     * Remove many layers
     * @param layers Layers to remove
     */
    /**
     * Remove many layers
     * @param {?} layers Layers to remove
     * @return {?}
     */
    IgoMap.prototype.removeLayers = /**
     * Remove many layers
     * @param {?} layers Layers to remove
     * @return {?}
     */
    function (layers) {
        var _this = this;
        /** @type {?} */
        var newLayers = this.layers$.value.slice(0);
        /** @type {?} */
        var layersToRemove = [];
        layers.forEach((/**
         * @param {?} layer
         * @return {?}
         */
        function (layer) {
            /** @type {?} */
            var index = newLayers.indexOf(layer);
            if (index >= 0) {
                layersToRemove.push(layer);
                newLayers.splice(index, 1);
            }
        }));
        layersToRemove.forEach((/**
         * @param {?} layer
         * @return {?}
         */
        function (layer) { return _this.doRemoveLayer(layer); }));
        this.setLayers(newLayers);
    };
    /**
     * Remove all layers
     */
    /**
     * Remove all layers
     * @return {?}
     */
    IgoMap.prototype.removeAllLayers = /**
     * Remove all layers
     * @return {?}
     */
    function () {
        var _this = this;
        this.layers.forEach((/**
         * @param {?} layer
         * @return {?}
         */
        function (layer) { return _this.doRemoveLayer(layer); }));
        this.layers$.next([]);
    };
    /**
     * @param {?} layer
     * @return {?}
     */
    IgoMap.prototype.raiseLayer = /**
     * @param {?} layer
     * @return {?}
     */
    function (layer) {
        /** @type {?} */
        var index = this.getLayerIndex(layer);
        if (index > 1) {
            this.moveLayer(layer, index, index - 1);
        }
    };
    /**
     * @param {?} layers
     * @return {?}
     */
    IgoMap.prototype.raiseLayers = /**
     * @param {?} layers
     * @return {?}
     */
    function (layers) {
        var e_2, _a;
        try {
            for (var layers_1 = __values(layers), layers_1_1 = layers_1.next(); !layers_1_1.done; layers_1_1 = layers_1.next()) {
                var layer = layers_1_1.value;
                this.raiseLayer(layer);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (layers_1_1 && !layers_1_1.done && (_a = layers_1.return)) _a.call(layers_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
    };
    /**
     * @param {?} layer
     * @return {?}
     */
    IgoMap.prototype.lowerLayer = /**
     * @param {?} layer
     * @return {?}
     */
    function (layer) {
        /** @type {?} */
        var index = this.getLayerIndex(layer);
        if (index < this.layers.length - 1) {
            this.moveLayer(layer, index, index + 1);
        }
    };
    /**
     * @param {?} layers
     * @return {?}
     */
    IgoMap.prototype.lowerLayers = /**
     * @param {?} layers
     * @return {?}
     */
    function (layers) {
        var e_3, _a;
        /** @type {?} */
        var reverseLayers = layers.reverse();
        try {
            for (var reverseLayers_1 = __values(reverseLayers), reverseLayers_1_1 = reverseLayers_1.next(); !reverseLayers_1_1.done; reverseLayers_1_1 = reverseLayers_1.next()) {
                var layer = reverseLayers_1_1.value;
                this.lowerLayer(layer);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (reverseLayers_1_1 && !reverseLayers_1_1.done && (_a = reverseLayers_1.return)) _a.call(reverseLayers_1);
            }
            finally { if (e_3) throw e_3.error; }
        }
    };
    /**
     * @param {?} layer
     * @param {?} from
     * @param {?} to
     * @return {?}
     */
    IgoMap.prototype.moveLayer = /**
     * @param {?} layer
     * @param {?} from
     * @param {?} to
     * @return {?}
     */
    function (layer, from, to) {
        /** @type {?} */
        var layerTo = this.layers[to];
        /** @type {?} */
        var zIndexTo = layerTo.zIndex;
        /** @type {?} */
        var zIndexFrom = layer.zIndex;
        if (layerTo.baseLayer || layer.baseLayer) {
            return;
        }
        layer.zIndex = zIndexTo;
        layerTo.zIndex = zIndexFrom;
        this.layers[to] = layer;
        this.layers[from] = layerTo;
        this.layers$.next(this.layers.slice(0));
    };
    /**
     * Add a layer to the OL map and start watching. If the layer is already
     * added to this map, make it visible but don't add it one again.
     * @param layer Layer
     * @returns The layer added, if any
     */
    /**
     * Add a layer to the OL map and start watching. If the layer is already
     * added to this map, make it visible but don't add it one again.
     * @private
     * @param {?} layer Layer
     * @param {?} offsetZIndex
     * @return {?} The layer added, if any
     */
    IgoMap.prototype.doAddLayer = /**
     * Add a layer to the OL map and start watching. If the layer is already
     * added to this map, make it visible but don't add it one again.
     * @private
     * @param {?} layer Layer
     * @param {?} offsetZIndex
     * @return {?} The layer added, if any
     */
    function (layer, offsetZIndex) {
        if (layer.baseLayer && layer.visible) {
            this.changeBaseLayer(layer);
        }
        /** @type {?} */
        var existingLayer = this.getLayerById(layer.id);
        if (existingLayer !== undefined) {
            existingLayer.visible = true;
            return;
        }
        if (!layer.baseLayer && layer.zIndex) {
            layer.zIndex += 10;
        }
        if (layer.zIndex === undefined || layer.zIndex === 0) {
            /** @type {?} */
            var maxZIndex = Math.max.apply(Math, __spread([layer.baseLayer ? 0 : 10], this.layers
                .filter((/**
             * @param {?} l
             * @return {?}
             */
            function (l) { return l.baseLayer === layer.baseLayer && l.zIndex < 200; } // zIndex > 200 = system layer
            ))
                .map((/**
             * @param {?} l
             * @return {?}
             */
            function (l) { return l.zIndex; }))));
            layer.zIndex = maxZIndex + 1 + offsetZIndex;
        }
        if (layer.baseLayer && layer.zIndex > 9) {
            layer.zIndex = 10; // baselayer must have zIndex < 10
        }
        layer.setMap(this);
        this.layerWatcher.watchLayer(layer);
        this.ol.addLayer(layer.ol);
        return layer;
    };
    /**
     * Remove a layer from the OL map and stop watching
     * @param layer Layer
     */
    /**
     * Remove a layer from the OL map and stop watching
     * @private
     * @param {?} layer Layer
     * @return {?}
     */
    IgoMap.prototype.doRemoveLayer = /**
     * Remove a layer from the OL map and stop watching
     * @private
     * @param {?} layer Layer
     * @return {?}
     */
    function (layer) {
        this.layerWatcher.unwatchLayer(layer);
        this.ol.removeLayer(layer.ol);
        layer.setMap(undefined);
    };
    /**
     * Update the layers observable
     * @param layers Layers
     */
    /**
     * Update the layers observable
     * @private
     * @param {?} layers Layers
     * @return {?}
     */
    IgoMap.prototype.setLayers = /**
     * Update the layers observable
     * @private
     * @param {?} layers Layers
     * @return {?}
     */
    function (layers) {
        this.layers$.next(this.sortLayersByZIndex(layers).slice(0));
    };
    /**
     * Sort layers by descending zIndex
     * @param layers Array of layers
     * @returns The original array, sorted by zIndex
     */
    /**
     * Sort layers by descending zIndex
     * @private
     * @param {?} layers Array of layers
     * @return {?} The original array, sorted by zIndex
     */
    IgoMap.prototype.sortLayersByZIndex = /**
     * Sort layers by descending zIndex
     * @private
     * @param {?} layers Array of layers
     * @return {?} The original array, sorted by zIndex
     */
    function (layers) {
        // Sort by descending zIndex
        return layers.sort((/**
         * @param {?} layer1
         * @param {?} layer2
         * @return {?}
         */
        function (layer1, layer2) { return layer2.zIndex - layer1.zIndex; }));
    };
    /**
     * Get layer index in the map's inenr array of layers
     * @param layer Layer
     * @returns The layer index
     */
    /**
     * Get layer index in the map's inenr array of layers
     * @private
     * @param {?} layer Layer
     * @return {?} The layer index
     */
    IgoMap.prototype.getLayerIndex = /**
     * Get layer index in the map's inenr array of layers
     * @private
     * @param {?} layer Layer
     * @return {?} The layer index
     */
    function (layer) {
        return this.layers.findIndex((/**
         * @param {?} _layer
         * @return {?}
         */
        function (_layer) { return _layer === layer; }));
    };
    // TODO: Create a GeolocationController with everything below
    // TODO: Create a GeolocationController with everything below
    /**
     * @param {?=} track
     * @return {?}
     */
    IgoMap.prototype.geolocate = 
    // TODO: Create a GeolocationController with everything below
    /**
     * @param {?=} track
     * @return {?}
     */
    function (track) {
        var _this = this;
        if (track === void 0) { track = false; }
        /** @type {?} */
        var first$$1 = true;
        if (this.geolocation$$) {
            track = this.geolocation.getTracking();
            this.unsubscribeGeolocate();
        }
        this.startGeolocation();
        this.geolocation$$ = this.geolocation$.subscribe((/**
         * @param {?} geolocation
         * @return {?}
         */
        function (geolocation) {
            if (!geolocation) {
                return;
            }
            /** @type {?} */
            var accuracy = geolocation.getAccuracy();
            if (accuracy < 10000) {
                /** @type {?} */
                var geometry = geolocation.getAccuracyGeometry();
                /** @type {?} */
                var extent = geometry.getExtent();
                if (_this.geolocationFeature &&
                    _this.overlay.dataSource.ol.getFeatureById(_this.geolocationFeature.getId())) {
                    _this.overlay.dataSource.ol.removeFeature(_this.geolocationFeature);
                }
                if (_this.bufferFeature) {
                    _this.buffer.dataSource.ol.removeFeature(_this.bufferFeature);
                }
                _this.geolocationFeature = new OlFeature({ geometry: geometry });
                _this.geolocationFeature.setId('geolocationFeature');
                if (!_this.positionFollower && _this.alwaysTracking) {
                    _this.overlay.addOlFeature(_this.geolocationFeature, FeatureMotion.None);
                }
                else if (_this.positionFollower && _this.alwaysTracking) {
                    _this.overlay.addOlFeature(_this.geolocationFeature, FeatureMotion.Move);
                }
                else {
                    _this.overlay.addOlFeature(_this.geolocationFeature);
                }
                if (_this.ol.getView().options_.buffer) {
                    /** @type {?} */
                    var bufferRadius = _this.ol.getView().options_.buffer.bufferRadius;
                    /** @type {?} */
                    var coordinates = geolocation.getPosition();
                    _this.bufferGeom = new olCircle(coordinates, bufferRadius);
                    /** @type {?} */
                    var bufferStroke = _this.ol.getView().options_.buffer.bufferStroke;
                    /** @type {?} */
                    var bufferFill = _this.ol.getView().options_.buffer.bufferFill;
                    /** @type {?} */
                    var bufferText = void 0;
                    if (_this.ol.getView().options_.buffer.showBufferRadius) {
                        bufferText = bufferRadius.toString() + 'm';
                    }
                    else {
                        bufferText = '';
                    }
                    _this.bufferFeature = new OlFeature(_this.bufferGeom);
                    _this.bufferFeature.setId('bufferFeature');
                    _this.bufferFeature.set('bufferStroke', bufferStroke);
                    _this.bufferFeature.set('bufferFill', bufferFill);
                    _this.bufferFeature.set('bufferText', bufferText);
                    _this.buffer.addOlFeature(_this.bufferFeature, FeatureMotion.None);
                }
                if (first$$1) {
                    _this.viewController.zoomToExtent(extent);
                    _this.positionFollower = !_this.positionFollower;
                }
            }
            else if (first$$1) {
                /** @type {?} */
                var view = _this.ol.getView();
                /** @type {?} */
                var coordinates = geolocation.getPosition();
                view.setCenter(coordinates);
                view.setZoom(14);
            }
            if (track && !_this.alwaysTracking) {
                _this.unsubscribeGeolocate();
            }
            first$$1 = false;
        }));
    };
    /**
     * @return {?}
     */
    IgoMap.prototype.unsubscribeGeolocate = /**
     * @return {?}
     */
    function () {
        this.stopGeolocation();
        if (this.geolocation$$) {
            this.geolocation$$.unsubscribe();
            this.geolocation$$ = undefined;
        }
    };
    /**
     * @private
     * @return {?}
     */
    IgoMap.prototype.startGeolocation = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        if (!this.geolocation) {
            this.geolocation = new olGeolocation({
                trackingOptions: {
                    enableHighAccuracy: true
                },
                projection: this.projection,
                tracking: true
            });
            this.geolocation.on('change', (/**
             * @param {?} evt
             * @return {?}
             */
            function (evt) {
                _this.geolocation$.next(_this.geolocation);
            }));
        }
        else {
            this.geolocation.setTracking(true);
        }
    };
    /**
     * @private
     * @return {?}
     */
    IgoMap.prototype.stopGeolocation = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.geolocation) {
            this.geolocation.setTracking(false);
        }
    };
    /**
     * @param {?} offline
     * @return {?}
     */
    IgoMap.prototype.onOfflineToggle = /**
     * @param {?} offline
     * @return {?}
     */
    function (offline) {
        this.offlineButtonToggle$.next(offline);
    };
    return IgoMap;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var MapOfflineDirective = /** @class */ (function () {
    function MapOfflineDirective(component, networkService, messageService, languageService) {
        this.networkService = networkService;
        this.messageService = messageService;
        this.languageService = languageService;
        this.offlineButtonStatus = false;
        this.networkState = {
            connection: true
        };
        this.offlineButtonState = {
            connection: true
        };
        this.component = component;
    }
    Object.defineProperty(MapOfflineDirective.prototype, "map", {
        get: /**
         * @return {?}
         */
        function () {
            return this.component.map;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    MapOfflineDirective.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.map.offlineButtonToggle$.subscribe((/**
         * @param {?} offlineButtonToggle
         * @return {?}
         */
        function (offlineButtonToggle) {
            _this.offlineButtonStatus = offlineButtonToggle;
            /** @type {?} */
            var translate = _this.languageService.translate;
            if (_this.offlineButtonStatus && _this.networkState.connection) {
                /** @type {?} */
                var message = translate.instant('igo.geo.network.offline.message');
                /** @type {?} */
                var title = translate.instant('igo.geo.network.offline.title');
                _this.messageService.info(message, title);
                _this.offlineButtonState.connection = false;
                _this.changeLayer();
            }
            else if (!_this.offlineButtonStatus && !_this.networkState.connection) {
                /** @type {?} */
                var message = translate.instant('igo.geo.network.offline.message');
                /** @type {?} */
                var title = translate.instant('igo.geo.network.offline.title');
                _this.messageService.info(message, title);
                _this.offlineButtonState.connection = false;
                _this.changeLayer();
            }
            else if (!_this.offlineButtonStatus && _this.networkState.connection) {
                /** @type {?} */
                var message_1;
                /** @type {?} */
                var title_1;
                /** @type {?} */
                var messageObs = translate.get('igo.geo.network.online.message');
                /** @type {?} */
                var titleObs = translate.get('igo.geo.network.online.title');
                messageObs.subscribe((/**
                 * @param {?} message1
                 * @return {?}
                 */
                function (message1) {
                    message_1 = message1;
                }));
                titleObs.subscribe((/**
                 * @param {?} title1
                 * @return {?}
                 */
                function (title1) {
                    title_1 = title1;
                }));
                _this.messageService.info(message_1, title_1);
                _this.offlineButtonState.connection = true;
                _this.changeLayer();
            }
        }));
        this.networkService.currentState().subscribe((/**
         * @param {?} state
         * @return {?}
         */
        function (state$$1) {
            _this.networkState = state$$1;
            if (!_this.offlineButtonStatus) {
                _this.changeLayer();
            }
        }));
        this.map.layers$.subscribe((/**
         * @param {?} layers
         * @return {?}
         */
        function (layers) {
            _this.changeLayer();
        }));
    };
    /**
     * @private
     * @return {?}
     */
    MapOfflineDirective.prototype.changeLayer = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var sourceOptions;
        /** @type {?} */
        var layerList = this.map.layers$.value;
        layerList.forEach((/**
         * @param {?} layer
         * @return {?}
         */
        function (layer) {
            if (layer.options.source instanceof MVTDataSource) {
                sourceOptions = ((/** @type {?} */ (layer.options.sourceOptions)));
                layer.ol.getSource().clear();
            }
            else if (layer.options.source instanceof XYZDataSource) {
                sourceOptions = ((/** @type {?} */ (layer.options.sourceOptions)));
            }
            else if (layer.options.source instanceof ClusterDataSource) {
                sourceOptions = ((/** @type {?} */ (layer.options.sourceOptions)));
            }
            else if (layer.options.source instanceof FeatureDataSource) {
                sourceOptions = ((/** @type {?} */ (layer.options.sourceOptions)));
            }
            else {
                if (_this.networkState.connection === false || _this.offlineButtonState.connection === false) {
                    layer.ol.setMaxResolution(0);
                    return;
                }
                else if (_this.networkState.connection === true || _this.offlineButtonState.connection === true) {
                    layer.ol.setMaxResolution(Infinity);
                    return;
                }
            }
            if (sourceOptions) {
                if (sourceOptions.pathOffline && _this.networkState.connection === false ||
                    sourceOptions.pathOffline && _this.offlineButtonState.connection === false) {
                    if (sourceOptions.type === 'vector' || sourceOptions.type === 'cluster') {
                        return;
                    }
                    layer.ol.getSource().setUrl(sourceOptions.pathOffline);
                }
                else if (sourceOptions.pathOffline && _this.networkState.connection === false ||
                    sourceOptions.pathOffline && _this.offlineButtonState.connection === true) {
                    if (sourceOptions.type === 'vector' || sourceOptions.type === 'cluster') {
                        return;
                    }
                    layer.ol.getSource().setUrl(sourceOptions.url);
                }
                else {
                    if (_this.networkState.connection === false || _this.offlineButtonState.connection === false) {
                        layer.ol.setMaxResolution(0);
                    }
                    else if (_this.networkState.connection === true || _this.offlineButtonState.connection === true) {
                        layer.ol.setMaxResolution(Infinity);
                    }
                }
            }
            else {
                if (_this.networkState.connection === false || _this.offlineButtonState.connection === false) {
                    layer.ol.setMaxResolution(0);
                }
                else if (_this.networkState.connection === true || _this.offlineButtonState.connection === true) {
                    layer.ol.setMaxResolution(Infinity);
                }
            }
        }));
    };
    MapOfflineDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igoMapOffline]'
                },] }
    ];
    /** @nocollapse */
    MapOfflineDirective.ctorParameters = function () { return [
        { type: MapBrowserComponent },
        { type: NetworkService },
        { type: MessageService },
        { type: LanguageService }
    ]; };
    return MapOfflineDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * This directive return the pointer coordinate (on click or pointermove)
 * in [longitude, latitude], delayed by in input (pointerMoveDelay)
 * to avoid too many emitted values.
 */
var PointerPositionDirective = /** @class */ (function () {
    function PointerPositionDirective(component, mediaService) {
        this.component = component;
        this.mediaService = mediaService;
        /**
         * Delay before emitting an event
         */
        this.pointerPositionDelay = 1000;
        /**
         * Event emitted when the pointer move, delayed by pointerMoveDelay
         */
        this.pointerPositionCoord = new EventEmitter();
    }
    Object.defineProperty(PointerPositionDirective.prototype, "map", {
        /**
         * IGO map
         * @internal
         */
        get: /**
         * IGO map
         * \@internal
         * @return {?}
         */
        function () {
            return this.component.map;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PointerPositionDirective.prototype, "mapProjection", {
        get: /**
         * @return {?}
         */
        function () {
            return ((/** @type {?} */ (this.component.map))).projection;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Start listening to pointermove
     * @internal
     */
    /**
     * Start listening to pointermove
     * \@internal
     * @return {?}
     */
    PointerPositionDirective.prototype.ngOnInit = /**
     * Start listening to pointermove
     * \@internal
     * @return {?}
     */
    function () {
        this.listenToMapPointerMove();
        this.listenToMapClick();
    };
    /**
     * Stop listening to pointermove
     * @internal
     */
    /**
     * Stop listening to pointermove
     * \@internal
     * @return {?}
     */
    PointerPositionDirective.prototype.ngOnDestroy = /**
     * Stop listening to pointermove
     * \@internal
     * @return {?}
     */
    function () {
        this.unlistenToMapPointerMove();
        this.unlistenToMapClick();
    };
    /**
     * On map pointermove
     */
    /**
     * On map pointermove
     * @private
     * @return {?}
     */
    PointerPositionDirective.prototype.listenToMapPointerMove = /**
     * On map pointermove
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this.pointerMoveListener = this.map.ol.on('pointermove', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.onPointerEvent(event, _this.pointerPositionDelay); }));
    };
    /**
     * On map click
     */
    /**
     * On map click
     * @private
     * @return {?}
     */
    PointerPositionDirective.prototype.listenToMapClick = /**
     * On map click
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this.mapClickListener = this.map.ol.on('singleclick', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.onPointerEvent(event, 0); }));
    };
    /**
     * Stop listening for map pointermove
     */
    /**
     * Stop listening for map pointermove
     * @private
     * @return {?}
     */
    PointerPositionDirective.prototype.unlistenToMapPointerMove = /**
     * Stop listening for map pointermove
     * @private
     * @return {?}
     */
    function () {
        this.map.ol.un(this.pointerMoveListener.type, this.pointerMoveListener.listener);
        this.pointerMoveListener = undefined;
    };
    /**
     * Stop listening for map clicks
     */
    /**
     * Stop listening for map clicks
     * @private
     * @return {?}
     */
    PointerPositionDirective.prototype.unlistenToMapClick = /**
     * Stop listening for map clicks
     * @private
     * @return {?}
     */
    function () {
        this.map.ol.un(this.mapClickListener.type, this.mapClickListener.listener);
        this.mapClickListener = undefined;
    };
    /**
     * emit delayed coordinate (longitude, latitude array) based on pointerMoveDelay or on click
     * @param event OL map browser pointer event
     */
    /**
     * emit delayed coordinate (longitude, latitude array) based on pointerMoveDelay or on click
     * @private
     * @param {?} event OL map browser pointer event
     * @param {?} delay
     * @return {?}
     */
    PointerPositionDirective.prototype.onPointerEvent = /**
     * emit delayed coordinate (longitude, latitude array) based on pointerMoveDelay or on click
     * @private
     * @param {?} event OL map browser pointer event
     * @param {?} delay
     * @return {?}
     */
    function (event, delay) {
        var _this = this;
        if (event.dragging || this.mediaService.isTouchScreen()) {
            return;
        }
        if (typeof this.lastTimeoutRequest !== 'undefined') { // cancel timeout when the mouse moves
            clearTimeout(this.lastTimeoutRequest);
        }
        /** @type {?} */
        var lonlat = transform(event.coordinate, this.mapProjection, 'EPSG:4326');
        this.lastTimeoutRequest = setTimeout((/**
         * @return {?}
         */
        function () {
            _this.pointerPositionCoord.emit(lonlat);
        }), delay);
    };
    PointerPositionDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igoPointerPosition]'
                },] }
    ];
    /** @nocollapse */
    PointerPositionDirective.ctorParameters = function () { return [
        { type: MapBrowserComponent, decorators: [{ type: Self }] },
        { type: MediaService }
    ]; };
    PointerPositionDirective.propDecorators = {
        pointerPositionDelay: [{ type: Input }],
        pointerPositionCoord: [{ type: Output }]
    };
    return PointerPositionDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * This directive return the pointer coordinate (on click or pointermove)
 * in [longitude, latitude], delayed by in input (pointerMoveDelay)
 * to avoid too many emitted values.
 * User needs to hold the key defined by pointerByKeyEventKeyCode to emit a coord.
 */
var PointerPositionByKeyDirective = /** @class */ (function () {
    function PointerPositionByKeyDirective(component, mediaService) {
        this.component = component;
        this.mediaService = mediaService;
        this.definedKeyIsDown$ = new BehaviorSubject(false);
        /**
         * Delay before emitting an event
         */
        this.pointerPositionByKeyDelay = 1000;
        /**
         * The key pressed (must be hold) to trigger the output
         */
        this.pointerPositionByKeyCode = 17;
        /**
         * Event emitted when the pointer move, delayed by pointerMoveDelay
         */
        this.pointerPositionByKeyCoord = new EventEmitter();
    }
    Object.defineProperty(PointerPositionByKeyDirective.prototype, "map", {
        /**
         * IGO map
         * @internal
         */
        get: /**
         * IGO map
         * \@internal
         * @return {?}
         */
        function () {
            return this.component.map;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PointerPositionByKeyDirective.prototype, "mapProjection", {
        get: /**
         * @return {?}
         */
        function () {
            return ((/** @type {?} */ (this.component.map))).projection;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Start listening to pointermove
     * @internal
     */
    /**
     * Start listening to pointermove
     * \@internal
     * @return {?}
     */
    PointerPositionByKeyDirective.prototype.ngOnInit = /**
     * Start listening to pointermove
     * \@internal
     * @return {?}
     */
    function () {
        this.listenToMapPointerMove();
        this.listenToMapClick();
        this.subscribeToKeyDown();
        this.subscribeToKeyUp();
    };
    /**
     * Stop listening to pointermove
     * @internal
     */
    /**
     * Stop listening to pointermove
     * \@internal
     * @return {?}
     */
    PointerPositionByKeyDirective.prototype.ngOnDestroy = /**
     * Stop listening to pointermove
     * \@internal
     * @return {?}
     */
    function () {
        this.unlistenToMapPointerMove();
        this.unlistenToMapClick();
        this.unsubscribeToKeyDown();
        this.unsubscribeToKeyUp();
    };
    /**
     * On map pointermove
     */
    /**
     * On map pointermove
     * @private
     * @return {?}
     */
    PointerPositionByKeyDirective.prototype.listenToMapPointerMove = /**
     * On map pointermove
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this.pointerMoveListener = this.map.ol.on('pointermove', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.onPointerEvent(event, _this.pointerPositionByKeyDelay); }));
    };
    /**
     * On map click
     */
    /**
     * On map click
     * @private
     * @return {?}
     */
    PointerPositionByKeyDirective.prototype.listenToMapClick = /**
     * On map click
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this.mapClickListener = this.map.ol.on('singleclick', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.onPointerEvent(event, 0); }));
    };
    /**
     * Subscribe to user defined key keyDown, hold down to activate the emit
     */
    /**
     * Subscribe to user defined key keyDown, hold down to activate the emit
     * @private
     * @return {?}
     */
    PointerPositionByKeyDirective.prototype.subscribeToKeyDown = /**
     * Subscribe to user defined key keyDown, hold down to activate the emit
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this.unsubscribeToKeyDown();
        this.keyDown$$ = fromEvent(document, 'keydown')
            .subscribe((/**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            // On user defined key is down,
            if (event.keyCode === _this.pointerPositionByKeyCode) {
                _this.definedKeyIsDown$.next(true);
                return;
            }
        }));
    };
    /**
     * Subscribe to user defined key keyUp, release to desactivate the emit
     */
    /**
     * Subscribe to user defined key keyUp, release to desactivate the emit
     * @private
     * @return {?}
     */
    PointerPositionByKeyDirective.prototype.subscribeToKeyUp = /**
     * Subscribe to user defined key keyUp, release to desactivate the emit
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this.unsubscribeToKeyUp();
        this.keyUp$$ = fromEvent(document, 'keyup')
            .subscribe((/**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            // When user defined key is released,
            if (event.keyCode === _this.pointerPositionByKeyCode) {
                _this.definedKeyIsDown$.next(false);
                return;
            }
        }));
    };
    /**
     * Stop listening for map pointermove
     */
    /**
     * Stop listening for map pointermove
     * @private
     * @return {?}
     */
    PointerPositionByKeyDirective.prototype.unlistenToMapPointerMove = /**
     * Stop listening for map pointermove
     * @private
     * @return {?}
     */
    function () {
        this.map.ol.un(this.pointerMoveListener.type, this.pointerMoveListener.listener);
        this.pointerMoveListener = undefined;
    };
    /**
     * Stop listening for map clicks
     */
    /**
     * Stop listening for map clicks
     * @private
     * @return {?}
     */
    PointerPositionByKeyDirective.prototype.unlistenToMapClick = /**
     * Stop listening for map clicks
     * @private
     * @return {?}
     */
    function () {
        this.map.ol.un(this.mapClickListener.type, this.mapClickListener.listener);
        this.mapClickListener = undefined;
    };
    /**
     * Unsubscribe to key down
     */
    /**
     * Unsubscribe to key down
     * @private
     * @return {?}
     */
    PointerPositionByKeyDirective.prototype.unsubscribeToKeyDown = /**
     * Unsubscribe to key down
     * @private
     * @return {?}
     */
    function () {
        if (this.keyDown$$ !== undefined) {
            this.keyDown$$.unsubscribe();
            this.keyDown$$ = undefined;
        }
    };
    /**
     * Unsubscribe to key up
     */
    /**
     * Unsubscribe to key up
     * @private
     * @return {?}
     */
    PointerPositionByKeyDirective.prototype.unsubscribeToKeyUp = /**
     * Unsubscribe to key up
     * @private
     * @return {?}
     */
    function () {
        if (this.keyUp$$ !== undefined) {
            this.keyUp$$.unsubscribe();
            this.keyUp$$ = undefined;
        }
    };
    /**
     * emit delayed coordinate (longitude, latitude array) based on pointerMoveDelay or on click
     * User must hold the defined key to allow the emit.
     * @param event OL map browser pointer event
     */
    /**
     * emit delayed coordinate (longitude, latitude array) based on pointerMoveDelay or on click
     * User must hold the defined key to allow the emit.
     * @private
     * @param {?} event OL map browser pointer event
     * @param {?} delay
     * @return {?}
     */
    PointerPositionByKeyDirective.prototype.onPointerEvent = /**
     * emit delayed coordinate (longitude, latitude array) based on pointerMoveDelay or on click
     * User must hold the defined key to allow the emit.
     * @private
     * @param {?} event OL map browser pointer event
     * @param {?} delay
     * @return {?}
     */
    function (event, delay) {
        var _this = this;
        if (event.dragging || this.mediaService.isTouchScreen()) {
            return;
        }
        if (typeof this.lastTimeoutRequest !== 'undefined') { // cancel timeout when the mouse moves
            clearTimeout(this.lastTimeoutRequest);
        }
        if (this.definedKeyIsDown$.value) {
            /** @type {?} */
            var lonlat_1 = transform(event.coordinate, this.mapProjection, 'EPSG:4326');
            this.lastTimeoutRequest = setTimeout((/**
             * @return {?}
             */
            function () {
                _this.pointerPositionByKeyCoord.emit(lonlat_1);
            }), delay);
        }
    };
    PointerPositionByKeyDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igoPointerPositionByKey]'
                },] }
    ];
    /** @nocollapse */
    PointerPositionByKeyDirective.ctorParameters = function () { return [
        { type: MapBrowserComponent, decorators: [{ type: Self }] },
        { type: MediaService }
    ]; };
    PointerPositionByKeyDirective.propDecorators = {
        pointerPositionByKeyDelay: [{ type: Input }],
        pointerPositionByKeyCode: [{ type: Input }],
        pointerPositionByKeyCoord: [{ type: Output }]
    };
    return PointerPositionByKeyDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * When injected, this service automatically registers and
 * projection defined in the application config. A custom projection
 * needs to be registered to be usable by OL.
 */
var ProjectionService = /** @class */ (function () {
    function ProjectionService(config) {
        var _this = this;
        this.config = config;
        /** @type {?} */
        var projections = this.config.getConfig('projections') || [];
        projections.forEach((/**
         * @param {?} projection
         * @return {?}
         */
        function (projection) {
            projection.alias = projection.alias ? projection.alias : projection.code;
            _this.registerProjection(projection);
        }));
        // register all utm zones
        for (var utmZone = 1; utmZone < 61; utmZone++) {
            /** @type {?} */
            var code = utmZone < 10 ? "EPSG:3260" + utmZone : "EPSG:326" + utmZone;
            /** @type {?} */
            var def = "+proj=utm +zone=" + utmZone + " +datum=WGS84 +units=m +no_defs";
            /** @type {?} */
            var proj = { code: code, def: def, extent: undefined };
            this.registerProjection(proj);
        }
        // register all mtm zones
        for (var mtmZone = 1; mtmZone < 11; mtmZone++) {
            /** @type {?} */
            var code = mtmZone < 10 ? "EPSG:3218" + mtmZone : "EPSG:321" + (80 + mtmZone);
            /** @type {?} */
            var lon0 = void 0;
            if (Number(mtmZone) <= 2) {
                lon0 = -50 - Number(mtmZone) * 3;
            }
            else if (Number(mtmZone) >= 12) {
                lon0 = -81 - (Number(mtmZone) - 12) * 3;
            }
            else {
                lon0 = -49.5 - Number(mtmZone) * 3;
            }
            /** @type {?} */
            var def = "+proj=tmerc +lat_0=0 +lon_0=" + lon0 + " +k=0.9999 +x_0=304800 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs\"";
            /** @type {?} */
            var proj = { code: code, def: def, extent: undefined };
            this.registerProjection(proj);
        }
    }
    /**
     * Define a proj4 projection and register it in OL
     * @param projection Projection
     */
    /**
     * Define a proj4 projection and register it in OL
     * @param {?} projection Projection
     * @return {?}
     */
    ProjectionService.prototype.registerProjection = /**
     * Define a proj4 projection and register it in OL
     * @param {?} projection Projection
     * @return {?}
     */
    function (projection) {
        proj4.defs(projection.code, projection.def);
        register(proj4);
        if (projection.extent) {
            get(projection.code).setExtent(projection.extent);
        }
    };
    ProjectionService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    ProjectionService.ctorParameters = function () { return [
        { type: ConfigService }
    ]; };
    /** @nocollapse */ ProjectionService.ngInjectableDef = defineInjectable({ factory: function ProjectionService_Factory() { return new ProjectionService(inject(ConfigService)); }, token: ProjectionService, providedIn: "root" });
    return ProjectionService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ZoomButtonComponent = /** @class */ (function () {
    function ZoomButtonComponent() {
    }
    Object.defineProperty(ZoomButtonComponent.prototype, "zoom", {
        get: /**
         * @return {?}
         */
        function () { return this.map.viewController.getZoom(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ZoomButtonComponent.prototype, "minZoom", {
        get: /**
         * @return {?}
         */
        function () { return this.map.viewController.olView.getMinZoom() || 1; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ZoomButtonComponent.prototype, "maxZoom", {
        get: /**
         * @return {?}
         */
        function () { return this.map.viewController.olView.getMaxZoom(); },
        enumerable: true,
        configurable: true
    });
    ZoomButtonComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igo-zoom-button',
                    template: "<div class=\"igo-zoom-button-container\">\r\n  <button\r\n    mat-icon-button\r\n    [matTooltip]=\"'igo.geo.mapButtons.zoomIn' | translate: {zoom: zoom + 1}\"\r\n    matTooltipPosition=\"left\"\r\n    [color]=\"color\"\r\n    [disabled]=\"zoom >= maxZoom\"\r\n    (click)=\"map.viewController.zoomIn()\">\r\n    <mat-icon svgIcon=\"plus\"></mat-icon>\r\n  </button>\r\n\r\n  <button\r\n    mat-icon-button\r\n    [matTooltip]=\"'igo.geo.mapButtons.zoomOut' | translate: {zoom: zoom - 1}\"\r\n    matTooltipPosition=\"left\"\r\n    [color]=\"color\"\r\n    [disabled]=\"zoom <= minZoom\"\r\n    (click)=\"map.viewController.zoomOut()\">\r\n    <mat-icon svgIcon=\"minus\"></mat-icon>\r\n  </button>\r\n</div>\r\n",
                    styles: [".igo-zoom-button-container{width:40px}.igo-zoom-button-container button{background-color:#fff}.igo-zoom-button-container button:hover{background-color:#efefef}.igo-zoom-button-container button:first-child{margin-bottom:2px}:host>>>button .mat-button-ripple-round,button{border-radius:0}"]
                }] }
    ];
    /** @nocollapse */
    ZoomButtonComponent.ctorParameters = function () { return []; };
    ZoomButtonComponent.propDecorators = {
        map: [{ type: Input }],
        color: [{ type: Input }]
    };
    return ZoomButtonComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var GeolocateButtonComponent = /** @class */ (function () {
    function GeolocateButtonComponent() {
    }
    Object.defineProperty(GeolocateButtonComponent.prototype, "map", {
        get: /**
         * @return {?}
         */
        function () {
            return this._map;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._map = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GeolocateButtonComponent.prototype, "color", {
        get: /**
         * @return {?}
         */
        function () {
            return this._color;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._color = value;
        },
        enumerable: true,
        configurable: true
    });
    GeolocateButtonComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igo-geolocate-button',
                    template: "<div class=\"igo-geolocate-button-container\">\r\n  <button\r\n    mat-icon-button\r\n    [matTooltip]=\"'igo.geo.mapButtons.geolocate' | translate\"\r\n    matTooltipPosition=\"left\"\r\n    [color]=\"color\"\r\n    (click)=\"map.geolocate()\">\r\n    <mat-icon svgIcon=\"crosshairs-gps\"></mat-icon>\r\n  </button>\r\n</div>\r\n",
                    styles: [".igo-geolocate-button-container{width:40px;background-color:#fff}.igo-geolocate-button-container:hover{background-color:#efefef}:host>>>button .mat-button-ripple-round,button{border-radius:0}"]
                }] }
    ];
    /** @nocollapse */
    GeolocateButtonComponent.ctorParameters = function () { return []; };
    GeolocateButtonComponent.propDecorators = {
        map: [{ type: Input }],
        color: [{ type: Input }]
    };
    return GeolocateButtonComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var OfflineButtonComponent = /** @class */ (function () {
    function OfflineButtonComponent(config) {
        this.config = config;
        this.btnStyle = 'baseStyle';
        this.colorOff = 'rgb(255,255,255)';
        this.change = new EventEmitter();
        this.check = false;
        this.visible = false;
        this.visible = this.config.getConfig('offlineButton') ? true : false;
    }
    Object.defineProperty(OfflineButtonComponent.prototype, "map", {
        get: /**
         * @return {?}
         */
        function () {
            return this._map;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._map = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OfflineButtonComponent.prototype, "color", {
        get: /**
         * @return {?}
         */
        function () {
            return this._color;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._color = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OfflineButtonComponent.prototype, "checked", {
        get: /**
         * @return {?}
         */
        function () {
            return this.check;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OfflineButtonComponent.prototype.onToggle = /**
     * @return {?}
     */
    function () {
        this.check = !this.check;
        if (this.check) {
            this.btnStyle = 'toggleStyle';
        }
        else {
            this.btnStyle = 'baseStyle';
        }
    };
    OfflineButtonComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igo-offline-button',
                    template: "<div *ngIf=\"visible\" class=\"igo-user-button-container\">\r\n  <div>\r\n    <button\r\n      mat-icon-button\r\n      [matTooltip]=\"checked ? ('igo.geo.mapButtons.online' | translate): ('igo.geo.mapButtons.offline' | translate)\"\r\n      matTooltipPosition=\"left\"\r\n      [ngClass]=\"[btnStyle]\"\r\n      [color]=\"checked ? color : [colorOff]\"\r\n      (click)=\"onToggle()\"\r\n      (click)=\"map.onOfflineToggle(check)\">\r\n      <mat-icon svgIcon=\"wifi-strength-off\"></mat-icon>\r\n    </button>\r\n  </div>\r\n</div>",
                    styles: [".baseStyle{width:40px;background-color:#fff}.baseStyle:hover{background-color:#efefef}.toggleStyle{width:40px;background-color:#b9b9b9}:host>>>button .mat-button-ripple-round,button{border-radius:0}"]
                }] }
    ];
    /** @nocollapse */
    OfflineButtonComponent.ctorParameters = function () { return [
        { type: ConfigService }
    ]; };
    OfflineButtonComponent.propDecorators = {
        change: [{ type: Output }],
        map: [{ type: Input }],
        color: [{ type: Input }],
        check: [{ type: Input }]
    };
    return OfflineButtonComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function baseLayersSwitcherSlideInOut() {
    return trigger('baseLayerSwitcherState', [
        state('collapseIcon', style({
            height: '40px',
            width: '40px',
            overflow: 'hidden'
        })),
        state('collapseMap', style({
            height: '85px',
            overflow: 'hidden'
        })),
        state('expand', style({
            overflow: 'hidden'
        })),
        transition('collapse => expand', animate('200ms')),
        transition('expand => collapse', animate('200ms'))
    ]);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var BaseLayersSwitcherComponent = /** @class */ (function () {
    function BaseLayersSwitcherComponent(mediaService) {
        this.mediaService = mediaService;
        this._baseLayers = [];
        this.expand = false;
        this.showButton = true;
        /** @type {?} */
        var media = this.mediaService.media$.value;
        if (media === Media.Mobile && this.useStaticIcon === undefined) {
            this.useStaticIcon = true;
        }
    }
    Object.defineProperty(BaseLayersSwitcherComponent.prototype, "map", {
        get: /**
         * @return {?}
         */
        function () {
            return this._map;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._map = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseLayersSwitcherComponent.prototype, "useStaticIcon", {
        get: /**
         * @return {?}
         */
        function () {
            return this._useStaticIcon;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._useStaticIcon = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    BaseLayersSwitcherComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.layers$$ = this.map.layers$.subscribe((/**
         * @param {?} arrayLayers
         * @return {?}
         */
        function (arrayLayers) {
            _this._baseLayers = arrayLayers.filter((/**
             * @param {?} l
             * @return {?}
             */
            function (l) { return l.baseLayer; }));
        }));
    };
    /**
     * @return {?}
     */
    BaseLayersSwitcherComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.layers$$.unsubscribe();
    };
    /**
     * @return {?}
     */
    BaseLayersSwitcherComponent.prototype.collapseOrExpand = /**
     * @return {?}
     */
    function () {
        if (this.baseLayers.length > 1 || this.useStaticIcon) {
            this.expand = !this.expand;
        }
        else {
            this.expand = false;
        }
    };
    Object.defineProperty(BaseLayersSwitcherComponent.prototype, "baseLayers", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var mapResolution = this.map.viewController.getResolution();
            /** @type {?} */
            var mapZoom = this.map.viewController.getZoom();
            /** @type {?} */
            var bl = this._baseLayers.filter((/**
             * @param {?} l
             * @return {?}
             */
            function (l) {
                return ((!l.options.maxResolution ||
                    mapResolution <= l.options.maxResolution) &&
                    (!l.options.minResolution || mapResolution >= l.options.minResolution) &&
                    (!l.options.source.options.maxZoom || mapZoom <= l.options.source.options.maxZoom) &&
                    (!l.options.source.options.minZoom || mapZoom >= l.options.source.options.minZoom));
            }));
            /** @type {?} */
            var blHidden = bl.filter((/**
             * @param {?} l
             * @return {?}
             */
            function (l) { return !l.visible; }));
            return blHidden.length + 1 === bl.length ? blHidden : bl;
        },
        enumerable: true,
        configurable: true
    });
    BaseLayersSwitcherComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igo-baselayers-switcher',
                    template: "<div *ngIf=\"baseLayers.length > 0\"\r\n     class=\"igo-baselayers-switcher-container\"\r\n     [ngClass]=\"{'container-expand': expand}\"\r\n     [@baseLayerSwitcherState]=\"expand ? 'expand' : useStaticIcon ? 'collapseIcon' : 'collapseMap'\"\r\n     (@baseLayerSwitcherState.start)=\"showButton=false\"\r\n     (@baseLayerSwitcherState.done)=\"showButton=true\"\r\n     (click)=\"collapseOrExpand()\">\r\n\r\n     <div *ngIf=\"useStaticIcon && !expand && showButton\" class=\"igo-baselayers-switcher-button-container\">\r\n       <button\r\n         mat-icon-button\r\n         [matTooltip]=\"'igo.geo.mapButtons.baselayerSwitcher' | translate\"\r\n         matTooltipPosition=\"right\"\r\n         color=\"primary\">\r\n         <mat-icon svgIcon=\"image-multiple\"></mat-icon>\r\n       </button>\r\n     </div>\r\n\r\n     <igo-mini-basemap *ngFor=\"let baseLayer of baseLayers; let i = index\"\r\n       [map]=\"map\"\r\n       [baseLayer]=\"baseLayer\"\r\n       [title]=\"(baseLayers.length > 2 && !expand) ? ('igo.geo.baselayersSwitcher.title' | translate) : baseLayer.title\"\r\n       [display]=\"expand || (i === 0 && !useStaticIcon)\"\r\n       [disabled]=\"!expand && baseLayers.length > 1\">\r\n     </igo-mini-basemap>\r\n\r\n    <div class=\"more-baselayers\">\r\n      <mat-icon class=\"material-icons mat-icon mat-list-avatar\" color=\"primary\" svgIcon=\"menu-down\"></mat-icon>\r\n    </div>\r\n\r\n</div>\r\n",
                    animations: [baseLayersSwitcherSlideInOut()],
                    styles: [".igo-baselayers-switcher-container{height:auto;position:relative}.container-expand{overflow:hidden;border-width:0}.more-baselayers{width:80px;height:20px;background-color:#fff;text-align:center;cursor:pointer}.more-baselayers:hover{background-color:#efefef}.igo-baselayers-switcher-button-container{width:40px;background-color:#fff}.igo-baselayers-switcher-button-container:hover{background-color:#efefef}:host>>>button .mat-button-ripple-round,button{border-radius:0}"]
                }] }
    ];
    /** @nocollapse */
    BaseLayersSwitcherComponent.ctorParameters = function () { return [
        { type: MediaService }
    ]; };
    BaseLayersSwitcherComponent.propDecorators = {
        map: [{ type: Input }],
        useStaticIcon: [{ type: Input }]
    };
    return BaseLayersSwitcherComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var MiniBaseMapComponent = /** @class */ (function () {
    function MiniBaseMapComponent(layerService, appRef) {
        this.layerService = layerService;
        this.appRef = appRef;
        this.basemap = new IgoMap({
            controls: {},
            interactions: false
        });
    }
    Object.defineProperty(MiniBaseMapComponent.prototype, "map", {
        get: /**
         * @return {?}
         */
        function () {
            return this._map;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._map = value;
            this.handleMoveEnd();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MiniBaseMapComponent.prototype, "baseLayer", {
        get: /**
         * @return {?}
         */
        function () {
            return this._baseLayer;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._baseLayer = value;
            this.handleBaseLayerChanged(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MiniBaseMapComponent.prototype, "disabled", {
        get: /**
         * @return {?}
         */
        function () {
            return this._disabled;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._disabled = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MiniBaseMapComponent.prototype, "display", {
        get: /**
         * @return {?}
         */
        function () {
            return this._display;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._display = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    MiniBaseMapComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.map.ol.on('moveend', (/**
         * @return {?}
         */
        function () { return _this.handleMoveEnd(); }));
        this.handleMoveEnd();
    };
    /**
     * @return {?}
     */
    MiniBaseMapComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.map.ol.un('moveend', (/**
         * @return {?}
         */
        function () { return _this.handleMoveEnd(); }));
    };
    /**
     * @param {?} baseLayer
     * @return {?}
     */
    MiniBaseMapComponent.prototype.changeBaseLayer = /**
     * @param {?} baseLayer
     * @return {?}
     */
    function (baseLayer) {
        if (this.disabled) {
            return;
        }
        this.map.changeBaseLayer(baseLayer);
        this.appRef.tick();
    };
    /**
     * @private
     * @return {?}
     */
    MiniBaseMapComponent.prototype.handleMoveEnd = /**
     * @private
     * @return {?}
     */
    function () {
        this.basemap.ol.setView(this.map.ol.getView());
    };
    /**
     * @private
     * @param {?} baselayer
     * @return {?}
     */
    MiniBaseMapComponent.prototype.handleBaseLayerChanged = /**
     * @private
     * @param {?} baselayer
     * @return {?}
     */
    function (baselayer) {
        this.basemap.removeAllLayers();
        /** @type {?} */
        var options = Object.assign(Object.create(baselayer.options), baselayer.options, {
            visible: true,
            baseLayer: false
        });
        /** @type {?} */
        var layer = this.layerService.createLayer(options);
        this.basemap.addLayer(layer);
    };
    MiniBaseMapComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igo-mini-basemap',
                    template: "<div class=\"igo-mini-basemap-container\">\r\n\r\n  <div *ngIf=\"display\" (click)=\"changeBaseLayer(baseLayer)\">\r\n    <igo-map-browser [map]=\"basemap\"></igo-map-browser>\r\n    <div *ngIf='title' class='igo-mini-basemap-title'> {{title}} </div>\r\n  </div>\r\n\r\n</div>\r\n",
                    styles: [".igo-mini-basemap-container{width:calc(40px * 2);height:calc(40px * 2);background-color:rgba(255,255,255,.01);border:2px solid #fff;box-shadow:0 1px 4px rgba(0,0,0,.3);cursor:pointer;margin-top:5px}.igo-mini-basemap-container:hover .igo-mini-basemap-title{color:#000;text-shadow:0 0 5px #fff}.igo-mini-basemap-container>div{width:100%;height:100%}.igo-mini-basemap-title{position:relative;top:-76px;height:76px;width:76px;text-align:center;vertical-align:bottom;color:#fff;text-shadow:0 0 5px #000;white-space:normal;display:-webkit-box;display:flex;-webkit-box-align:end;align-items:flex-end;-webkit-box-pack:center;justify-content:center}"]
                }] }
    ];
    /** @nocollapse */
    MiniBaseMapComponent.ctorParameters = function () { return [
        { type: LayerService },
        { type: ApplicationRef }
    ]; };
    MiniBaseMapComponent.propDecorators = {
        map: [{ type: Input }],
        baseLayer: [{ type: Input }],
        disabled: [{ type: Input }],
        display: [{ type: Input }],
        title: [{ type: Input }]
    };
    return MiniBaseMapComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var RotationButtonComponent = /** @class */ (function () {
    function RotationButtonComponent() {
    }
    Object.defineProperty(RotationButtonComponent.prototype, "map", {
        get: /**
         * @return {?}
         */
        function () {
            return this._map;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._map = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RotationButtonComponent.prototype, "showIfNoRotation", {
        get: /**
         * @return {?}
         */
        function () {
            return this._showIfNoRotation;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._showIfNoRotation = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RotationButtonComponent.prototype, "color", {
        get: /**
         * @return {?}
         */
        function () {
            return this._color;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._color = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RotationButtonComponent.prototype, "rotated", {
        get: /**
         * @return {?}
         */
        function () {
            return this.map.viewController.getRotation() !== 0;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} radians
     * @return {?}
     */
    RotationButtonComponent.prototype.rotationStyle = /**
     * @param {?} radians
     * @return {?}
     */
    function (radians) {
        /** @type {?} */
        var rotation = 'rotate(' + radians + 'rad)';
        return {
            transform: rotation
        };
    };
    RotationButtonComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igo-rotation-button',
                    template: "<div *ngIf=\"rotated && !showIfNoRotation\" class=\"igo-rotation-button-container\"\r\n  [matTooltip]=\"rotated ? ('igo.geo.mapButtons.resetRotation' | translate): ('igo.geo.mapButtons.tipRotation' | translate)\"\r\n  matTooltipPosition=\"left\">\r\n  <button mat-icon-button matTooltipPosition=\"left\" [color]=\"color\" [disabled]=\"!rotated\"\r\n    (click)=\"map.viewController.resetRotation()\">\r\n    <mat-icon [ngStyle]=\"rotationStyle(map.viewController.getRotation())\" svgIcon=\"navigation\">\r\n    </mat-icon>\r\n  </button>\r\n</div>\r\n\r\n<div *ngIf=\"showIfNoRotation\" class=\"igo-rotation-button-container\"\r\n  [matTooltip]=\"rotated ? ('igo.geo.mapButtons.resetRotation' | translate): ('igo.geo.mapButtons.tipRotation' | translate)\"\r\n  matTooltipPosition=\"left\">\r\n  <button mat-icon-button matTooltipPosition=\"left\" [color]=\"color\" [disabled]=\"!rotated\"\r\n    (click)=\"map.viewController.resetRotation()\">\r\n    <mat-icon [ngStyle]=\"rotationStyle(map.viewController.getRotation())\" svgIcon=\"navigation\">\r\n    </mat-icon>\r\n  </button>\r\n</div>",
                    styles: [".igo-rotation-button-container{width:40px;background-color:#fff}.igo-rotation-button-container:hover{background-color:#efefef}:host>>>button .mat-button-ripple-round,button{border-radius:0}@media only screen and (orientation:portrait) and (max-width:599px),only screen and (orientation:landscape) and (max-width:959px){:host>>>button .mat-button-ripple-round:disabled,button:disabled{display:none}}"]
                }] }
    ];
    /** @nocollapse */
    RotationButtonComponent.ctorParameters = function () { return []; };
    RotationButtonComponent.propDecorators = {
        map: [{ type: Input }],
        showIfNoRotation: [{ type: Input }],
        color: [{ type: Input }]
    };
    return RotationButtonComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var EsriStyleGenerator = /** @class */ (function () {
    function EsriStyleGenerator() {
        this._converters = {};
        this._converters.esriPMS = EsriStyleGenerator._convertEsriPMS;
        this._converters.esriSFS = EsriStyleGenerator._convertEsriSFS;
        this._converters.esriSLS = EsriStyleGenerator._convertEsriSLS;
        this._converters.esriSMS = EsriStyleGenerator._convertEsriSMS;
        this._converters.esriTS = EsriStyleGenerator._convertEsriTS;
        this._renderers = {};
        this._renderers.uniqueValue = this._renderUniqueValue;
        this._renderers.simple = this._renderSimple;
        this._renderers.classBreaks = this._renderClassBreaks;
    }
    /**
     * @param {?} point
     * @return {?}
     */
    EsriStyleGenerator._convertPointToPixel = /**
     * @param {?} point
     * @return {?}
     */
    function (point) {
        return point / 0.75;
    };
    /**
     * @param {?} color
     * @return {?}
     */
    EsriStyleGenerator._transformColor = /**
     * @param {?} color
     * @return {?}
     */
    function (color) {
        // alpha channel is different, runs from 0-255 but in ol3 from 0-1
        return [color[0], color[1], color[2], color[3] / 255];
    };
    /**
     * @param {?} scale
     * @param {?} units
     * @return {?}
     */
    EsriStyleGenerator._getResolutionForScale = /**
     * @param {?} scale
     * @param {?} units
     * @return {?}
     */
    function (scale, units) {
        /** @type {?} */
        var dpi = 96;
        /** @type {?} */
        var mpu = METERS_PER_UNIT[units];
        /** @type {?} */
        var inchesPerMeter = 39.3701;
        return parseFloat(scale) / (mpu * inchesPerMeter * dpi);
    };
    /* convert an Esri Text Symbol */
    /* convert an Esri Text Symbol */
    /**
     * @param {?} symbol
     * @return {?}
     */
    EsriStyleGenerator._convertEsriTS = /* convert an Esri Text Symbol */
    /**
     * @param {?} symbol
     * @return {?}
     */
    function (symbol) {
        /** @type {?} */
        var rotation = EsriStyleGenerator._transformAngle(symbol.angle);
        /** @type {?} */
        var text = symbol.text !== undefined ? symbol.text : undefined;
        return new Style({
            text: new Text({
                fill: new Fill({
                    color: EsriStyleGenerator._transformColor(symbol.color)
                }),
                font: symbol.font.style +
                    ' ' +
                    symbol.font.weight +
                    ' ' +
                    symbol.font.size +
                    ' px ' +
                    symbol.font.family,
                textBaseline: symbol.verticalAlignment,
                textAlign: symbol.horizontalAlignment,
                offsetX: EsriStyleGenerator._convertPointToPixel(symbol.xoffset),
                offsetY: EsriStyleGenerator._convertPointToPixel(symbol.yoffset),
                rotation: rotation,
                text: text
            })
        });
    };
    /* convert an Esri Picture Marker Symbol */
    /* convert an Esri Picture Marker Symbol */
    /**
     * @param {?} symbol
     * @return {?}
     */
    EsriStyleGenerator._convertEsriPMS = /* convert an Esri Picture Marker Symbol */
    /**
     * @param {?} symbol
     * @return {?}
     */
    function (symbol) {
        /** @type {?} */
        var src = 'data:' + symbol.contentType + ';base64, ' + symbol.imageData;
        /** @type {?} */
        var rotation = EsriStyleGenerator._transformAngle(symbol.angle);
        return new Style({
            image: new Icon({
                src: src,
                rotation: rotation
            })
        });
    };
    /* convert an Esri Simple Fill Symbol */
    /* convert an Esri Simple Fill Symbol */
    /**
     * @param {?} symbol
     * @return {?}
     */
    EsriStyleGenerator._convertEsriSFS = /* convert an Esri Simple Fill Symbol */
    /**
     * @param {?} symbol
     * @return {?}
     */
    function (symbol) {
        // there is no support in openlayers currently for fill patterns, so style is not interpreted
        /** @type {?} */
        var fill = new Fill({
            color: EsriStyleGenerator._transformColor(symbol.color)
        });
        /** @type {?} */
        var stroke = symbol.outline
            ? EsriStyleGenerator._convertOutline(symbol.outline)
            : undefined;
        return new Style({
            fill: fill,
            stroke: stroke
        });
    };
    /**
     * @param {?} outline
     * @return {?}
     */
    EsriStyleGenerator._convertOutline = /**
     * @param {?} outline
     * @return {?}
     */
    function (outline) {
        /** @type {?} */
        var lineDash;
        /** @type {?} */
        var color = EsriStyleGenerator._transformColor(outline.color);
        if (outline.style === 'esriSLSDash') {
            lineDash = [5];
        }
        else if (outline.style === 'esriSLSDashDot') {
            lineDash = [5, 5, 1, 2];
        }
        else if (outline.style === 'esriSLSDashDotDot') {
            lineDash = [5, 5, 1, 2, 1, 2];
        }
        else if (outline.style === 'esriSLSDot') {
            lineDash = [1, 2];
        }
        else if (outline.style === 'esriSLSNull') {
            // line not visible, make color fully transparent
            color[3] = 0;
        }
        return new Stroke({
            color: color,
            lineDash: lineDash,
            width: EsriStyleGenerator._convertPointToPixel(outline.width)
        });
    };
    /* convert an Esri Simple Line Symbol */
    /* convert an Esri Simple Line Symbol */
    /**
     * @param {?} symbol
     * @return {?}
     */
    EsriStyleGenerator._convertEsriSLS = /* convert an Esri Simple Line Symbol */
    /**
     * @param {?} symbol
     * @return {?}
     */
    function (symbol) {
        return new Style({
            stroke: EsriStyleGenerator._convertOutline(symbol)
        });
    };
    /**
     * @param {?} angle
     * @return {?}
     */
    EsriStyleGenerator._transformAngle = /**
     * @param {?} angle
     * @return {?}
     */
    function (angle) {
        if (angle === 0 || angle === undefined) {
            return undefined;
        }
        /** @type {?} */
        var normalRad = (angle * Math.PI) / 180;
        /** @type {?} */
        var ol3Rad = -normalRad + Math.PI / 2;
        if (ol3Rad < 0) {
            return 2 * Math.PI + ol3Rad;
        }
        else {
            return ol3Rad;
        }
    };
    /* convert an Esri Simple Marker Symbol */
    /* convert an Esri Simple Marker Symbol */
    /**
     * @param {?} symbol
     * @return {?}
     */
    EsriStyleGenerator._convertEsriSMS = /* convert an Esri Simple Marker Symbol */
    /**
     * @param {?} symbol
     * @return {?}
     */
    function (symbol) {
        /** @type {?} */
        var fill = new Fill({
            color: EsriStyleGenerator._transformColor(symbol.color)
        });
        /** @type {?} */
        var stroke = symbol.outline
            ? EsriStyleGenerator._convertOutline(symbol.outline)
            : undefined;
        /** @type {?} */
        var radius = EsriStyleGenerator._convertPointToPixel(symbol.size) / 2;
        /** @type {?} */
        var rotation = EsriStyleGenerator._transformAngle(symbol.angle);
        if (symbol.style === 'esriSMSCircle') {
            return new Style({
                image: new Circle({
                    radius: radius,
                    fill: fill,
                    stroke: stroke
                })
            });
        }
        else if (symbol.style === 'esriSMSCross') {
            return new Style({
                image: new RegularShape({
                    fill: fill,
                    stroke: stroke,
                    points: 4,
                    radius: radius,
                    radius2: 0,
                    angle: 0,
                    rotation: rotation
                })
            });
        }
        else if (symbol.style === 'esriSMSDiamond') {
            return new Style({
                image: new RegularShape({
                    fill: fill,
                    stroke: stroke,
                    points: 4,
                    radius: radius,
                    rotation: rotation
                })
            });
        }
        else if (symbol.style === 'esriSMSSquare') {
            return new Style({
                image: new RegularShape({
                    fill: fill,
                    stroke: stroke,
                    points: 4,
                    radius: radius,
                    angle: Math.PI / 4,
                    rotation: rotation
                })
            });
        }
        else if (symbol.style === 'esriSMSX') {
            return new Style({
                image: new RegularShape({
                    fill: fill,
                    stroke: stroke,
                    points: 4,
                    radius: radius,
                    radius2: 0,
                    angle: Math.PI / 4,
                    rotation: rotation
                })
            });
        }
        else if (symbol.style === 'esriSMSTriangle') {
            return new Style({
                image: new RegularShape({
                    fill: fill,
                    stroke: stroke,
                    points: 3,
                    radius: radius,
                    angle: 0,
                    rotation: rotation
                })
            });
        }
    };
    /**
     * @param {?} labelingInfo
     * @param {?} mapUnits
     * @return {?}
     */
    EsriStyleGenerator.prototype._convertLabelingInfo = /**
     * @param {?} labelingInfo
     * @param {?} mapUnits
     * @return {?}
     */
    function (labelingInfo, mapUnits) {
        /** @type {?} */
        var styles = [];
        for (var i = 0, ii = labelingInfo.length; i < ii; ++i) {
            /** @type {?} */
            var labelExpression = labelingInfo[i].labelExpression;
            // only limited support for label expressions
            /** @type {?} */
            var field = labelExpression.substr(labelExpression.indexOf('[') + 1, labelExpression.indexOf(']') - 1);
            /** @type {?} */
            var symbol = labelingInfo[i].symbol;
            /** @type {?} */
            var maxScale = labelingInfo[i].maxScale;
            /** @type {?} */
            var minScale = labelingInfo[i].minScale;
            /** @type {?} */
            var minResolution = null;
            if (maxScale !== 0) {
                minResolution = EsriStyleGenerator._getResolutionForScale(maxScale, mapUnits);
            }
            /** @type {?} */
            var maxResolution = null;
            if (minScale !== 0) {
                maxResolution = EsriStyleGenerator._getResolutionForScale(minScale, mapUnits);
            }
            /** @type {?} */
            var style$$1 = this._converters[symbol.type].call(this, symbol);
            styles.push(((/**
             * @return {?}
             */
            function () {
                return (/**
                 * @param {?} feature
                 * @param {?} resolution
                 * @return {?}
                 */
                function (feature, resolution) {
                    /** @type {?} */
                    var visible = true;
                    if (this.minResolution !== null && this.maxResolution !== null) {
                        visible =
                            resolution < this.maxResolution &&
                                resolution >= this.minResolution;
                    }
                    else if (this.minResolution !== null) {
                        visible = resolution >= this.minResolution;
                    }
                    else if (this.maxResolution !== null) {
                        visible = resolution < this.maxResolution;
                    }
                    if (visible) {
                        /** @type {?} */
                        var value = feature.get(this.field);
                        this.style.getText().setText(value);
                        return [this.style];
                    }
                });
            }))().bind({
                minResolution: minResolution,
                maxResolution: maxResolution,
                field: field,
                style: style$$1
            }));
        }
        return styles;
    };
    /**
     * @param {?} renderer
     * @return {?}
     */
    EsriStyleGenerator.prototype._renderSimple = /**
     * @param {?} renderer
     * @return {?}
     */
    function (renderer) {
        /** @type {?} */
        var style$$1 = this._converters[renderer.symbol.type].call(this, renderer.symbol);
        return ((/**
         * @return {?}
         */
        function () {
            return (/**
             * @return {?}
             */
            function () {
                return [style$$1];
            });
        }))();
    };
    /**
     * @param {?} renderer
     * @return {?}
     */
    EsriStyleGenerator.prototype._renderClassBreaks = /**
     * @param {?} renderer
     * @return {?}
     */
    function (renderer) {
        /** @type {?} */
        var defaultSymbol = renderer.defaultSymbol;
        /** @type {?} */
        var defaultStyle = this._converters[defaultSymbol.type].call(this, defaultSymbol);
        /** @type {?} */
        var field = renderer.field;
        /** @type {?} */
        var classes = [];
        for (var i = 0, ii = renderer.classBreakInfos.length; i < ii; ++i) {
            /** @type {?} */
            var classBreakInfo = renderer.classBreakInfos[i];
            /** @type {?} */
            var min = void 0;
            if (classBreakInfo.classMinValue === null ||
                classBreakInfo.classMinValue === undefined) {
                if (i === 0) {
                    min = renderer.minValue;
                }
                else {
                    min = renderer.classBreakInfos[i - 1].classMaxValue;
                }
            }
            else {
                min = classBreakInfo.classMinValue;
            }
            /** @type {?} */
            var max = classBreakInfo.classMaxValue;
            /** @type {?} */
            var symbol = classBreakInfo.symbol;
            /** @type {?} */
            var style$$1 = this._converters[symbol.type].call(this, symbol);
            classes.push({ min: min, max: max, style: style$$1 });
        }
        return ((/**
         * @return {?}
         */
        function () {
            return (/**
             * @param {?} feature
             * @return {?}
             */
            function (feature) {
                /** @type {?} */
                var value = feature.get(field);
                for (var i = 0, ii = classes.length; i < ii; ++i) {
                    /** @type {?} */
                    var condition = void 0;
                    if (i === 0) {
                        condition = value >= classes[i].min && value <= classes[i].max;
                    }
                    else {
                        condition = value > classes[i].min && value <= classes[i].max;
                    }
                    if (condition) {
                        return [classes[i].style];
                    }
                }
                return [defaultStyle];
            });
        }))();
    };
    /**
     * @param {?} renderer
     * @return {?}
     */
    EsriStyleGenerator.prototype._renderUniqueValue = /**
     * @param {?} renderer
     * @return {?}
     */
    function (renderer) {
        /** @type {?} */
        var defaultSymbol = renderer.defaultSymbol;
        /** @type {?} */
        var defaultStyle = [];
        if (defaultSymbol) {
            defaultStyle = [
                this._converters[defaultSymbol.type].call(this, defaultSymbol)
            ];
        }
        /** @type {?} */
        var field = renderer.field1;
        /** @type {?} */
        var infos = renderer.uniqueValueInfos;
        /** @type {?} */
        var me = this;
        return ((/**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var hash = {};
            for (var i = 0, ii = infos.length; i < ii; ++i) {
                /** @type {?} */
                var info = infos[i];
                /** @type {?} */
                var symbol = info.symbol;
                hash[info.value] = [me._converters[symbol.type].call(me, symbol)];
            }
            return (/**
             * @param {?} feature
             * @return {?}
             */
            function (feature) {
                /** @type {?} */
                var style$$1 = hash[feature.get(field)];
                return style$$1 ? style$$1 : defaultStyle;
            });
        }))();
    };
    /**
     * @param {?} layerInfo
     * @param {?} mapUnits
     * @return {?}
     */
    EsriStyleGenerator.prototype.generateStyle = /**
     * @param {?} layerInfo
     * @param {?} mapUnits
     * @return {?}
     */
    function (layerInfo, mapUnits) {
        /** @type {?} */
        var drawingInfo = layerInfo.drawingInfo;
        /** @type {?} */
        var styleFunctions = [];
        /** @type {?} */
        var drawingInfoStyle = this._renderers[drawingInfo.renderer.type].call(this, drawingInfo.renderer);
        if (drawingInfoStyle !== undefined) {
            styleFunctions.push(drawingInfoStyle);
        }
        if (layerInfo.labelingInfo) {
            /** @type {?} */
            var labelingInfoStyleFunctions = this._convertLabelingInfo(layerInfo.labelingInfo, mapUnits);
            styleFunctions = styleFunctions.concat(labelingInfoStyleFunctions);
        }
        if (styleFunctions.length === 1) {
            return styleFunctions[0];
        }
        else {
            return ((/**
             * @return {?}
             */
            function () {
                return (/**
                 * @param {?} feature
                 * @param {?} resolution
                 * @return {?}
                 */
                function (feature, resolution) {
                    /** @type {?} */
                    var styles = [];
                    for (var i = 0, ii = styleFunctions.length; i < ii; ++i) {
                        /** @type {?} */
                        var result = styleFunctions[i].call(null, feature, resolution);
                        if (result) {
                            styles = styles.concat(result);
                        }
                    }
                    return styles;
                });
            }))();
        }
    };
    return EsriStyleGenerator;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
var TimeFilterType = {
    DATE: 'date',
    TIME: 'time',
    DATETIME: 'datetime',
    YEAR: 'year',
};
/** @enum {string} */
var TimeFilterStyle = {
    CALENDAR: 'calendar',
    SLIDER: 'slider',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
var TypeCapabilities = {
    wms: 'wms',
    wmts: 'wmts',
};
var CapabilitiesService = /** @class */ (function () {
    function CapabilitiesService(http) {
        this.http = http;
        this.parsers = {
            wms: new WMSCapabilities(),
            wmts: new WMTSCapabilities()
        };
    }
    /**
     * @param {?} baseOptions
     * @return {?}
     */
    CapabilitiesService.prototype.getWMSOptions = /**
     * @param {?} baseOptions
     * @return {?}
     */
    function (baseOptions) {
        var _this = this;
        /** @type {?} */
        var url = baseOptions.url;
        /** @type {?} */
        var version = ((/** @type {?} */ (baseOptions.params))).VERSION;
        return this.getCapabilities('wms', url, version).pipe(map((/**
         * @param {?} capabilities
         * @return {?}
         */
        function (capabilities) {
            return capabilities
                ? _this.parseWMSOptions(baseOptions, capabilities)
                : undefined;
        })));
    };
    /**
     * @param {?} baseOptions
     * @return {?}
     */
    CapabilitiesService.prototype.getWMTSOptions = /**
     * @param {?} baseOptions
     * @return {?}
     */
    function (baseOptions) {
        var _this = this;
        /** @type {?} */
        var url = baseOptions.url;
        /** @type {?} */
        var version = baseOptions.version;
        /** @type {?} */
        var options = this.getCapabilities('wmts', url, version).pipe(map((/**
         * @param {?} capabilities
         * @return {?}
         */
        function (capabilities) {
            return capabilities
                ? _this.parseWMTSOptions(baseOptions, capabilities)
                : undefined;
        })));
        return options;
    };
    /**
     * @param {?} baseOptions
     * @return {?}
     */
    CapabilitiesService.prototype.getCartoOptions = /**
     * @param {?} baseOptions
     * @return {?}
     */
    function (baseOptions) {
        var _this = this;
        /** @type {?} */
        var baseUrl = 'https://' +
            baseOptions.account +
            '.carto.com/api/v2/viz/' +
            baseOptions.mapId +
            '/viz.json';
        return this.http
            .jsonp(baseUrl, 'callback')
            .pipe(map((/**
         * @param {?} cartoOptions
         * @return {?}
         */
        function (cartoOptions) {
            return _this.parseCartoOptions(baseOptions, cartoOptions);
        })));
    };
    /**
     * @param {?} baseOptions
     * @return {?}
     */
    CapabilitiesService.prototype.getArcgisOptions = /**
     * @param {?} baseOptions
     * @return {?}
     */
    function (baseOptions) {
        var _this = this;
        /** @type {?} */
        var baseUrl = baseOptions.url + '/' + baseOptions.layer + '?f=json';
        /** @type {?} */
        var modifiedUrl = baseOptions.url.replace('FeatureServer', 'MapServer');
        /** @type {?} */
        var legendUrl = modifiedUrl + '/legend?f=json';
        /** @type {?} */
        var arcgisOptions = this.http.get(baseUrl);
        /** @type {?} */
        var legend = this.http.get(legendUrl).pipe(map((/**
         * @param {?} res
         * @return {?}
         */
        function (res) { return res; })), catchError((/**
         * @param {?} err
         * @return {?}
         */
        function (err) {
            console.log('No legend associated with this Feature Service');
            return of(err);
        })));
        return forkJoin([arcgisOptions, legend]).pipe(map((/**
         * @param {?} res
         * @return {?}
         */
        function (res) {
            return _this.parseArcgisOptions(baseOptions, res[0], res[1]);
        })));
    };
    /**
     * @param {?} baseOptions
     * @return {?}
     */
    CapabilitiesService.prototype.getTileArcgisOptions = /**
     * @param {?} baseOptions
     * @return {?}
     */
    function (baseOptions) {
        var _this = this;
        /** @type {?} */
        var baseUrl = baseOptions.url + '/' + baseOptions.layer + '?f=json';
        /** @type {?} */
        var legendUrl = baseOptions.url + '/legend?f=json';
        /** @type {?} */
        var arcgisOptions = this.http.get(baseUrl);
        /** @type {?} */
        var legendInfo = this.http.get(legendUrl);
        return forkJoin([arcgisOptions, legendInfo]).pipe(map((/**
         * @param {?} res
         * @return {?}
         */
        function (res) {
            return _this.parseTileArcgisOptions(baseOptions, res[0], res[1]);
        })));
    };
    /**
     * @param {?} service
     * @param {?} baseUrl
     * @param {?=} version
     * @return {?}
     */
    CapabilitiesService.prototype.getCapabilities = /**
     * @param {?} service
     * @param {?} baseUrl
     * @param {?=} version
     * @return {?}
     */
    function (service, baseUrl, version) {
        var _this = this;
        /** @type {?} */
        var params = new HttpParams({
            fromObject: {
                request: 'GetCapabilities',
                service: service.toUpperCase(),
                version: version || '1.3.0',
                _i: 'true'
            }
        });
        /** @type {?} */
        var request = this.http.get(baseUrl, {
            params: params,
            responseType: 'text'
        });
        return request.pipe(map((/**
         * @param {?} res
         * @return {?}
         */
        function (res) {
            try {
                return _this.parsers[service].read(res);
            }
            catch (e) {
                return undefined;
            }
        })), catchError((/**
         * @param {?} e
         * @return {?}
         */
        function (e) {
            e.error.caught = true;
            throw e;
        })));
    };
    /**
     * @private
     * @param {?} baseOptions
     * @param {?} capabilities
     * @return {?}
     */
    CapabilitiesService.prototype.parseWMSOptions = /**
     * @private
     * @param {?} baseOptions
     * @param {?} capabilities
     * @return {?}
     */
    function (baseOptions, capabilities) {
        var e_1, _a;
        /** @type {?} */
        var layers = ((/** @type {?} */ (baseOptions.params))).LAYERS;
        /** @type {?} */
        var layer = this.findDataSourceInCapabilities(capabilities.Capability.Layer, layers);
        if (!layer) {
            throw {
                error: {
                    message: 'Layer not found'
                }
            };
        }
        /** @type {?} */
        var metadata = layer.DataURL ? layer.DataURL[0] : undefined;
        /** @type {?} */
        var abstract = layer.Abstract ? layer.Abstract : undefined;
        /** @type {?} */
        var keywordList = layer.KeywordList ? layer.KeywordList : undefined;
        /** @type {?} */
        var queryable = layer.queryable;
        /** @type {?} */
        var timeFilter = this.getTimeFilter(layer);
        /** @type {?} */
        var timeFilterable = timeFilter && Object.keys(timeFilter).length > 0;
        /** @type {?} */
        var legendOptions = layer.Style ? this.getStyle(layer.Style) : undefined;
        /** @type {?} */
        var queryFormat;
        /** @type {?} */
        var queryFormatMimeTypePriority = [
            QueryFormatMimeType.GEOJSON,
            QueryFormatMimeType.GEOJSON2,
            QueryFormatMimeType.GML3,
            QueryFormatMimeType.GML2,
            QueryFormatMimeType.JSON,
            QueryFormatMimeType.HTML
        ];
        var _loop_1 = function (mimeType) {
            if (capabilities.Capability.Request.GetFeatureInfo.Format.indexOf(mimeType) !== -1) {
                /** @type {?} */
                var keyEnum = Object.keys(QueryFormatMimeType).find((/**
                 * @param {?} key
                 * @return {?}
                 */
                function (key) { return QueryFormatMimeType[key] === mimeType; }));
                queryFormat = QueryFormat[keyEnum];
                return "break";
            }
        };
        try {
            for (var queryFormatMimeTypePriority_1 = __values(queryFormatMimeTypePriority), queryFormatMimeTypePriority_1_1 = queryFormatMimeTypePriority_1.next(); !queryFormatMimeTypePriority_1_1.done; queryFormatMimeTypePriority_1_1 = queryFormatMimeTypePriority_1.next()) {
                var mimeType = queryFormatMimeTypePriority_1_1.value;
                var state_1 = _loop_1(mimeType);
                if (state_1 === "break")
                    break;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (queryFormatMimeTypePriority_1_1 && !queryFormatMimeTypePriority_1_1.done && (_a = queryFormatMimeTypePriority_1.return)) _a.call(queryFormatMimeTypePriority_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (!queryFormat) {
            queryable = false;
        }
        /** @type {?} */
        var options = ObjectUtils.removeUndefined({
            _layerOptionsFromSource: {
                title: layer.Title,
                maxResolution: getResolutionFromScale(layer.MaxScaleDenominator),
                minResolution: getResolutionFromScale(layer.MinScaleDenominator),
                metadata: {
                    url: metadata ? metadata.OnlineResource : undefined,
                    extern: metadata ? true : undefined,
                    abstract: abstract,
                    keywordList: keywordList
                },
                legendOptions: legendOptions
            },
            queryable: queryable,
            queryFormat: queryFormat,
            timeFilter: timeFilterable ? timeFilter : undefined,
            timeFilterable: timeFilterable ? true : undefined
        });
        return ObjectUtils.mergeDeep(options, baseOptions);
    };
    /**
     * @private
     * @param {?} baseOptions
     * @param {?} capabilities
     * @return {?}
     */
    CapabilitiesService.prototype.parseWMTSOptions = /**
     * @private
     * @param {?} baseOptions
     * @param {?} capabilities
     * @return {?}
     */
    function (baseOptions, capabilities) {
        // Put Title source in _layerOptionsFromSource. (For source & catalog in _layerOptionsFromSource, if not already on config)
        /** @type {?} */
        var layer = capabilities.Contents.Layer.find((/**
         * @param {?} el
         * @return {?}
         */
        function (el) { return el.Identifier === baseOptions.layer; }));
        /** @type {?} */
        var options = optionsFromCapabilities(capabilities, baseOptions);
        /** @type {?} */
        var ouputOptions = Object.assign(options, baseOptions);
        /** @type {?} */
        var sourceOptions = ObjectUtils.removeUndefined({
            _layerOptionsFromSource: {
                title: layer.Title
            }
        });
        return ObjectUtils.mergeDeep(sourceOptions, ouputOptions);
    };
    /**
     * @private
     * @param {?} baseOptions
     * @param {?} cartoOptions
     * @return {?}
     */
    CapabilitiesService.prototype.parseCartoOptions = /**
     * @private
     * @param {?} baseOptions
     * @param {?} cartoOptions
     * @return {?}
     */
    function (baseOptions, cartoOptions) {
        /** @type {?} */
        var layers = [];
        /** @type {?} */
        var params = cartoOptions.layers[1].options.layer_definition;
        params.layers.forEach((/**
         * @param {?} element
         * @return {?}
         */
        function (element) {
            layers.push({
                type: element.type.toLowerCase(),
                options: element.options,
                legend: element.legend
            });
        }));
        /** @type {?} */
        var options = ObjectUtils.removeUndefined({
            config: {
                version: params.version,
                layers: layers
            }
        });
        return ObjectUtils.mergeDeep(options, baseOptions);
    };
    /**
     * @private
     * @param {?} baseOptions
     * @param {?} arcgisOptions
     * @param {?=} legend
     * @return {?}
     */
    CapabilitiesService.prototype.parseArcgisOptions = /**
     * @private
     * @param {?} baseOptions
     * @param {?} arcgisOptions
     * @param {?=} legend
     * @return {?}
     */
    function (baseOptions, arcgisOptions, legend) {
        /** @type {?} */
        var legendInfo = legend.layers ? legend : undefined;
        /** @type {?} */
        var styleGenerator = new EsriStyleGenerator();
        /** @type {?} */
        var units = arcgisOptions.units === 'esriMeters' ? 'm' : 'degrees';
        /** @type {?} */
        var style$$1 = styleGenerator.generateStyle(arcgisOptions, units);
        /** @type {?} */
        var attributions = new olAttribution({
            html: arcgisOptions.copyrightText
        });
        /** @type {?} */
        var timeExtent;
        /** @type {?} */
        var timeFilter;
        if (arcgisOptions.timeInfo) {
            /** @type {?} */
            var time = arcgisOptions.timeInfo.timeExtent;
            timeExtent = time[0] + ',' + time[1];
            /** @type {?} */
            var min = new Date();
            min.setTime(time[0]);
            /** @type {?} */
            var max = new Date();
            max.setTime(time[1]);
            timeFilter = {
                min: min.toUTCString(),
                max: max.toUTCString(),
                range: true,
                type: TimeFilterType.DATETIME,
                style: TimeFilterStyle.CALENDAR
            };
        }
        /** @type {?} */
        var params = Object.assign({}, {
            legendInfo: legendInfo,
            style: style$$1,
            timeFilter: timeFilter,
            timeExtent: timeExtent,
            attributions: attributions
        });
        /** @type {?} */
        var options = ObjectUtils.removeUndefined({
            params: params
        });
        return ObjectUtils.mergeDeep(options, baseOptions);
    };
    /**
     * @private
     * @param {?} baseOptions
     * @param {?} arcgisOptions
     * @param {?} legend
     * @return {?}
     */
    CapabilitiesService.prototype.parseTileArcgisOptions = /**
     * @private
     * @param {?} baseOptions
     * @param {?} arcgisOptions
     * @param {?} legend
     * @return {?}
     */
    function (baseOptions, arcgisOptions, legend) {
        /** @type {?} */
        var legendInfo = legend.layers ? legend : undefined;
        /** @type {?} */
        var attributions = new olAttribution({
            html: arcgisOptions.copyrightText
        });
        /** @type {?} */
        var timeExtent;
        /** @type {?} */
        var timeFilter;
        if (arcgisOptions.timeInfo) {
            /** @type {?} */
            var time = arcgisOptions.timeInfo.timeExtent;
            timeExtent = time[0] + ',' + time[1];
            /** @type {?} */
            var min = new Date();
            min.setTime(time[0]);
            /** @type {?} */
            var max = new Date();
            max.setTime(time[1]);
            timeFilter = {
                min: min.toUTCString(),
                max: max.toUTCString(),
                range: true,
                type: TimeFilterType.DATETIME,
                style: TimeFilterStyle.CALENDAR
            };
        }
        /** @type {?} */
        var params = Object.assign({}, {
            layers: 'show:' + baseOptions.layer,
            time: timeExtent
        });
        /** @type {?} */
        var options = ObjectUtils.removeUndefined({
            params: params,
            legendInfo: legendInfo,
            timeFilter: timeFilter,
            attributions: attributions
        });
        return ObjectUtils.mergeDeep(options, baseOptions);
    };
    /**
     * @private
     * @param {?} layerArray
     * @param {?} name
     * @return {?}
     */
    CapabilitiesService.prototype.findDataSourceInCapabilities = /**
     * @private
     * @param {?} layerArray
     * @param {?} name
     * @return {?}
     */
    function (layerArray, name) {
        var _this = this;
        if (Array.isArray(layerArray)) {
            /** @type {?} */
            var layer_1;
            layerArray.find((/**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                layer_1 = _this.findDataSourceInCapabilities(value, name);
                return layer_1 !== undefined;
            }), this);
            return layer_1;
        }
        else if (layerArray.Layer) {
            return this.findDataSourceInCapabilities(layerArray.Layer, name);
        }
        else {
            if (layerArray.Name && layerArray.Name === name) {
                return layerArray;
            }
            return undefined;
        }
    };
    /**
     * @param {?} layer
     * @return {?}
     */
    CapabilitiesService.prototype.getTimeFilter = /**
     * @param {?} layer
     * @return {?}
     */
    function (layer) {
        /** @type {?} */
        var dimension;
        if (layer.Dimension) {
            /** @type {?} */
            var timeFilter = {};
            dimension = layer.Dimension[0];
            if (dimension.values) {
                /** @type {?} */
                var minMaxDim = dimension.values.split('/');
                timeFilter.min = minMaxDim[0] !== undefined ? minMaxDim[0] : undefined;
                timeFilter.max = minMaxDim[1] !== undefined ? minMaxDim[1] : undefined;
                timeFilter.step = minMaxDim[2] !== undefined ? minMaxDim[2] : undefined;
            }
            if (dimension.default) {
                timeFilter.value = dimension.default;
            }
            return timeFilter;
        }
    };
    /**
     * @param {?} Style
     * @return {?}
     */
    CapabilitiesService.prototype.getStyle = /**
     * @param {?} Style
     * @return {?}
     */
    function (Style$$1) {
        /** @type {?} */
        var styleOptions = Style$$1.map((/**
         * @param {?} style
         * @return {?}
         */
        function (style$$1) {
            return {
                name: style$$1.Name,
                title: style$$1.Title
            };
        }))
            // Handle repeat the style "default" in output  (MapServer or OpenLayer)
            .filter((/**
         * @param {?} item
         * @param {?} index
         * @param {?} self
         * @return {?}
         */
        function (item, index, self) {
            return self.findIndex((/**
             * @param {?} i
             * @return {?}
             */
            function (i) { return i.name === item.name; })) ===
                index;
        }));
        /** @type {?} */
        var legendOptions = (/** @type {?} */ ({
            stylesAvailable: styleOptions
        }));
        return legendOptions;
    };
    CapabilitiesService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    CapabilitiesService.ctorParameters = function () { return [
        { type: HttpClient }
    ]; };
    /** @nocollapse */ CapabilitiesService.ngInjectableDef = defineInjectable({ factory: function CapabilitiesService_Factory() { return new CapabilitiesService(inject(HttpClient)); }, token: CapabilitiesService, providedIn: "root" });
    __decorate([
        Cacheable({
            maxCacheCount: 20
        }),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [String, String, String]),
        __metadata("design:returntype", Observable)
    ], CapabilitiesService.prototype, "getCapabilities", null);
    return CapabilitiesService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
var  /**
 * @abstract
 */
OptionsService = /** @class */ (function () {
    function OptionsService() {
    }
    return OptionsService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var DataSourceService = /** @class */ (function () {
    function DataSourceService(capabilitiesService, optionsService, wfsDataSourceService, languageService, messageService, projectionService) {
        this.capabilitiesService = capabilitiesService;
        this.optionsService = optionsService;
        this.wfsDataSourceService = wfsDataSourceService;
        this.languageService = languageService;
        this.messageService = messageService;
        this.projectionService = projectionService;
        this.datasources$ = new BehaviorSubject([]);
    }
    /**
     * @param {?} context
     * @return {?}
     */
    DataSourceService.prototype.createAsyncDataSource = /**
     * @param {?} context
     * @return {?}
     */
    function (context) {
        if (!context.type) {
            console.error(context);
            throw new Error('Datasource needs a type');
        }
        /** @type {?} */
        var dataSource;
        switch (context.type.toLowerCase()) {
            case 'osm':
                dataSource = this.createOSMDataSource((/** @type {?} */ (context)));
                break;
            case 'vector':
                dataSource = this.createFeatureDataSource((/** @type {?} */ (context)));
                break;
            case 'wfs':
                dataSource = this.createWFSDataSource((/** @type {?} */ (context)));
                break;
            case 'wms':
                /** @type {?} */
                var wmsContext = (/** @type {?} */ (context));
                ObjectUtils.removeDuplicateCaseInsensitive(wmsContext.params);
                dataSource = this.createWMSDataSource(wmsContext);
                break;
            case 'wmts':
                dataSource = this.createWMTSDataSource((/** @type {?} */ (context)));
                break;
            case 'xyz':
                dataSource = this.createXYZDataSource((/** @type {?} */ (context)));
                break;
            case 'carto':
                dataSource = this.createCartoDataSource((/** @type {?} */ (context)));
                break;
            case 'arcgisrest':
                dataSource = this.createArcGISRestDataSource((/** @type {?} */ (context)));
                break;
            case 'websocket':
                dataSource = this.createWebSocketDataSource((/** @type {?} */ (context)));
                break;
            case 'mvt':
                dataSource = this.createMVTDataSource((/** @type {?} */ (context)));
                break;
            case 'tilearcgisrest':
                dataSource = this.createTileArcGISRestDataSource((/** @type {?} */ (context)));
                break;
            case 'cluster':
                dataSource = this.createClusterDataSource((/** @type {?} */ (context)));
                break;
            default:
                console.error(context);
                throw new Error('Invalid datasource type');
        }
        this.datasources$.next(this.datasources$.value.concat([dataSource]));
        return dataSource;
    };
    /**
     * @private
     * @param {?} context
     * @return {?}
     */
    DataSourceService.prototype.createOSMDataSource = /**
     * @private
     * @param {?} context
     * @return {?}
     */
    function (context) {
        return new Observable((/**
         * @param {?} d
         * @return {?}
         */
        function (d) { return d.next(new OSMDataSource(context)); }));
    };
    /**
     * @private
     * @param {?} context
     * @return {?}
     */
    DataSourceService.prototype.createFeatureDataSource = /**
     * @private
     * @param {?} context
     * @return {?}
     */
    function (context) {
        return new Observable((/**
         * @param {?} d
         * @return {?}
         */
        function (d) { return d.next(new FeatureDataSource(context)); }));
    };
    /**
     * @private
     * @param {?} context
     * @return {?}
     */
    DataSourceService.prototype.createWebSocketDataSource = /**
     * @private
     * @param {?} context
     * @return {?}
     */
    function (context) {
        return new Observable((/**
         * @param {?} d
         * @return {?}
         */
        function (d) { return d.next(new WebSocketDataSource(context)); }));
    };
    /**
     * @private
     * @param {?} context
     * @return {?}
     */
    DataSourceService.prototype.createWFSDataSource = /**
     * @private
     * @param {?} context
     * @return {?}
     */
    function (context) {
        var _this = this;
        return new Observable((/**
         * @param {?} d
         * @return {?}
         */
        function (d) {
            return d.next(new WFSDataSource(context, _this.wfsDataSourceService));
        }));
    };
    /**
     * @private
     * @param {?} context
     * @return {?}
     */
    DataSourceService.prototype.createWMSDataSource = /**
     * @private
     * @param {?} context
     * @return {?}
     */
    function (context) {
        var _this = this;
        /** @type {?} */
        var observables = [];
        if (context.optionsFromCapabilities) {
            observables.push(this.capabilitiesService.getWMSOptions(context).pipe(catchError((/**
             * @param {?} e
             * @return {?}
             */
            function (e) {
                /** @type {?} */
                var title = _this.languageService.translate.instant('igo.geo.dataSource.unavailableTitle');
                /** @type {?} */
                var message = _this.languageService.translate.instant('igo.geo.dataSource.unavailable', { value: context.params.LAYERS });
                _this.messageService.error(message, title);
                throw e;
            }))));
        }
        if (this.optionsService && context.optionsFromApi === true) {
            observables.push(this.optionsService.getWMSOptions(context).pipe(catchError((/**
             * @param {?} e
             * @return {?}
             */
            function (e) {
                e.error.toDisplay = true;
                e.error.title = _this.languageService.translate.instant('igo.geo.dataSource.unavailableTitle');
                e.error.message = _this.languageService.translate.instant('igo.geo.dataSource.optionsApiUnavailable');
                return of({});
            }))));
        }
        observables.push(of(context));
        return forkJoin(observables).pipe(map((/**
         * @param {?} options
         * @return {?}
         */
        function (options) {
            /** @type {?} */
            var optionsMerged = options.reduce((/**
             * @param {?} a
             * @param {?} b
             * @return {?}
             */
            function (a, b) {
                return ObjectUtils.mergeDeep(a, b);
            }));
            return new WMSDataSource(optionsMerged, _this.wfsDataSourceService);
        })), catchError((/**
         * @return {?}
         */
        function () {
            return of(undefined);
        })));
    };
    /**
     * @private
     * @param {?} context
     * @return {?}
     */
    DataSourceService.prototype.createWMTSDataSource = /**
     * @private
     * @param {?} context
     * @return {?}
     */
    function (context) {
        var _this = this;
        if (context.optionsFromCapabilities) {
            return this.capabilitiesService.getWMTSOptions(context).pipe(map((/**
             * @param {?} options
             * @return {?}
             */
            function (options) {
                return options ? new WMTSDataSource(options) : undefined;
            })), catchError((/**
             * @return {?}
             */
            function () {
                /** @type {?} */
                var title = _this.languageService.translate.instant('igo.geo.dataSource.unavailableTitle');
                /** @type {?} */
                var message = _this.languageService.translate.instant('igo.geo.dataSource.unavailable', { value: context.layer });
                _this.messageService.error(message, title);
                return of(undefined);
            })));
        }
        return new Observable((/**
         * @param {?} d
         * @return {?}
         */
        function (d) { return d.next(new WMTSDataSource(context)); }));
    };
    /**
     * @private
     * @param {?} context
     * @return {?}
     */
    DataSourceService.prototype.createXYZDataSource = /**
     * @private
     * @param {?} context
     * @return {?}
     */
    function (context) {
        return new Observable((/**
         * @param {?} d
         * @return {?}
         */
        function (d) { return d.next(new XYZDataSource(context)); }));
    };
    /**
     * @private
     * @param {?} context
     * @return {?}
     */
    DataSourceService.prototype.createCartoDataSource = /**
     * @private
     * @param {?} context
     * @return {?}
     */
    function (context) {
        if (context.mapId) {
            return this.capabilitiesService
                .getCartoOptions(context)
                .pipe(map((/**
             * @param {?} options
             * @return {?}
             */
            function (options) { return new CartoDataSource(options); })));
        }
        return new Observable((/**
         * @param {?} d
         * @return {?}
         */
        function (d) { return d.next(new CartoDataSource(context)); }));
    };
    /**
     * @private
     * @param {?} context
     * @return {?}
     */
    DataSourceService.prototype.createArcGISRestDataSource = /**
     * @private
     * @param {?} context
     * @return {?}
     */
    function (context) {
        return this.capabilitiesService
            .getArcgisOptions(context)
            .pipe(map((/**
         * @param {?} options
         * @return {?}
         */
        function (options) {
            return new ArcGISRestDataSource(options);
        })));
    };
    /**
     * @private
     * @param {?} context
     * @return {?}
     */
    DataSourceService.prototype.createTileArcGISRestDataSource = /**
     * @private
     * @param {?} context
     * @return {?}
     */
    function (context) {
        return this.capabilitiesService
            .getTileArcgisOptions(context)
            .pipe(map((/**
         * @param {?} options
         * @return {?}
         */
        function (options) {
            return new TileArcGISRestDataSource(options);
        })));
    };
    /**
     * @private
     * @param {?} context
     * @return {?}
     */
    DataSourceService.prototype.createMVTDataSource = /**
     * @private
     * @param {?} context
     * @return {?}
     */
    function (context) {
        return new Observable((/**
         * @param {?} d
         * @return {?}
         */
        function (d) { return d.next(new MVTDataSource(context)); }));
    };
    /**
     * @private
     * @param {?} context
     * @return {?}
     */
    DataSourceService.prototype.createClusterDataSource = /**
     * @private
     * @param {?} context
     * @return {?}
     */
    function (context) {
        return new Observable((/**
         * @param {?} d
         * @return {?}
         */
        function (d) { return d.next(new ClusterDataSource(context)); }));
    };
    DataSourceService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    DataSourceService.ctorParameters = function () { return [
        { type: CapabilitiesService },
        { type: OptionsService, decorators: [{ type: Optional }] },
        { type: WFSService },
        { type: LanguageService },
        { type: MessageService },
        { type: ProjectionService }
    ]; };
    /** @nocollapse */ DataSourceService.ngInjectableDef = defineInjectable({ factory: function DataSourceService_Factory() { return new DataSourceService(inject(CapabilitiesService), inject(OptionsService, 8), inject(WFSService), inject(LanguageService), inject(MessageService), inject(ProjectionService)); }, token: DataSourceService, providedIn: "root" });
    return DataSourceService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var OptionsApiService = /** @class */ (function (_super) {
    __extends(OptionsApiService, _super);
    function OptionsApiService(http, options) {
        if (options === void 0) { options = {}; }
        var _this = _super.call(this) || this;
        _this.http = http;
        _this.urlApi = options.url || _this.urlApi;
        return _this;
    }
    /**
     * @param {?} baseOptions
     * @return {?}
     */
    OptionsApiService.prototype.getWMSOptions = /**
     * @param {?} baseOptions
     * @return {?}
     */
    function (baseOptions) {
        if (!this.urlApi) {
            return of((/** @type {?} */ ({})));
        }
        /** @type {?} */
        var params = new HttpParams({
            fromObject: {
                type: baseOptions.type,
                url: baseOptions.url,
                layers: baseOptions.params.LAYERS
            }
        });
        /** @type {?} */
        var request = this.http.get(this.urlApi, {
            params: params
        });
        return request.pipe(map((/**
         * @param {?} res
         * @return {?}
         */
        function (res) {
            if (!res || !res.sourceOptions) {
                return (/** @type {?} */ ({}));
            }
            res.sourceOptions._layerOptionsFromSource = res.layerOptions;
            return res.sourceOptions;
        })));
    };
    OptionsApiService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    OptionsApiService.ctorParameters = function () { return [
        { type: HttpClient },
        { type: undefined, decorators: [{ type: Inject, args: ['options',] }] }
    ]; };
    /** @nocollapse */ OptionsApiService.ngInjectableDef = defineInjectable({ factory: function OptionsApiService_Factory() { return new OptionsApiService(inject(HttpClient), inject("options")); }, token: OptionsApiService, providedIn: "root" });
    return OptionsApiService;
}(OptionsService));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var LayerService = /** @class */ (function () {
    function LayerService(http, styleService, dataSourceService, authInterceptor) {
        this.http = http;
        this.styleService = styleService;
        this.dataSourceService = dataSourceService;
        this.authInterceptor = authInterceptor;
    }
    /**
     * @param {?} layerOptions
     * @return {?}
     */
    LayerService.prototype.createLayer = /**
     * @param {?} layerOptions
     * @return {?}
     */
    function (layerOptions) {
        if (!layerOptions.source) {
            return;
        }
        if (layerOptions.source.options &&
            layerOptions.source.options._layerOptionsFromSource) {
            layerOptions = ObjectUtils.mergeDeep(layerOptions.source.options._layerOptionsFromSource, layerOptions || {});
        }
        /** @type {?} */
        var layer;
        switch (layerOptions.source.constructor) {
            case OSMDataSource:
            case WMTSDataSource:
            case XYZDataSource:
            case CartoDataSource:
            case TileArcGISRestDataSource:
                layer = this.createTileLayer((/** @type {?} */ (layerOptions)));
                break;
            case FeatureDataSource:
            case WFSDataSource:
            case ArcGISRestDataSource:
            case WebSocketDataSource:
            case ClusterDataSource:
                layer = this.createVectorLayer((/** @type {?} */ (layerOptions)));
                break;
            case WMSDataSource:
                layer = this.createImageLayer((/** @type {?} */ (layerOptions)));
                break;
            case MVTDataSource:
                layer = this.createVectorTileLayer((/** @type {?} */ (layerOptions)));
                break;
            default:
                break;
        }
        return layer;
    };
    /**
     * @param {?} layerOptions
     * @return {?}
     */
    LayerService.prototype.createAsyncLayer = /**
     * @param {?} layerOptions
     * @return {?}
     */
    function (layerOptions) {
        var _this = this;
        if (layerOptions.source) {
            return new Observable((/**
             * @param {?} d
             * @return {?}
             */
            function (d) { return d.next(_this.createLayer(layerOptions)); }));
        }
        return this.dataSourceService
            .createAsyncDataSource(layerOptions.sourceOptions)
            .pipe(map((/**
         * @param {?} source
         * @return {?}
         */
        function (source) {
            if (source === undefined) {
                return undefined;
            }
            return _this.createLayer(Object.assign(layerOptions, { source: source }));
        })));
    };
    /**
     * @private
     * @param {?} layerOptions
     * @return {?}
     */
    LayerService.prototype.createImageLayer = /**
     * @private
     * @param {?} layerOptions
     * @return {?}
     */
    function (layerOptions) {
        return new ImageLayer(layerOptions, this.authInterceptor);
    };
    /**
     * @private
     * @param {?} layerOptions
     * @return {?}
     */
    LayerService.prototype.createTileLayer = /**
     * @private
     * @param {?} layerOptions
     * @return {?}
     */
    function (layerOptions) {
        return new TileLayer(layerOptions);
    };
    /**
     * @private
     * @param {?} layerOptions
     * @return {?}
     */
    LayerService.prototype.createVectorLayer = /**
     * @private
     * @param {?} layerOptions
     * @return {?}
     */
    function (layerOptions) {
        /** @type {?} */
        var style$$1;
        /** @type {?} */
        var olLayer;
        if (layerOptions.style !== undefined) {
            style$$1 = this.styleService.createStyle(layerOptions.style);
        }
        if (layerOptions.source instanceof ArcGISRestDataSource) {
            /** @type {?} */
            var source = (/** @type {?} */ (layerOptions.source));
            style$$1 = source.options.params.style;
        }
        else if (layerOptions.styleByAttribute) {
            /** @type {?} */
            var serviceStyle_1 = this.styleService;
            layerOptions.style = (/**
             * @param {?} feature
             * @return {?}
             */
            function (feature) {
                return serviceStyle_1.createStyleByAttribute(feature, layerOptions.styleByAttribute);
            });
            olLayer = new VectorLayer(layerOptions);
        }
        if (layerOptions.source instanceof ClusterDataSource) {
            /** @type {?} */
            var serviceStyle_2 = this.styleService;
            /** @type {?} */
            var baseStyle_1 = layerOptions.clusterBaseStyle;
            layerOptions.style = (/**
             * @param {?} feature
             * @return {?}
             */
            function (feature) {
                return serviceStyle_2.createClusterStyle(feature, layerOptions.clusterParam, baseStyle_1);
            });
            olLayer = new VectorLayer(layerOptions);
        }
        /** @type {?} */
        var layerOptionsOl = Object.assign({}, layerOptions, {
            style: style$$1
        });
        if (!olLayer) {
            olLayer = new VectorLayer(layerOptionsOl);
        }
        this.applyMapboxStyle(olLayer, layerOptionsOl);
        return olLayer;
    };
    /**
     * @private
     * @param {?} layerOptions
     * @return {?}
     */
    LayerService.prototype.createVectorTileLayer = /**
     * @private
     * @param {?} layerOptions
     * @return {?}
     */
    function (layerOptions) {
        /** @type {?} */
        var style$$1;
        /** @type {?} */
        var olLayer;
        if (layerOptions.style !== undefined) {
            style$$1 = this.styleService.createStyle(layerOptions.style);
        }
        if (layerOptions.styleByAttribute) {
            /** @type {?} */
            var serviceStyle_3 = this.styleService;
            layerOptions.style = (/**
             * @param {?} feature
             * @return {?}
             */
            function (feature) {
                return serviceStyle_3.createStyleByAttribute(feature, layerOptions.styleByAttribute);
            });
            olLayer = new VectorTileLayer(layerOptions);
        }
        /** @type {?} */
        var layerOptionsOl = Object.assign({}, layerOptions, {
            style: style$$1
        });
        if (!olLayer) {
            olLayer = new VectorTileLayer(layerOptionsOl);
        }
        this.applyMapboxStyle(olLayer, layerOptionsOl);
        return olLayer;
    };
    /**
     * @private
     * @param {?} layer
     * @param {?} layerOptions
     * @return {?}
     */
    LayerService.prototype.applyMapboxStyle = /**
     * @private
     * @param {?} layer
     * @param {?} layerOptions
     * @return {?}
     */
    function (layer, layerOptions) {
        if (layerOptions.mapboxStyle) {
            this.getMapboxGlStyle(layerOptions.mapboxStyle.url).subscribe((/**
             * @param {?} res
             * @return {?}
             */
            function (res) {
                stylefunction(layer.ol, res, layerOptions.mapboxStyle.source);
            }));
        }
    };
    /**
     * @param {?} url
     * @return {?}
     */
    LayerService.prototype.getMapboxGlStyle = /**
     * @param {?} url
     * @return {?}
     */
    function (url) {
        return this.http.get(url).pipe(map((/**
         * @param {?} res
         * @return {?}
         */
        function (res) { return res; })), catchError((/**
         * @param {?} err
         * @return {?}
         */
        function (err) {
            console.log('No style was found');
            return of(err);
        })));
    };
    LayerService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    LayerService.ctorParameters = function () { return [
        { type: HttpClient },
        { type: StyleService },
        { type: DataSourceService },
        { type: AuthInterceptor, decorators: [{ type: Optional }] }
    ]; };
    /** @nocollapse */ LayerService.ngInjectableDef = defineInjectable({ factory: function LayerService_Factory() { return new LayerService(inject(HttpClient), inject(StyleService), inject(DataSourceService), inject(AuthInterceptor, 8)); }, token: LayerService, providedIn: "root" });
    return LayerService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
var CatalogItemType = {
    Layer: 'layer',
    Group: 'group',
};
/** @enum {number} */
var TypeCatalog = {
    wms: 0, wmts: 1, baselayers: 2, composite: 3,
};
TypeCatalog[TypeCatalog.wms] = 'wms';
TypeCatalog[TypeCatalog.wmts] = 'wmts';
TypeCatalog[TypeCatalog.baselayers] = 'baselayers';
TypeCatalog[TypeCatalog.composite] = 'composite';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
var  /**
 * @abstract
 */
Catalog = /** @class */ (function () {
    function Catalog(options, service) {
        Object.assign(this, options);
        this.catalogService = service;
    }
    return Catalog;
}());
var WMSCatalog = /** @class */ (function (_super) {
    __extends(WMSCatalog, _super);
    function WMSCatalog(options, service) {
        var _this = _super.call(this, options, service) || this;
        /** @type {?} */
        var sType = TypeCatalog[TypeCatalog.wms];
        _this.type = TypeCatalog[sType];
        return _this;
    }
    /**
     * @return {?}
     */
    WMSCatalog.prototype.collectCatalogItems = /**
     * @return {?}
     */
    function () {
        return this.catalogService.loadCatalogWMSLayerItems(this);
    };
    return WMSCatalog;
}(Catalog));
var WMTSCatalog = /** @class */ (function (_super) {
    __extends(WMTSCatalog, _super);
    function WMTSCatalog(options, service) {
        var _this = _super.call(this, options, service) || this;
        /** @type {?} */
        var sType = TypeCatalog[TypeCatalog.wmts];
        _this.type = TypeCatalog[sType];
        return _this;
    }
    /**
     * @return {?}
     */
    WMTSCatalog.prototype.collectCatalogItems = /**
     * @return {?}
     */
    function () {
        return this.catalogService.loadCatalogWMTSLayerItems(this);
    };
    return WMTSCatalog;
}(Catalog));
var BaselayersCatalog = /** @class */ (function (_super) {
    __extends(BaselayersCatalog, _super);
    function BaselayersCatalog(options, service) {
        var _this = _super.call(this, options, service) || this;
        /** @type {?} */
        var sType = TypeCatalog[TypeCatalog.baselayers];
        _this.type = TypeCatalog[sType];
        return _this;
    }
    /**
     * @return {?}
     */
    BaselayersCatalog.prototype.collectCatalogItems = /**
     * @return {?}
     */
    function () {
        return this.catalogService.loadCatalogBaseLayerItems(this);
    };
    return BaselayersCatalog;
}(Catalog));
var CompositeCatalog = /** @class */ (function (_super) {
    __extends(CompositeCatalog, _super);
    function CompositeCatalog(options, service) {
        var _this = _super.call(this, options, service) || this;
        /** @type {?} */
        var sType = TypeCatalog[TypeCatalog.composite];
        _this.type = TypeCatalog[sType];
        _this.url = null;
        return _this;
    }
    /**
     * @return {?}
     */
    CompositeCatalog.prototype.collectCatalogItems = /**
     * @return {?}
     */
    function () {
        return this.catalogService.loadCatalogCompositeLayerItems(this);
    };
    return CompositeCatalog;
}(Catalog));
var CatalogFactory = /** @class */ (function () {
    function CatalogFactory() {
    }
    /**
     * @param {?} options
     * @param {?} service
     * @return {?}
     */
    CatalogFactory.createInstanceCatalog = /**
     * @param {?} options
     * @param {?} service
     * @return {?}
     */
    function (options, service) {
        /** @type {?} */
        var catalog;
        if (options.hasOwnProperty('composite')) {
            catalog = new CompositeCatalog(options, service);
        }
        else if (options.type === TypeCatalog[TypeCatalog.baselayers]) {
            catalog = new BaselayersCatalog(options, service);
        }
        else if (options.type === TypeCatalog[TypeCatalog.wmts]) {
            catalog = new WMTSCatalog(options, service);
        }
        else {
            catalog = new WMSCatalog(options, service);
        }
        return catalog;
    };
    return CatalogFactory;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var QueryService = /** @class */ (function () {
    function QueryService(http) {
        this.http = http;
        this.queryEnabled = true;
    }
    /**
     * @param {?} layers
     * @param {?} options
     * @return {?}
     */
    QueryService.prototype.query = /**
     * @param {?} layers
     * @param {?} options
     * @return {?}
     */
    function (layers, options) {
        var _this = this;
        return layers
            .filter((/**
         * @param {?} layer
         * @return {?}
         */
        function (layer) { return layer.visible && layer.isInResolutionsRange; }))
            .map((/**
         * @param {?} layer
         * @return {?}
         */
        function (layer) { return _this.queryLayer(layer, options); }));
    };
    /**
     * @param {?} layer
     * @param {?} options
     * @return {?}
     */
    QueryService.prototype.queryLayer = /**
     * @param {?} layer
     * @param {?} options
     * @return {?}
     */
    function (layer, options) {
        var _this = this;
        /** @type {?} */
        var url = this.getQueryUrl(layer.dataSource, options);
        if (!url) {
            return of([]);
        }
        if (((/** @type {?} */ (layer.dataSource))).options.queryFormat ===
            QueryFormat.HTMLGML2) {
            /** @type {?} */
            var urlGml = this.getQueryUrl(layer.dataSource, options, true);
            return this.http.get(urlGml, { responseType: 'text' }).pipe(mergeMap((/**
             * @param {?} gmlRes
             * @return {?}
             */
            function (gmlRes) {
                /** @type {?} */
                var imposedGeom = _this.mergeGML(gmlRes, url);
                return _this.http
                    .get(url, { responseType: 'text' })
                    .pipe(map((/**
                 * @param {?} res
                 * @return {?}
                 */
                function (res) {
                    return _this.extractData(res, layer, options, url, imposedGeom);
                })));
            })));
        }
        /** @type {?} */
        var request = this.http.get(url, { responseType: 'text' });
        return request.pipe(map((/**
         * @param {?} res
         * @return {?}
         */
        function (res) { return _this.extractData(res, layer, options, url); })));
    };
    /**
     * @private
     * @param {?} gmlRes
     * @param {?} url
     * @return {?}
     */
    QueryService.prototype.mergeGML = /**
     * @private
     * @param {?} gmlRes
     * @param {?} url
     * @return {?}
     */
    function (gmlRes, url) {
        /** @type {?} */
        var parser = new olFormatGML2();
        /** @type {?} */
        var features = parser.readFeatures(gmlRes);
        // Handle non standard GML output (MapServer)
        if (features.length === 0) {
            parser = new WMSGetFeatureInfo();
            features = parser.readFeatures(gmlRes);
        }
        /** @type {?} */
        var olmline = new MultiLineString([]);
        /** @type {?} */
        var pts;
        /** @type {?} */
        var ptsArray = [];
        /** @type {?} */
        var olmpoly = new MultiPolygon([]);
        /** @type {?} */
        var firstFeatureType;
        /** @type {?} */
        var nbFeatures = features.length;
        // Check if geometry intersect bbox
        // for geoserver getfeatureinfo response in data projection, not call projection
        /** @type {?} */
        var searchParams = this.getQueryParams(url.toLowerCase());
        /** @type {?} */
        var bboxRaw = searchParams.bbox;
        /** @type {?} */
        var bbox$$1 = bboxRaw.split(',');
        /** @type {?} */
        var bboxExtent = createEmpty();
        extend(bboxExtent, bbox$$1);
        /** @type {?} */
        var outBboxExtent = false;
        features.map((/**
         * @param {?} feature
         * @return {?}
         */
        function (feature) {
            /*  if (!feature.getGeometry().simplify(100).intersectsExtent(bboxExtent)) {
                    outBboxExtent = true;
                    // TODO: Check to project the geometry?
                  }*/
            /** @type {?} */
            var featureGeometryCoordinates = feature.getGeometry().getCoordinates();
            /** @type {?} */
            var featureGeometryType = feature.getGeometry().getType();
            if (!firstFeatureType && !outBboxExtent) {
                firstFeatureType = featureGeometryType;
            }
            {
                switch (featureGeometryType) {
                    case 'Point':
                        if (nbFeatures === 1) {
                            pts = new Point(featureGeometryCoordinates, 'XY');
                        }
                        else {
                            ptsArray.push(featureGeometryCoordinates);
                        }
                        break;
                    case 'LineString':
                        olmline.appendLineString(new LineString(featureGeometryCoordinates, 'XY'));
                        break;
                    case 'Polygon':
                        olmpoly.appendPolygon(new Polygon(featureGeometryCoordinates, 'XY'));
                        break;
                    case 'MultiPolygon':
                        olmpoly = new MultiPolygon(featureGeometryCoordinates, 'XY');
                        break;
                    default:
                        return;
                }
            }
        }));
        /** @type {?} */
        var olmpts;
        if (ptsArray.length === 0 && pts) {
            olmpts = {
                type: pts.getType(),
                coordinates: pts.getCoordinates()
            };
        }
        else {
            olmpts = {
                type: 'Polygon',
                coordinates: [this.convexHull(ptsArray)]
            };
        }
        switch (firstFeatureType) {
            case 'LineString':
                return {
                    type: olmline.getType(),
                    coordinates: olmline.getCoordinates()
                };
            case 'Point':
                return olmpts;
            case 'Polygon':
                return {
                    type: olmpoly.getType(),
                    coordinates: olmpoly.getCoordinates()
                };
            case 'MultiPolygon':
                return {
                    type: olmpoly.getType(),
                    coordinates: olmpoly.getCoordinates()
                };
            default:
                return;
        }
    };
    /**
     * @param {?} a
     * @param {?} b
     * @param {?} o
     * @return {?}
     */
    QueryService.prototype.cross = /**
     * @param {?} a
     * @param {?} b
     * @param {?} o
     * @return {?}
     */
    function (a, b, o) {
        return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);
    };
    /**
     * @param points An array of [X, Y] coordinates
     * This method is use instead of turf.js convexHull because Turf needs at least 3 point to make a hull.
     * https://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain#JavaScript
     */
    /**
     * @param {?} points An array of [X, Y] coordinates
     * This method is use instead of turf.js convexHull because Turf needs at least 3 point to make a hull.
     * https://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain#JavaScript
     * @return {?}
     */
    QueryService.prototype.convexHull = /**
     * @param {?} points An array of [X, Y] coordinates
     * This method is use instead of turf.js convexHull because Turf needs at least 3 point to make a hull.
     * https://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain#JavaScript
     * @return {?}
     */
    function (points) {
        var e_1, _a;
        points.sort((/**
         * @param {?} a
         * @param {?} b
         * @return {?}
         */
        function (a, b) {
            return a[0] === b[0] ? a[1] - b[1] : a[0] - b[0];
        }));
        /** @type {?} */
        var lower = [];
        try {
            for (var points_1 = __values(points), points_1_1 = points_1.next(); !points_1_1.done; points_1_1 = points_1.next()) {
                var point = points_1_1.value;
                while (lower.length >= 2 &&
                    this.cross(lower[lower.length - 2], lower[lower.length - 1], point) <= 0) {
                    lower.pop();
                }
                lower.push(point);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (points_1_1 && !points_1_1.done && (_a = points_1.return)) _a.call(points_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        /** @type {?} */
        var upper = [];
        for (var i = points.length - 1; i >= 0; i--) {
            while (upper.length >= 2 &&
                this.cross(upper[upper.length - 2], upper[upper.length - 1], points[i]) <= 0) {
                upper.pop();
            }
            upper.push(points[i]);
        }
        upper.pop();
        lower.pop();
        return lower.concat(upper);
    };
    /**
     * @private
     * @param {?} res
     * @param {?} layer
     * @param {?} options
     * @param {?} url
     * @param {?=} imposedGeometry
     * @return {?}
     */
    QueryService.prototype.extractData = /**
     * @private
     * @param {?} res
     * @param {?} layer
     * @param {?} options
     * @param {?} url
     * @param {?=} imposedGeometry
     * @return {?}
     */
    function (res, layer, options, url, imposedGeometry) {
        var _this = this;
        var e_2, _a;
        /** @type {?} */
        var queryDataSource = (/** @type {?} */ (layer.dataSource));
        /** @type {?} */
        var allowedFieldsAndAlias = this.getAllowedFieldsAndAlias(layer);
        /** @type {?} */
        var features = [];
        switch (queryDataSource.options.queryFormat) {
            case QueryFormat.GML3:
                features = this.extractGML3Data(res, layer.zIndex, allowedFieldsAndAlias);
                break;
            case QueryFormat.JSON:
            case QueryFormat.GEOJSON:
            case QueryFormat.GEOJSON2:
                features = this.extractGeoJSONData(res);
                break;
            case QueryFormat.ESRIJSON:
                features = this.extractEsriJSONData(res, layer.zIndex);
                break;
            case QueryFormat.TEXT:
                features = this.extractTextData(res);
                break;
            case QueryFormat.HTML:
                features = this.extractHtmlData(res, queryDataSource.queryHtmlTarget, url);
                break;
            case QueryFormat.HTMLGML2:
                features = this.extractHtmlData(res, queryDataSource.queryHtmlTarget, url, imposedGeometry);
                break;
            case QueryFormat.GML2:
            default:
                features = this.extractGML2Data(res, layer, allowedFieldsAndAlias);
                break;
        }
        if (features.length > 0 && features[0].geometry == null) {
            /** @type {?} */
            var geomToAdd = this.createGeometryFromUrlClick(url);
            try {
                for (var features_1 = __values(features), features_1_1 = features_1.next(); !features_1_1.done; features_1_1 = features_1.next()) {
                    var feature = features_1_1.value;
                    feature.geometry = geomToAdd;
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (features_1_1 && !features_1_1.done && (_a = features_1.return)) _a.call(features_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
        return features.map((/**
         * @param {?} feature
         * @param {?} index
         * @return {?}
         */
        function (feature, index) {
            /** @type {?} */
            var mapLabel = feature.properties[queryDataSource.mapLabel];
            /** @type {?} */
            var exclude;
            if (layer.options.sourceOptions.type === 'wms') {
                /** @type {?} */
                var sourceOptions = (/** @type {?} */ (layer.options
                    .sourceOptions));
                exclude = sourceOptions ? sourceOptions.excludeAttribute : undefined;
            }
            /** @type {?} */
            var title = _this.getQueryTitle(feature, layer);
            if (!title && features.length > 1) {
                title = layer.title + " (" + (index + 1) + ")";
            }
            else if (!title) {
                title = layer.title;
            }
            /** @type {?} */
            var meta = Object.assign({}, feature.meta || {}, {
                id: uuid(),
                title: title,
                mapTitle: mapLabel,
                sourceTitle: layer.title,
                order: 1000 - layer.zIndex,
                excludeAttribute: exclude
            });
            return Object.assign(feature, {
                meta: meta,
                projection: queryDataSource.options.type === 'carto'
                    ? 'EPSG:4326'
                    : options.projection
            });
        }));
    };
    /**
     * @private
     * @param {?} url
     * @return {?}
     */
    QueryService.prototype.createGeometryFromUrlClick = /**
     * @private
     * @param {?} url
     * @return {?}
     */
    function (url) {
        /** @type {?} */
        var searchParams = this.getQueryParams(url.toLowerCase());
        /** @type {?} */
        var bboxRaw = searchParams.bbox;
        /** @type {?} */
        var width = parseInt(searchParams.width, 10);
        /** @type {?} */
        var height = parseInt(searchParams.height, 10);
        /** @type {?} */
        var xPosition = parseInt(searchParams.i || searchParams.x, 10);
        /** @type {?} */
        var yPosition = parseInt(searchParams.j || searchParams.y, 10);
        /** @type {?} */
        var projection = searchParams.crs || searchParams.srs || 'EPSG:3857';
        /** @type {?} */
        var bbox$$1 = bboxRaw.split(',');
        /** @type {?} */
        var threshold = (Math.abs(parseFloat(bbox$$1[0])) - Math.abs(parseFloat(bbox$$1[2]))) * 0.05;
        // for context in degree (EPSG:4326,4269...)
        if (Math.abs(parseFloat(bbox$$1[0])) < 180) {
            threshold = 0.045;
        }
        /** @type {?} */
        var clickx = parseFloat(bbox$$1[0]) +
            (Math.abs(parseFloat(bbox$$1[0]) - parseFloat(bbox$$1[2])) * xPosition) /
                width -
            threshold;
        /** @type {?} */
        var clicky = parseFloat(bbox$$1[1]) +
            (Math.abs(parseFloat(bbox$$1[1]) - parseFloat(bbox$$1[3])) * yPosition) /
                height -
            threshold;
        /** @type {?} */
        var clickx1 = clickx + threshold * 2;
        /** @type {?} */
        var clicky1 = clicky + threshold * 2;
        /** @type {?} */
        var wktPoly = 'POLYGON((' +
            clickx +
            ' ' +
            clicky +
            ', ' +
            clickx +
            ' ' +
            clicky1 +
            ', ' +
            clickx1 +
            ' ' +
            clicky1 +
            ', ' +
            clickx1 +
            ' ' +
            clicky +
            ', ' +
            clickx +
            ' ' +
            clicky +
            '))';
        /** @type {?} */
        var format = new WKT();
        /** @type {?} */
        var tenPercentWidthGeom = format.readFeature(wktPoly);
        /** @type {?} */
        var f = (/** @type {?} */ (tenPercentWidthGeom.getGeometry()));
        /** @type {?} */
        var newGeom = {
            type: f.getType(),
            coordinates: f.getCoordinates()
        };
        return newGeom;
    };
    /**
     * @private
     * @param {?} res
     * @param {?} zIndex
     * @param {?=} allowedFieldsAndAlias
     * @return {?}
     */
    QueryService.prototype.extractGML2Data = /**
     * @private
     * @param {?} res
     * @param {?} zIndex
     * @param {?=} allowedFieldsAndAlias
     * @return {?}
     */
    function (res, zIndex, allowedFieldsAndAlias) {
        var _this = this;
        /** @type {?} */
        var parser = new olFormatGML2();
        /** @type {?} */
        var features = parser.readFeatures(res);
        // Handle non standard GML output (MapServer)
        if (features.length === 0) {
            parser = new WMSGetFeatureInfo();
            try {
                features = parser.readFeatures(res);
            }
            catch (e) {
                console.warn('query.service: Multipolygons are badly managed in mapserver in GML2. Use another format.');
            }
        }
        return features.map((/**
         * @param {?} feature
         * @return {?}
         */
        function (feature) {
            return _this.featureToResult(feature, zIndex, allowedFieldsAndAlias);
        }));
    };
    /**
     * @private
     * @param {?} res
     * @param {?} zIndex
     * @param {?=} allowedFieldsAndAlias
     * @return {?}
     */
    QueryService.prototype.extractGML3Data = /**
     * @private
     * @param {?} res
     * @param {?} zIndex
     * @param {?=} allowedFieldsAndAlias
     * @return {?}
     */
    function (res, zIndex, allowedFieldsAndAlias) {
        var _this = this;
        /** @type {?} */
        var parser = new olFormatGML3();
        /** @type {?} */
        var features = [];
        try {
            features = parser.readFeatures(res);
        }
        catch (e) {
            console.warn('query.service: GML3 is not well supported');
        }
        return features.map((/**
         * @param {?} feature
         * @return {?}
         */
        function (feature) {
            return _this.featureToResult(feature, zIndex, allowedFieldsAndAlias);
        }));
    };
    /**
     * @private
     * @param {?} res
     * @return {?}
     */
    QueryService.prototype.extractGeoJSONData = /**
     * @private
     * @param {?} res
     * @return {?}
     */
    function (res) {
        /** @type {?} */
        var features = [];
        try {
            features = JSON.parse(res).features;
        }
        catch (e) {
            console.warn('query.service: Unable to parse geojson', '\n', res);
        }
        return features;
    };
    /**
     * @private
     * @param {?} res
     * @param {?} zIndex
     * @return {?}
     */
    QueryService.prototype.extractEsriJSONData = /**
     * @private
     * @param {?} res
     * @param {?} zIndex
     * @return {?}
     */
    function (res, zIndex) {
        var _this = this;
        /** @type {?} */
        var parser = new olFormatEsriJSON();
        /** @type {?} */
        var features = parser.readFeatures(res);
        return features.map((/**
         * @param {?} feature
         * @return {?}
         */
        function (feature) { return _this.featureToResult(feature, zIndex); }));
    };
    /**
     * @private
     * @param {?} res
     * @return {?}
     */
    QueryService.prototype.extractTextData = /**
     * @private
     * @param {?} res
     * @return {?}
     */
    function (res) {
        // TODO
        return [];
    };
    /**
     * @private
     * @param {?} res
     * @param {?} htmlTarget
     * @param {?} url
     * @param {?=} imposedGeometry
     * @return {?}
     */
    QueryService.prototype.extractHtmlData = /**
     * @private
     * @param {?} res
     * @param {?} htmlTarget
     * @param {?} url
     * @param {?=} imposedGeometry
     * @return {?}
     */
    function (res, htmlTarget, url, imposedGeometry) {
        /** @type {?} */
        var searchParams = this.getQueryParams(url.toLowerCase());
        /** @type {?} */
        var projection = searchParams.crs || searchParams.srs || 'EPSG:3857';
        /** @type {?} */
        var geomToAdd = this.createGeometryFromUrlClick(url);
        if (htmlTarget !== QueryHtmlTarget.BLANK &&
            htmlTarget !== QueryHtmlTarget.IFRAME) {
            htmlTarget = QueryHtmlTarget.IFRAME;
        }
        /** @type {?} */
        var bodyTagStart = res.toLowerCase().indexOf('<body>');
        /** @type {?} */
        var bodyTagEnd = res.toLowerCase().lastIndexOf('</body>') + 7;
        // replace \r \n  and ' ' with '' to validate if the body is really empty.
        /** @type {?} */
        var body = res.slice(bodyTagStart, bodyTagEnd).replace(/(\r|\n|\s)/g, '');
        if (body === '<body></body>' || res === '') {
            return [];
        }
        return [
            {
                type: FEATURE,
                projection: projection,
                properties: { target: htmlTarget, body: res, url: url },
                geometry: imposedGeometry || geomToAdd
            }
        ];
    };
    /**
     * @private
     * @param {?} url
     * @return {?}
     */
    QueryService.prototype.getQueryParams = /**
     * @private
     * @param {?} url
     * @return {?}
     */
    function (url) {
        /** @type {?} */
        var queryString = url.split('?');
        if (!queryString[1]) {
            return;
        }
        /** @type {?} */
        var pairs = queryString[1].split('&');
        /** @type {?} */
        var result = {};
        pairs.forEach((/**
         * @param {?} pair
         * @return {?}
         */
        function (pair) {
            pair = pair.split('=');
            result[pair[0]] = decodeURIComponent(pair[1] || '');
        }));
        return result;
    };
    /**
     * @param {?} featureOL
     * @param {?} zIndex
     * @param {?=} allowedFieldsAndAlias
     * @return {?}
     */
    QueryService.prototype.featureToResult = /**
     * @param {?} featureOL
     * @param {?} zIndex
     * @param {?=} allowedFieldsAndAlias
     * @return {?}
     */
    function (featureOL, zIndex, allowedFieldsAndAlias) {
        /** @type {?} */
        var featureGeometry = (/** @type {?} */ (featureOL.getGeometry()));
        /** @type {?} */
        var properties = Object.assign({}, featureOL.getProperties());
        delete properties.geometry;
        delete properties.boundedBy;
        delete properties.shape;
        delete properties.SHAPE;
        delete properties.the_geom;
        /** @type {?} */
        var geometry;
        if (featureGeometry !== undefined) {
            geometry = {
                type: featureGeometry.getType(),
                coordinates: featureGeometry.getCoordinates()
            };
        }
        return {
            type: FEATURE,
            projection: undefined,
            properties: properties,
            geometry: geometry,
            meta: {
                id: uuid(),
                order: 1000 - zIndex,
                alias: allowedFieldsAndAlias
            }
        };
    };
    /**
     * @private
     * @param {?} datasource
     * @param {?} options
     * @param {?=} forceGML2
     * @return {?}
     */
    QueryService.prototype.getQueryUrl = /**
     * @private
     * @param {?} datasource
     * @param {?} options
     * @param {?=} forceGML2
     * @return {?}
     */
    function (datasource, options, forceGML2) {
        if (forceGML2 === void 0) { forceGML2 = false; }
        /** @type {?} */
        var url;
        switch (datasource.constructor) {
            case WMSDataSource:
                /** @type {?} */
                var wmsDatasource = (/** @type {?} */ (datasource));
                /** @type {?} */
                var WMSGetFeatureInfoOptions = {
                    INFO_FORMAT: wmsDatasource.params.INFO_FORMAT ||
                        this.getMimeInfoFormat(datasource.options.queryFormat),
                    QUERY_LAYERS: wmsDatasource.params.LAYERS,
                    FEATURE_COUNT: wmsDatasource.params.FEATURE_COUNT || '5'
                };
                if (forceGML2) {
                    WMSGetFeatureInfoOptions.INFO_FORMAT = this.getMimeInfoFormat(QueryFormat.GML2);
                }
                url = wmsDatasource.ol.getGetFeatureInfoUrl(options.coordinates, options.resolution, options.projection, WMSGetFeatureInfoOptions);
                // const wmsVersion =
                //   wmsDatasource.params.VERSION ||
                //   wmsDatasource.params.version ||
                //   '1.3.0';
                // if (wmsVersion !== '1.3.0') {
                //   url = url.replace('&I=', '&X=');
                //   url = url.replace('&J=', '&Y=');
                // }
                break;
            case CartoDataSource:
                /** @type {?} */
                var cartoDatasource = (/** @type {?} */ (datasource));
                /** @type {?} */
                var baseUrl = 'https://' +
                    cartoDatasource.options.account +
                    '.carto.com/api/v2/sql?';
                /** @type {?} */
                var format = 'format=GeoJSON';
                /** @type {?} */
                var sql = '&q=' + cartoDatasource.options.config.layers[0].options.sql;
                /** @type {?} */
                var clause = ' WHERE ST_Intersects(the_geom_webmercator,ST_BUFFER(ST_SetSRID(ST_POINT(';
                /** @type {?} */
                var meters = cartoDatasource.options.queryPrecision
                    ? cartoDatasource.options.queryPrecision
                    : '1000';
                /** @type {?} */
                var coordinates = options.coordinates[0] +
                    ',' +
                    options.coordinates[1] +
                    '),3857),' +
                    meters +
                    '))';
                url = "" + baseUrl + format + sql + clause + coordinates;
                break;
            case TileArcGISRestDataSource:
                /** @type {?} */
                var tileArcGISRestDatasource = (/** @type {?} */ (datasource));
                /** @type {?} */
                var extent = boundingExtent([options.coordinates]);
                if (tileArcGISRestDatasource.options.queryPrecision) {
                    extent = buffer(extent, tileArcGISRestDatasource.options.queryPrecision);
                }
                /** @type {?} */
                var serviceUrl = tileArcGISRestDatasource.options.url +
                    '/' +
                    tileArcGISRestDatasource.options.layer +
                    '/query/';
                /** @type {?} */
                var geometry = encodeURIComponent('{"xmin":' +
                    extent[0] +
                    ',"ymin":' +
                    extent[1] +
                    ',"xmax":' +
                    extent[2] +
                    ',"ymax":' +
                    extent[3] +
                    ',"spatialReference":{"wkid":102100}}');
                /** @type {?} */
                var params = [
                    'f=json',
                    "geometry=" + geometry,
                    'geometryType=esriGeometryEnvelope',
                    'inSR=102100',
                    'spatialRel=esriSpatialRelIntersects',
                    'outFields=*',
                    'returnGeometry=true',
                    'outSR=102100'
                ];
                url = serviceUrl + "?" + params.join('&');
                break;
            default:
                break;
        }
        return url;
    };
    /**
     * @private
     * @param {?} queryFormat
     * @return {?}
     */
    QueryService.prototype.getMimeInfoFormat = /**
     * @private
     * @param {?} queryFormat
     * @return {?}
     */
    function (queryFormat) {
        /** @type {?} */
        var mime = 'application/vnd.ogc.gml';
        /** @type {?} */
        var keyEnum = Object.keys(QueryFormat).find((/**
         * @param {?} key
         * @return {?}
         */
        function (key) { return QueryFormat[key] === queryFormat; }));
        if (keyEnum) {
            mime = QueryFormatMimeType[keyEnum];
        }
        return mime;
    };
    /**
     * @param {?} layer
     * @return {?}
     */
    QueryService.prototype.getAllowedFieldsAndAlias = /**
     * @param {?} layer
     * @return {?}
     */
    function (layer) {
        /** @type {?} */
        var allowedFieldsAndAlias;
        if (layer.options &&
            layer.options.source &&
            layer.options.source.options &&
            layer.options.source.options.sourceFields &&
            layer.options.source.options.sourceFields.length >= 1) {
            allowedFieldsAndAlias = {};
            layer.options.source.options.sourceFields.forEach((/**
             * @param {?} sourceField
             * @return {?}
             */
            function (sourceField) {
                /** @type {?} */
                var alias = sourceField.alias ? sourceField.alias : sourceField.name;
                allowedFieldsAndAlias[sourceField.name] = alias;
            }));
        }
        return allowedFieldsAndAlias;
    };
    /**
     * @param {?} feature
     * @param {?} layer
     * @return {?}
     */
    QueryService.prototype.getQueryTitle = /**
     * @param {?} feature
     * @param {?} layer
     * @return {?}
     */
    function (feature, layer) {
        /** @type {?} */
        var title;
        if (layer.options && layer.options.source && layer.options.source.options) {
            /** @type {?} */
            var dataSourceOptions = (/** @type {?} */ (layer.options.source
                .options));
            if (dataSourceOptions.queryTitle) {
                title = this.getLabelMatch(feature, dataSourceOptions.queryTitle);
            }
        }
        return title;
    };
    /**
     * @param {?} feature
     * @param {?} labelMatch
     * @return {?}
     */
    QueryService.prototype.getLabelMatch = /**
     * @param {?} feature
     * @param {?} labelMatch
     * @return {?}
     */
    function (feature, labelMatch) {
        /** @type {?} */
        var label = labelMatch;
        /** @type {?} */
        var labelToGet = Array.from(labelMatch.matchAll(/\$\{([^\{\}]+)\}/g));
        labelToGet.forEach((/**
         * @param {?} v
         * @return {?}
         */
        function (v) {
            label = label.replace(v[0], feature.properties[v[1]]);
        }));
        // Nothing done? check feature's attribute
        if (labelToGet.length === 0 && label === labelMatch) {
            label = feature.properties[labelMatch] || labelMatch;
        }
        return label;
    };
    QueryService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    QueryService.ctorParameters = function () { return [
        { type: HttpClient }
    ]; };
    /** @nocollapse */ QueryService.ngInjectableDef = defineInjectable({ factory: function QueryService_Factory() { return new QueryService(inject(HttpClient)); }, token: QueryService, providedIn: "root" });
    return QueryService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * This directive makes a map queryable with a click of with a drag box.
 * By default, all layers are queryable but this can ben controlled at
 * the layer level.
 */
var QueryDirective = /** @class */ (function () {
    function QueryDirective(component, queryService) {
        this.component = component;
        this.queryService = queryService;
        /**
         * Subscriptions to ongoing queries
         */
        this.queries$$ = [];
        /**
         * Whter to query features or not
         */
        this.queryFeatures = false;
        /**
         * Feature query hit tolerance
         */
        this.queryFeaturesHitTolerance = 0;
        /**
         * Whether all query should complete before emitting an event
         */
        this.waitForAllQueries = true;
        /**
         * Event emitted when a query (or all queries) complete
         */
        this.query = new EventEmitter();
    }
    Object.defineProperty(QueryDirective.prototype, "map", {
        /**
         * IGO map
         * @internal
         */
        get: /**
         * IGO map
         * \@internal
         * @return {?}
         */
        function () {
            return (/** @type {?} */ (((/** @type {?} */ (this.component.map)))));
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Start listening to click and drag box events
     * @internal
     */
    /**
     * Start listening to click and drag box events
     * \@internal
     * @return {?}
     */
    QueryDirective.prototype.ngAfterViewInit = /**
     * Start listening to click and drag box events
     * \@internal
     * @return {?}
     */
    function () {
        this.listenToMapClick();
    };
    /**
     * Stop listening to click and drag box events and cancel ongoind requests
     * @internal
     */
    /**
     * Stop listening to click and drag box events and cancel ongoind requests
     * \@internal
     * @return {?}
     */
    QueryDirective.prototype.ngOnDestroy = /**
     * Stop listening to click and drag box events and cancel ongoind requests
     * \@internal
     * @return {?}
     */
    function () {
        this.cancelOngoingQueries();
        this.unlistenToMapClick();
    };
    /**
     * On map click, issue queries
     */
    /**
     * On map click, issue queries
     * @private
     * @return {?}
     */
    QueryDirective.prototype.listenToMapClick = /**
     * On map click, issue queries
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this.mapClickListener = this.map.ol.on('singleclick', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.onMapEvent(event); }));
    };
    /**
     * Stop listening for map clicks
     */
    /**
     * Stop listening for map clicks
     * @private
     * @return {?}
     */
    QueryDirective.prototype.unlistenToMapClick = /**
     * Stop listening for map clicks
     * @private
     * @return {?}
     */
    function () {
        this.map.ol.un(this.mapClickListener.type, this.mapClickListener.listener);
        this.mapClickListener = undefined;
    };
    /**
     * Issue queries from a map event and emit events with the results
     * @param event OL map browser pointer event
     */
    /**
     * Issue queries from a map event and emit events with the results
     * @private
     * @param {?} event OL map browser pointer event
     * @return {?}
     */
    QueryDirective.prototype.onMapEvent = /**
     * Issue queries from a map event and emit events with the results
     * @private
     * @param {?} event OL map browser pointer event
     * @return {?}
     */
    function (event) {
        var _this = this;
        this.cancelOngoingQueries();
        if (!this.queryService.queryEnabled) {
            return;
        }
        /** @type {?} */
        var queries$ = [];
        if (this.queryFeatures) {
            queries$.push(this.doQueryFeatures(event));
        }
        /** @type {?} */
        var resolution = this.map.ol.getView().getResolution();
        /** @type {?} */
        var queryLayers = this.map.layers.filter(layerIsQueryable);
        queries$.push.apply(queries$, __spread(this.queryService.query(queryLayers, {
            coordinates: event.coordinate,
            projection: this.map.projection,
            resolution: resolution
        })));
        if (queries$.length === 0) {
            return;
        }
        if (this.waitForAllQueries) {
            this.queries$$.push(zip.apply(void 0, __spread(queries$)).subscribe((/**
             * @param {?} results
             * @return {?}
             */
            function (results) {
                /** @type {?} */
                var features = [].concat.apply([], __spread(results));
                _this.query.emit({ features: features, event: event });
            })));
        }
        else {
            this.queries$$ = queries$.map((/**
             * @param {?} query$
             * @return {?}
             */
            function (query$) {
                return query$.subscribe((/**
                 * @param {?} features
                 * @return {?}
                 */
                function (features) {
                    _this.query.emit({ features: features, event: event });
                }));
            }));
        }
    };
    /**
     * Query features already present on the map
     * @param event OL map browser pointer event
     */
    /**
     * Query features already present on the map
     * @private
     * @param {?} event OL map browser pointer event
     * @return {?}
     */
    QueryDirective.prototype.doQueryFeatures = /**
     * Query features already present on the map
     * @private
     * @param {?} event OL map browser pointer event
     * @return {?}
     */
    function (event) {
        var _this = this;
        /** @type {?} */
        var clickedFeatures = [];
        this.map.ol.forEachFeatureAtPixel(event.pixel, (/**
         * @param {?} featureOL
         * @param {?} layerOL
         * @return {?}
         */
        function (featureOL, layerOL) {
            var e_1, _a;
            if (featureOL) {
                if (featureOL.get('features')) {
                    try {
                        for (var _b = __values(featureOL.get('features')), _c = _b.next(); !_c.done; _c = _b.next()) {
                            var feature = _c.value;
                            /** @type {?} */
                            var newFeature = featureFromOl(feature, _this.map.projection);
                            newFeature.meta = {
                                title: feature.values_.nom,
                                id: feature.id_,
                                icon: feature.values_._icon,
                                sourceTitle: layerOL.values_.title
                            };
                            clickedFeatures.push(newFeature);
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }
                else if (featureOL instanceof OlRenderFeature) {
                    /** @type {?} */
                    var feature = renderFeatureFromOl(featureOL, _this.map.projection, layerOL);
                    clickedFeatures.push(feature);
                }
                else {
                    /** @type {?} */
                    var feature = featureFromOl(featureOL, _this.map.projection, layerOL);
                    clickedFeatures.push(feature);
                }
            }
        }), {
            hitTolerance: this.queryFeaturesHitTolerance || 0,
            layerFilter: this.queryFeaturesCondition
                ? this.queryFeaturesCondition
                : olLayerIsQueryable
        });
        /** @type {?} */
        var queryableLayers = this.map.layers.filter(layerIsQueryable);
        clickedFeatures.forEach((/**
         * @param {?} feature
         * @return {?}
         */
        function (feature) {
            queryableLayers.forEach((/**
             * @param {?} layer
             * @return {?}
             */
            function (layer) {
                if (typeof layer.ol.getSource().hasFeature !== 'undefined') {
                    if (layer.ol.getSource().hasFeature(feature.ol)) {
                        feature.meta.alias = _this.queryService.getAllowedFieldsAndAlias(layer);
                        feature.meta.title = feature.meta.title || _this.queryService.getQueryTitle(feature, layer);
                        feature.meta.sourceTitle = layer.title;
                    }
                }
            }));
        }));
        return of(clickedFeatures);
    };
    /**
     * Cancel ongoing requests, if any
     */
    /**
     * Cancel ongoing requests, if any
     * @private
     * @return {?}
     */
    QueryDirective.prototype.cancelOngoingQueries = /**
     * Cancel ongoing requests, if any
     * @private
     * @return {?}
     */
    function () {
        this.queries$$.forEach((/**
         * @param {?} sub
         * @return {?}
         */
        function (sub) { return sub.unsubscribe(); }));
        this.queries$$ = [];
    };
    QueryDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igoQuery]'
                },] }
    ];
    /** @nocollapse */
    QueryDirective.ctorParameters = function () { return [
        { type: MapBrowserComponent, decorators: [{ type: Self }] },
        { type: QueryService }
    ]; };
    QueryDirective.propDecorators = {
        queryFeatures: [{ type: Input }],
        queryFeaturesHitTolerance: [{ type: Input }],
        queryFeaturesCondition: [{ type: Input }],
        waitForAllQueries: [{ type: Input }],
        query: [{ type: Output }]
    };
    return QueryDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Base search source class
 */
var SearchSource = /** @class */ (function () {
    function SearchSource(options) {
        var _this = this;
        this.options = options;
        this.options = Object.assign({}, this.getDefaultOptions(), options);
        // Set Default Params from Settings
        this.settings.forEach((/**
         * @param {?} setting
         * @return {?}
         */
        function (setting) {
            _this.setParamFromSetting(setting);
        }));
    }
    /**
     * Get search source's id
     * @returns Search source's id
     */
    /**
     * Get search source's id
     * @return {?} Search source's id
     */
    SearchSource.prototype.getId = /**
     * Get search source's id
     * @return {?} Search source's id
     */
    function () {
        throw new Error('You have to implement the method "getId".');
    };
    /**
     * Get search source's type
     * @returns Search source's type
     */
    /**
     * Get search source's type
     * @return {?} Search source's type
     */
    SearchSource.prototype.getType = /**
     * Get search source's type
     * @return {?} Search source's type
     */
    function () {
        throw new Error('You have to implement the method "getType".');
    };
    /**
     * Get search source's default options
     * @returns Search source default options
     */
    /**
     * Get search source's default options
     * @protected
     * @return {?} Search source default options
     */
    SearchSource.prototype.getDefaultOptions = /**
     * Get search source's default options
     * @protected
     * @return {?} Search source default options
     */
    function () {
        throw new Error('You have to implement the method "getDefaultOptions".');
    };
    Object.defineProperty(SearchSource.prototype, "title", {
        /**
         * Search source's title
         */
        get: /**
         * Search source's title
         * @return {?}
         */
        function () {
            return this.options.title;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchSource.prototype, "available", {
        /**
         * Whether the search source is available
         */
        get: /**
         * Whether the search source is available
         * @return {?}
         */
        function () {
            return this.options.available !== false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchSource.prototype, "enabled", {
        get: /**
         * @return {?}
         */
        function () {
            return this.available && this.options.enabled !== false;
        },
        /**
         * Whether the search source is enabled
         */
        set: /**
         * Whether the search source is enabled
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.options.enabled = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchSource.prototype, "showInPointerSummary", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var showInPointerSummary = this.options.showInPointerSummary;
            return showInPointerSummary ? showInPointerSummary : false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchSource.prototype, "showInSettings", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var showInSettings = this.options.showInSettings;
            return showInSettings === undefined ? true : showInSettings;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchSource.prototype, "searchUrl", {
        /**
         * Search url
         */
        get: /**
         * Search url
         * @return {?}
         */
        function () {
            return this.options.searchUrl;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchSource.prototype, "params", {
        /**
         * Search query params
         */
        get: /**
         * Search query params
         * @return {?}
         */
        function () {
            return this.options.params === undefined ? {} : this.options.params;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchSource.prototype, "settings", {
        /**
         * Search settings
         */
        get: /**
         * Search settings
         * @return {?}
         */
        function () {
            return this.options.settings === undefined ? [] : this.options.settings;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Set params from selected settings
     */
    /**
     * Set params from selected settings
     * @param {?} setting
     * @return {?}
     */
    SearchSource.prototype.setParamFromSetting = /**
     * Set params from selected settings
     * @param {?} setting
     * @return {?}
     */
    function (setting) {
        var _this = this;
        var _a;
        switch (setting.type) {
            case 'radiobutton':
                setting.values.forEach((/**
                 * @param {?} conf
                 * @return {?}
                 */
                function (conf) {
                    var _a;
                    if (conf.enabled) {
                        _this.options.params = Object.assign(_this.options.params || {}, (_a = {},
                            _a[setting.name] = conf.value,
                            _a));
                    }
                }));
                break;
            case 'checkbox':
                /** @type {?} */
                var confValue_1 = '';
                setting.values
                    .filter((/**
                 * @param {?} s
                 * @return {?}
                 */
                function (s) { return s.available !== false; }))
                    .forEach((/**
                 * @param {?} conf
                 * @return {?}
                 */
                function (conf) {
                    if (conf.enabled) {
                        confValue_1 += conf.value + ',';
                    }
                }));
                confValue_1 = confValue_1.slice(0, -1);
                this.options.params = Object.assign(this.options.params || {}, (_a = {},
                    _a[setting.name] = confValue_1,
                    _a));
                break;
        }
    };
    Object.defineProperty(SearchSource.prototype, "displayOrder", {
        /**
         * Search results display order
         */
        get: /**
         * Search results display order
         * @return {?}
         */
        function () {
            return this.options.order === undefined ? 99 : this.options.order;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Get hashtags valid
     * @param hashtag hashtag from query
     */
    /**
     * Get hashtags valid
     * @param {?} term
     * @param {?} settingsName
     * @return {?}
     */
    SearchSource.prototype.getHashtagsValid = /**
     * Get hashtags valid
     * @param {?} term
     * @param {?} settingsName
     * @return {?}
     */
    function (term, settingsName) {
        /** @type {?} */
        var hashtags = term.match(/(#[^\s]+)/g);
        if (!hashtags) {
            return undefined;
        }
        /** @type {?} */
        var searchSourceSetting = this.getSettingsValues(settingsName);
        /** @type {?} */
        var hashtagsValid = [];
        hashtags.forEach((/**
         * @param {?} hashtag
         * @return {?}
         */
        function (hashtag) {
            searchSourceSetting.values.forEach((/**
             * @param {?} conf
             * @return {?}
             */
            function (conf) {
                /** @type {?} */
                var hashtagKey = hashtag.substring(1);
                if (typeof conf.value === 'string') {
                    /** @type {?} */
                    var types = conf.value
                        .toLowerCase()
                        .normalize('NFD')
                        .replace(/[\u0300-\u036f]/g, '')
                        .split(',');
                    /** @type {?} */
                    var index = types.indexOf(hashtagKey
                        .toLowerCase()
                        .normalize('NFD')
                        .replace(/[\u0300-\u036f]/g, ''));
                    if (index !== -1) {
                        hashtagsValid.push(types[index]);
                    }
                }
                if (conf.hashtags && conf.hashtags.indexOf(hashtagKey) !== -1) {
                    hashtagsValid.push(conf.value);
                }
            }));
        }));
        return hashtagsValid.filter((/**
         * @param {?} a
         * @param {?} b
         * @return {?}
         */
        function (a, b) { return hashtagsValid.indexOf(a) === b; }));
    };
    /**
     * @param {?} search
     * @return {?}
     */
    SearchSource.prototype.getSettingsValues = /**
     * @param {?} search
     * @return {?}
     */
    function (search) {
        return this.getDefaultOptions().settings.find((/**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            return value.name === search;
        }));
    };
    /**
     * Search source ID
     * \@internal
     */
    SearchSource.id = '';
    /**
     * Search source type
     * \@internal
     */
    SearchSource.type = '';
    return SearchSource;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Map search source. For now it has no search capability. All it does
 * is act as a placeholder for the map query results' "search source".
 */
var QuerySearchSource = /** @class */ (function (_super) {
    __extends(QuerySearchSource, _super);
    function QuerySearchSource(options) {
        return _super.call(this, options) || this;
    }
    /**
     * @return {?}
     */
    QuerySearchSource.prototype.getId = /**
     * @return {?}
     */
    function () {
        return QuerySearchSource.id;
    };
    /**
     * @return {?}
     */
    QuerySearchSource.prototype.getType = /**
     * @return {?}
     */
    function () {
        return QuerySearchSource.type;
    };
    /**
     * @protected
     * @return {?}
     */
    QuerySearchSource.prototype.getDefaultOptions = /**
     * @protected
     * @return {?}
     */
    function () {
        return {
            title: 'Carte'
        };
    };
    QuerySearchSource.id = 'map';
    QuerySearchSource.type = FEATURE;
    QuerySearchSource.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    QuerySearchSource.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: ['options',] }] }
    ]; };
    return QuerySearchSource;
}(SearchSource));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var GoogleLinks = /** @class */ (function () {
    function GoogleLinks() {
    }
    /**
     * @param {?} lon
     * @param {?} lat
     * @return {?}
     */
    GoogleLinks.getGoogleMapsCoordLink = /**
     * @param {?} lon
     * @param {?} lat
     * @return {?}
     */
    function (lon, lat) {
        return 'https://www.google.com/maps?q=' + lat + ',' + lon;
    };
    /**
     * @param {?} lon
     * @param {?} lat
     * @return {?}
     */
    GoogleLinks.getGoogleStreetViewLink = /**
     * @param {?} lon
     * @param {?} lat
     * @return {?}
     */
    function (lon, lat) {
        return 'https://www.google.com/maps?q=&layer=c&cbll=' + lat + ',' + lon;
    };
    /**
     * @param {?} name
     * @return {?}
     */
    GoogleLinks.getGoogleMapsNameLink = /**
     * @param {?} name
     * @return {?}
     */
    function (name) {
        /** @type {?} */
        var encodedName = encodeURI(name);
        return 'https://www.google.com/maps?q=' + encodedName;
    };
    return GoogleLinks;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var OsmLinks = /** @class */ (function () {
    function OsmLinks() {
    }
    /**
     * @param {?} lon
     * @param {?} lat
     * @param {?=} zoom
     * @return {?}
     */
    OsmLinks.getOpenStreetMapLink = /**
     * @param {?} lon
     * @param {?} lat
     * @param {?=} zoom
     * @return {?}
     */
    function (lon, lat, zoom) {
        if (zoom === void 0) { zoom = 17; }
        // return 'https://www.google.com/maps?q=' + lat + ',' + lon;
        return "https://www.openstreetmap.org/?mlat=" + lat + "&mlon=" + lon + "#map=" + zoom + "/" + lat + "/" + lon;
    };
    /**
     * @param {?} lon
     * @param {?} lat
     * @param {?=} zoom
     * @return {?}
     */
    OsmLinks.getOpenStreetCamLink = /**
     * @param {?} lon
     * @param {?} lat
     * @param {?=} zoom
     * @return {?}
     */
    function (lon, lat, zoom) {
        if (zoom === void 0) { zoom = 17; }
        return "https://openstreetcam.org/map/@" + lat + "," + lon + "," + zoom + "z";
    };
    return OsmLinks;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var CatalogService = /** @class */ (function () {
    function CatalogService(http, config, languageService, capabilitiesService) {
        this.http = http;
        this.config = config;
        this.languageService = languageService;
        this.capabilitiesService = capabilitiesService;
    }
    /**
     * @return {?}
     */
    CatalogService.prototype.loadCatalogs = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var contextConfig = this.config.getConfig('context') || {};
        /** @type {?} */
        var catalogConfig = this.config.getConfig('catalog') || {};
        /** @type {?} */
        var apiUrl = catalogConfig.url || contextConfig.url;
        /** @type {?} */
        var catalogsFromConfig = catalogConfig.sources || [];
        /** @type {?} */
        var observables$ = [];
        if (apiUrl) {
            // Base layers catalog
            if (catalogConfig.baseLayers) {
                /** @type {?} */
                var translate = this.languageService.translate;
                /** @type {?} */
                var title = translate.instant('igo.geo.catalog.baseLayers');
                /** @type {?} */
                var baseLayersCatalog = [
                    {
                        id: 'catalog.baselayers',
                        title: title,
                        url: apiUrl + "/baselayers",
                        type: 'baselayers'
                    }
                ];
                observables$.push(of(baseLayersCatalog));
            }
            // Catalogs from API
            /** @type {?} */
            var catalogsFromApi$ = this.http
                .get(apiUrl + "/catalogs")
                .pipe(map((/**
             * @param {?} catalogs
             * @return {?}
             */
            function (catalogs) {
                return catalogs.map((/**
                 * @param {?} c
                 * @return {?}
                 */
                function (c) { return Object.assign(c, c.options); }));
            })), catchError((/**
             * @param {?} _response
             * @return {?}
             */
            function (_response) { return EMPTY; })));
            observables$.push(catalogsFromApi$);
        }
        // Catalogs from config
        if (catalogsFromConfig.length > 0) {
            observables$.push(of(catalogsFromConfig).pipe(map((/**
             * @param {?} catalogs
             * @return {?}
             */
            function (catalogs) {
                return catalogs.map((/**
                 * @param {?} c
                 * @return {?}
                 */
                function (c) {
                    if (!c.id) {
                        c.id = uuid();
                    }
                    return c;
                }));
            }))));
        }
        return (/** @type {?} */ (zip.apply(void 0, __spread(observables$)).pipe(map((/**
         * @param {?} catalogs
         * @return {?}
         */
        function (catalogs) { return [].concat.apply([], catalogs); })))));
    };
    /**
     * @param {?} catalog
     * @return {?}
     */
    CatalogService.prototype.loadCatalogItems = /**
     * @param {?} catalog
     * @return {?}
     */
    function (catalog) {
        /** @type {?} */
        var newCatalog;
        newCatalog = CatalogFactory.createInstanceCatalog(catalog, this);
        return newCatalog.collectCatalogItems();
    };
    /**
     * @param {?} catalog
     * @return {?}
     */
    CatalogService.prototype.loadCatalogBaseLayerItems = /**
     * @param {?} catalog
     * @return {?}
     */
    function (catalog) {
        return this.getCatalogBaseLayersOptions(catalog).pipe(map((/**
         * @param {?} layersOptions
         * @return {?}
         */
        function (layersOptions) {
            /** @type {?} */
            var items = layersOptions.map((/**
             * @param {?} layerOptions
             * @return {?}
             */
            function (layerOptions) {
                return (/** @type {?} */ ({
                    id: generateIdFromSourceOptions(layerOptions.sourceOptions),
                    title: layerOptions.title,
                    type: CatalogItemType.Layer,
                    options: layerOptions
                }));
            }));
            return [
                {
                    id: 'catalog.group.baselayers',
                    type: CatalogItemType.Group,
                    title: catalog.title,
                    items: items
                }
            ];
        })));
    };
    /**
     * @private
     * @param {?} catalog
     * @return {?}
     */
    CatalogService.prototype.getCatalogBaseLayersOptions = /**
     * @private
     * @param {?} catalog
     * @return {?}
     */
    function (catalog) {
        return this.http.get(catalog.url);
    };
    /**
     * @param {?} catalog
     * @return {?}
     */
    CatalogService.prototype.loadCatalogWMSLayerItems = /**
     * @param {?} catalog
     * @return {?}
     */
    function (catalog) {
        var _this = this;
        return this.getCatalogCapabilities(catalog).pipe(map((/**
         * @param {?} capabilities
         * @return {?}
         */
        function (capabilities) {
            /** @type {?} */
            var items = [];
            _this.includeRecursiveItems(catalog, capabilities.Capability.Layer, items);
            return items;
        })));
    };
    /**
     * @param {?} catalog
     * @return {?}
     */
    CatalogService.prototype.loadCatalogWMTSLayerItems = /**
     * @param {?} catalog
     * @return {?}
     */
    function (catalog) {
        var _this = this;
        return this.getCatalogCapabilities(catalog).pipe(map((/**
         * @param {?} capabilities
         * @return {?}
         */
        function (capabilities) { return _this.getWMTSItems(catalog, capabilities); })));
    };
    /**
     * @param {?} catalog
     * @return {?}
     */
    CatalogService.prototype.loadCatalogCompositeLayerItems = /**
     * @param {?} catalog
     * @return {?}
     */
    function (catalog) {
        var _this = this;
        /** @type {?} */
        var compositeCatalog = ((/** @type {?} */ (catalog))).composite;
        /** @type {?} */
        var catalogsFromInstance = (/** @type {?} */ ([]));
        compositeCatalog.map((/**
         * @param {?} component
         * @return {?}
         */
        function (component) {
            return catalogsFromInstance.push(CatalogFactory.createInstanceCatalog(component, _this));
        }));
        // get CatalogItems for each original Catalog-----------------------------------------------------
        /** @type {?} */
        var request1$ = [];
        catalogsFromInstance.map((/**
         * @param {?} component
         * @return {?}
         */
        function (component) {
            return request1$.push(component.collectCatalogItems());
        }));
        // integrate imposed group -----------------------------------------------------
        /** @type {?} */
        var request2$ = [];
        /**
         * @param {?} arr
         * @return {?}
         */
        function flatDeepLayer(arr) {
            return arr.reduce((/**
             * @param {?} acc
             * @param {?} val
             * @return {?}
             */
            function (acc, val) {
                return acc.concat(val.type === CatalogItemType.Group ? flatDeepLayer(val.items) : val);
            }), []);
        }
        if (Object.keys(compositeCatalog).find((/**
         * @param {?} k
         * @return {?}
         */
        function (k) { return compositeCatalog[k].groupImpose; }))) {
            /** @type {?} */
            var pushImposeGroup_1 = (/**
             * @param {?} item
             * @param {?} index
             * @return {?}
             */
            function (item, index) {
                /** @type {?} */
                var c = catalogsFromInstance[index];
                /** @type {?} */
                var outGroupImpose = Object.assign({}, c.groupImpose);
                outGroupImpose.address = c.id;
                outGroupImpose.type = CatalogItemType.Group;
                outGroupImpose.items = [];
                /** @type {?} */
                var flatLayer = flatDeepLayer(item);
                flatLayer.map((/**
                 * @param {?} v
                 * @return {?}
                 */
                function (v) { return (v.address = outGroupImpose.address + "." + outGroupImpose.id); }));
                outGroupImpose.items = flatLayer;
                return outGroupImpose;
            });
            request2$ = request1$.map((/**
             * @param {?} obs
             * @param {?} idx
             * @return {?}
             */
            function (obs, idx) {
                return obs.pipe(map((/**
                 * @param {?} items
                 * @return {?}
                 */
                function (items) {
                    return compositeCatalog[idx].groupImpose
                        ? pushImposeGroup_1(items, idx)
                        : items;
                })));
            }));
        }
        else {
            request2$ = request1$;
        }
        // concat Group -----------------------------------------------------
        /** @type {?} */
        var request3$ = zip.apply(void 0, __spread(request2$)).pipe(map((/**
         * @param {?} output
         * @return {?}
         */
        function (output) { return [].concat.apply([], __spread(output)); } // [].concat.apply([], result1
        )));
        // merge Group (first level only) -----------------------------------------------------
        /** @type {?} */
        var groupByGroupId = (/**
         * @param {?} data
         * @param {?} keyFn
         * @return {?}
         */
        function (data, keyFn) {
            return data.reduce((/**
             * @param {?} acc
             * @param {?} group
             * @return {?}
             */
            function (acc, group) {
                var _a;
                /** @type {?} */
                var groupId = keyFn(group);
                /** @type {?} */
                var ind = acc.find((/**
                 * @param {?} x
                 * @return {?}
                 */
                function (x) { return x.id === groupId; }));
                if (!ind) {
                    acc[acc.length] = group;
                }
                else {
                    /** @type {?} */
                    var ix = acc.indexOf(ind);
                    if (acc[ix].address.split('|').indexOf(group.address) === -1) {
                        acc[ix].address = acc[ix].address + "|" + group.address;
                    }
                    (_a = acc[ix].items).push.apply(_a, __spread(group.items));
                }
                return acc;
            }), []);
        });
        // merge Layer for each Level (catalog, group(recursive))
        /** @type {?} */
        var recursiveGroupByLayerAddress = (/**
         * @param {?} items
         * @param {?} keyFn
         * @return {?}
         */
        function (items, keyFn) {
            return items.reduce((/**
             * @param {?} acc
             * @param {?} item
             * @param {?} idx
             * @param {?} arr
             * @return {?}
             */
            function (acc, item, idx, arr) {
                /** @type {?} */
                var layerTitle = keyFn(item);
                /** @type {?} */
                var outItem = Object.assign({}, item);
                if (item.type === CatalogItemType.Layer) {
                    // same title, same address => result: only one item is keep
                    // same title, address diff
                    /** @type {?} */
                    var indicesMatchTitle_1 = [];
                    /** @type {?} */
                    var diffAddress = arr.filter((/**
                     * @param {?} x
                     * @param {?} i
                     * @return {?}
                     */
                    function (x, i) {
                        /** @type {?} */
                        var bInd = false;
                        if (x.title === layerTitle && x.type === CatalogItemType.Layer) {
                            if (i !== idx && x.address !== item.address) {
                                bInd = true;
                            }
                            indicesMatchTitle_1.push(i);
                        }
                        return bInd;
                    }));
                    if (diffAddress.length > 0) {
                        /** @type {?} */
                        var nPosition = indicesMatchTitle_1.findIndex((/**
                         * @param {?} x
                         * @return {?}
                         */
                        function (x) { return x === idx; })) + 1;
                        outItem.title = item.title + " (" + nPosition + ")"; // source: ${item.address.split('.')[0]}
                    }
                    /** @type {?} */
                    var exist = acc.find((/**
                     * @param {?} x
                     * @return {?}
                     */
                    function (x) { return x.title === outItem.title && x.type === CatalogItemType.Layer; }));
                    if (!exist) {
                        acc[acc.length] = outItem;
                    }
                }
                else if (item.type === CatalogItemType.Group) {
                    outItem.items = recursiveGroupByLayerAddress(item.items, (/**
                     * @param {?} layer
                     * @return {?}
                     */
                    function (layer) { return layer.title; }));
                    acc[acc.length] = outItem;
                }
                return acc;
            }), []);
        });
        /** @type {?} */
        var request4$ = request3$.pipe(map((/**
         * @param {?} output
         * @return {?}
         */
        function (output) { return groupByGroupId(output, (/**
         * @param {?} group
         * @return {?}
         */
        function (group) { return group.id; })); })), map((/**
         * @param {?} output
         * @return {?}
         */
        function (output) { return [].concat.apply([], __spread(output)); })), map((/**
         * @param {?} data
         * @return {?}
         */
        function (data) { return recursiveGroupByLayerAddress(data, (/**
         * @param {?} layer
         * @return {?}
         */
        function (layer) { return layer.title; })); })));
        return request4$;
    };
    /**
     * @private
     * @param {?} catalog
     * @return {?}
     */
    CatalogService.prototype.getCatalogCapabilities = /**
     * @private
     * @param {?} catalog
     * @return {?}
     */
    function (catalog) {
        /** @type {?} */
        var sType = TypeCatalog[(/** @type {?} */ (catalog.type))];
        return this.capabilitiesService.getCapabilities(TypeCapabilities[sType], catalog.url, catalog.version);
    };
    /**
     * @private
     * @param {?} layer
     * @param {?} idParent
     * @param {?} layersQueryFormat
     * @param {?} catalog
     * @return {?}
     */
    CatalogService.prototype.prepareCatalogItemLayer = /**
     * @private
     * @param {?} layer
     * @param {?} idParent
     * @param {?} layersQueryFormat
     * @param {?} catalog
     * @return {?}
     */
    function (layer, idParent, layersQueryFormat, catalog) {
        /** @type {?} */
        var configuredQueryFormat = this.retriveLayerInfoFormat(layer.Name, layersQueryFormat);
        /** @type {?} */
        var metadata = layer.DataURL ? layer.DataURL[0] : undefined;
        /** @type {?} */
        var legendOptions = catalog.showLegend && layer.Style
            ? this.capabilitiesService.getStyle(layer.Style)
            : undefined;
        /** @type {?} */
        var params = Object.assign({}, catalog.queryParams, (/** @type {?} */ ({
            LAYERS: layer.Name,
            VERSION: catalog.version
        })));
        /** @type {?} */
        var baseSourceOptions = {
            type: 'wms',
            url: catalog.url,
            crossOrigin: catalog.setCrossOriginAnonymous ? 'anonymous' : undefined,
            queryFormat: configuredQueryFormat,
            queryHtmlTarget: configuredQueryFormat === QueryFormat.HTML ||
                configuredQueryFormat === QueryFormat.HTMLGML2
                ? 'iframe'
                : undefined,
            optionsFromCapabilities: true
        };
        /** @type {?} */
        var sourceOptions = (/** @type {?} */ (Object.assign({}, baseSourceOptions, catalog.sourceOptions, { params: params })));
        /** @type {?} */
        var layerPrepare = {
            id: generateIdFromSourceOptions(sourceOptions),
            type: CatalogItemType.Layer,
            title: layer.Title,
            address: idParent,
            options: {
                maxResolution: getResolutionFromScale(layer.MaxScaleDenominator),
                minResolution: getResolutionFromScale(layer.MinScaleDenominator),
                metadata: {
                    url: metadata ? metadata.OnlineResource : undefined,
                    extern: metadata ? true : undefined
                },
                legendOptions: legendOptions,
                tooltip: { type: catalog.tooltipType },
                sourceOptions: sourceOptions
            }
        };
        return ObjectUtils.removeUndefined(layerPrepare);
    };
    /**
     * @private
     * @param {?} itemListIn
     * @param {?} regexes
     * @param {?} idGroup
     * @param {?} layersQueryFormat
     * @param {?} catalog
     * @return {?}
     */
    CatalogService.prototype.prepareCatalogItemGroup = /**
     * @private
     * @param {?} itemListIn
     * @param {?} regexes
     * @param {?} idGroup
     * @param {?} layersQueryFormat
     * @param {?} catalog
     * @return {?}
     */
    function (itemListIn, regexes, idGroup, layersQueryFormat, catalog) {
        var _this = this;
        /** @type {?} */
        var groupPrepare = {
            id: idGroup,
            type: CatalogItemType.Group,
            title: itemListIn.Title,
            address: catalog.id,
            items: itemListIn.Layer.reduce((/**
             * @param {?} items
             * @param {?} layer
             * @return {?}
             */
            function (items, layer) {
                if (layer.Layer !== undefined) {
                    // recursive, check next level
                    /** @type {?} */
                    var idGroupItemNextLevel = idGroup + (".group." + (layer.Name || layer.Layer[0].Name));
                    /** @type {?} */
                    var groupItem = _this.prepareCatalogItemGroup(layer, regexes, idGroupItemNextLevel, layersQueryFormat, catalog);
                    items.push(groupItem);
                }
                else {
                    if (_this.testLayerRegexes(layer.Name, regexes) === false) {
                        return items;
                    }
                    /** @type {?} */
                    var layerItem = _this.prepareCatalogItemLayer(layer, idGroup, layersQueryFormat, catalog);
                    items.push(layerItem);
                }
                return items;
            }), [])
        };
        return groupPrepare;
    };
    /**
     * @private
     * @param {?} catalog
     * @param {?} itemListIn
     * @param {?} itemsPrepare
     * @param {?=} loopLevel
     * @return {?}
     */
    CatalogService.prototype.includeRecursiveItems = /**
     * @private
     * @param {?} catalog
     * @param {?} itemListIn
     * @param {?} itemsPrepare
     * @param {?=} loopLevel
     * @return {?}
     */
    function (catalog, itemListIn, itemsPrepare, loopLevel) {
        if (loopLevel === void 0) { loopLevel = 0; }
        var e_1, _a;
        // Dig all levels until last level (layer object are not defined on last level)
        /** @type {?} */
        var regexes = (catalog.regFilters || []).map((/**
         * @param {?} pattern
         * @return {?}
         */
        function (pattern) { return new RegExp(pattern); }));
        if (!itemListIn.Layer) {
            return;
        }
        try {
            for (var _b = __values(itemListIn.Layer), _c = _b.next(); !_c.done; _c = _b.next()) {
                var item = _c.value;
                if (item.Layer !== undefined) {
                    // recursive, check next level
                    this.includeRecursiveItems(catalog, item, itemsPrepare, loopLevel + 1);
                    continue;
                }
                /** @type {?} */
                var layersQueryFormat = this.findCatalogInfoFormat(catalog);
                // group(with layers) and layer(without group) level 1
                if (loopLevel !== 0) {
                    // TODO: Slice that into multiple methods
                    // Define object of group layer
                    /** @type {?} */
                    var idGroupItem = "catalog.group." + (itemListIn.Name || item.Name);
                    /** @type {?} */
                    var groupItem = this.prepareCatalogItemGroup(itemListIn, regexes, idGroupItem, layersQueryFormat, catalog);
                    if (groupItem.items.length !== 0) {
                        itemsPrepare.push(groupItem);
                    }
                    // Break the group (don't add a group of layer for each of their layer!)
                    break;
                }
                else {
                    // layer without group
                    if (this.testLayerRegexes(item.Name, regexes) !== false) {
                        /** @type {?} */
                        var layerItem = this.prepareCatalogItemLayer(item, catalog.id, layersQueryFormat, catalog);
                        itemsPrepare.push(layerItem);
                    }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    /**
     * @private
     * @param {?} catalog
     * @param {?} capabilities
     * @return {?}
     */
    CatalogService.prototype.getWMTSItems = /**
     * @private
     * @param {?} catalog
     * @param {?} capabilities
     * @return {?}
     */
    function (catalog, capabilities) {
        var _this = this;
        /** @type {?} */
        var layers = capabilities.Contents.Layer;
        /** @type {?} */
        var regexes = (catalog.regFilters || []).map((/**
         * @param {?} pattern
         * @return {?}
         */
        function (pattern) { return new RegExp(pattern); }));
        return layers
            .map((/**
         * @param {?} layer
         * @return {?}
         */
        function (layer) {
            if (_this.testLayerRegexes(layer.Identifier, regexes) === false) {
                return undefined;
            }
            /** @type {?} */
            var params = Object.assign({}, catalog.queryParams, {
                version: '1.0.0'
            });
            /** @type {?} */
            var baseSourceOptions = (/** @type {?} */ ({
                type: 'wmts',
                url: catalog.url,
                crossOrigin: catalog.setCrossOriginAnonymous
                    ? 'anonymous'
                    : undefined,
                layer: layer.Identifier,
                matrixSet: catalog.matrixSet,
                optionsFromCapabilities: true,
                requestEncoding: catalog.requestEncoding || 'KVP',
                style: 'default'
            }));
            /** @type {?} */
            var sourceOptions = (/** @type {?} */ (Object.assign({}, baseSourceOptions, catalog.sourceOptions, { params: params })));
            return ObjectUtils.removeUndefined({
                id: generateIdFromSourceOptions(sourceOptions),
                type: CatalogItemType.Layer,
                title: layer.Title,
                address: catalog.id,
                options: {
                    sourceOptions: sourceOptions
                }
            });
        }))
            .filter((/**
         * @param {?} item
         * @return {?}
         */
        function (item) { return item !== undefined; }));
    };
    /**
     * @private
     * @param {?} layerName
     * @param {?} regexes
     * @return {?}
     */
    CatalogService.prototype.testLayerRegexes = /**
     * @private
     * @param {?} layerName
     * @param {?} regexes
     * @return {?}
     */
    function (layerName, regexes) {
        if (regexes.length === 0) {
            return true;
        }
        return regexes.find((/**
         * @param {?} regex
         * @return {?}
         */
        function (regex) { return regex.test(layerName); })) !== undefined;
    };
    /**
     * @private
     * @param {?} layerNameFromCatalog
     * @param {?} layersQueryFormat
     * @return {?}
     */
    CatalogService.prototype.retriveLayerInfoFormat = /**
     * @private
     * @param {?} layerNameFromCatalog
     * @param {?} layersQueryFormat
     * @return {?}
     */
    function (layerNameFromCatalog, layersQueryFormat) {
        /** @type {?} */
        var currentLayerInfoFormat = layersQueryFormat.find((/**
         * @param {?} f
         * @return {?}
         */
        function (f) { return f.layer === layerNameFromCatalog; }));
        /** @type {?} */
        var baseInfoFormat = layersQueryFormat.find((/**
         * @param {?} f
         * @return {?}
         */
        function (f) { return f.layer === '*'; }));
        /** @type {?} */
        var queryFormat;
        if (currentLayerInfoFormat) {
            queryFormat = currentLayerInfoFormat.queryFormat;
        }
        else if (baseInfoFormat) {
            queryFormat = baseInfoFormat.queryFormat;
        }
        return queryFormat;
    };
    /**
     * @private
     * @param {?} catalog
     * @return {?}
     */
    CatalogService.prototype.findCatalogInfoFormat = /**
     * @private
     * @param {?} catalog
     * @return {?}
     */
    function (catalog) {
        /** @type {?} */
        var layersQueryFormat = [];
        if (!catalog.queryFormat) {
            return layersQueryFormat;
        }
        Object.keys(catalog.queryFormat).forEach((/**
         * @param {?} configuredInfoFormat
         * @return {?}
         */
        function (configuredInfoFormat) {
            if (catalog.queryFormat[configuredInfoFormat] instanceof Array) {
                catalog.queryFormat[configuredInfoFormat].forEach((/**
                 * @param {?} layerName
                 * @return {?}
                 */
                function (layerName) {
                    if (!layersQueryFormat.find((/**
                     * @param {?} specific
                     * @return {?}
                     */
                    function (specific) { return specific.layer === layerName; }))) {
                        layersQueryFormat.push({
                            layer: layerName,
                            queryFormat: (/** @type {?} */ (configuredInfoFormat))
                        });
                    }
                }));
            }
            else {
                if (!layersQueryFormat.find((/**
                 * @param {?} specific
                 * @return {?}
                 */
                function (specific) {
                    return specific.layer === catalog.queryFormat[configuredInfoFormat];
                }))) {
                    layersQueryFormat.push({
                        layer: catalog.queryFormat[configuredInfoFormat],
                        queryFormat: (/** @type {?} */ (configuredInfoFormat))
                    });
                }
            }
        }));
        return layersQueryFormat;
    };
    CatalogService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    CatalogService.ctorParameters = function () { return [
        { type: HttpClient },
        { type: ConfigService },
        { type: LanguageService },
        { type: CapabilitiesService }
    ]; };
    /** @nocollapse */ CatalogService.ngInjectableDef = defineInjectable({ factory: function CatalogService_Factory() { return new CatalogService(inject(HttpClient), inject(ConfigService), inject(LanguageService), inject(CapabilitiesService)); }, token: CatalogService, providedIn: "root" });
    return CatalogService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Component to browse a catalog's groups and layers and display them on a map.
 */
var CatalogBrowserComponent = /** @class */ (function () {
    function CatalogBrowserComponent(layerService, cdRef) {
        this.layerService = layerService;
        this.cdRef = cdRef;
        this.catalogAllowLegend = false;
        /**
         * Whether a group can be toggled when it's collapsed
         */
        this.toggleCollapsedGroup = true;
    }
    Object.defineProperty(CatalogBrowserComponent.prototype, "resolution$", {
        // private resolution$$: Subscription;
        get: 
        // private resolution$$: Subscription;
        /**
         * @return {?}
         */
        function () { return this.map.viewController.resolution$; },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal
     */
    /**
     * \@internal
     * @return {?}
     */
    CatalogBrowserComponent.prototype.ngOnInit = /**
     * \@internal
     * @return {?}
     */
    function () {
        /** @type {?} */
        var currentItems = this.map.layers.map((/**
         * @param {?} layer
         * @return {?}
         */
        function (layer) {
            return {
                id: layer.options.source.id,
                title: layer.title,
                type: CatalogItemType.Layer
            };
        }));
        this.store.state.updateMany(currentItems, { added: true }, true);
        if (this.catalog && this.catalog.sortDirection !== undefined) {
            this.store.view.sort({
                direction: this.catalog.sortDirection,
                valueAccessor: (/**
                 * @param {?} item
                 * @return {?}
                 */
                function (item) { return item.title; })
            });
        }
        /** @type {?} */
        var catalogShowLegend = this.catalog ? this.catalog.showLegend : false;
        this.catalogAllowLegend = catalogShowLegend ? catalogShowLegend : this.catalogAllowLegend;
        this.watcher = new EntityStoreWatcher(this.store, this.cdRef);
    };
    /**
     * @return {?}
     */
    CatalogBrowserComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.watcher.destroy();
    };
    /**
     * @internal
     */
    /**
     * \@internal
     * @param {?} item
     * @return {?}
     */
    CatalogBrowserComponent.prototype.isGroup = /**
     * \@internal
     * @param {?} item
     * @return {?}
     */
    function (item) {
        return item.type === CatalogItemType.Group;
    };
    /**
     * @internal
     */
    /**
     * \@internal
     * @param {?} item
     * @return {?}
     */
    CatalogBrowserComponent.prototype.isLayer = /**
     * \@internal
     * @param {?} item
     * @return {?}
     */
    function (item) {
        return item.type === CatalogItemType.Layer;
    };
    /**
     * When a layer is added or removed, add or remove it from the map
     * @internal
     * @param event Layer added event
     */
    /**
     * When a layer is added or removed, add or remove it from the map
     * \@internal
     * @param {?} event Layer added event
     * @return {?}
     */
    CatalogBrowserComponent.prototype.onLayerAddedChange = /**
     * When a layer is added or removed, add or remove it from the map
     * \@internal
     * @param {?} event Layer added event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var layer = event.layer;
        this.store.state.update(layer, { added: event.added }, false);
        event.added ? this.addLayerToMap(layer) : this.removeLayerFromMap(layer);
    };
    /**
     * When a froup is added or removed, add or remove it from the map
     * @internal
     * @param event Group added event
     */
    /**
     * When a froup is added or removed, add or remove it from the map
     * \@internal
     * @param {?} event Group added event
     * @return {?}
     */
    CatalogBrowserComponent.prototype.onGroupAddedChange = /**
     * When a froup is added or removed, add or remove it from the map
     * \@internal
     * @param {?} event Group added event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var group = event.group;
        this.store.state.update(group, { added: event.added }, false);
        event.added ? this.addGroupToMap(group) : this.removeGroupFromMap(group);
    };
    /**
     * Add layer to map
     * @param layer Catalog layer
     */
    /**
     * Add layer to map
     * @private
     * @param {?} layer Catalog layer
     * @return {?}
     */
    CatalogBrowserComponent.prototype.addLayerToMap = /**
     * Add layer to map
     * @private
     * @param {?} layer Catalog layer
     * @return {?}
     */
    function (layer) {
        this.addLayersToMap([layer]);
    };
    /**
     * Remove layer from map
     * @param layer Catalog layer
     */
    /**
     * Remove layer from map
     * @private
     * @param {?} layer Catalog layer
     * @return {?}
     */
    CatalogBrowserComponent.prototype.removeLayerFromMap = /**
     * Remove layer from map
     * @private
     * @param {?} layer Catalog layer
     * @return {?}
     */
    function (layer) {
        this.removeLayersFromMap([layer]);
    };
    /**
     * Add multiple layers to map
     * @param layers Catalog layers
     */
    /**
     * Add multiple layers to map
     * @private
     * @param {?} layers Catalog layers
     * @return {?}
     */
    CatalogBrowserComponent.prototype.addLayersToMap = /**
     * Add multiple layers to map
     * @private
     * @param {?} layers Catalog layers
     * @return {?}
     */
    function (layers) {
        var _this = this;
        /** @type {?} */
        var layers$ = layers.map((/**
         * @param {?} layer
         * @return {?}
         */
        function (layer) {
            if (layer.options.sourceOptions.optionsFromApi === undefined) {
                layer.options.sourceOptions.optionsFromApi = true;
            }
            return _this.layerService.createAsyncLayer(layer.options);
        }));
        zip.apply(void 0, __spread(layers$)).subscribe((/**
         * @param {?} oLayers
         * @return {?}
         */
        function (oLayers) {
            _this.store.state.updateMany(layers, { added: true });
            _this.map.addLayers(oLayers);
        }));
    };
    /**
     * Remove multiple layers from map
     * @param layers Catalog layers
     */
    /**
     * Remove multiple layers from map
     * @private
     * @param {?} layers Catalog layers
     * @return {?}
     */
    CatalogBrowserComponent.prototype.removeLayersFromMap = /**
     * Remove multiple layers from map
     * @private
     * @param {?} layers Catalog layers
     * @return {?}
     */
    function (layers) {
        var _this = this;
        layers.forEach((/**
         * @param {?} layer
         * @return {?}
         */
        function (layer) {
            _this.store.state.update(layer, { added: false });
            if (layer.options.baseLayer === true) {
                /** @type {?} */
                var oLayer = _this.map.getLayerById(layer.options.id);
                if (oLayer !== undefined) {
                    _this.map.removeLayer(oLayer);
                }
            }
            else {
                /** @type {?} */
                var oLayer = _this.map.getLayerById(layer.id);
                if (oLayer !== undefined) {
                    _this.map.removeLayer(oLayer);
                }
            }
        }));
    };
    /**
     * Sort the layers by title. asc or desc.
     * @internal
     */
    /**
     * Sort the layers by title. asc or desc.
     * \@internal
     * @private
     * @param {?} items
     * @param {?} direction
     * @return {?}
     */
    CatalogBrowserComponent.prototype.sortCatalogItemsByTitle = /**
     * Sort the layers by title. asc or desc.
     * \@internal
     * @private
     * @param {?} items
     * @param {?} direction
     * @return {?}
     */
    function (items, direction) {
        /** @type {?} */
        var returnItem = items.sort((/**
         * @param {?} a
         * @param {?} b
         * @return {?}
         */
        function (a, b) {
            /** @type {?} */
            var titleA = a.title.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
            /** @type {?} */
            var titleB = b.title.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
            if (titleA < titleB) {
                return -1;
            }
            if (titleA > titleB) {
                return 1;
            }
            return 0;
        }));
        switch (direction) {
            case 'asc':
                return returnItem;
            case 'desc':
                return returnItem.reverse();
            default:
                return items;
        }
    };
    /**
     * Add all the layers of a group to map
     * @param group Catalog group
     */
    /**
     * Add all the layers of a group to map
     * @private
     * @param {?} group Catalog group
     * @return {?}
     */
    CatalogBrowserComponent.prototype.addGroupToMap = /**
     * Add all the layers of a group to map
     * @private
     * @param {?} group Catalog group
     * @return {?}
     */
    function (group) {
        var _this = this;
        /** @type {?} */
        var layers = group.items.filter((/**
         * @param {?} item
         * @return {?}
         */
        function (item) {
            /** @type {?} */
            var added = _this.store.state.get(item).added || false;
            return _this.isLayer(item) && added === false;
        }));
        if (this.catalog && this.catalog.sortDirection !== undefined) {
            layers = this.sortCatalogItemsByTitle(layers, this.catalog.sortDirection);
        }
        this.addLayersToMap((/** @type {?} */ (layers.reverse())));
    };
    /**
     * Remove all the layers of a group from map
     * @param group Catalog group
     */
    /**
     * Remove all the layers of a group from map
     * @private
     * @param {?} group Catalog group
     * @return {?}
     */
    CatalogBrowserComponent.prototype.removeGroupFromMap = /**
     * Remove all the layers of a group from map
     * @private
     * @param {?} group Catalog group
     * @return {?}
     */
    function (group) {
        var _this = this;
        /** @type {?} */
        var layers = group.items.filter((/**
         * @param {?} item
         * @return {?}
         */
        function (item) {
            /** @type {?} */
            var added = _this.store.state.get(item).added || false;
            return _this.isLayer(item) && added === true;
        }));
        this.removeLayersFromMap((/** @type {?} */ (layers)));
    };
    CatalogBrowserComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igo-catalog-browser',
                    template: "<igo-list [navigation]=\"false\" [selection]=\"false\">\r\n  <ng-template ngFor let-item [ngForOf]=\"store.view.all$() | async\">\r\n    <ng-container *ngIf=\"isGroup(item)\">\r\n      <igo-catalog-browser-group\r\n        [catalog]=\"catalog\"\r\n        [group]=\"item\"\r\n        [state]=\"store.state\"\r\n        [resolution]=\"resolution$ | async\"\r\n        [catalogAllowLegend]=\"catalogAllowLegend\"\r\n        [toggleCollapsed]=\"toggleCollapsedGroup\"\r\n        (addedChange)=\"onGroupAddedChange($event)\"\r\n        (layerAddedChange)=\"onLayerAddedChange($event)\">\r\n      </igo-catalog-browser-group>\r\n    </ng-container>\r\n\r\n    <ng-container *ngIf=\"isLayer(item)\">\r\n      <igo-catalog-browser-layer\r\n        igoListItem\r\n        [layer]=\"item\"\r\n        [resolution]=\"resolution$ | async\"\r\n        [catalogAllowLegend]=\"catalogAllowLegend\"\r\n        [added]=\"store.state.get(item).added\"\r\n        (addedChange)=\"onLayerAddedChange($event)\">\r\n      </igo-catalog-browser-layer>\r\n    </ng-container>\r\n  </ng-template>\r\n</igo-list>\r\n",
                    changeDetection: ChangeDetectionStrategy.OnPush
                }] }
    ];
    /** @nocollapse */
    CatalogBrowserComponent.ctorParameters = function () { return [
        { type: LayerService },
        { type: ChangeDetectorRef }
    ]; };
    CatalogBrowserComponent.propDecorators = {
        catalogAllowLegend: [{ type: Input }],
        catalog: [{ type: Input }],
        store: [{ type: Input }],
        map: [{ type: Input }],
        toggleCollapsedGroup: [{ type: Input }]
    };
    return CatalogBrowserComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Catalog browser layer item
 */
var CatalogBrowserLayerComponent = /** @class */ (function () {
    function CatalogBrowserLayerComponent(layerService) {
        this.layerService = layerService;
        this.inRange$ = new BehaviorSubject(true);
        this.isPreview$ = new BehaviorSubject(false);
        this.layerLegendShown$ = new BehaviorSubject(false);
        this.igoLayer$ = new BehaviorSubject(undefined);
        this.catalogAllowLegend = false;
        /**
         * Whether the layer is already added to the map
         */
        this.added = false;
        /**
         * Event emitted when the add/remove button is clicked
         */
        this.addedChange = new EventEmitter();
        this.addedLayerIsPreview = new EventEmitter();
    }
    Object.defineProperty(CatalogBrowserLayerComponent.prototype, "title", {
        /**
         * @internal
         */
        get: /**
         * \@internal
         * @return {?}
         */
        function () {
            return getEntityTitle(this.layer);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CatalogBrowserLayerComponent.prototype, "icon", {
        /**
         * @internal
         */
        get: /**
         * \@internal
         * @return {?}
         */
        function () {
            return getEntityIcon(this.layer) || 'layers';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    CatalogBrowserLayerComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.isInResolutionsRange();
        this.isPreview$.subscribe((/**
         * @param {?} value
         * @return {?}
         */
        function (value) { return _this.addedLayerIsPreview.emit(value); }));
    };
    /**
     * On mouse event, mouseenter /mouseleave
     * @internal
     */
    /**
     * On mouse event, mouseenter /mouseleave
     * \@internal
     * @param {?} event
     * @return {?}
     */
    CatalogBrowserLayerComponent.prototype.onMouseEvent = /**
     * On mouse event, mouseenter /mouseleave
     * \@internal
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.onToggleClick(event);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    CatalogBrowserLayerComponent.prototype.askForLegend = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        this.layerLegendShown$.next(!this.layerLegendShown$.value);
        this.layerService.createAsyncLayer(this.layer.options).pipe(first())
            .subscribe((/**
         * @param {?} layer
         * @return {?}
         */
        function (layer) { return _this.igoLayer$.next(layer); }));
    };
    /**
     * On toggle button click, emit the added change event
     * @internal
     */
    /**
     * On toggle button click, emit the added change event
     * \@internal
     * @param {?} event
     * @return {?}
     */
    CatalogBrowserLayerComponent.prototype.onToggleClick = /**
     * On toggle button click, emit the added change event
     * \@internal
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        if (typeof this.lastTimeoutRequest !== 'undefined') {
            clearTimeout(this.lastTimeoutRequest);
        }
        switch (event.type) {
            case 'click':
                if (!this.isPreview$.value) {
                    if (this.added) {
                        this.remove();
                    }
                    else {
                        this.add();
                    }
                }
                this.isPreview$.next(false);
                break;
            case 'mouseenter':
                if (!this.isPreview$.value && !this.added) {
                    this.lastTimeoutRequest = setTimeout((/**
                     * @return {?}
                     */
                    function () {
                        _this.add();
                        _this.isPreview$.next(true);
                    }), 500);
                }
                break;
            case 'mouseleave':
                if (this.isPreview$.value) {
                    this.remove();
                    this.isPreview$.next(false);
                }
                break;
            default:
                break;
        }
    };
    /**
     * Emit added change event with added = true
     */
    /**
     * Emit added change event with added = true
     * @private
     * @return {?}
     */
    CatalogBrowserLayerComponent.prototype.add = /**
     * Emit added change event with added = true
     * @private
     * @return {?}
     */
    function () {
        if (!this.added) {
            this.added = true;
            this.addedChange.emit({ added: true, layer: this.layer });
        }
    };
    /**
     * Emit added change event with added = false
     */
    /**
     * Emit added change event with added = false
     * @private
     * @return {?}
     */
    CatalogBrowserLayerComponent.prototype.remove = /**
     * Emit added change event with added = false
     * @private
     * @return {?}
     */
    function () {
        if (this.added) {
            this.added = false;
            this.addedChange.emit({ added: false, layer: this.layer });
        }
    };
    /**
     * @return {?}
     */
    CatalogBrowserLayerComponent.prototype.haveGroup = /**
     * @return {?}
     */
    function () {
        return !(!this.layer.address || this.layer.address.split('.').length === 1);
    };
    /**
     * @return {?}
     */
    CatalogBrowserLayerComponent.prototype.isInResolutionsRange = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var minResolution = this.layer.options.minResolution || 0;
        /** @type {?} */
        var maxResolution = this.layer.options.maxResolution || Infinity;
        this.inRange$.next(this.resolution >= minResolution && this.resolution <= maxResolution);
        return this.inRange$.value;
    };
    /**
     * @return {?}
     */
    CatalogBrowserLayerComponent.prototype.computeTooltip = /**
     * @return {?}
     */
    function () {
        if (this.added) {
            return this.isPreview$.value
                ? 'igo.geo.catalog.layer.addToMap'
                : this.inRange$.value
                    ? 'igo.geo.catalog.layer.removeFromMap'
                    : 'igo.geo.catalog.layer.removeFromMapOutRange';
        }
        else {
            return this.inRange$.value
                ? 'igo.geo.catalog.layer.addToMap'
                : 'igo.geo.catalog.layer.addToMapOutRange';
        }
    };
    CatalogBrowserLayerComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igo-catalog-browser-layer',
                    template: "<mat-list-item>\r\n  <mat-icon *ngIf=\"haveGroup()\" mat-list-avatar svgIcon=\"blank\"></mat-icon>\r\n  <h4 mat-line matTooltipShowDelay=\"500\" [ngClass]=\"(catalogAllowLegend)?'igo-cataloglayer-title':''\" (click)=\"askForLegend($event)\" [matTooltip]=\"title\">{{title}}</h4>\r\n\r\n  <igo-metadata-button [layer]=\"layer\"></igo-metadata-button>\r\n\r\n  <button\r\n    (mouseenter)=\"onMouseEvent($event)\" (mouseleave)=\"onMouseEvent($event)\"\r\n    mat-icon-button\r\n    tooltip-position=\"below\"\r\n    matTooltipShowDelay=\"500\"\r\n    [matTooltip]=\"computeTooltip() | translate\"\r\n    [color]=\"(isPreview$ | async) ? '' : added ? 'warn' : ''\"\r\n    (click)=\"onToggleClick($event)\">\r\n    <mat-icon\r\n       matBadge\r\n       igoMatBadgeIcon=\"eye-off\"\r\n       [matBadgeHidden]=\"isInResolutionsRange()\"\r\n       matBadgeColor=\"accent\"\r\n       matBadgeSize=\"small\"\r\n       matBadgePosition=\"after\"\r\n       [svgIcon]=\"(isPreview$ | async) ? 'plus' : added ? 'delete' : 'plus'\">\r\n    </mat-icon>\r\n  </button>\r\n\r\n</mat-list-item>\r\n\r\n<div #legend class=\"igo-cataloglayer-legend-container\">\r\n  <igo-layer-legend\r\n    *ngIf=\"(layerLegendShown$ | async) && (igoLayer$ | async) && catalogAllowLegend\"\r\n    [layer]=\"igoLayer$ | async\">\r\n  </igo-layer-legend>\r\n</div>\r\n",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: [".mat-badge-small .mat-badge-content{color:rgba(0,0,0,.38)}.igo-cataloglayer-title{cursor:pointer}.igo-cataloglayer-legend-container{padding-left:18px;width:calc(100% - 18px);margin-left:40px}"]
                }] }
    ];
    /** @nocollapse */
    CatalogBrowserLayerComponent.ctorParameters = function () { return [
        { type: LayerService }
    ]; };
    CatalogBrowserLayerComponent.propDecorators = {
        resolution: [{ type: Input }],
        catalogAllowLegend: [{ type: Input }],
        layer: [{ type: Input }],
        added: [{ type: Input }],
        addedChange: [{ type: Output }],
        addedLayerIsPreview: [{ type: Output }]
    };
    return CatalogBrowserLayerComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Catalog browser group item
 */
var CatalogBrowserGroupComponent = /** @class */ (function () {
    function CatalogBrowserGroupComponent() {
        /**
         * Group's items store
         * \@internal
         */
        this.store = new EntityStore([]);
        /**
         * Whether all the layers of the group are added
         * \@internal
         */
        this.added$ = new BehaviorSubject(false);
        this.preview$ = new BehaviorSubject(false);
        /**
         * Whether the toggle button is disabled
         * \@internal
         */
        this.disabled$ = new BehaviorSubject(false);
        /**
         * Whether the group is collapsed
         */
        this.collapsed = true;
        this.catalogAllowLegend = false;
        /**
         * Whether the group can be toggled when it's collapsed
         */
        this.toggleCollapsed = true;
        /**
         * Event emitted when the add/remove button of the group is clicked
         */
        this.addedChange = new EventEmitter();
        /**
         * Event emitted when the add/remove button of a layer is clicked
         */
        this.layerAddedChange = new EventEmitter();
    }
    Object.defineProperty(CatalogBrowserGroupComponent.prototype, "title", {
        /**
         * @internal
         */
        get: /**
         * \@internal
         * @return {?}
         */
        function () {
            return this.group.title;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal
     */
    /**
     * \@internal
     * @return {?}
     */
    CatalogBrowserGroupComponent.prototype.ngOnInit = /**
     * \@internal
     * @return {?}
     */
    function () {
        this.store.load(this.group.items);
        this.evaluateAdded();
        this.evaluateDisabled(this.collapsed);
        if (this.catalog && this.catalog.sortDirection !== undefined) {
            this.store.view.sort({
                direction: this.catalog.sortDirection,
                valueAccessor: (/**
                 * @param {?} item
                 * @return {?}
                 */
                function (item) { return item.title; })
            });
        }
    };
    /**
     * @return {?}
     */
    CatalogBrowserGroupComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.store.destroy();
    };
    /**
     * @internal
     */
    /**
     * \@internal
     * @param {?} item
     * @return {?}
     */
    CatalogBrowserGroupComponent.prototype.isGroup = /**
     * \@internal
     * @param {?} item
     * @return {?}
     */
    function (item) {
        return item.type === CatalogItemType.Group;
    };
    /**
     * @internal
     */
    /**
     * \@internal
     * @param {?} item
     * @return {?}
     */
    CatalogBrowserGroupComponent.prototype.isLayer = /**
     * \@internal
     * @param {?} item
     * @return {?}
     */
    function (item) {
        return item.type === CatalogItemType.Layer;
    };
    /**
     * On toggle button click, emit the added change event
     * @internal
     */
    /**
     * On toggle button click, emit the added change event
     * \@internal
     * @return {?}
     */
    CatalogBrowserGroupComponent.prototype.onToggleClick = /**
     * On toggle button click, emit the added change event
     * \@internal
     * @return {?}
     */
    function () {
        this.added$.value ? this.remove() : this.add();
    };
    /**
     * On toggle button click, emit the added change event
     * @internal
     */
    /**
     * On toggle button click, emit the added change event
     * \@internal
     * @param {?} collapsed
     * @return {?}
     */
    CatalogBrowserGroupComponent.prototype.onToggleCollapsed = /**
     * On toggle button click, emit the added change event
     * \@internal
     * @param {?} collapsed
     * @return {?}
     */
    function (collapsed) {
        this.evaluateDisabled(collapsed);
    };
    /**
     * When a layer is added or removed, evaluate if all the layers of the group
     * are now added or removed. If so, consider that the group itself is added
     * or removed.
     * @internal
     * @param event Layer added change event
     */
    /**
     * When a layer is added or removed, evaluate if all the layers of the group
     * are now added or removed. If so, consider that the group itself is added
     * or removed.
     * \@internal
     * @param {?} event Layer added change event
     * @return {?}
     */
    CatalogBrowserGroupComponent.prototype.onLayerAddedChange = /**
     * When a layer is added or removed, evaluate if all the layers of the group
     * are now added or removed. If so, consider that the group itself is added
     * or removed.
     * \@internal
     * @param {?} event Layer added change event
     * @return {?}
     */
    function (event) {
        this.layerAddedChange.emit(event);
        this.tryToggleGroup(event);
    };
    /**
     * Emit added change event with added = true
     */
    /**
     * Emit added change event with added = true
     * @private
     * @return {?}
     */
    CatalogBrowserGroupComponent.prototype.add = /**
     * Emit added change event with added = true
     * @private
     * @return {?}
     */
    function () {
        this.added$.next(true);
        this.addedChange.emit({
            added: true,
            group: this.group
        });
    };
    /**
     * Emit added change event with added = true
     */
    /**
     * Emit added change event with added = true
     * @private
     * @return {?}
     */
    CatalogBrowserGroupComponent.prototype.remove = /**
     * Emit added change event with added = true
     * @private
     * @return {?}
     */
    function () {
        this.added$.next(false);
        this.addedChange.emit({
            added: false,
            group: this.group
        });
    };
    /**
     * @param {?} event
     * @return {?}
     */
    CatalogBrowserGroupComponent.prototype.onLayerPreview = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.preview$.next(event);
    };
    /**
     * If all the layers of the group added or removed, add or remove the group itself.
     * @param event The last layer added change event to occur
     */
    /**
     * If all the layers of the group added or removed, add or remove the group itself.
     * @private
     * @param {?} event The last layer added change event to occur
     * @return {?}
     */
    CatalogBrowserGroupComponent.prototype.tryToggleGroup = /**
     * If all the layers of the group added or removed, add or remove the group itself.
     * @private
     * @param {?} event The last layer added change event to occur
     * @return {?}
     */
    function (event) {
        var _this = this;
        /** @type {?} */
        var added = event.added;
        /** @type {?} */
        var layer = event.layer;
        /** @type {?} */
        var layersAdded = this.store.view
            .all()
            .filter((/**
         * @param {?} item
         * @return {?}
         */
        function (item) { return item.id !== layer.id; }))
            .map((/**
         * @param {?} item
         * @return {?}
         */
        function (item) { return _this.state.get(item).added || false; }));
        if (layersAdded.every((/**
         * @param {?} value
         * @return {?}
         */
        function (value) { return value === added; }))) {
            added ? this.add() : this.remove();
        }
        else if (this.added$.value === true) {
            this.added$.next(false);
        }
    };
    /**
     * @private
     * @return {?}
     */
    CatalogBrowserGroupComponent.prototype.evaluateAdded = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var added = this.store.all().every((/**
         * @param {?} item
         * @return {?}
         */
        function (item) {
            return (_this.state.get(item).added || false) === true;
        }));
        this.added$.next(added);
    };
    /**
     * @private
     * @param {?} collapsed
     * @return {?}
     */
    CatalogBrowserGroupComponent.prototype.evaluateDisabled = /**
     * @private
     * @param {?} collapsed
     * @return {?}
     */
    function (collapsed) {
        /** @type {?} */
        var disabled = false;
        if (this.toggleCollapsed === false) {
            disabled = collapsed;
        }
        this.disabled$.next(disabled);
    };
    /**
     * @return {?}
     */
    CatalogBrowserGroupComponent.prototype.onTitleClick = /**
     * @return {?}
     */
    function () {
        this.collapsed = !this.collapsed;
    };
    CatalogBrowserGroupComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igo-catalog-browser-group',
                    template: "<mat-list-item>\r\n  <mat-icon\r\n    mat-list-avatar\r\n    svgIcon=\"chevron-up\"\r\n    igoCollapse\r\n    class=\"igo-chevron\"\r\n    [target]=\"items\"\r\n    [collapsed]=\"collapsed\"\r\n    (toggle)=\"onToggleCollapsed($event)\">\r\n  </mat-icon>\r\n\r\n  <h4 class=\"igo-catalog-group-title\" id=\"catalog-group-title\" mat-line matTooltipShowDelay=\"500\" [matTooltip]=\"title\" (click)=\"onTitleClick()\">{{title}}</h4>\r\n  <ng-container *ngIf=\"(added$ | async) && !(preview$ | async); else notadded\">\r\n    <button\r\n      mat-icon-button\r\n      tooltip-position=\"below\"\r\n      matTooltipShowDelay=\"500\"\r\n      [matTooltip]=\"'igo.geo.catalog.group.removeFromMap' | translate\"\r\n      color=\"warn\"\r\n      [disabled]=\"disabled$ | async\"\r\n      (click)=\"onToggleClick()\">\r\n      <mat-icon svgIcon=\"delete\"></mat-icon>\r\n    </button>\r\n  </ng-container>\r\n\r\n  <ng-template #notadded>\r\n    <button\r\n      mat-icon-button\r\n      tooltip-position=\"below\"\r\n      matTooltipShowDelay=\"500\"\r\n      [matTooltip]=\"'igo.geo.catalog.group.addToMap' | translate\"\r\n      [disabled]=\"disabled$ | async\"\r\n      (click)=\"onToggleClick()\">\r\n      <mat-icon svgIcon=\"plus\"></mat-icon>\r\n    </button>\r\n  </ng-template>\r\n</mat-list-item>\r\n\r\n<div #items>\r\n  <ng-template ngFor let-item [ngForOf]=\"store.view.all$() | async\">\r\n    <ng-container *ngIf=\"isGroup(item)\">\r\n      <!-- todo: add display ans manage CatalogItemGroup -->\r\n    </ng-container>\r\n    <ng-container *ngIf=\"isLayer(item)\">\r\n      <igo-catalog-browser-layer\r\n        igoListItem\r\n        [layer]=\"item\"\r\n        [resolution]=\"resolution\"\r\n        [catalogAllowLegend]=\"catalogAllowLegend\"\r\n        [added]=\"state.get(item).added\"\r\n        (addedLayerIsPreview)=\"onLayerPreview($event)\"\r\n        (addedChange)=\"onLayerAddedChange($event)\">\r\n      </igo-catalog-browser-layer>\r\n    </ng-container>\r\n  </ng-template>\r\n</div>\r\n",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: [".igo-catalog-group-title{cursor:pointer;opacity:.9}#catalog-group-title{font-weight:700}"]
                }] }
    ];
    CatalogBrowserGroupComponent.propDecorators = {
        catalog: [{ type: Input }],
        group: [{ type: Input }],
        collapsed: [{ type: Input }],
        resolution: [{ type: Input }],
        catalogAllowLegend: [{ type: Input }],
        toggleCollapsed: [{ type: Input }],
        state: [{ type: Input }],
        addedChange: [{ type: Output }],
        layerAddedChange: [{ type: Output }]
    };
    return CatalogBrowserGroupComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var LayerLegendListBindingDirective = /** @class */ (function () {
    function LayerLegendListBindingDirective(component, mapService) {
        this.mapService = mapService;
        this.component = component;
    }
    /**
     * @return {?}
     */
    LayerLegendListBindingDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // Override input layers
        this.component.layers = [];
        this.layersOrResolutionChange$$ = combineLatest([
            this.mapService.getMap().layers$,
            this.mapService.getMap().viewController.resolution$
        ]).pipe(debounceTime(10)).subscribe((/**
         * @param {?} bunch
         * @return {?}
         */
        function (bunch) {
            /** @type {?} */
            var shownLayers = bunch[0].filter((/**
             * @param {?} layer
             * @return {?}
             */
            function (layer) {
                return layer.showInLayerList === true;
            }));
            _this.component.layers = shownLayers;
            _this.layersVisibility$$ = combineLatest(shownLayers
                .map((/**
             * @param {?} layer
             * @return {?}
             */
            function (layer) { return layer.visible$; })))
                .subscribe((/**
             * @param {?} r
             * @return {?}
             */
            function (r) {
                _this.component.change$.next();
            }));
        }));
    };
    /**
     * @return {?}
     */
    LayerLegendListBindingDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.layersOrResolutionChange$$.unsubscribe();
        if (this.layersVisibility$$ !== undefined) {
            this.layersVisibility$$.unsubscribe();
            this.layersVisibility$$ = undefined;
        }
    };
    LayerLegendListBindingDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igoLayerLegendListBinding]'
                },] }
    ];
    /** @nocollapse */
    LayerLegendListBindingDirective.ctorParameters = function () { return [
        { type: LayerLegendListComponent, decorators: [{ type: Self }] },
        { type: MapService }
    ]; };
    return LayerLegendListBindingDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgoLayerModule = /** @class */ (function () {
    function IgoLayerModule() {
    }
    /**
     * @return {?}
     */
    IgoLayerModule.forRoot = /**
     * @return {?}
     */
    function () {
        return {
            ngModule: IgoLayerModule,
            providers: [LayerService, StyleService, LayerListToolService]
        };
    };
    IgoLayerModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        MatInputModule,
                        MatFormFieldModule,
                        CommonModule,
                        FormsModule,
                        MatDividerModule,
                        MatMenuModule,
                        MatIconModule,
                        MatButtonModule,
                        MatSlideToggleModule,
                        MatSelectModule,
                        MatTooltipModule,
                        MatListModule,
                        MatSliderModule,
                        MatBadgeModule,
                        MatCheckboxModule,
                        IgoLanguageModule,
                        IgoListModule,
                        IgoCollapsibleModule,
                        IgoImageModule,
                        IgoPanelModule
                    ],
                    exports: [
                        LayerItemComponent,
                        LayerLegendItemComponent,
                        LayerLegendComponent,
                        LayerListComponent,
                        LayerListToolComponent,
                        LayerLegendListComponent,
                        LayerListBindingDirective,
                        LayerLegendListBindingDirective,
                        TrackFeatureButtonComponent
                    ],
                    declarations: [
                        LayerItemComponent,
                        LayerLegendItemComponent,
                        LayerLegendComponent,
                        LayerListComponent,
                        LayerListToolComponent,
                        LayerLegendListComponent,
                        LayerListBindingDirective,
                        LayerLegendListBindingDirective,
                        TrackFeatureButtonComponent
                    ]
                },] }
    ];
    return IgoLayerModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @ignore
 */
var IgoCatalogBrowserModule = /** @class */ (function () {
    function IgoCatalogBrowserModule() {
    }
    IgoCatalogBrowserModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        MatBadgeModule,
                        MatButtonModule,
                        MatIconModule,
                        MatListModule,
                        MatTooltipModule,
                        IgoMatBadgeIconModule,
                        IgoLanguageModule,
                        IgoListModule,
                        IgoCollapsibleModule,
                        IgoMetadataModule,
                        IgoLayerModule
                    ],
                    exports: [
                        CatalogBrowserComponent
                    ],
                    declarations: [
                        CatalogBrowserComponent,
                        CatalogBrowserGroupComponent,
                        CatalogBrowserLayerComponent
                    ]
                },] }
    ];
    return IgoCatalogBrowserModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Component to browse a list of available catalogs
 */
var CatalogLibaryComponent = /** @class */ (function () {
    function CatalogLibaryComponent() {
        /**
         * Event emitted a catalog is selected or unselected
         */
        this.catalogSelectChange = new EventEmitter();
    }
    /**
     * @internal
     */
    /**
     * \@internal
     * @return {?}
     */
    CatalogLibaryComponent.prototype.ngOnInit = /**
     * \@internal
     * @return {?}
     */
    function () {
        this.store.state.clear();
    };
    /**
     * When a catalog is selected, update it's state in the store
     * and emit the catalog select change event
     * @internal
     */
    /**
     * When a catalog is selected, update it's state in the store
     * and emit the catalog select change event
     * \@internal
     * @param {?} catalog
     * @return {?}
     */
    CatalogLibaryComponent.prototype.onCatalogSelect = /**
     * When a catalog is selected, update it's state in the store
     * and emit the catalog select change event
     * \@internal
     * @param {?} catalog
     * @return {?}
     */
    function (catalog) {
        this.store.state.update(catalog, {
            selected: true,
            focused: true
        }, true);
        this.catalogSelectChange.emit({ selected: true, catalog: catalog });
    };
    CatalogLibaryComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igo-catalog-library',
                    template: "<igo-list [navigation]=\"false\">\r\n  <ng-template ngFor let-catalog [ngForOf]=\"store.view.all$() | async\">\r\n    <igo-catalog-library-item\r\n      igoListItem\r\n      color=\"accent\"\r\n      [map]=\"map\"\r\n      [catalog]=\"catalog\"\r\n      (select)=\"onCatalogSelect(catalog)\">\r\n    </igo-catalog-library-item>\r\n  </ng-template>\r\n</igo-list>\r\n",
                    changeDetection: ChangeDetectionStrategy.OnPush
                }] }
    ];
    CatalogLibaryComponent.propDecorators = {
        store: [{ type: Input }],
        map: [{ type: Input }],
        catalogSelectChange: [{ type: Output }]
    };
    return CatalogLibaryComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Catalog library item
 */
var CatalogLibaryItemComponent = /** @class */ (function () {
    function CatalogLibaryItemComponent() {
    }
    Object.defineProperty(CatalogLibaryItemComponent.prototype, "title", {
        /**
         * @internal
         */
        get: /**
         * \@internal
         * @return {?}
         */
        function () { return getEntityTitle(this.catalog); },
        enumerable: true,
        configurable: true
    });
    CatalogLibaryItemComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igo-catalog-library-item',
                    template: "<mat-list-item>\r\n  <h4 mat-line>{{title}}</h4>\r\n</mat-list-item>\r\n",
                    changeDetection: ChangeDetectionStrategy.OnPush
                }] }
    ];
    CatalogLibaryItemComponent.propDecorators = {
        catalog: [{ type: Input }],
        map: [{ type: Input }]
    };
    return CatalogLibaryItemComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @ignore
 */
var IgoCatalogLibraryModule = /** @class */ (function () {
    function IgoCatalogLibraryModule() {
    }
    IgoCatalogLibraryModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        MatIconModule,
                        MatListModule,
                        MatTooltipModule,
                        IgoListModule
                    ],
                    exports: [
                        CatalogLibaryComponent
                    ],
                    declarations: [
                        CatalogLibaryComponent,
                        CatalogLibaryItemComponent
                    ]
                },] }
    ];
    return IgoCatalogLibraryModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgoCatalogModule = /** @class */ (function () {
    function IgoCatalogModule() {
    }
    IgoCatalogModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        MatBadgeModule,
                        MatIconModule,
                        MatListModule,
                        MatTooltipModule,
                        IgoMatBadgeIconModule,
                        IgoListModule,
                        IgoCollapsibleModule
                    ],
                    exports: [
                        IgoCatalogBrowserModule,
                        IgoCatalogLibraryModule
                    ],
                    declarations: []
                },] }
    ];
    return IgoCatalogModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgoDataSourceModule = /** @class */ (function () {
    function IgoDataSourceModule() {
    }
    /**
     * @return {?}
     */
    IgoDataSourceModule.forRoot = /**
     * @return {?}
     */
    function () {
        return {
            ngModule: IgoDataSourceModule,
            providers: []
        };
    };
    IgoDataSourceModule.decorators = [
        { type: NgModule, args: [{
                    imports: [],
                    exports: [],
                    declarations: []
                },] }
    ];
    return IgoDataSourceModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FilterableDataSourcePipe = /** @class */ (function () {
    function FilterableDataSourcePipe() {
    }
    /**
     * @param {?} value
     * @param {?} arg
     * @return {?}
     */
    FilterableDataSourcePipe.prototype.transform = /**
     * @param {?} value
     * @param {?} arg
     * @return {?}
     */
    function (value, arg) {
        var _this = this;
        /** @type {?} */
        var layers;
        if (arg === 'time') {
            layers = value.filter((/**
             * @param {?} layer
             * @return {?}
             */
            function (layer) {
                /** @type {?} */
                var datasource = (/** @type {?} */ (layer.dataSource));
                return (_this.isTimeFilterable(datasource) &&
                    datasource.options.timeFilter !== undefined &&
                    Object.keys(datasource.options.timeFilter).length);
            }));
        }
        if (arg === 'ogc') {
            layers = value.filter((/**
             * @param {?} layer
             * @return {?}
             */
            function (layer) {
                /** @type {?} */
                var datasource = (/** @type {?} */ (layer.dataSource));
                return _this.isOgcFilterable(datasource);
            }));
        }
        return layers;
    };
    /**
     * @private
     * @param {?} dataSource
     * @return {?}
     */
    FilterableDataSourcePipe.prototype.isTimeFilterable = /**
     * @private
     * @param {?} dataSource
     * @return {?}
     */
    function (dataSource) {
        if (dataSource.options.type !== 'wms') {
            return false;
        }
        return dataSource.options.timeFilterable;
    };
    /**
     * @private
     * @param {?} dataSource
     * @return {?}
     */
    FilterableDataSourcePipe.prototype.isOgcFilterable = /**
     * @private
     * @param {?} dataSource
     * @return {?}
     */
    function (dataSource) {
        /** @type {?} */
        var isOgcFilterable = false;
        if (dataSource.options.ogcFilters &&
            dataSource.options.ogcFilters.enabled &&
            dataSource.options.ogcFilters.editable) {
            isOgcFilterable = true;
        }
        if (dataSource.options.ogcFilters &&
            dataSource.options.ogcFilters.enabled &&
            dataSource.options.ogcFilters.pushButtons) {
            isOgcFilterable = true;
        }
        return isOgcFilterable;
    };
    FilterableDataSourcePipe.decorators = [
        { type: Pipe, args: [{
                    name: 'filterableDataSource'
                },] }
    ];
    return FilterableDataSourcePipe;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var TimeFilterService = /** @class */ (function () {
    function TimeFilterService() {
    }
    /**
     * @param {?} datasource
     * @param {?} date
     * @return {?}
     */
    TimeFilterService.prototype.filterByDate = /**
     * @param {?} datasource
     * @param {?} date
     * @return {?}
     */
    function (datasource, date) {
        /** @type {?} */
        var time;
        /** @type {?} */
        var newdateform;
        /** @type {?} */
        var newdateformStart;
        /** @type {?} */
        var newdateformEnd;
        if (Array.isArray(date)) {
            /** @type {?} */
            var dates = [];
            if (date[0]) {
                newdateformStart = this.reformatDateTime(date[0]);
                dates.push(date[0]);
            }
            if (date[1]) {
                newdateformEnd = this.reformatDateTime(date[1]);
                dates.push(date[1]);
            }
            if (dates.length === 2 && newdateformStart !== newdateformEnd) {
                if (datasource instanceof TileArcGISRestDataSource) {
                    time = newdateformStart + ',' + newdateformEnd;
                }
                else {
                    time = newdateformStart + '/' + newdateformEnd;
                }
            }
            if (newdateformStart === newdateformEnd) {
                time = newdateformStart;
            }
        }
        else if (date) {
            newdateform = this.reformatDateTime(date);
            time = newdateform;
        }
        /** @type {?} */
        var params = { TIME: time };
        datasource.ol.updateParams(params);
    };
    /**
     * @param {?} datasource
     * @param {?} year
     * @return {?}
     */
    TimeFilterService.prototype.filterByYear = /**
     * @param {?} datasource
     * @param {?} year
     * @return {?}
     */
    function (datasource, year) {
        /** @type {?} */
        var time;
        /** @type {?} */
        var newdateformStart;
        /** @type {?} */
        var newdateformEnd;
        if (Array.isArray(year)) {
            /** @type {?} */
            var years = [];
            if (year[0]) {
                newdateformStart = year[0];
                years.push(year[0]);
            }
            if (year[1]) {
                newdateformEnd = year[1];
                years.push(year[1]);
            }
            if (years.length === 2 && newdateformStart !== newdateformEnd) {
                if (datasource instanceof TileArcGISRestDataSource) {
                    time = newdateformStart + ',' + newdateformEnd;
                }
                else {
                    time = newdateformStart + '/' + newdateformEnd;
                }
            }
            if (newdateformStart === newdateformEnd) {
                time = newdateformStart;
            }
        }
        else { // to reset filter.
            time = year;
        }
        /** @type {?} */
        var params = { TIME: time };
        datasource.ol.updateParams(params);
    };
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    TimeFilterService.prototype.reformatDateTime = /**
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        /** @type {?} */
        var year = value.getFullYear();
        /** @type {?} */
        var month = value.getMonth() + 1;
        /** @type {?} */
        var day = value.getUTCDate();
        /** @type {?} */
        var hour = value.getUTCHours();
        /** @type {?} */
        var minute = value.getUTCMinutes();
        if (Number(month) < 10) {
            month = '0' + month;
        }
        if (Number(day) < 10) {
            day = '0' + day;
        }
        if (Number(hour) < 10) {
            hour = '0' + hour;
        }
        if (Number(minute) < 10) {
            minute = '0' + minute;
        }
        return year + '-' + month + '-' + day + 'T' + hour + ':' + minute + ':00Z';
    };
    TimeFilterService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    TimeFilterService.ctorParameters = function () { return []; };
    return TimeFilterService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
var OgcFilterOperatorType = {
    BasicNumericOperator: 'BasicNumericOperator',
    Basic: 'Basic',
    BasicAndSpatial: 'BasicAndSpatial',
    Spatial: 'Spatial',
    All: 'All',
    Time: 'time',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var OGCFilterService = /** @class */ (function () {
    function OGCFilterService() {
    }
    /**
     * @param {?} wmsDatasource
     * @param {?} filterString
     * @return {?}
     */
    OGCFilterService.prototype.filterByOgc = /**
     * @param {?} wmsDatasource
     * @param {?} filterString
     * @return {?}
     */
    function (wmsDatasource, filterString) {
        /** @type {?} */
        var appliedFilter = new OgcFilterWriter().formatProcessedOgcFilter(filterString, wmsDatasource.options.params.LAYERS);
        wmsDatasource.ol.updateParams({ FILTER: appliedFilter });
    };
    /**
     * @param {?} wfsDatasource
     * @return {?}
     */
    OGCFilterService.prototype.setOgcWFSFiltersOptions = /**
     * @param {?} wfsDatasource
     * @return {?}
     */
    function (wfsDatasource) {
        /** @type {?} */
        var options = wfsDatasource.options;
        /** @type {?} */
        var ogcFilterWriter = new OgcFilterWriter();
        if (options.ogcFilters.enabled && options.ogcFilters.filters) {
            options.ogcFilters.filters = ogcFilterWriter.checkIgoFiltersProperties(options.ogcFilters.filters, options.paramsWFS.fieldNameGeometry, new olProjection({ code: options.paramsWFS.srsName }), true);
            if (!options.ogcFilters.interfaceOgcFilters) {
                options.ogcFilters.interfaceOgcFilters = ogcFilterWriter.defineInterfaceFilterSequence(options.ogcFilters.filters, options.paramsWFS.fieldNameGeometry);
            }
        }
    };
    /**
     * @param {?} wmsDatasource
     * @return {?}
     */
    OGCFilterService.prototype.setOgcWMSFiltersOptions = /**
     * @param {?} wmsDatasource
     * @return {?}
     */
    function (wmsDatasource) {
        /** @type {?} */
        var options = wmsDatasource.options;
        /** @type {?} */
        var ogcFilterWriter = new OgcFilterWriter();
        if (options.ogcFilters.enabled && options.ogcFilters.filters) {
            options.ogcFilters.filters = ogcFilterWriter.checkIgoFiltersProperties(options.ogcFilters.filters, options.fieldNameGeometry, undefined, true);
            if (!options.ogcFilters.interfaceOgcFilters) {
                options.ogcFilters.interfaceOgcFilters = ogcFilterWriter.defineInterfaceFilterSequence(
                // With some wms server, this param must be set to make spatials call.
                options.ogcFilters.filters, options.fieldNameGeometry);
            }
            this.filterByOgc((/** @type {?} */ (wmsDatasource)), ogcFilterWriter.buildFilter(options.ogcFilters.filters));
            options.filtered = true;
        }
        else {
            options.ogcFilters.filters = undefined;
            options.ogcFilters.interfaceOgcFilters = [];
            options.filtered = false;
        }
    };
    OGCFilterService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    OGCFilterService.ctorParameters = function () { return []; };
    return OGCFilterService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
var SpatialFilterQueryType = {
    AdmRegion: 'AdmRegion',
    Mun: 'Mun',
    Arrond: 'Arrond',
    CircFed: 'CircFed',
    CircProv: 'CircProv',
    DirReg: 'DirReg',
    MRC: 'MRC',
    RegTour: 'RegTour',
};
/** @enum {string} */
var SpatialFilterType = {
    Predefined: 'Predefined',
    Polygon: 'Polygon',
    Point: 'Point',
};
/** @enum {string} */
var SpatialFilterItemType = {
    Address: 'Address',
    Thematics: 'Thematics',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SpatialFilterService = /** @class */ (function () {
    function SpatialFilterService(http, languageService, configService) {
        this.http = http;
        this.languageService = languageService;
        this.configService = configService;
        this.baseUrl = 'https://geoegl.msp.gouv.qc.ca/apis/terrapi/';
        /*
           * Type association with URL
           */
        this.urlFilterList = {
            AdmRegion: 'regadmin',
            Arrond: 'arrondissements',
            CircFed: 'circ-fed',
            CircProv: 'circ-prov',
            DirReg: 'dir-reg',
            MRC: 'mrc',
            Mun: 'municipalites',
            RegTour: 'tourisme',
            bornes: 'bornes-sumi',
            hydro: 'hydro',
            routes: 'routes'
        };
        this.baseUrl =
            this.configService.getConfig('spatialFilter.url') || this.baseUrl;
    }
    /**
     * @param {?} object
     * @param {?} value
     * @return {?}
     */
    SpatialFilterService.prototype.getKeyByValue = /**
     * @param {?} object
     * @param {?} value
     * @return {?}
     */
    function (object, value) {
        return Object.keys(object).find((/**
         * @param {?} key
         * @return {?}
         */
        function (key) { return object[key] === value; }));
    };
    /*
     * Loading data for spatial filter list component (NO GEOMETRY)
     */
    /*
       * Loading data for spatial filter list component (NO GEOMETRY)
       */
    /**
     * @param {?} type
     * @return {?}
     */
    SpatialFilterService.prototype.loadFilterList = /*
       * Loading data for spatial filter list component (NO GEOMETRY)
       */
    /**
     * @param {?} type
     * @return {?}
     */
    function (type) {
        /** @type {?} */
        var urlPath = (/** @type {?} */ (type));
        if (urlPath) {
            return this.http
                .get(this.baseUrl + this.urlFilterList[urlPath])
                .pipe(map((/**
             * @param {?} featureCollection
             * @return {?}
             */
            function (featureCollection) {
                return featureCollection.features.map((/**
                 * @param {?} f
                 * @return {?}
                 */
                function (f) {
                    f.meta = {
                        id: f.properties.code
                    };
                    return f;
                }));
            })));
        }
    };
    /*
     * Loading item list (STRING)
     */
    /*
       * Loading item list (STRING)
       */
    /**
     * @return {?}
     */
    SpatialFilterService.prototype.loadThematicsList = /*
       * Loading item list (STRING)
       */
    /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var url = 'types';
        /** @type {?} */
        var items = [];
        return this.http.get(this.baseUrl + url).pipe(map((/**
         * @param {?} types
         * @return {?}
         */
        function (types) {
            types.forEach((/**
             * @param {?} type
             * @return {?}
             */
            function (type) {
                if (type.startsWith('lieux')) {
                    /** @type {?} */
                    var item = {
                        name: undefined,
                        source: type
                    };
                    /** @type {?} */
                    var substr = type.substring(6, type.length);
                    /** @type {?} */
                    var name_1 = substr;
                    if (substr.includes('.')) {
                        /** @type {?} */
                        var index = substr.indexOf('.');
                        name_1 = substr.substring(index + 1, substr.length);
                        substr = substr.substring(0, index);
                    }
                    try {
                        item.name = _this.languageService.translate.instant('igo.geo.terrapi.' + name_1);
                    }
                    catch (e) {
                        item.name = name_1.substring(0, 1).toUpperCase() + name_1.substring(1, name_1.length - 1);
                    }
                    try {
                        item.group = _this.languageService.translate.instant('igo.geo.spatialFilter.group.' + substr);
                    }
                    catch (e) {
                        item.group = substr.substring(0, 1).toUpperCase() + substr.substring(1, name_1.length - 1);
                    }
                    items.push(item);
                }
                else {
                    if (_this.getKeyByValue(_this.urlFilterList, type)) {
                        /** @type {?} */
                        var item = {
                            name: undefined,
                            source: type
                        };
                        /** @type {?} */
                        var name_2 = _this.getKeyByValue(_this.urlFilterList, type);
                        try {
                            item.name = _this.languageService.translate.instant('igo.geo.terrapi.' + name_2);
                        }
                        catch (e) {
                            item.name = name_2.substring(0, 1).toUpperCase() + name_2.substring(1, name_2.length - 1);
                        }
                        item.source = type;
                        items.push(item);
                    }
                }
            }));
            return items;
        })));
    };
    /*
     * Loading data for spatial filter item component (Address or Thematics) depends on predefined zone or draw zone (feature)
     */
    /*
       * Loading data for spatial filter item component (Address or Thematics) depends on predefined zone or draw zone (feature)
       */
    /**
     * @param {?} feature
     * @param {?} itemType
     * @param {?=} type
     * @param {?=} thematic
     * @param {?=} buffer
     * @return {?}
     */
    SpatialFilterService.prototype.loadFilterItem = /*
       * Loading data for spatial filter item component (Address or Thematics) depends on predefined zone or draw zone (feature)
       */
    /**
     * @param {?} feature
     * @param {?} itemType
     * @param {?=} type
     * @param {?=} thematic
     * @param {?=} buffer
     * @return {?}
     */
    function (feature, itemType, type, thematic, buffer$$1) {
        var _this = this;
        if (type) {
            // Predefined type
            /** @type {?} */
            var urlType = (/** @type {?} */ (type));
            /** @type {?} */
            var url = this.baseUrl + this.urlFilterList[urlType];
            /** @type {?} */
            var urlItem = '';
            if (itemType === SpatialFilterItemType.Address) {
                urlItem = 'adresses';
                return this.http
                    .get(url + '/' + feature.properties.code + '/' + urlItem, {
                    params: {
                        geometry: 'true',
                        icon: 'true'
                    }
                })
                    .pipe(map((/**
                 * @param {?} featureCollection
                 * @return {?}
                 */
                function (featureCollection) {
                    return featureCollection.features.map((/**
                     * @param {?} f
                     * @return {?}
                     */
                    function (f) {
                        f.meta = {
                            id: f.properties.code,
                            title: _this.languageService.translate.instant('igo.geo.spatialFilter.Address'),
                            icon: ((/** @type {?} */ (f))).icon
                        };
                        return f;
                    }));
                })));
            }
            else {
                // If thematics search
                urlItem = thematic.source;
                return this.http
                    .get(url + '/' + feature.properties.code + '/' + urlItem, {
                    params: {
                        geometry: 'true',
                        icon: 'true'
                    }
                })
                    .pipe(map((/**
                 * @param {?} featureCollection
                 * @return {?}
                 */
                function (featureCollection) {
                    return featureCollection.features.map((/**
                     * @param {?} f
                     * @return {?}
                     */
                    function (f) {
                        f.meta = {
                            id: f.properties.code,
                            title: thematic.name,
                            icon: ((/** @type {?} */ (f))).icon
                        };
                        return f;
                    }));
                })));
            }
        }
        else {
            // Draw type
            /** @type {?} */
            var url = this.baseUrl + 'locate';
            if (itemType === SpatialFilterItemType.Address) {
                /** @type {?} */
                var urlItem = '?type=adresses';
                return this.http
                    .post(url + urlItem, {
                    geometry: 'true',
                    icon: 'true',
                    buffer: buffer$$1,
                    loc: JSON.stringify(feature)
                })
                    .pipe(map((/**
                 * @param {?} featureCollection
                 * @return {?}
                 */
                function (featureCollection) {
                    return featureCollection.features.map((/**
                     * @param {?} f
                     * @return {?}
                     */
                    function (f) {
                        f.meta = {
                            id: f.properties.code,
                            title: _this.languageService.translate.instant('igo.geo.spatialFilter.Address'),
                            icon: ((/** @type {?} */ (f))).icon
                        };
                        return f;
                    }));
                })));
            }
            else {
                // If thematics search
                /** @type {?} */
                var urlItem = '?type=' + thematic.source;
                return this.http
                    .post(url + urlItem, {
                    geometry: 'true',
                    icon: 'true',
                    buffer: buffer$$1,
                    loc: JSON.stringify(feature)
                })
                    .pipe(map((/**
                 * @param {?} featureCollection
                 * @return {?}
                 */
                function (featureCollection) {
                    return featureCollection.features.map((/**
                     * @param {?} f
                     * @return {?}
                     */
                    function (f) {
                        f.meta = {
                            id: f.properties.code,
                            title: thematic.name,
                            icon: ((/** @type {?} */ (f))).icon
                        };
                        return f;
                    }));
                })));
            }
        }
    };
    /*
     * Get one territory by id (WITH GEOMETRY)
     */
    /*
       * Get one territory by id (WITH GEOMETRY)
       */
    /**
     * @param {?} feature
     * @param {?} type
     * @return {?}
     */
    SpatialFilterService.prototype.loadItemById = /*
       * Get one territory by id (WITH GEOMETRY)
       */
    /**
     * @param {?} feature
     * @param {?} type
     * @return {?}
     */
    function (feature, type) {
        /** @type {?} */
        var featureType = this.urlFilterList[type];
        /** @type {?} */
        var featureCode = '/' + feature.properties.code;
        if (featureType && featureCode) {
            return this.http
                .get(this.baseUrl + featureType + featureCode, {
                params: {
                    geometry: 'true'
                }
            })
                .pipe(map((/**
             * @param {?} f
             * @return {?}
             */
            function (f) {
                f.meta = {
                    id: f.properties.code,
                    alias: f.properties.nom,
                    title: f.properties.nom
                };
                return f;
            })));
        }
    };
    SpatialFilterService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    SpatialFilterService.ctorParameters = function () { return [
        { type: HttpClient },
        { type: LanguageService },
        { type: ConfigService }
    ]; };
    /** @nocollapse */ SpatialFilterService.ngInjectableDef = defineInjectable({ factory: function SpatialFilterService_Factory() { return new SpatialFilterService(inject(HttpClient), inject(LanguageService), inject(ConfigService)); }, token: SpatialFilterService, providedIn: "root" });
    return SpatialFilterService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var DownloadService = /** @class */ (function () {
    function DownloadService(messageService, languageService) {
        this.messageService = messageService;
        this.languageService = languageService;
    }
    /**
     * @param {?} layer
     * @return {?}
     */
    DownloadService.prototype.open = /**
     * @param {?} layer
     * @return {?}
     */
    function (layer) {
        /** @type {?} */
        var translate = this.languageService.translate;
        /** @type {?} */
        var title = translate.instant('igo.geo.download.title');
        this.messageService.success(translate.instant('igo.geo.download.start'), title);
        /** @type {?} */
        var DSOptions = layer.dataSource.options;
        if (Object.keys(DSOptions.download).length > 0) {
            if (DSOptions.download.dynamicUrl &&
                DSOptions.download.url === undefined) {
                /** @type {?} */
                var wfsOptions = void 0;
                if (((/** @type {?} */ (layer.dataSource.options))).paramsWFS &&
                    Object.keys(((/** @type {?} */ (layer.dataSource.options))).paramsWFS).length > 0) {
                    wfsOptions = ((/** @type {?} */ (layer.dataSource.options))).paramsWFS;
                }
                else {
                    wfsOptions = ((/** @type {?} */ (layer.dataSource.options))).params;
                }
                /** @type {?} */
                var outputFormatDownload = wfsOptions.outputFormatDownload === undefined
                    ? 'outputformat=' + wfsOptions.outputFormat
                    : 'outputformat=' + wfsOptions.outputFormatDownload;
                /** @type {?} */
                var baseurl = DSOptions.download.dynamicUrl
                    .replace(/&?outputformat=[^&]*/gi, '')
                    .replace(/&?filter=[^&]*/gi, '')
                    .replace(/&?bbox=[^&]*/gi, '');
                /** @type {?} */
                var ogcFilters = ((/** @type {?} */ (layer.dataSource.options))).ogcFilters;
                /** @type {?} */
                var filterQueryString = void 0;
                filterQueryString = new OgcFilterWriter()
                    .handleOgcFiltersAppliedValue(layer.dataSource.options, ogcFilters.geometryName, layer.map.viewController.getExtent(), new olProjection({ code: layer.map.projection }));
                if (!filterQueryString) {
                    // Prevent getting all the features for empty filter
                    filterQueryString = new OgcFilterWriter().buildFilter(undefined, layer.map.viewController.getExtent(), new olProjection({ code: layer.map.projection }), ogcFilters.geometryName);
                }
                else {
                    filterQueryString = 'filter=' + encodeURIComponent(filterQueryString);
                }
                window.open(baseurl + "&" + filterQueryString + "&" + outputFormatDownload, '_blank');
            }
            else if (DSOptions.download) {
                window.open(DSOptions.download.url, '_blank');
            }
        }
    };
    DownloadService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    DownloadService.ctorParameters = function () { return [
        { type: MessageService },
        { type: LanguageService }
    ]; };
    /** @nocollapse */ DownloadService.ngInjectableDef = defineInjectable({ factory: function DownloadService_Factory() { return new DownloadService(inject(MessageService), inject(LanguageService)); }, token: DownloadService, providedIn: "root" });
    return DownloadService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var DownloadButtonComponent = /** @class */ (function () {
    function DownloadButtonComponent(downloadService) {
        this.downloadService = downloadService;
        this._color = 'primary';
    }
    Object.defineProperty(DownloadButtonComponent.prototype, "layer", {
        get: /**
         * @return {?}
         */
        function () {
            return this._layer;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._layer = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DownloadButtonComponent.prototype, "color", {
        get: /**
         * @return {?}
         */
        function () {
            return this._color;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._color = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} layer
     * @return {?}
     */
    DownloadButtonComponent.prototype.openDownload = /**
     * @param {?} layer
     * @return {?}
     */
    function (layer) {
        this.downloadService.open(layer);
    };
    Object.defineProperty(DownloadButtonComponent.prototype, "options", {
        get: /**
         * @return {?}
         */
        function () {
            if (!this.layer) {
                return;
            }
            return this.layer.dataSource.options;
        },
        enumerable: true,
        configurable: true
    });
    DownloadButtonComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igo-download-button',
                    template: "<button\r\n  *ngIf=\"options && options.download && (options.download['dynamicUrl'] || options.download['url']) \"\r\n  mat-icon-button\r\n  tooltip-position=\"below\"\r\n  matTooltipShowDelay=\"500\"\r\n  [matTooltip]=\"'igo.geo.download.action' | translate\"\r\n  [color]=\"color\"\r\n  (click)=\"openDownload(layer)\">\r\n  <mat-icon svgIcon=\"download\"></mat-icon>\r\n</button>\r\n",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: [""]
                }] }
    ];
    /** @nocollapse */
    DownloadButtonComponent.ctorParameters = function () { return [
        { type: DownloadService }
    ]; };
    DownloadButtonComponent.propDecorators = {
        layer: [{ type: Input }],
        color: [{ type: Input }]
    };
    return DownloadButtonComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgoDownloadModule = /** @class */ (function () {
    function IgoDownloadModule() {
    }
    /**
     * @return {?}
     */
    IgoDownloadModule.forRoot = /**
     * @return {?}
     */
    function () {
        return {
            ngModule: IgoDownloadModule
        };
    };
    IgoDownloadModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        MatIconModule,
                        MatButtonModule,
                        MatTooltipModule,
                        IgoLanguageModule
                    ],
                    exports: [DownloadButtonComponent],
                    declarations: [DownloadButtonComponent]
                },] }
    ];
    return IgoDownloadModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FeatureDetailsComponent = /** @class */ (function () {
    function FeatureDetailsComponent(cdRef, sanitizer, networkService) {
        var _this = this;
        this.cdRef = cdRef;
        this.sanitizer = sanitizer;
        this.networkService = networkService;
        this.networkService.currentState().subscribe((/**
         * @param {?} state
         * @return {?}
         */
        function (state$$1) {
            _this.state = state$$1;
        }));
    }
    Object.defineProperty(FeatureDetailsComponent.prototype, "source", {
        get: /**
         * @return {?}
         */
        function () {
            return this._source;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._source = value;
            this.cdRef.detectChanges();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FeatureDetailsComponent.prototype, "feature", {
        get: /**
         * @return {?}
         */
        function () {
            return this._feature;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._feature = value;
            this.cdRef.detectChanges();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FeatureDetailsComponent.prototype, "title", {
        /**
         * @internal
         */
        get: /**
         * \@internal
         * @return {?}
         */
        function () {
            return getEntityTitle(this.feature);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FeatureDetailsComponent.prototype, "icon", {
        /**
         * @internal
         */
        get: /**
         * \@internal
         * @return {?}
         */
        function () {
            return getEntityIcon(this.feature) || 'link';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} value
     * @return {?}
     */
    FeatureDetailsComponent.prototype.htmlSanitizer = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        return this.sanitizer.bypassSecurityTrustResourceUrl(value);
    };
    /**
     * @param {?} value
     * @return {?}
     */
    FeatureDetailsComponent.prototype.isObject = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        return typeof value === 'object';
    };
    /**
     * @param {?} value
     * @return {?}
     */
    FeatureDetailsComponent.prototype.isUrl = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (typeof value === 'string') {
            return (value.slice(0, 8) === 'https://' || value.slice(0, 7) === 'http://');
        }
        else {
            return false;
        }
    };
    /**
     * @param {?} feature
     * @return {?}
     */
    FeatureDetailsComponent.prototype.filterFeatureProperties = /**
     * @param {?} feature
     * @return {?}
     */
    function (feature) {
        /** @type {?} */
        var allowedFieldsAndAlias = feature.meta ? feature.meta.alias : undefined;
        /** @type {?} */
        var properties = {};
        /** @type {?} */
        var offlineButtonState;
        if (this.map) {
            this.map.offlineButtonToggle$.subscribe((/**
             * @param {?} state
             * @return {?}
             */
            function (state$$1) {
                offlineButtonState = state$$1;
            }));
        }
        if (allowedFieldsAndAlias) {
            Object.keys(allowedFieldsAndAlias).forEach((/**
             * @param {?} field
             * @return {?}
             */
            function (field) {
                properties[allowedFieldsAndAlias[field]] = feature.properties[field];
            }));
            return properties;
        }
        else if (offlineButtonState !== undefined) {
            if (!offlineButtonState) {
                if (this.state.connection && feature.meta && feature.meta.excludeAttribute) {
                    /** @type {?} */
                    var excludeAttribute = feature.meta.excludeAttribute;
                    excludeAttribute.forEach((/**
                     * @param {?} attribute
                     * @return {?}
                     */
                    function (attribute) {
                        delete feature.properties[attribute];
                    }));
                }
                else if (!this.state.connection && feature.meta && feature.meta.excludeAttributeOffline) {
                    /** @type {?} */
                    var excludeAttributeOffline = feature.meta.excludeAttributeOffline;
                    excludeAttributeOffline.forEach((/**
                     * @param {?} attribute
                     * @return {?}
                     */
                    function (attribute) {
                        delete feature.properties[attribute];
                    }));
                }
            }
            else {
                if (feature.meta && feature.meta.excludeAttributeOffline) {
                    /** @type {?} */
                    var excludeAttributeOffline = feature.meta.excludeAttributeOffline;
                    excludeAttributeOffline.forEach((/**
                     * @param {?} attribute
                     * @return {?}
                     */
                    function (attribute) {
                        delete feature.properties[attribute];
                    }));
                }
            }
        }
        else {
            if (this.state.connection && feature.meta && feature.meta.excludeAttribute) {
                /** @type {?} */
                var excludeAttribute = feature.meta.excludeAttribute;
                excludeAttribute.forEach((/**
                 * @param {?} attribute
                 * @return {?}
                 */
                function (attribute) {
                    delete feature.properties[attribute];
                }));
            }
            else if (!this.state.connection && feature.meta && feature.meta.excludeAttributeOffline) {
                /** @type {?} */
                var excludeAttributeOffline = feature.meta.excludeAttributeOffline;
                excludeAttributeOffline.forEach((/**
                 * @param {?} attribute
                 * @return {?}
                 */
                function (attribute) {
                    delete feature.properties[attribute];
                }));
            }
        }
        return feature.properties;
    };
    FeatureDetailsComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igo-feature-details',
                    template: "<table class=\"igo-striped mat-typography\" *ngIf=\"feature && isObject(feature.properties) && feature.properties.target !== 'iframe'\">\r\n  <tbody>\r\n    <tr *ngFor=\"let property of filterFeatureProperties(feature) | keyvalue\">\r\n\r\n      <td *ngIf=\"feature.properties.target === '_blank' && property.key === 'url'\">\r\n        <mat-icon mat-list-avatar svgIcon=\"{{icon}}\"></mat-icon>\r\n      </td>\r\n\r\n      <td *ngIf=\"feature.properties.target === '_blank' && property.key === 'url'\">\r\n        <a href=\"{{property.value}}\" target='_blank'> {{ 'igo.geo.targetHtmlUrl' | translate }} {{title}}</a>\r\n      </td>\r\n\r\n      <td id=\"keyValue\" *ngIf=\"feature.properties.target === undefined\">\r\n        {{property.key }}\r\n      </td>\r\n\r\n      <td *ngIf=\"feature.properties.target === undefined && !isObject(property.value) && !isUrl(property.value)\" [innerHTML]=property.value>\r\n      </td>\r\n\r\n      <td *ngIf=\"feature.properties.target === undefined && !isObject(property.value) && isUrl(property.value)\">\r\n        <a href=\"{{property.value}}\" target='_blank'>{{ 'igo.geo.targetHtmlUrl' | translate }} </a>\r\n      </td>\r\n\r\n      <td *ngIf=\"feature.properties.target === undefined && isObject(property.value)\" [innerHTML]=\"property.value | json\">\r\n      </td>\r\n\r\n    </tr>\r\n  </tbody>\r\n</table>\r\n\r\n<iframe *ngIf=\"feature && isObject(feature.properties) && feature.properties.target === 'iframe'\" [src]=\"htmlSanitizer(feature.properties.url)\"></iframe>\r\n",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: ["table{width:100%}table td{padding:5px}#keyValue{width:30%}iframe{height:calc(100% - 4px);width:100%;border:0}"]
                }] }
    ];
    /** @nocollapse */
    FeatureDetailsComponent.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: DomSanitizer },
        { type: NetworkService }
    ]; };
    FeatureDetailsComponent.propDecorators = {
        source: [{ type: Input }],
        map: [{ type: Input }],
        feature: [{ type: Input }]
    };
    return FeatureDetailsComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @ignore
 */
var IgoFeatureDetailsModule = /** @class */ (function () {
    function IgoFeatureDetailsModule() {
    }
    IgoFeatureDetailsModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        MatIconModule,
                        IgoLanguageModule,
                        IgoKeyValueModule
                    ],
                    exports: [FeatureDetailsComponent],
                    declarations: [FeatureDetailsComponent]
                },] }
    ];
    return IgoFeatureDetailsModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @ignore
 */
var IgoFeatureFormModule = /** @class */ (function () {
    function IgoFeatureFormModule() {
    }
    IgoFeatureFormModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        IgoFormModule
                    ],
                    exports: [
                        IgoFormModule,
                        FeatureFormComponent
                    ],
                    declarations: [
                        FeatureFormComponent
                    ]
                },] }
    ];
    return IgoFeatureFormModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgoFeatureModule = /** @class */ (function () {
    function IgoFeatureModule() {
    }
    IgoFeatureModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule
                    ],
                    exports: [
                        IgoFeatureDetailsModule,
                        IgoFeatureFormModule
                    ],
                    declarations: [],
                    providers: []
                },] }
    ];
    return IgoFeatureModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * This input allows a user to draw a new geometry or to edit
 * an existing one on a map.
 */
var GeometryFormFieldComponent = /** @class */ (function () {
    function GeometryFormFieldComponent(cdRef) {
        this.cdRef = cdRef;
        this.value$ = new BehaviorSubject(undefined);
        this.drawControlIsActive = true;
        this.freehandDrawIsActive = false;
        this.geometryType$ = new BehaviorSubject(undefined);
        /**
         * Whether a geometry type toggle should be displayed
         */
        this.geometryTypeField = false;
        /**
         * Available geometry types
         */
        this.geometryTypes = ['Point', 'LineString', 'Polygon'];
        /**
         * Whether a draw guide field should be displayed
         */
        this.drawGuideField = false;
        this.drawGuide$ = new BehaviorSubject(0);
        /**
         * Draw guide placeholder
         */
        this.drawGuidePlaceholder = '';
        /**
         * Whether a measure tooltip should be displayed
         */
        this.measure = false;
        /**
         * Control options
         */
        this.controlOptions = {};
    }
    Object.defineProperty(GeometryFormFieldComponent.prototype, "geometryType", {
        get: /**
         * @return {?}
         */
        function () { return this.geometryType$.value; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) { this.geometryType$.next(value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GeometryFormFieldComponent.prototype, "drawGuide", {
        get: /**
         * @return {?}
         */
        function () { return this.drawGuide$.value; },
        /**
         * The drawGuide around the mouse pointer to help drawing
         */
        set: /**
         * The drawGuide around the mouse pointer to help drawing
         * @param {?} value
         * @return {?}
         */
        function (value) { this.drawGuide$.next(value); },
        enumerable: true,
        configurable: true
    });
    /**
     * Set up a value stream
     * @internal
     */
    /**
     * Set up a value stream
     * \@internal
     * @return {?}
     */
    GeometryFormFieldComponent.prototype.ngOnInit = /**
     * Set up a value stream
     * \@internal
     * @return {?}
     */
    function () {
        var _this = this;
        this.value$.next(this.formControl.value ? this.formControl.value : undefined);
        this.value$$ = this.formControl.valueChanges.subscribe((/**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            _this.value$.next(value ? value : undefined);
        }));
    };
    /**
     * Unsubscribe to the value stream
     * @internal
     */
    /**
     * Unsubscribe to the value stream
     * \@internal
     * @return {?}
     */
    GeometryFormFieldComponent.prototype.ngOnDestroy = /**
     * Unsubscribe to the value stream
     * \@internal
     * @return {?}
     */
    function () {
        this.value$$.unsubscribe();
    };
    GeometryFormFieldComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igo-geometry-form-field',
                    template: "<igo-geometry-form-field-input\r\n  [formControl]=\"formControl\"\r\n  [map]=\"map\"\r\n  [geometryType]=\"geometryType$ | async\"\r\n  [drawGuide]=\"drawGuide$ | async\"\r\n  [measure]=\"measure\"\r\n  [drawControlIsActive]=\"drawControlIsActive\"\r\n  [freehandDrawIsActive]=\"freehandDrawIsActive\"\r\n  [controlOptions]=\"controlOptions\"\r\n  [drawStyle]=\"drawStyle\"\r\n  [overlayStyle]=\"overlayStyle\">\r\n</igo-geometry-form-field-input>\r\n\r\n<div *ngIf=\"geometryTypeField\" class=\"geometry-type-toggle\">\r\n  <mat-button-toggle-group\r\n    [disabled]=\"(value$ | async) !== undefined\"\r\n    [(ngModel)]=\"geometryType\">\r\n    <mat-button-toggle\r\n      value=\"Point\"\r\n      [disabled]=\"geometryTypes.indexOf('Point') < 0\">\r\n      {{'igo.geo.geometry.point' | translate}}\r\n    </mat-button-toggle>\r\n    <mat-button-toggle\r\n      value=\"LineString\"\r\n      [disabled]=\"geometryTypes.indexOf('LineString') < 0\">\r\n      {{'igo.geo.geometry.line' | translate}}\r\n    </mat-button-toggle>\r\n    <mat-button-toggle\r\n      value=\"Polygon\"\r\n      [disabled]=\"geometryTypes.indexOf('Polygon') < 0\">\r\n      {{'igo.geo.geometry.polygon' | translate}}\r\n    </mat-button-toggle>\r\n  </mat-button-toggle-group>\r\n</div>\r\n\r\n<mat-form-field *ngIf=\"drawGuideField\" class=\"draw-guide-field\">\r\n  <input\r\n    matInput\r\n    type=\"number\"\r\n    [placeholder]=\"drawGuidePlaceholder\"\r\n    [(ngModel)]=\"drawGuide\">\r\n  <mat-icon\r\n    matPrefix\r\n    [color]=\"'primary'\"\r\n    svgIcon=\"adjust\">    \r\n  </mat-icon>\r\n  <span matSuffix class=\"draw-guide-units\">{{'igo.geo.measure.meters' | translate}}</span>\r\n</mat-form-field>",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: [":host{display:block;width:100%}.draw-guide-field,.geometry-type-toggle{width:100%}.geometry-type-toggle{padding:10px;text-align:center}.draw-guide-field mat-icon{margin:0 10px}.draw-guide-units{padding:10px}"]
                }] }
    ];
    /** @nocollapse */
    GeometryFormFieldComponent.ctorParameters = function () { return [
        { type: ChangeDetectorRef }
    ]; };
    GeometryFormFieldComponent.propDecorators = {
        formControl: [{ type: Input }],
        map: [{ type: Input }],
        geometryType: [{ type: Input }],
        geometryTypeField: [{ type: Input }],
        geometryTypes: [{ type: Input }],
        drawGuideField: [{ type: Input }],
        drawGuide: [{ type: Input }],
        drawGuidePlaceholder: [{ type: Input }],
        measure: [{ type: Input }],
        controlOptions: [{ type: Input }],
        drawStyle: [{ type: Input }],
        overlayStyle: [{ type: Input }]
    };
    /**
     * This input allows a user to draw a new geometry or to edit
     * an existing one on a map.
     */
    GeometryFormFieldComponent = __decorate([
        FormFieldComponent('geometry'),
        __metadata("design:paramtypes", [ChangeDetectorRef])
    ], GeometryFormFieldComponent);
    return GeometryFormFieldComponent;
}());

var _a, _b;
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var MEASURE_UNIT_AUTO = 'auto';
/** @enum {string} */
var MeasureType = {
    Length: 'length',
    Area: 'area',
};
/** @enum {string} */
var MeasureLengthUnit = {
    Meters: 'meters',
    Kilometers: 'kilometers',
    Miles: 'miles',
    Feet: 'feet',
};
/** @type {?} */
var MeasureLengthUnitAbbreviation = (_a = {},
    _a[MeasureLengthUnit.Meters] = 'm',
    _a[MeasureLengthUnit.Kilometers] = 'km',
    _a[MeasureLengthUnit.Miles] = 'mi',
    _a[MeasureLengthUnit.Feet] = 'ft',
    _a);
/** @enum {string} */
var MeasureAreaUnit = {
    SquareMeters: 'squareMeters',
    SquareKilometers: 'squareKilometers',
    SquareMiles: 'squareMiles',
    SquareFeet: 'squareFeet',
    Hectares: 'hectares',
    Acres: 'acres',
};
/** @type {?} */
var MeasureAreaUnitAbbreviation = (_b = {},
    _b[MeasureAreaUnit.SquareMeters] = 'm²',
    _b[MeasureAreaUnit.SquareKilometers] = 'km²',
    _b[MeasureAreaUnit.SquareMiles] = 'mi²',
    _b[MeasureAreaUnit.SquareFeet] = 'ft²',
    _b[MeasureAreaUnit.Hectares] = 'ha',
    _b[MeasureAreaUnit.Acres] = 'ac',
    _b);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Convert value from meters to kilometers
 * @param {?} value Value in meters
 * @return {?} Value in kilometers
 */
function metersToKilometers(value) {
    return value * 0.001;
}
/**
 * Convert value from meters to feet
 * @param {?} value Value in meters
 * @return {?} Value in feet
 */
function metersToFeet(value) {
    return value * 3.2808;
}
/**
 * Convert value from meters to miles
 * @param {?} value Value in meters
 * @return {?} Value in miles
 */
function metersToMiles(value) {
    return value * 0.000621;
}
/**
 * Convert value from square meters to square kilometers
 * @param {?} value Value in square meters
 * @return {?} Value in square kilometers
 */
function squareMetersToSquareKilometers(value) {
    return value * 0.000001;
}
/**
 * Convert value from square meters to square miles
 * @param {?} value Value in square meters
 * @return {?} Value in square miles
 */
function squareMetersToSquareMiles(value) {
    return value * 0.0000003861;
}
/**
 * Convert value from square meters to square feet
 * @param {?} value Value in square meters
 * @return {?} Value in square feet
 */
function squareMetersToSquareFeet(value) {
    return value * 10.764;
}
/**
 * Convert value from square meters to hectares
 * @param {?} value Value in square meters
 * @return {?} Value in hectares
 */
function squareMetersToHectares(value) {
    return value * 0.0001;
}
/**
 * Convert value from square meters to acres
 * @param {?} value Value in square meters
 * @return {?} Value in acres
 */
function squareMetersToAcres(value) {
    return value * 0.00024711;
}
/**
 * Convert value from meters to the specified length unit
 * @param {?} value Value in meters
 * @param {?} unit Length unit
 * @return {?} Value in unit
 */
function metersToUnit(value, unit) {
    /** @type {?} */
    var conversionMapper = new Map([
        [MeasureLengthUnit.Meters, (/**
             * @param {?} val
             * @return {?}
             */
            function (val) { return val; })],
        [MeasureLengthUnit.Kilometers, metersToKilometers],
        [MeasureLengthUnit.Miles, metersToMiles],
        [MeasureLengthUnit.Feet, metersToFeet],
    ]);
    /** @type {?} */
    var conversion = conversionMapper.get(unit);
    return conversion ? conversion(value) : undefined;
}
/**
 * Convert value from square meters to the specified area unit
 * @param {?} value Value in meters
 * @param {?} unit Area unit
 * @return {?} Value in unit
 */
function squareMetersToUnit(value, unit) {
    /** @type {?} */
    var conversionMapper = new Map([
        [MeasureAreaUnit.SquareMeters, (/**
             * @param {?} val
             * @return {?}
             */
            function (val) { return val; })],
        [MeasureAreaUnit.SquareKilometers, squareMetersToSquareKilometers],
        [MeasureAreaUnit.SquareMiles, squareMetersToSquareMiles],
        [MeasureAreaUnit.SquareFeet, squareMetersToSquareFeet],
        [MeasureAreaUnit.Hectares, squareMetersToHectares],
        [MeasureAreaUnit.Acres, squareMetersToAcres],
    ]);
    /** @type {?} */
    var conversion = conversionMapper.get(unit);
    return conversion ? conversion(value) : undefined;
}
/**
 * This method format a measure to a readable format
 * @param {?} measure Measure
 * @param {?=} options Formatting options
 * @param {?=} languageService
 * @return {?} Formatted measure
 */
function formatMeasure(measure, options, languageService) {
    /** @type {?} */
    var decimal = options.decimal;
    if (decimal === undefined || decimal < 0) {
        decimal = 1;
    }
    /** @type {?} */
    var parts = [];
    if (options.locale !== undefined) {
        parts.push(measure.toLocaleString(options.locale, {
            minimumFractionDigits: decimal,
            maximumFractionDigits: decimal
        }));
    }
    else {
        parts.push(measure.toFixed(decimal).toString());
    }
    if (options.unit !== undefined && options.unitAbbr === true) {
        if (languageService) {
            parts.push(MeasureLengthUnitAbbreviation[options.unit] ?
                languageService.translate.instant('igo.geo.measure.' + MeasureLengthUnitAbbreviation[options.unit]) :
                languageService.translate.instant('igo.geo.measure.' + MeasureAreaUnitAbbreviation[options.unit]));
        }
        else {
            parts.push(MeasureLengthUnitAbbreviation[options.unit] || MeasureAreaUnitAbbreviation[options.unit]);
        }
    }
    return parts.filter((/**
     * @param {?} p
     * @return {?}
     */
    function (p) { return p !== undefined; })).join(' ');
}
/**
 * Compute best length measure unit for a given measure in meters
 * @param {?} value Value in meters
 * @return {?} Measure unit
 */
function computeBestLengthUnit(value) {
    /** @type {?} */
    var unit = MeasureLengthUnit.Meters;
    /** @type {?} */
    var converted = value;
    /** @type {?} */
    var possibleUnits = [MeasureLengthUnit.Kilometers];
    while (converted > 1000 && possibleUnits.length > 0) {
        unit = possibleUnits.pop();
        converted = metersToUnit(value, unit);
    }
    return unit;
}
/**
 * Compute best length measure unit for a given measure in square meters
 * @param {?} value Value in meters
 * @return {?} Measure unit
 */
function computeBestAreaUnit(value) {
    /** @type {?} */
    var unit = MeasureAreaUnit.SquareMeters;
    /** @type {?} */
    var converted = value;
    /** @type {?} */
    var possibleUnits = [MeasureAreaUnit.SquareKilometers];
    while (converted > 1000000 && possibleUnits.length > 0) {
        unit = possibleUnits.pop();
        converted = squareMetersToUnit(value, unit);
    }
    return unit;
}
/**
 * Create a default style for a measure interaction
 * @return {?} OL style
 */
function createMeasureInteractionStyle() {
    return new Style({
        stroke: new Stroke({
            color: '#ffcc33',
            lineDash: [10, 10],
            width: 2
        }),
        fill: new Fill({
            color: 'rgba(255, 255, 255, 0.2)'
        }),
        image: new Circle({
            radius: 5,
            stroke: new Stroke({
                color: '#ffcc33',
            }),
            fill: new Fill({
                color: 'rgba(255, 255, 255, 0.2)'
            })
        })
    });
}
/**
 * Create a default style for a measure layer
 * @return {?} OL style
 */
function createMeasureLayerStyle() {
    return new Style({
        stroke: new Stroke({
            color: '#ffcc33',
            width: 2
        }),
        fill: new Fill({
            color: 'rgba(255, 255, 255, 0.2)'
        })
    });
}
/**
 * Compute the length in meters of an OL geometry with a given projection
 * @param {?} olGeometry Ol geometry
 * @param {?} projection olGeometry's projection
 * @return {?} Length in meters
 */
function measureOlGeometryLength(olGeometry, projection) {
    if (olGeometry instanceof OlPoint) {
        return undefined;
    }
    if (olGeometry.getFlatCoordinates().length === 0) {
        return undefined;
    }
    return getLength(olGeometry, { projection: projection });
}
/**
 * Compute the area in square meters of an OL geometry with a given projection
 * @param {?} olGeometry Ol geometry
 * @param {?} projection olGeometry's projection
 * @return {?} Area in square meters
 */
function measureOlGeometryArea(olGeometry, projection) {
    if (olGeometry instanceof OlPoint || olGeometry instanceof OlLineString) {
        return undefined;
    }
    if (olGeometry.getFlatCoordinates().length === 0) {
        return undefined;
    }
    return getArea$1(olGeometry, { projection: projection });
}
/**
 * Compute the area (square meters), length (meters) and last length (meters)
 * of an OL geometry with a given projection.
 * @param {?} olGeometry Ol geometry
 * @param {?} projection olGeometry's projection
 * @return {?} Computed measure
 */
function measureOlGeometry(olGeometry, projection) {
    /** @type {?} */
    var length = measureOlGeometryLength(olGeometry, projection);
    /** @type {?} */
    var area = measureOlGeometryArea(olGeometry, projection);
    /** @type {?} */
    var lengths = [];
    /** @type {?} */
    var coordinates = olGeometry.flatCoordinates;
    /** @type {?} */
    var coordinatesLength = coordinates.length;
    for (var i = 0; i <= coordinatesLength - 4; i += 2) {
        /** @type {?} */
        var olSegment = new OlLineString([
            [coordinates[i], coordinates[i + 1]],
            [coordinates[i + 2], coordinates[i + 3]]
        ]);
        lengths.push(measureOlGeometryLength(olSegment, projection));
    }
    return {
        area: area,
        length: length,
        lengths: lengths
    };
}
/**
 * Update an OL geometry midpoints and return an array of those points
 * @param {?} olGeometry OL Geometry
 * @return {?} OL points
 */
function updateOlGeometryMidpoints(olGeometry) {
    /** @type {?} */
    var olMidpoints = getOlGeometryMidpoints(olGeometry);
    // TODO: handle multi geometries
    /** @type {?} */
    var coordinates = olGeometry.flatCoordinates;
    /** @type {?} */
    var midpointsLength = olMidpoints.length;
    for (var i = 0; i < midpointsLength; i++) {
        /** @type {?} */
        var j = i * 2;
        /** @type {?} */
        var olSegment = new OlLineString([
            [coordinates[j], coordinates[j + 1]],
            [coordinates[j + 2], coordinates[j + 3]]
        ]);
        /** @type {?} */
        var midpointCoordinate = olSegment.getCoordinateAt(0.5);
        /** @type {?} */
        var olMidpoint = olMidpoints[i];
        if (olMidpoint !== undefined) {
            olMidpoint.setCoordinates(midpointCoordinate);
        }
        else {
            olMidpoints[i] = new OlPoint(midpointCoordinate);
        }
    }
    return olMidpoints;
}
/**
 * Clear an OL geometry midpoints and return an array of those points
 * @param {?} olGeometry OL Geometry
 * @return {?}
 */
function clearOlGeometryMidpoints(olGeometry) {
    /** @type {?} */
    var olMidpoints = olGeometry.get('_midpoints') || [];
    /** @type {?} */
    var midpointsLength = olMidpoints.length;
    for (var i = 0; i < midpointsLength; i++) {
        /** @type {?} */
        var olMidpoint = olMidpoints[i];
        if (olMidpoint !== undefined) {
            if (olMidpoint !== undefined) {
                clearOlMidpointTooltip(olMidpoint);
            }
        }
    }
    olGeometry.set('_midpoints', undefined, true);
    return olMidpoints;
}
/**
 * Return an array of  OL geometry midpoints, if any
 * @param {?} olGeometry OL Geometry
 * @return {?} OL points
 */
function getOlGeometryMidpoints(olGeometry) {
    /** @type {?} */
    var expectedNumber = Math.max((olGeometry.flatCoordinates.length / 2) - 1, 0);
    // TODO: This works but it's quite messy. If time permits,
    // clean this. Maybe a Tooltip class could handle that
    /** @type {?} */
    var olMidpoints = olGeometry.get('_midpoints');
    if (olMidpoints === undefined) {
        olMidpoints = new Array(expectedNumber);
        olGeometry.set('_midpoints', olMidpoints, true);
        return olMidpoints;
    }
    if (expectedNumber === olMidpoints.length) {
        return olMidpoints;
    }
    if (expectedNumber > olMidpoints.length) {
        olMidpoints.push.apply(olMidpoints, __spread(new Array(expectedNumber - olMidpoints.length)));
        return olMidpoints;
    }
    for (var i = expectedNumber; i < olMidpoints.length; i++) {
        /** @type {?} */
        var olMidpoint = olMidpoints[expectedNumber];
        if (olMidpoint !== undefined) {
            clearOlMidpointTooltip(olMidpoint);
        }
    }
    olMidpoints.splice(expectedNumber);
    return olMidpoints;
}
/**
 * Remove an OL midpoint's tooltip from the map
 * @param {?} olMidpoint OL Point
 * @return {?}
 */
function clearOlMidpointTooltip(olMidpoint) {
    /** @type {?} */
    var olTooltip = olMidpoint.get('_tooltip');
    if (olTooltip !== undefined) {
        /** @type {?} */
        var olMap$$1 = olTooltip.getMap();
        if (olMap$$1 !== undefined) {
            olMap$$1.removeOverlay(olTooltip);
        }
    }
}
/**
 * Add an OL overlay at each midpoint and return an array of those overlays
 * @param {?} olGeometry OL Geometry
 * @return {?} OL overlays
 */
function updateOlTooltipsAtMidpoints(olGeometry) {
    /** @type {?} */
    var olMidpoints = updateOlGeometryMidpoints(olGeometry);
    /** @type {?} */
    var olTooltips = olMidpoints.map((/**
     * @param {?} olMidpoint
     * @return {?}
     */
    function (olMidpoint) {
        /** @type {?} */
        var olTooltip = olMidpoint.get('_tooltip');
        if (olTooltip === undefined) {
            olTooltip = createOlTooltipAtPoint(olMidpoint);
        }
        else {
            olTooltip.setPosition(olMidpoint.flatCoordinates);
        }
        return olTooltip;
    }));
    return olTooltips;
}
/**
 * Return an array of OL overlay at midspoints, if any
 * @param {?} olGeometry OL Geometry
 * @return {?} OL overlays
 */
function getOlTooltipsAtMidpoints(olGeometry) {
    /** @type {?} */
    var olMidpoints = getOlGeometryMidpoints(olGeometry);
    return olMidpoints.map((/**
     * @param {?} olMidpoint
     * @return {?}
     */
    function (olMidpoint) {
        return olMidpoint ? olMidpoint.get('_tooltip') : undefined;
    }));
}
/**
 * Update an OL geometry center and return it
 * @param {?} olGeometry OL Geometry
 * @return {?} OL point
 */
function updateOlGeometryCenter(olGeometry) {
    /** @type {?} */
    var olCenter = olGeometry.get('_center');
    /** @type {?} */
    var centerCoordinate = getCenter(olGeometry.getExtent());
    if (olCenter !== undefined) {
        olCenter.setCoordinates(centerCoordinate);
    }
    else {
        olCenter = new OlPoint(centerCoordinate);
        olGeometry.set('_center', olCenter);
    }
    return olCenter;
}
/**
 * Add an OL overlay at the center of a geometry and return that overlay
 * @param {?} olGeometry OL Geometry
 * @return {?} OL overlay
 */
function updateOlTooltipAtCenter(olGeometry) {
    /** @type {?} */
    var olCenter = updateOlGeometryCenter(olGeometry);
    /** @type {?} */
    var olTooltip = olCenter.get('_tooltip');
    if (olTooltip === undefined) {
        olTooltip = createOlTooltipAtPoint(olCenter);
    }
    else {
        olTooltip.setPosition(olCenter.flatCoordinates);
    }
    return olTooltip;
}
/**
 * Return an array of OL overlay at midspoints, if any
 * @param {?} olGeometry OL Geometry
 * @return {?} OL overlays
 */
function getOlTooltipAtCenter(olGeometry) {
    /** @type {?} */
    var olCenter = olGeometry.get('_center');
    return olCenter ? olCenter.get('_tooltip') : undefined;
}
/**
 * Get all the tooltips of an OL geometry
 * @param {?} olGeometry OL Geometry
 * @return {?} OL overlays
 */
function getTooltipsOfOlGeometry(olGeometry) {
    /** @type {?} */
    var olTooltips = [].concat(getOlTooltipsAtMidpoints(olGeometry) || []);
    /** @type {?} */
    var olCenterTooltip = getOlTooltipAtCenter(olGeometry);
    if (olCenterTooltip !== undefined) {
        olTooltips.push(olCenterTooltip);
    }
    return olTooltips;
}
/**
 * Create an OL overlay at a point and bind the overlay to the point
 * @param {?} olPoint OL Point
 * @return {?} OL overlay
 */
function createOlTooltipAtPoint(olPoint) {
    /** @type {?} */
    var olTooltip = new OlOverlay({
        element: document.createElement('div'),
        offset: [-30, -10],
        className: [
            'igo-map-tooltip',
            'igo-map-tooltip-measure'
        ].join(' '),
        stopEvent: false
    });
    olTooltip.setPosition(olPoint.flatCoordinates);
    olPoint.set('_tooltip', olTooltip);
    return olTooltip;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/* tslint:disable */
// See this issue: https://github.com/Microsoft/TypeScript/issues/13965
// And the solution: https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work
// for an explanation as to why the prototype is set manually
/* tslint:enable */
var GeometrySliceError = /** @class */ (function (_super) {
    __extends(GeometrySliceError, _super);
    function GeometrySliceError() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return GeometrySliceError;
}(Error));
var GeometrySliceMultiPolygonError = /** @class */ (function (_super) {
    __extends(GeometrySliceMultiPolygonError, _super);
    function GeometrySliceMultiPolygonError() {
        var _this = _super.call(this, 'Can\'t slice a MultiPolygon.') || this;
        Object.setPrototypeOf(_this, GeometrySliceMultiPolygonError.prototype);
        return _this;
    }
    return GeometrySliceMultiPolygonError;
}(GeometrySliceError));
var GeometrySliceLineStringError = /** @class */ (function (_super) {
    __extends(GeometrySliceLineStringError, _super);
    function GeometrySliceLineStringError() {
        var _this = _super.call(this, 'Can\'t slice with a line that has more than 2 points.') || this;
        Object.setPrototypeOf(_this, GeometrySliceLineStringError.prototype);
        return _this;
    }
    return GeometrySliceLineStringError;
}(GeometrySliceError));
var GeometrySliceTooManyIntersectionError = /** @class */ (function (_super) {
    __extends(GeometrySliceTooManyIntersectionError, _super);
    function GeometrySliceTooManyIntersectionError() {
        var _this = _super.call(this, 'More than 2 intersections found between the target polygon and the slicing line.') || this;
        Object.setPrototypeOf(_this, GeometrySliceTooManyIntersectionError.prototype);
        return _this;
    }
    return GeometrySliceTooManyIntersectionError;
}(GeometrySliceError));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Create a default style for draw and modify interactions
 * @param {?=} color Style color (R, G, B)
 * @return {?} OL style
 */
function createDrawInteractionStyle(color) {
    color = color || [0, 153, 255];
    return new Style({
        stroke: new Stroke({
            color: color.concat([1]),
            width: 2
        }),
        fill: new Fill({
            color: color.concat([0.2])
        }),
        image: new Circle({
            radius: 8,
            stroke: new Stroke({
                color: color.concat([1])
            }),
            fill: new Fill({
                color: color.concat([0.2])
            })
        })
    });
}
/**
 * Create a default style for drawing a hole
 * @return {?} OL style
 */
function createDrawHoleInteractionStyle() {
    return new Style({
        stroke: new Stroke({
            color: [0, 153, 255, 1],
            width: 2
        })
    });
}
/**
 * Slice geometry into two parts
 * @param {?} olGeometry OL geometry
 * @param {?} olSlicer Slicing line
 * @return {?} New OL geometries
 */
function sliceOlGeometry(olGeometry, olSlicer) {
    if (olGeometry instanceof OlPolygon) {
        return sliceOlPolygon(olGeometry, olSlicer);
    }
    else if (olGeometry instanceof OlLineString) {
        return sliceOlLineString(olGeometry, olSlicer);
    }
    return [];
}
/**
 * Slice OL LineString into one or more lines
 * @param {?} olLineString OL line string
 * @param {?} olSlicer Slicing line
 * @return {?} New OL line strings
 */
function sliceOlLineString(olLineString, olSlicer) {
    return [];
}
/**
 * Slice OL Polygon into one or more polygons
 * @param {?} olPolygon OL polygon
 * @param {?} olSlicer Slicing line
 * @return {?} New OL polygons
 */
function sliceOlPolygon(olPolygon, olSlicer) {
    if (olPolygon.getLinearRingCount() > 1) {
        throw new GeometrySliceMultiPolygonError();
    }
    if (olSlicer.getCoordinates().length > 2) {
        throw new GeometrySliceLineStringError();
    }
    /** @type {?} */
    var olGeoJSON = new OlGeoJSON();
    /** @type {?} */
    var slicer = olGeoJSON.writeGeometryObject(olSlicer);
    /** @type {?} */
    var outerCoordinates = olPolygon.getLinearRing(0).getCoordinates();
    /** @type {?} */
    var parts = [[], []];
    /** @type {?} */
    var totalIntersectionCount = 0;
    for (var i = 0, ii = outerCoordinates.length - 1; i < ii; i++) {
        /** @type {?} */
        var segmentCoordinates = [outerCoordinates[i], outerCoordinates[i + 1]];
        /** @type {?} */
        var segment = lineString(segmentCoordinates);
        /** @type {?} */
        var intersections = lineIntersect(segment, slicer).features;
        /** @type {?} */
        var intersectionCount = intersections.length;
        totalIntersectionCount += intersectionCount;
        if (intersectionCount > 1 || totalIntersectionCount > 2) {
            throw new GeometrySliceTooManyIntersectionError();
        }
        parts[0].push(segmentCoordinates[0]);
        if (intersectionCount === 1) {
            /** @type {?} */
            var intersection = intersections[0].geometry.coordinates;
            parts[0].push(intersection);
            parts[1].push(intersection);
            parts.reverse();
        }
    }
    if (totalIntersectionCount <= 1) {
        return [];
    }
    parts[0].push(parts[0][0]);
    parts[1].push(parts[1][0]);
    return [new OlPolygon([parts[0]]), new OlPolygon([parts[1]])];
}
/**
 * Splice geometry into two parts
 * @param {?} olPolygon
 * @param {?} olLinearRing
 * @return {?} New OL geometries
 */
function addLinearRingToOlPolygon(olPolygon, olLinearRing) {
    // TODO: make some validation and support updating an existing linear ring
    olPolygon.appendLinearRing(olLinearRing);
}
/**
 * @param {?} olEvent
 * @return {?}
 */
function getMousePositionFromOlGeometryEvent(olEvent) {
    /** @type {?} */
    var olGeometry = olEvent.target;
    if (olGeometry instanceof OlPolygon) {
        return olGeometry.flatCoordinates.slice(-4, -2);
    }
    return olGeometry.flatCoordinates.slice(-2);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Control to draw geometries
 */
var  /**
 * Control to draw geometries
 */
DrawControl = /** @class */ (function () {
    function DrawControl(options) {
        this.options = options;
        /**
         * Draw start observable
         */
        this.start$ = new Subject();
        /**
         * Draw end observable
         */
        this.end$ = new Subject();
        /**
         * Geometry changes observable
         */
        this.changes$ = new Subject();
        this.freehand$ = new BehaviorSubject(false);
        if (options.layer !== undefined) {
            this.olOverlayLayer = options.layer;
        }
        else {
            this.olOverlayLayer = this.createOlInnerOverlayLayer();
        }
    }
    Object.defineProperty(DrawControl.prototype, "active", {
        /**
         * Wheter the control is active
         */
        get: /**
         * Wheter the control is active
         * @return {?}
         */
        function () {
            return this.olMap !== undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DrawControl.prototype, "geometryType", {
        /**
         * Geometry type
         * @internal
         */
        get: /**
         * Geometry type
         * \@internal
         * @return {?}
         */
        function () {
            return this.options.geometryType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DrawControl.prototype, "olOverlaySource", {
        /**
         * OL overlay source
         * @internal
         */
        get: /**
         * OL overlay source
         * \@internal
         * @return {?}
         */
        function () {
            return this.olOverlayLayer.getSource();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Add or remove this control to/from a map.
     * @param map OL Map
     */
    /**
     * Add or remove this control to/from a map.
     * @param {?} olMap
     * @return {?}
     */
    DrawControl.prototype.setOlMap = /**
     * Add or remove this control to/from a map.
     * @param {?} olMap
     * @return {?}
     */
    function (olMap$$1) {
        if (olMap$$1 === undefined) {
            this.clearOlInnerOverlaySource();
            this.removeOlInnerOverlayLayer();
            this.removeOlDrawInteraction();
            this.olMap = olMap$$1;
            return;
        }
        this.olMap = olMap$$1;
        this.addOlInnerOverlayLayer();
        this.addOlDrawInteraction();
    };
    /**
     * Return the overlay source
     */
    /**
     * Return the overlay source
     * @return {?}
     */
    DrawControl.prototype.getSource = /**
     * Return the overlay source
     * @return {?}
     */
    function () {
        return this.olOverlaySource;
    };
    /**
     * Create an overlay source if none is defined in the options
     */
    /**
     * Create an overlay source if none is defined in the options
     * @private
     * @return {?}
     */
    DrawControl.prototype.createOlInnerOverlayLayer = /**
     * Create an overlay source if none is defined in the options
     * @private
     * @return {?}
     */
    function () {
        return new OlVectorLayer({
            source: this.options.source ? this.options.source : new OlVectorSource(),
            style: this.options.layerStyle,
            zIndex: 500
        });
    };
    /**
     * Clear the overlay layer if it wasn't defined in the options
     */
    /**
     * Clear the overlay layer if it wasn't defined in the options
     * @private
     * @return {?}
     */
    DrawControl.prototype.removeOlInnerOverlayLayer = /**
     * Clear the overlay layer if it wasn't defined in the options
     * @private
     * @return {?}
     */
    function () {
        if (this.options.layer === undefined && this.olMap !== undefined) {
            this.olMap.removeLayer(this.olOverlayLayer);
        }
    };
    /**
     * Add the overlay layer if it wasn't defined in the options
     */
    /**
     * Add the overlay layer if it wasn't defined in the options
     * @private
     * @return {?}
     */
    DrawControl.prototype.addOlInnerOverlayLayer = /**
     * Add the overlay layer if it wasn't defined in the options
     * @private
     * @return {?}
     */
    function () {
        if (this.options.layer === undefined) {
            this.olMap.addLayer(this.olOverlayLayer);
        }
    };
    /**
     * Clear the overlay source if it wasn't defined in the options
     */
    /**
     * Clear the overlay source if it wasn't defined in the options
     * @private
     * @return {?}
     */
    DrawControl.prototype.clearOlInnerOverlaySource = /**
     * Clear the overlay source if it wasn't defined in the options
     * @private
     * @return {?}
     */
    function () {
        if (this.options.layer === undefined && this.options.source === undefined) {
            this.olOverlaySource.clear(true);
        }
    };
    /**
     * Add a draw interaction to the map an set up some listeners
     */
    /**
     * Add a draw interaction to the map an set up some listeners
     * @return {?}
     */
    DrawControl.prototype.addOlDrawInteraction = /**
     * Add a draw interaction to the map an set up some listeners
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var olDrawInteraction;
        if (this.freehand$.getValue() === false) {
            olDrawInteraction = new OlDraw({
                type: this.geometryType,
                source: this.getSource(),
                stopClick: true,
                style: this.options.drawStyle,
                maxPoints: this.options.maxPoints,
                freehand: false,
                freehandCondition: (/**
                 * @return {?}
                 */
                function () { return false; })
            });
        }
        else {
            if (this.geometryType === 'Point') {
                olDrawInteraction = new OlDraw({
                    type: 'Circle',
                    source: this.getSource(),
                    maxPoints: this.options.maxPoints,
                    freehand: true
                });
            }
            else {
                olDrawInteraction = new OlDraw({
                    type: this.geometryType,
                    source: this.getSource(),
                    maxPoints: this.options.maxPoints,
                    freehand: true
                });
            }
        }
        this.onDrawStartKey = olDrawInteraction
            .on('drawstart', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.onDrawStart(event); }));
        this.onDrawEndKey = olDrawInteraction
            .on('drawend', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.onDrawEnd(event); }));
        this.olMap.addInteraction(olDrawInteraction);
        this.olDrawInteraction = olDrawInteraction;
    };
    /**
     * Remove the draw interaction
     */
    /**
     * Remove the draw interaction
     * @private
     * @return {?}
     */
    DrawControl.prototype.removeOlDrawInteraction = /**
     * Remove the draw interaction
     * @private
     * @return {?}
     */
    function () {
        if (this.olDrawInteraction === undefined) {
            return;
        }
        this.unsubscribeToKeyDown();
        unByKey([
            this.onDrawStartKey,
            this.onDrawEndKey,
            this.onDrawKey
        ]);
        if (this.olMap !== undefined) {
            this.olMap.removeInteraction(this.olDrawInteraction);
        }
        this.olDrawInteraction = undefined;
    };
    /**
     * When drawing starts, clear the overlay and start watching from changes
     * @param event Draw start event
     */
    /**
     * When drawing starts, clear the overlay and start watching from changes
     * @private
     * @param {?} event Draw start event
     * @return {?}
     */
    DrawControl.prototype.onDrawStart = /**
     * When drawing starts, clear the overlay and start watching from changes
     * @private
     * @param {?} event Draw start event
     * @return {?}
     */
    function (event) {
        var _this = this;
        /** @type {?} */
        var olGeometry = event.feature.getGeometry();
        this.start$.next(olGeometry);
        this.clearOlInnerOverlaySource();
        this.onDrawKey = olGeometry.on('change', (/**
         * @param {?} olGeometryEvent
         * @return {?}
         */
        function (olGeometryEvent) {
            _this.mousePosition = getMousePositionFromOlGeometryEvent(olGeometryEvent);
            _this.changes$.next(olGeometryEvent.target);
        }));
        this.subscribeToKeyDown();
    };
    /**
     * When drawing ends, update the geometry observable and start watching from changes
     * @param event Draw end event
     */
    /**
     * When drawing ends, update the geometry observable and start watching from changes
     * @private
     * @param {?} event Draw end event
     * @return {?}
     */
    DrawControl.prototype.onDrawEnd = /**
     * When drawing ends, update the geometry observable and start watching from changes
     * @private
     * @param {?} event Draw end event
     * @return {?}
     */
    function (event) {
        this.unsubscribeToKeyDown();
        unByKey(this.onDrawKey);
        this.end$.next(event.feature.getGeometry());
    };
    /**
     * Subscribe to CTRL key down to activate the draw control
     */
    /**
     * Subscribe to CTRL key down to activate the draw control
     * @private
     * @return {?}
     */
    DrawControl.prototype.subscribeToKeyDown = /**
     * Subscribe to CTRL key down to activate the draw control
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this.unsubscribeToKeyDown();
        this.keyDown$$ = fromEvent(document, 'keydown').subscribe((/**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            // On ESC key down, remove the last vertex
            if (event.keyCode === 27) {
                _this.olDrawInteraction.removeLastPoint();
                return;
            }
            // On space bar, pan to the current mouse position
            if (event.keyCode === 32) {
                _this.olMap.getView().animate({
                    center: _this.mousePosition,
                    duration: 0
                });
                return;
            }
        }));
    };
    /**
     * Unsubscribe to key down
     */
    /**
     * Unsubscribe to key down
     * @private
     * @return {?}
     */
    DrawControl.prototype.unsubscribeToKeyDown = /**
     * Unsubscribe to key down
     * @private
     * @return {?}
     */
    function () {
        if (this.keyDown$$ !== undefined) {
            this.keyDown$$.unsubscribe();
            this.keyDown$$ = undefined;
        }
    };
    return DrawControl;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Control to modify geometries
 */
var  /**
 * Control to modify geometries
 */
ModifyControl = /** @class */ (function () {
    function ModifyControl(options) {
        this.options = options;
        /**
         * Modify start observable
         */
        this.start$ = new Subject();
        /**
         * Modify end observable
         */
        this.end$ = new Subject();
        /**
         * Geometry changes observable
         */
        this.changes$ = new Subject();
        this.olModifyInteractionIsActive = false;
        this.olTranslateInteractionIsActive = false;
        this.olDrawInteractionIsActive = false;
        this.removedOlInteractions = [];
        /**
         * Whether a modify control should be available
         */
        this.modify = true;
        /**
         * Whether a translate control should be available
         */
        this.translate = true;
        if (options.modify !== undefined) {
            this.modify = options.modify;
        }
        if (options.translate !== undefined) {
            this.translate = options.translate;
        }
        if (options.layer !== undefined) {
            this.olOverlayLayer = options.layer;
        }
        else {
            this.olOverlayLayer = this.createOlInnerOverlayLayer();
        }
        this.olLinearRingsLayer = this.createOlLinearRingsLayer();
    }
    Object.defineProperty(ModifyControl.prototype, "active", {
        /**
         * Wheter the control is active
         */
        get: /**
         * Wheter the control is active
         * @return {?}
         */
        function () {
            return this.olMap !== undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ModifyControl.prototype, "olOverlaySource", {
        /**
         * OL overlay source
         * @internal
         */
        get: /**
         * OL overlay source
         * \@internal
         * @return {?}
         */
        function () {
            return this.olOverlayLayer.getSource();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ModifyControl.prototype, "olLinearRingsSource", {
        /**
         * OL linear rings source
         * @internal
         */
        get: /**
         * OL linear rings source
         * \@internal
         * @return {?}
         */
        function () {
            return this.olLinearRingsLayer.getSource();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Add or remove this control to/from a map.
     * @param map OL Map
     */
    /**
     * Add or remove this control to/from a map.
     * @param {?} olMap
     * @return {?}
     */
    ModifyControl.prototype.setOlMap = /**
     * Add or remove this control to/from a map.
     * @param {?} olMap
     * @return {?}
     */
    function (olMap$$1) {
        if (olMap$$1 === undefined) {
            this.clearOlInnerOverlaySource();
            this.removeOlInnerOverlayLayer();
            this.removeOlModifyInteraction();
            this.removeOlTranslateInteraction();
            this.removeOlDrawInteraction();
            this.olMap = olMap$$1;
            return;
        }
        this.olMap = olMap$$1;
        this.addOlInnerOverlayLayer();
        // The order in which these interactions
        // are added is important
        if (this.modify === true) {
            this.addOlDrawInteraction();
        }
        if (this.translate === true) {
            this.addOlTranslateInteraction();
            this.activateTranslateInteraction();
        }
        if (this.modify === true) {
            this.addOlModifyInteraction();
            this.activateModifyInteraction();
        }
    };
    /**
     * Return the overlay source
     */
    /**
     * Return the overlay source
     * @return {?}
     */
    ModifyControl.prototype.getSource = /**
     * Return the overlay source
     * @return {?}
     */
    function () {
        return this.olOverlaySource;
    };
    /**
     * Add an OL geometry to the overlay and start modifying it
     * @param olGeometry Ol Geometry
     */
    /**
     * Add an OL geometry to the overlay and start modifying it
     * @param {?} olGeometry Ol Geometry
     * @return {?}
     */
    ModifyControl.prototype.setOlGeometry = /**
     * Add an OL geometry to the overlay and start modifying it
     * @param {?} olGeometry Ol Geometry
     * @return {?}
     */
    function (olGeometry) {
        /** @type {?} */
        var olFeature = new OlFeature({ geometry: olGeometry });
        this.olOverlaySource.clear();
        this.olOverlaySource.addFeature(olFeature);
    };
    /**
     * Create an overlay source if none is defined in the options
     */
    /**
     * Create an overlay source if none is defined in the options
     * @private
     * @return {?}
     */
    ModifyControl.prototype.createOlInnerOverlayLayer = /**
     * Create an overlay source if none is defined in the options
     * @private
     * @return {?}
     */
    function () {
        return new OlVectorLayer({
            source: this.options.source ? this.options.source : new OlVectorSource(),
            style: this.options.layerStyle,
            zIndex: 500
        });
    };
    /**
     * Add the overlay layer if it wasn't defined in the options
     */
    /**
     * Add the overlay layer if it wasn't defined in the options
     * @private
     * @return {?}
     */
    ModifyControl.prototype.addOlInnerOverlayLayer = /**
     * Add the overlay layer if it wasn't defined in the options
     * @private
     * @return {?}
     */
    function () {
        if (this.options.layer === undefined) {
            this.olMap.addLayer(this.olOverlayLayer);
        }
    };
    /**
     * Clear the overlay layer if it wasn't defined in the options
     */
    /**
     * Clear the overlay layer if it wasn't defined in the options
     * @private
     * @return {?}
     */
    ModifyControl.prototype.removeOlInnerOverlayLayer = /**
     * Clear the overlay layer if it wasn't defined in the options
     * @private
     * @return {?}
     */
    function () {
        if (this.options.layer === undefined && this.olMap !== undefined) {
            this.olMap.removeLayer(this.olOverlayLayer);
        }
    };
    /**
     * Clear the overlay source if it wasn't defined in the options
     */
    /**
     * Clear the overlay source if it wasn't defined in the options
     * @private
     * @return {?}
     */
    ModifyControl.prototype.clearOlInnerOverlaySource = /**
     * Clear the overlay source if it wasn't defined in the options
     * @private
     * @return {?}
     */
    function () {
        if (this.options.layer === undefined && this.options.source === undefined) {
            this.olOverlaySource.clear(true);
        }
    };
    /**
     * @private
     * @return {?}
     */
    ModifyControl.prototype.createOlLinearRingsLayer = /**
     * @private
     * @return {?}
     */
    function () {
        return new OlVectorLayer({
            source: new OlVectorSource(),
            style: createDrawHoleInteractionStyle(),
            zIndex: 500
        });
    };
    /**
     * Add the linear rings layer
     */
    /**
     * Add the linear rings layer
     * @private
     * @return {?}
     */
    ModifyControl.prototype.addOlLinearRingsLayer = /**
     * Add the linear rings layer
     * @private
     * @return {?}
     */
    function () {
        this.olMap.addLayer(this.olLinearRingsLayer);
    };
    /**
     * Clear the linear rings layer
     */
    /**
     * Clear the linear rings layer
     * @private
     * @return {?}
     */
    ModifyControl.prototype.removeOlLinearRingsLayer = /**
     * Clear the linear rings layer
     * @private
     * @return {?}
     */
    function () {
        this.olMap.removeLayer(this.olLinearRingsLayer);
    };
    /**
     * Clear the linear rings source
     */
    /**
     * Clear the linear rings source
     * @private
     * @return {?}
     */
    ModifyControl.prototype.clearOlLinearRingsSource = /**
     * Clear the linear rings source
     * @private
     * @return {?}
     */
    function () {
        this.olLinearRingsSource.clear(true);
    };
    /**
     * Add a modify interaction to the map an set up some listeners
     */
    /**
     * Add a modify interaction to the map an set up some listeners
     * @private
     * @return {?}
     */
    ModifyControl.prototype.addOlModifyInteraction = /**
     * Add a modify interaction to the map an set up some listeners
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var olModifyInteraction = new OlModify({
            source: this.olOverlaySource,
            style: this.options.drawStyle
        });
        this.olModifyInteraction = olModifyInteraction;
    };
    /**
     * Remove the modify interaction
     */
    /**
     * Remove the modify interaction
     * @private
     * @return {?}
     */
    ModifyControl.prototype.removeOlModifyInteraction = /**
     * Remove the modify interaction
     * @private
     * @return {?}
     */
    function () {
        if (this.olModifyInteraction === undefined) {
            return;
        }
        this.deactivateModifyInteraction();
        this.olModifyInteraction = undefined;
    };
    /**
     * @private
     * @return {?}
     */
    ModifyControl.prototype.activateModifyInteraction = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.olModifyInteractionIsActive === true) {
            return;
        }
        this.olModifyInteractionIsActive = true;
        this.onModifyStartKey = this.olModifyInteraction
            .on('modifystart', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.onModifyStart(event); }));
        this.onModifyEndKey = this.olModifyInteraction
            .on('modifyend', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.onModifyEnd(event); }));
        this.olMap.addInteraction(this.olModifyInteraction);
    };
    /**
     * @private
     * @return {?}
     */
    ModifyControl.prototype.deactivateModifyInteraction = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.olModifyInteractionIsActive === false) {
            return;
        }
        this.olModifyInteractionIsActive = false;
        unByKey([
            this.onModifyStartKey,
            this.onModifyEndKey,
            this.onModifyKey
        ]);
        if (this.olMap !== undefined) {
            this.olMap.removeInteraction(this.olModifyInteraction);
        }
    };
    /**
     * When modifying starts, clear the overlay and start watching for changes
     * @param event Modify start event
     */
    /**
     * When modifying starts, clear the overlay and start watching for changes
     * @private
     * @param {?} event Modify start event
     * @return {?}
     */
    ModifyControl.prototype.onModifyStart = /**
     * When modifying starts, clear the overlay and start watching for changes
     * @private
     * @param {?} event Modify start event
     * @return {?}
     */
    function (event) {
        var _this = this;
        /** @type {?} */
        var olGeometry = event.features.item(0).getGeometry();
        this.start$.next(olGeometry);
        this.onModifyKey = olGeometry.on('change', (/**
         * @param {?} olGeometryEvent
         * @return {?}
         */
        function (olGeometryEvent) {
            _this.mousePosition = getMousePositionFromOlGeometryEvent(olGeometryEvent);
            _this.changes$.next(olGeometryEvent.target);
        }));
        this.subscribeToKeyDown();
    };
    /**
     * When modifying ends, update the geometry observable and stop watching for changes
     * @param event Modify end event
     */
    /**
     * When modifying ends, update the geometry observable and stop watching for changes
     * @private
     * @param {?} event Modify end event
     * @return {?}
     */
    ModifyControl.prototype.onModifyEnd = /**
     * When modifying ends, update the geometry observable and stop watching for changes
     * @private
     * @param {?} event Modify end event
     * @return {?}
     */
    function (event) {
        unByKey(this.onModifyKey);
        this.end$.next(event.features.item(0).getGeometry());
        this.unsubscribeToKeyDown();
    };
    /**
     * Subscribe to space key down to pan the map
     */
    /**
     * Subscribe to space key down to pan the map
     * @private
     * @return {?}
     */
    ModifyControl.prototype.subscribeToKeyDown = /**
     * Subscribe to space key down to pan the map
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this.keyDown$$ = fromEvent(document, 'keydown').subscribe((/**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (event.keyCode === 32) {
                // On space bar, pan to the current mouse position
                _this.olMap.getView().animate({
                    center: _this.mousePosition,
                    duration: 0
                });
                return;
            }
        }));
    };
    /**
     * Unsubscribe to key down
     */
    /**
     * Unsubscribe to key down
     * @private
     * @return {?}
     */
    ModifyControl.prototype.unsubscribeToKeyDown = /**
     * Unsubscribe to key down
     * @private
     * @return {?}
     */
    function () {
        if (this.keyDown$$ !== undefined) {
            this.keyDown$$.unsubscribe();
        }
    };
    /**
     * Add a translate interaction to the map an set up some listeners
     */
    /**
     * Add a translate interaction to the map an set up some listeners
     * @private
     * @return {?}
     */
    ModifyControl.prototype.addOlTranslateInteraction = /**
     * Add a translate interaction to the map an set up some listeners
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var olTranslateInteraction = new OlTranslate({
            layers: [this.olOverlayLayer]
        });
        this.olTranslateInteraction = olTranslateInteraction;
    };
    /**
     * Remove the translate interaction
     */
    /**
     * Remove the translate interaction
     * @private
     * @return {?}
     */
    ModifyControl.prototype.removeOlTranslateInteraction = /**
     * Remove the translate interaction
     * @private
     * @return {?}
     */
    function () {
        if (this.olTranslateInteraction === undefined) {
            return;
        }
        this.deactivateTranslateInteraction();
        this.olTranslateInteraction = undefined;
    };
    /**
     * @private
     * @return {?}
     */
    ModifyControl.prototype.activateTranslateInteraction = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.olTranslateInteractionIsActive === true) {
            return;
        }
        this.olTranslateInteractionIsActive = true;
        this.onTranslateStartKey = this.olTranslateInteraction
            .on('translatestart', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.onTranslateStart(event); }));
        this.onTranslateEndKey = this.olTranslateInteraction
            .on('translateend', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.onTranslateEnd(event); }));
        this.olMap.addInteraction(this.olTranslateInteraction);
    };
    /**
     * @private
     * @return {?}
     */
    ModifyControl.prototype.deactivateTranslateInteraction = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.olTranslateInteractionIsActive === false) {
            return;
        }
        this.olTranslateInteractionIsActive = false;
        unByKey([
            this.onTranslateStartKey,
            this.onTranslateEndKey,
            this.onTranslateKey
        ]);
        if (this.olMap !== undefined) {
            this.olMap.removeInteraction(this.olTranslateInteraction);
        }
    };
    /**
     * When translation starts, clear the overlay and start watching for changes
     * @param event Translate start event
     */
    /**
     * When translation starts, clear the overlay and start watching for changes
     * @private
     * @param {?} event Translate start event
     * @return {?}
     */
    ModifyControl.prototype.onTranslateStart = /**
     * When translation starts, clear the overlay and start watching for changes
     * @private
     * @param {?} event Translate start event
     * @return {?}
     */
    function (event) {
        var _this = this;
        /** @type {?} */
        var olGeometry = event.features.item(0).getGeometry();
        this.start$.next(olGeometry);
        this.onTranslateKey = olGeometry.on('change', (/**
         * @param {?} olGeometryEvent
         * @return {?}
         */
        function (olGeometryEvent) {
            _this.changes$.next(olGeometryEvent.target);
        }));
    };
    /**
     * When translation ends, update the geometry observable and stop watchign for changes
     * @param event Translate end event
     */
    /**
     * When translation ends, update the geometry observable and stop watchign for changes
     * @private
     * @param {?} event Translate end event
     * @return {?}
     */
    ModifyControl.prototype.onTranslateEnd = /**
     * When translation ends, update the geometry observable and stop watchign for changes
     * @private
     * @param {?} event Translate end event
     * @return {?}
     */
    function (event) {
        unByKey(this.onTranslateKey);
        this.end$.next(event.features.item(0).getGeometry());
    };
    /**
     * Add a draw interaction to the map an set up some listeners
     */
    /**
     * Add a draw interaction to the map an set up some listeners
     * @private
     * @return {?}
     */
    ModifyControl.prototype.addOlDrawInteraction = /**
     * Add a draw interaction to the map an set up some listeners
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var olDrawInteraction = new OlDraw({
            type: 'Polygon',
            source: this.olLinearRingsSource,
            stopClick: true,
            style: createDrawHoleInteractionStyle(),
            condition: (/**
             * @param {?} event
             * @return {?}
             */
            function (event) {
                /** @type {?} */
                var olOuterGeometry = _this.olOuterGeometry || _this.getOlGeometry();
                /** @type {?} */
                var intersects$$1 = olOuterGeometry.intersectsCoordinate(event.coordinate);
                return intersects$$1;
            })
        });
        this.olDrawInteraction = olDrawInteraction;
        this.subscribeToDrawKeyDown();
    };
    /**
     * Subscribe to CTRL key down to activate the draw control
     */
    /**
     * Subscribe to CTRL key down to activate the draw control
     * @private
     * @return {?}
     */
    ModifyControl.prototype.subscribeToDrawKeyDown = /**
     * Subscribe to CTRL key down to activate the draw control
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this.drawKeyDown$$ = fromEvent(document, 'keydown').subscribe((/**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (event.keyCode !== 17) {
                return;
            }
            _this.unsubscribeToDrawKeyDown();
            /** @type {?} */
            var olGeometry = _this.getOlGeometry();
            if (!olGeometry || !(olGeometry instanceof OlPolygon)) {
                return;
            }
            _this.subscribeToDrawKeyUp();
            _this.deactivateModifyInteraction();
            _this.deactivateTranslateInteraction();
            _this.activateDrawInteraction();
        }));
    };
    /**
     * Subscribe to CTRL key up to deactivate the draw control
     */
    /**
     * Subscribe to CTRL key up to deactivate the draw control
     * @private
     * @return {?}
     */
    ModifyControl.prototype.subscribeToDrawKeyUp = /**
     * Subscribe to CTRL key up to deactivate the draw control
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this.drawKeyUp$$ = fromEvent(document, 'keyup')
            .subscribe((/**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (event.keyCode !== 17) {
                return;
            }
            _this.unsubscribeToDrawKeyUp();
            _this.unsubscribeToKeyDown();
            _this.deactivateDrawInteraction();
            _this.activateModifyInteraction();
            if (_this.translate === true) {
                _this.activateTranslateInteraction();
            }
            _this.subscribeToDrawKeyDown();
            _this.olOuterGeometry = undefined;
            _this.clearOlLinearRingsSource();
            _this.end$.next(_this.getOlGeometry());
        }));
    };
    /**
     * Unsubscribe to draw key down
     */
    /**
     * Unsubscribe to draw key down
     * @private
     * @return {?}
     */
    ModifyControl.prototype.unsubscribeToDrawKeyDown = /**
     * Unsubscribe to draw key down
     * @private
     * @return {?}
     */
    function () {
        if (this.drawKeyDown$$ !== undefined) {
            this.drawKeyDown$$.unsubscribe();
        }
    };
    /**
     * Unsubscribe to key up
     */
    /**
     * Unsubscribe to key up
     * @private
     * @return {?}
     */
    ModifyControl.prototype.unsubscribeToDrawKeyUp = /**
     * Unsubscribe to key up
     * @private
     * @return {?}
     */
    function () {
        if (this.drawKeyUp$$ !== undefined) {
            this.drawKeyUp$$.unsubscribe();
        }
    };
    /**
     * Remove the draw interaction
     */
    /**
     * Remove the draw interaction
     * @private
     * @return {?}
     */
    ModifyControl.prototype.removeOlDrawInteraction = /**
     * Remove the draw interaction
     * @private
     * @return {?}
     */
    function () {
        if (this.olDrawInteraction === undefined) {
            return;
        }
        this.unsubscribeToKeyDown();
        this.unsubscribeToDrawKeyUp();
        this.unsubscribeToDrawKeyDown();
        this.deactivateDrawInteraction();
        this.clearOlLinearRingsSource();
        this.olDrawInteraction = undefined;
    };
    /**
     * Activate the draw interaction
     */
    /**
     * Activate the draw interaction
     * @private
     * @return {?}
     */
    ModifyControl.prototype.activateDrawInteraction = /**
     * Activate the draw interaction
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.olDrawInteractionIsActive === true) {
            return;
        }
        this.clearOlLinearRingsSource();
        this.addOlLinearRingsLayer();
        this.olMap.getInteractions().forEach((/**
         * @param {?} olInteraction
         * @return {?}
         */
        function (olInteraction) {
            if (olInteraction instanceof OlDragBoxInteraction) {
                _this.olMap.removeInteraction(olInteraction);
                _this.removedOlInteractions.push(olInteraction);
            }
        }));
        this.olDrawInteractionIsActive = true;
        this.onDrawStartKey = this.olDrawInteraction
            .on('drawstart', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.onDrawStart(event); }));
        this.onDrawEndKey = this.olDrawInteraction
            .on('drawend', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.onDrawEnd(event); }));
        this.olMap.addInteraction(this.olDrawInteraction);
    };
    /**
     * Deactivate the draw interaction
     */
    /**
     * Deactivate the draw interaction
     * @private
     * @return {?}
     */
    ModifyControl.prototype.deactivateDrawInteraction = /**
     * Deactivate the draw interaction
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.olDrawInteractionIsActive === false) {
            return;
        }
        this.removeOlLinearRingsLayer();
        this.removedOlInteractions.forEach((/**
         * @param {?} olInteraction
         * @return {?}
         */
        function (olInteraction) {
            _this.olMap.addInteraction(olInteraction);
        }));
        this.removedOlInteractions = [];
        this.olDrawInteractionIsActive = false;
        unByKey([
            this.onDrawStartKey,
            this.onDrawEndKey,
            this.onDrawKey
        ]);
        if (this.olMap !== undefined) {
            this.olMap.removeInteraction(this.olDrawInteraction);
        }
    };
    /**
     * When draw start, add a new linerar ring to the geometry and start watching for changes
     * @param event Draw start event
     */
    /**
     * When draw start, add a new linerar ring to the geometry and start watching for changes
     * @private
     * @param {?} event Draw start event
     * @return {?}
     */
    ModifyControl.prototype.onDrawStart = /**
     * When draw start, add a new linerar ring to the geometry and start watching for changes
     * @private
     * @param {?} event Draw start event
     * @return {?}
     */
    function (event) {
        var _this = this;
        /** @type {?} */
        var olGeometry = event.feature.getGeometry();
        this.olOuterGeometry = this.getOlGeometry().clone();
        /** @type {?} */
        var linearRingCoordinates = olGeometry.getLinearRing().getCoordinates();
        this.addLinearRingToOlGeometry(linearRingCoordinates);
        this.start$.next(this.getOlGeometry());
        this.onDrawKey = olGeometry.on('change', (/**
         * @param {?} olGeometryEvent
         * @return {?}
         */
        function (olGeometryEvent) {
            _this.mousePosition = getMousePositionFromOlGeometryEvent(olGeometryEvent);
            /** @type {?} */
            var _linearRingCoordinates = olGeometryEvent.target.getLinearRing().getCoordinates();
            _this.updateLinearRingOfOlGeometry(_linearRingCoordinates);
            _this.changes$.next(_this.getOlGeometry());
        }));
        this.subscribeToKeyDown();
    };
    /**
     * When translation ends, update the geometry observable and stop watchign for changes
     * @param event Draw end event
     */
    /**
     * When translation ends, update the geometry observable and stop watchign for changes
     * @private
     * @param {?} event Draw end event
     * @return {?}
     */
    ModifyControl.prototype.onDrawEnd = /**
     * When translation ends, update the geometry observable and stop watchign for changes
     * @private
     * @param {?} event Draw end event
     * @return {?}
     */
    function (event) {
        unByKey(this.onDrawKey);
        this.olOuterGeometry = undefined;
        /** @type {?} */
        var linearRingCoordinates = event.feature.getGeometry().getLinearRing().getCoordinates();
        this.updateLinearRingOfOlGeometry(linearRingCoordinates);
        this.clearOlLinearRingsSource();
        this.end$.next(this.getOlGeometry());
        this.unsubscribeToKeyDown();
    };
    /**
     * Add a linear ring to the geometry being modified
     * @param coordinates Linear ring coordinates
     */
    /**
     * Add a linear ring to the geometry being modified
     * @private
     * @param {?} coordinates Linear ring coordinates
     * @return {?}
     */
    ModifyControl.prototype.addLinearRingToOlGeometry = /**
     * Add a linear ring to the geometry being modified
     * @private
     * @param {?} coordinates Linear ring coordinates
     * @return {?}
     */
    function (coordinates) {
        /** @type {?} */
        var olGeometry = this.getOlGeometry();
        /** @type {?} */
        var olLinearRing = new OlLinearRing(coordinates);
        addLinearRingToOlPolygon(olGeometry, olLinearRing);
    };
    /**
     * Update the last linear ring of the geometry being modified
     * @param coordinates Linear ring coordinates
     */
    /**
     * Update the last linear ring of the geometry being modified
     * @private
     * @param {?} coordinates Linear ring coordinates
     * @return {?}
     */
    ModifyControl.prototype.updateLinearRingOfOlGeometry = /**
     * Update the last linear ring of the geometry being modified
     * @private
     * @param {?} coordinates Linear ring coordinates
     * @return {?}
     */
    function (coordinates) {
        /** @type {?} */
        var olGeometry = this.getOlGeometry();
        // Remove the last linear ring (the one we are updating)
        /** @type {?} */
        var olLinearRings = olGeometry.getLinearRings().slice(0, -1);
        /** @type {?} */
        var newCoordinates = olLinearRings.map((/**
         * @param {?} olLinearRing
         * @return {?}
         */
        function (olLinearRing) {
            return olLinearRing.getCoordinates();
        }));
        newCoordinates.push(coordinates);
        olGeometry.setCoordinates(newCoordinates);
    };
    /**
     * Get the geometry being modified
     * @returns OL Geometry
     */
    /**
     * Get the geometry being modified
     * @private
     * @return {?} OL Geometry
     */
    ModifyControl.prototype.getOlGeometry = /**
     * Get the geometry being modified
     * @private
     * @return {?} OL Geometry
     */
    function () {
        /** @type {?} */
        var olFeatures = this.olOverlaySource.getFeatures();
        return olFeatures.length > 0 ? olFeatures[0].getGeometry() : undefined;
    };
    return ModifyControl;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Control to modify geometries
 */
var  /**
 * Control to modify geometries
 */
SliceControl = /** @class */ (function () {
    function SliceControl(options) {
        this.options = options;
        /**
         * Slice end observable
         */
        this.end$ = new Subject();
        /**
         * Slice error, if any
         */
        this.error$ = new Subject();
        if (options.layer !== undefined) {
            this.olOverlayLayer = options.layer;
        }
        else {
            this.olOverlayLayer = this.createOlInnerOverlayLayer();
        }
    }
    Object.defineProperty(SliceControl.prototype, "active", {
        /**
         * Wheter the control is active
         */
        get: /**
         * Wheter the control is active
         * @return {?}
         */
        function () {
            return this.olMap !== undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SliceControl.prototype, "olOverlaySource", {
        /**
         * OL overlay source
         * @internal
         */
        get: /**
         * OL overlay source
         * \@internal
         * @return {?}
         */
        function () {
            return this.olOverlayLayer.getSource();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Add or remove this control to/from a map.
     * @param map OL Map
     */
    /**
     * Add or remove this control to/from a map.
     * @param {?} olMap
     * @return {?}
     */
    SliceControl.prototype.setOlMap = /**
     * Add or remove this control to/from a map.
     * @param {?} olMap
     * @return {?}
     */
    function (olMap$$1) {
        if (olMap$$1 === undefined) {
            this.clearOlInnerOverlaySource();
            this.removeOlInnerOverlayLayer();
            this.removeDrawLineControl();
            this.olMap = olMap$$1;
            return;
        }
        this.olMap = olMap$$1;
        this.addOlInnerOverlayLayer();
        this.addDrawLineControl();
    };
    /**
     * Return the overlay source
     */
    /**
     * Return the overlay source
     * @return {?}
     */
    SliceControl.prototype.getSource = /**
     * Return the overlay source
     * @return {?}
     */
    function () {
        return this.olOverlaySource;
    };
    /**
     * Add an OL geometry to the overlay for slicing
     * @param olGeometry Ol Geometry
     */
    /**
     * Add an OL geometry to the overlay for slicing
     * @param {?} olGeometry Ol Geometry
     * @return {?}
     */
    SliceControl.prototype.setOlGeometry = /**
     * Add an OL geometry to the overlay for slicing
     * @param {?} olGeometry Ol Geometry
     * @return {?}
     */
    function (olGeometry) {
        /** @type {?} */
        var olFeature = new OlFeature({ geometry: olGeometry });
        this.olOverlaySource.clear(true);
        this.olOverlaySource.addFeature(olFeature);
    };
    /**
     * Create an overlay source if none is defined in the options
     */
    /**
     * Create an overlay source if none is defined in the options
     * @private
     * @return {?}
     */
    SliceControl.prototype.createOlInnerOverlayLayer = /**
     * Create an overlay source if none is defined in the options
     * @private
     * @return {?}
     */
    function () {
        return new OlVectorLayer({
            source: this.options.source ? this.options.source : new OlVectorSource(),
            style: this.options.layerStyle,
            zIndex: 500
        });
    };
    /**
     * Clear the overlay layer if it wasn't defined in the options
     */
    /**
     * Clear the overlay layer if it wasn't defined in the options
     * @private
     * @return {?}
     */
    SliceControl.prototype.removeOlInnerOverlayLayer = /**
     * Clear the overlay layer if it wasn't defined in the options
     * @private
     * @return {?}
     */
    function () {
        if (this.options.layer === undefined && this.olMap !== undefined) {
            this.olMap.removeLayer(this.olOverlayLayer);
        }
    };
    /**
     * Add the overlay layer if it wasn't defined in the options
     */
    /**
     * Add the overlay layer if it wasn't defined in the options
     * @private
     * @return {?}
     */
    SliceControl.prototype.addOlInnerOverlayLayer = /**
     * Add the overlay layer if it wasn't defined in the options
     * @private
     * @return {?}
     */
    function () {
        if (this.options.layer === undefined) {
            this.olMap.addLayer(this.olOverlayLayer);
        }
    };
    /**
     * Clear the overlay source if it wasn't defined in the options
     */
    /**
     * Clear the overlay source if it wasn't defined in the options
     * @private
     * @return {?}
     */
    SliceControl.prototype.clearOlInnerOverlaySource = /**
     * Clear the overlay source if it wasn't defined in the options
     * @private
     * @return {?}
     */
    function () {
        if (this.options.layer === undefined && this.options.source === undefined) {
            this.olOverlaySource.clear(true);
        }
    };
    /**
     * Create a draw line control and add it to the map
     */
    /**
     * Create a draw line control and add it to the map
     * @private
     * @return {?}
     */
    SliceControl.prototype.addDrawLineControl = /**
     * Create a draw line control and add it to the map
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this.drawLineControl = new DrawControl({
            geometryType: 'LineString',
            drawStyle: this.options.drawStyle,
            maxPoints: 2
        });
        this.drawLineStart$$ = this.drawLineControl.start$
            .subscribe((/**
         * @param {?} olLine
         * @return {?}
         */
        function (olLine) { return _this.onDrawLineStart(olLine); }));
        this.drawLineEnd$$ = this.drawLineControl.end$
            .subscribe((/**
         * @param {?} olLine
         * @return {?}
         */
        function (olLine) { return _this.onDrawLineEnd(olLine); }));
        this.drawLineControl.setOlMap(this.olMap);
    };
    /**
     * Remove draw line control
     */
    /**
     * Remove draw line control
     * @private
     * @return {?}
     */
    SliceControl.prototype.removeDrawLineControl = /**
     * Remove draw line control
     * @private
     * @return {?}
     */
    function () {
        if (this.drawLineControl === undefined) {
            return;
        }
        this.drawLineStart$$.unsubscribe();
        this.drawLineEnd$$.unsubscribe();
        this.drawLineControl.getSource().clear(true);
        this.drawLineControl.setOlMap(undefined);
    };
    /**
     * Clear the draw source and track the geometry being draw
     * @param olLine Ol linestring or polygon
     */
    /**
     * Clear the draw source and track the geometry being draw
     * @private
     * @param {?} olLine Ol linestring or polygon
     * @return {?}
     */
    SliceControl.prototype.onDrawLineStart = /**
     * Clear the draw source and track the geometry being draw
     * @private
     * @param {?} olLine Ol linestring or polygon
     * @return {?}
     */
    function (olLine) {
        this.drawLineControl.getSource().clear(true);
    };
    /**
     * Slice the first geometry encountered with the drawn line
     * @param olLine Ol linestring
     */
    /**
     * Slice the first geometry encountered with the drawn line
     * @private
     * @param {?} olLine Ol linestring
     * @return {?}
     */
    SliceControl.prototype.onDrawLineEnd = /**
     * Slice the first geometry encountered with the drawn line
     * @private
     * @param {?} olLine Ol linestring
     * @return {?}
     */
    function (olLine) {
        var _this = this;
        /** @type {?} */
        var olSlicedGeometries = [];
        /** @type {?} */
        var lineExtent = olLine.getExtent();
        /** @type {?} */
        var olFeaturesToRemove = [];
        try {
            this.olOverlaySource.forEachFeatureInExtent(lineExtent, (/**
             * @param {?} olFeature
             * @return {?}
             */
            function (olFeature) {
                /** @type {?} */
                var olGeometry = olFeature.getGeometry();
                /** @type {?} */
                var olParts = sliceOlGeometry(olGeometry, olLine);
                if (olParts.length > 0) {
                    olSlicedGeometries.push.apply(olSlicedGeometries, __spread(olParts));
                    olFeaturesToRemove.push(olFeature);
                }
            }));
        }
        catch (e) {
            if (e instanceof GeometrySliceError) {
                this.error$.next(e);
                return;
            }
            else {
                throw e;
            }
        }
        this.drawLineControl.getSource().clear(true);
        this.olOverlaySource.addFeatures(olSlicedGeometries.map((/**
         * @param {?} olGeometry
         * @return {?}
         */
        function (olGeometry) { return new OlFeature(olGeometry); })));
        olFeaturesToRemove.forEach((/**
         * @param {?} olFeature
         * @return {?}
         */
        function (olFeature) {
            _this.olOverlaySource.removeFeature(olFeature);
        }));
        this.error$.next(undefined);
        this.end$.next(olSlicedGeometries);
    };
    return SliceControl;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var MeasurerDialogComponent = /** @class */ (function () {
    function MeasurerDialogComponent(dialogRef, data) {
        this.dialogRef = dialogRef;
        this.data = data;
        this.measureAreaUnit = MeasureAreaUnit;
        this.measureLengthUnit = MeasureLengthUnit;
    }
    /**
     * @return {?}
     */
    MeasurerDialogComponent.prototype.onNoClick = /**
     * @return {?}
     */
    function () {
        this.dialogRef.close();
    };
    MeasurerDialogComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igo-measurer-dialog',
                    template: "<div mat-dialog-content>\r\n  <h3>{{'igo.geo.measure.dialog.title' | translate}}</h3>\r\n\r\n  <table>\r\n    <thead>\r\n      <tr>\r\n        <th colspan=\"2\">{{'igo.geo.measure.dialog.length.title' | translate}}</th>\r\n      </tr>\r\n    </thead>\r\n    <tbody>\r\n      <tr>\r\n        <td>{{'igo.geo.measure.dialog.lengthInMeters' | translate}}</td>\r\n        <td>{{data.length | measureFormat: measureLengthUnit.Meters}}</td>\r\n      </tr>\r\n      <tr>\r\n        <td>{{'igo.geo.measure.dialog.lengthInKilometers' | translate}}</td>\r\n        <td>{{data.length | measureFormat: measureLengthUnit.Kilometers}}</td>\r\n      </tr>\r\n      <tr>\r\n        <td>{{'igo.geo.measure.dialog.lengthInMiles' | translate}}</td>\r\n        <td>{{data.length | measureFormat: measureLengthUnit.Miles}}</td>\r\n      </tr>\r\n      <tr>\r\n        <td>{{'igo.geo.measure.dialog.lengthInFeet' | translate}}</td>\r\n        <td>{{data.length | measureFormat: measureLengthUnit.Feet}}</td>\r\n      </tr>\r\n    </tbody>\r\n  </table>\r\n\r\n  <table>\r\n    <thead>\r\n      <tr>\r\n        <th colspan=\"2\">{{'igo.geo.measure.dialog.area.title' | translate}}</th>\r\n      </tr>\r\n    </thead>\r\n    <tbody>\r\n      <tr>\r\n        <td>{{'igo.geo.measure.dialog.areaInSquareMeters' | translate}}</td>\r\n        <td>{{data.area | measureFormat: measureAreaUnit.SquareMeters}}</td>\r\n      </tr>\r\n      <tr>\r\n        <td>{{'igo.geo.measure.dialog.areaInSquareKilometers' | translate}}</td>\r\n        <td>{{data.area | measureFormat:measureAreaUnit.SquareKilometers}}</td>\r\n      </tr>\r\n      <tr>\r\n        <td>{{'igo.geo.measure.dialog.areaInSquareMiles' | translate}}</td>\r\n        <td>{{data.area | measureFormat: measureAreaUnit.SquareMiles}}</td>\r\n      </tr>\r\n      <tr>\r\n        <td>{{'igo.geo.measure.dialog.areaInAcres' | translate}}</td>\r\n        <td>{{data.area | measureFormat: measureAreaUnit.Acres}}</td>\r\n      </tr>\r\n      <tr>\r\n        <td>{{'igo.geo.measure.dialog.areaInHectares' | translate}}</td>\r\n        <td>{{data.area | measureFormat: measureAreaUnit.Hectares}}</td>\r\n      </tr>\r\n      <tr>\r\n        <td>{{'igo.geo.measure.dialog.perimeterInMeters' | translate}}</td>\r\n        <td>{{data.perimeter | measureFormat: measureLengthUnit.Meters}}</td>\r\n      </tr>\r\n    </tbody>\r\n  </table>\r\n</div>\r\n",
                    styles: [":host{font-family:Roboto,\"Helvetica Neue\",sans-serif}h3{text-align:center;margin:0}table{width:100%;padding:10px}table tbody tr td:last-child{padding-left:10px}"]
                }] }
    ];
    /** @nocollapse */
    MeasurerDialogComponent.ctorParameters = function () { return [
        { type: MatDialogRef },
        { type: undefined, decorators: [{ type: Inject, args: [MAT_DIALOG_DATA,] }] }
    ]; };
    return MeasurerDialogComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Tool to measure lengths and areas
 */
var MeasurerComponent = /** @class */ (function () {
    function MeasurerComponent(languageService, dialog) {
        var _this = this;
        this.languageService = languageService;
        this.dialog = dialog;
        /**
         * Table template
         * \@internal
         */
        this.tableTemplate = {
            selection: true,
            selectMany: true,
            selectionCheckbox: true,
            sort: true,
            columns: [
                {
                    name: 'length',
                    title: this.languageService.translate.instant('igo.geo.measure.lengthHeader'),
                    valueAccessor: (/**
                     * @param {?} feature
                     * @return {?}
                     */
                    function (feature) {
                        /** @type {?} */
                        var unit = _this.activeLengthUnit;
                        /** @type {?} */
                        var measure = metersToUnit(feature.properties.measure.length, unit);
                        return formatMeasure(measure, {
                            decimal: 1,
                            unit: unit,
                            unitAbbr: false,
                            locale: 'fr'
                        });
                    })
                },
                {
                    name: 'area',
                    title: this.languageService.translate.instant('igo.geo.measure.areaHeader'),
                    valueAccessor: (/**
                     * @param {?} feature
                     * @return {?}
                     */
                    function (feature) {
                        /** @type {?} */
                        var unit = _this.activeAreaUnit;
                        /** @type {?} */
                        var measure = squareMetersToUnit(feature.properties.measure.area, unit);
                        return measure ? formatMeasure(measure, {
                            decimal: 1,
                            unit: unit,
                            unitAbbr: false,
                            locale: 'fr'
                        }) : '';
                    })
                }
            ]
        };
        /**
         * Reference to the MeasureType enum
         * \@internal
         */
        this.measureType = MeasureType;
        /**
         * Reference to the AreaMeasureUnit enum
         * \@internal
         */
        this.measureAreaUnit = MeasureAreaUnit;
        /**
         * Reference to the LengthMeasureUnit enum
         * \@internal
         */
        this.measureLengthUnit = MeasureLengthUnit;
        /**
         * Whether measure units should be automatically determined
         * \@internal
         */
        this.measureUnitsAuto = false;
        /**
         * Observable of area
         * \@internal
         */
        this.measure$ = new BehaviorSubject({});
        /**
         * Observable of selected features
         * \@internal
         */
        this.selectedFeatures$ = new BehaviorSubject([]);
        /**
         * OL draw source
         * \@internal
         */
        this.showTooltips = true;
        /**
         * Active mlength unit
         */
        this.activeLengthUnit = MeasureLengthUnit.Meters;
        /**
         * Active area unit
         */
        this.activeAreaUnit = MeasureAreaUnit.SquareMeters;
        /**
         * OL draw source
         */
        this.olDrawSource = new OlVectorSource();
        this._activeMeasureType = MeasureType.Length;
        /**
         * The minimum length a segment must have to display a tooltip.
         * It also applies to area tooltips.
         */
        this.minSegmentLength = 10;
    }
    Object.defineProperty(MeasurerComponent.prototype, "activeMeasureType", {
        get: /**
         * @return {?}
         */
        function () { return this._activeMeasureType; },
        /**
         * Measure type
         * @internal
         */
        set: /**
         * Measure type
         * \@internal
         * @param {?} value
         * @return {?}
         */
        function (value) { this.setActiveMeasureType(value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeasurerComponent.prototype, "drawControlIsActive", {
        /**
         * Wheter one of the draw control is active
         * @internal
         */
        get: /**
         * Wheter one of the draw control is active
         * \@internal
         * @return {?}
         */
        function () {
            return this.activeDrawControl !== undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeasurerComponent.prototype, "projection", {
        get: /**
         * @return {?}
         */
        function () {
            return this.map.ol.getView().getProjection();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Add draw controls and activate one
     * @internal
     */
    /**
     * Add draw controls and activate one
     * \@internal
     * @return {?}
     */
    MeasurerComponent.prototype.ngOnInit = /**
     * Add draw controls and activate one
     * \@internal
     * @return {?}
     */
    function () {
        this.initStore();
        this.createDrawLineControl();
        this.createDrawPolygonControl();
        this.createModifyControl();
        this.toggleDrawControl();
        this.onToggleTooltips(this.showTooltips);
        this.updateTooltipsOfOlSource(this.store.source.ol);
    };
    /**
     * Clear the overlay layer and any interaction added by this component.
     * @internal
     */
    /**
     * Clear the overlay layer and any interaction added by this component.
     * \@internal
     * @return {?}
     */
    MeasurerComponent.prototype.ngOnDestroy = /**
     * Clear the overlay layer and any interaction added by this component.
     * \@internal
     * @return {?}
     */
    function () {
        this.setActiveMeasureType(undefined);
        this.deactivateModifyControl();
        this.freezeStore();
    };
    /**
     * Set the measure type
     * @internal
     */
    /**
     * Set the measure type
     * \@internal
     * @param {?} measureType
     * @return {?}
     */
    MeasurerComponent.prototype.onMeasureTypeChange = /**
     * Set the measure type
     * \@internal
     * @param {?} measureType
     * @return {?}
     */
    function (measureType) {
        this.activeMeasureType = measureType;
    };
    /**
     * Activate or deactivate the current draw control
     * @internal
     */
    /**
     * Activate or deactivate the current draw control
     * \@internal
     * @param {?} toggle
     * @return {?}
     */
    MeasurerComponent.prototype.onToggleDrawControl = /**
     * Activate or deactivate the current draw control
     * \@internal
     * @param {?} toggle
     * @return {?}
     */
    function (toggle) {
        if (toggle === true) {
            this.toggleDrawControl();
        }
        else {
            this.deactivateDrawControl();
        }
    };
    /**
     * Activate or deactivate the current draw control
     * @internal
     */
    /**
     * Activate or deactivate the current draw control
     * \@internal
     * @param {?} toggle
     * @return {?}
     */
    MeasurerComponent.prototype.onToggleTooltips = /**
     * Activate or deactivate the current draw control
     * \@internal
     * @param {?} toggle
     * @return {?}
     */
    function (toggle) {
        this.showTooltips = toggle;
        if (toggle === true) {
            this.showTooltipsOfOlSource(this.store.source.ol);
        }
        else {
            this.clearTooltipsOfOlSource(this.store.source.ol);
        }
    };
    /**
     * Activate or deactivate the current draw control
     * @internal
     */
    /**
     * Activate or deactivate the current draw control
     * \@internal
     * @param {?} toggle
     * @return {?}
     */
    MeasurerComponent.prototype.onToggleMeasureUnitsAuto = /**
     * Activate or deactivate the current draw control
     * \@internal
     * @param {?} toggle
     * @return {?}
     */
    function (toggle) {
        this.measureUnitsAuto = toggle;
    };
    /**
     * Set the measure type
     * @internal
     */
    /**
     * Set the measure type
     * \@internal
     * @param {?} unit
     * @return {?}
     */
    MeasurerComponent.prototype.onLengthUnitChange = /**
     * Set the measure type
     * \@internal
     * @param {?} unit
     * @return {?}
     */
    function (unit) {
        this.activeLengthUnit = unit;
        this.table.refresh();
        this.updateTooltipsOfOlSource(this.store.source.ol);
        if (this.activeOlGeometry !== undefined) {
            this.updateTooltipsOfOlGeometry(this.activeOlGeometry);
        }
    };
    /**
     * Set the measure type
     * @internal
     */
    /**
     * Set the measure type
     * \@internal
     * @param {?} unit
     * @return {?}
     */
    MeasurerComponent.prototype.onAreaUnitChange = /**
     * Set the measure type
     * \@internal
     * @param {?} unit
     * @return {?}
     */
    function (unit) {
        this.activeAreaUnit = unit;
        this.table.refresh();
        this.updateTooltipsOfOlSource(this.store.source.ol);
        if (this.activeOlGeometry !== undefined) {
            this.updateTooltipsOfOlGeometry(this.activeOlGeometry);
        }
    };
    /**
     * @return {?}
     */
    MeasurerComponent.prototype.onCalculateClick = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var features = this.selectedFeatures$.value;
        /** @type {?} */
        var area = features.reduce((/**
         * @param {?} sum
         * @param {?} feature
         * @return {?}
         */
        function (sum, feature) {
            return sum + feature.properties.measure.area || 0;
        }), 0);
        /** @type {?} */
        var length = features.reduce((/**
         * @param {?} sum
         * @param {?} feature
         * @return {?}
         */
        function (sum, feature) {
            if (feature.geometry.type === 'Polygon') {
                return sum;
            }
            return sum + feature.properties.measure.length || 0;
        }), 0);
        /** @type {?} */
        var perimeter = features.reduce((/**
         * @param {?} sum
         * @param {?} feature
         * @return {?}
         */
        function (sum, feature) {
            if (feature.geometry.type === 'LineString') {
                return sum;
            }
            return sum + feature.properties.measure.length || 0;
        }), 0);
        this.openDialog({
            area: area,
            length: length,
            perimeter: perimeter
        });
    };
    /**
     * @return {?}
     */
    MeasurerComponent.prototype.onDeleteClick = /**
     * @return {?}
     */
    function () {
        this.store.deleteMany(this.selectedFeatures$.value);
    };
    /**
     * @return {?}
     */
    MeasurerComponent.prototype.onModifyClick = /**
     * @return {?}
     */
    function () {
        if (this.selectedFeatures$.value.length !== 1) {
            return;
        }
        if (this.modifyControl.active === true) {
            this.deactivateModifyControl();
            this.toggleDrawControl();
        }
        else {
            /** @type {?} */
            var feature_1 = this.selectedFeatures$.value[0];
            /** @type {?} */
            var olFeatures = this.store.layer.ol.getSource().getFeatures();
            /** @type {?} */
            var olFeature = olFeatures.find((/**
             * @param {?} _olFeature
             * @return {?}
             */
            function (_olFeature) {
                return _olFeature.get('id') === feature_1.properties.id;
            }));
            if (olFeature !== undefined) {
                this.deactivateDrawControl();
                this.activateModifyControl();
                /** @type {?} */
                var olGeometry = olFeature.getGeometry();
                this.clearTooltipsOfOlGeometry(olGeometry);
                this.modifyControl.setOlGeometry(olGeometry);
            }
        }
    };
    /**
     * @private
     * @param {?} data
     * @return {?}
     */
    MeasurerComponent.prototype.openDialog = /**
     * @private
     * @param {?} data
     * @return {?}
     */
    function (data) {
        this.dialog.open(MeasurerDialogComponent, { data: data });
    };
    /**
     * Initialize the measure store and set up some listeners
     * @internal
     */
    /**
     * Initialize the measure store and set up some listeners
     * \@internal
     * @private
     * @return {?}
     */
    MeasurerComponent.prototype.initStore = /**
     * Initialize the measure store and set up some listeners
     * \@internal
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var store = this.store;
        /** @type {?} */
        var layer = new VectorLayer({
            title: 'Measures',
            zIndex: 200,
            source: new FeatureDataSource(),
            style: createMeasureLayerStyle(),
            showInLayerList: false,
            exportable: false,
            browsable: false
        });
        tryBindStoreLayer(store, layer);
        tryAddLoadingStrategy(store);
        tryAddSelectionStrategy(store, new FeatureStoreSelectionStrategy({
            map: this.map,
            many: true
        }));
        this.onFeatureAddedKey = store.source.ol.on('addfeature', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            /** @type {?} */
            var feature = event.feature;
            /** @type {?} */
            var olGeometry = feature.getGeometry();
            _this.updateMeasureOfOlGeometry(olGeometry, feature.get('measure'));
        }));
        this.onFeatureRemovedKey = store.source.ol.on('removefeature', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            /** @type {?} */
            var olGeometry = event.feature.getGeometry();
            _this.clearTooltipsOfOlGeometry(olGeometry);
        }));
        this.selectedFeatures$$ = store.stateView.manyBy$((/**
         * @param {?} record
         * @return {?}
         */
        function (record) {
            return record.state.selected === true;
        })).pipe(skip(1) // Skip initial emission
        )
            .subscribe((/**
         * @param {?} records
         * @return {?}
         */
        function (records) {
            if (_this.modifyControl.active === true) {
                _this.deactivateModifyControl();
            }
            _this.selectedFeatures$.next(records.map((/**
             * @param {?} record
             * @return {?}
             */
            function (record) { return record.entity; })));
        }));
    };
    /**
     * Freeze any store, meaning the layer is removed, strategies are deactivated
     * and some listener removed
     * @internal
     */
    /**
     * Freeze any store, meaning the layer is removed, strategies are deactivated
     * and some listener removed
     * \@internal
     * @private
     * @return {?}
     */
    MeasurerComponent.prototype.freezeStore = /**
     * Freeze any store, meaning the layer is removed, strategies are deactivated
     * and some listener removed
     * \@internal
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var store = this.store;
        this.selectedFeatures$$.unsubscribe();
        unByKey(this.onFeatureAddedKey);
        unByKey(this.onFeatureRemovedKey);
        this.clearTooltipsOfOlSource(store.source.ol);
        this.map.removeLayer(store.layer);
        store.deactivateStrategyOfType(FeatureStoreLoadingStrategy);
        store.deactivateStrategyOfType(FeatureStoreSelectionStrategy);
    };
    /**
     * Create a draw line control
     */
    /**
     * Create a draw line control
     * @private
     * @return {?}
     */
    MeasurerComponent.prototype.createDrawLineControl = /**
     * Create a draw line control
     * @private
     * @return {?}
     */
    function () {
        this.drawLineControl = new DrawControl({
            geometryType: 'LineString',
            source: this.olDrawSource,
            drawStyle: createMeasureInteractionStyle(),
            layerStyle: new OlStyle({})
        });
    };
    /**
     * Create a draw polygon control
     */
    /**
     * Create a draw polygon control
     * @private
     * @return {?}
     */
    MeasurerComponent.prototype.createDrawPolygonControl = /**
     * Create a draw polygon control
     * @private
     * @return {?}
     */
    function () {
        this.drawPolygonControl = new DrawControl({
            geometryType: 'Polygon',
            source: this.olDrawSource,
            drawStyle: createMeasureInteractionStyle(),
            layerStyle: new OlStyle({})
        });
    };
    /**
     * Create a draw polygon control
     */
    /**
     * Create a draw polygon control
     * @private
     * @return {?}
     */
    MeasurerComponent.prototype.createModifyControl = /**
     * Create a draw polygon control
     * @private
     * @return {?}
     */
    function () {
        this.modifyControl = new ModifyControl({
            source: this.olDrawSource,
            drawStyle: createMeasureInteractionStyle(),
            layerStyle: new OlStyle({})
        });
    };
    /**
     * Activate the right control
     */
    /**
     * Activate the right control
     * @private
     * @return {?}
     */
    MeasurerComponent.prototype.toggleDrawControl = /**
     * Activate the right control
     * @private
     * @return {?}
     */
    function () {
        this.deactivateDrawControl();
        // this.deactivateModifyControl();
        if (this.activeMeasureType === MeasureType.Length) {
            this.activateDrawControl(this.drawLineControl);
        }
        else if (this.activeMeasureType === MeasureType.Area) {
            this.activateDrawControl(this.drawPolygonControl);
        }
    };
    /**
     * Activate a given control
     * @param drawControl Draw control
     */
    /**
     * Activate a given control
     * @private
     * @param {?} drawControl Draw control
     * @return {?}
     */
    MeasurerComponent.prototype.activateDrawControl = /**
     * Activate a given control
     * @private
     * @param {?} drawControl Draw control
     * @return {?}
     */
    function (drawControl) {
        var _this = this;
        this.activeDrawControl = drawControl;
        this.drawStart$$ = drawControl.start$
            .subscribe((/**
         * @param {?} olGeometry
         * @return {?}
         */
        function (olGeometry) { return _this.onDrawStart(olGeometry); }));
        this.drawEnd$$ = drawControl.end$
            .subscribe((/**
         * @param {?} olGeometry
         * @return {?}
         */
        function (olGeometry) { return _this.onDrawEnd(olGeometry); }));
        this.drawChanges$$ = drawControl.changes$
            .subscribe((/**
         * @param {?} olGeometry
         * @return {?}
         */
        function (olGeometry) { return _this.onDrawChanges(olGeometry); }));
        drawControl.setOlMap(this.map.ol);
    };
    /**
     * Deactivate the active draw control
     */
    /**
     * Deactivate the active draw control
     * @private
     * @return {?}
     */
    MeasurerComponent.prototype.deactivateDrawControl = /**
     * Deactivate the active draw control
     * @private
     * @return {?}
     */
    function () {
        if (this.activeDrawControl === undefined) {
            return;
        }
        this.olDrawSource.clear();
        if (this.drawStart$$ !== undefined) {
            this.drawStart$$.unsubscribe();
        }
        if (this.drawEnd$$ !== undefined) {
            this.drawEnd$$.unsubscribe();
        }
        if (this.drawChanges$$ !== undefined) {
            this.drawChanges$$.unsubscribe();
        }
        this.clearTooltipsOfOlSource(this.olDrawSource);
        if (this.activeOlGeometry !== undefined) {
            this.clearTooltipsOfOlGeometry(this.activeOlGeometry);
        }
        this.activeDrawControl.setOlMap(undefined);
        this.activeDrawControl = undefined;
        this.activeOlGeometry = undefined;
    };
    /**
     * @private
     * @param {?} measureType
     * @return {?}
     */
    MeasurerComponent.prototype.setActiveMeasureType = /**
     * @private
     * @param {?} measureType
     * @return {?}
     */
    function (measureType) {
        this._activeMeasureType = measureType;
        this.clearMeasures();
        this.toggleDrawControl();
    };
    /**
     * Clear the draw source and track the geometry being drawn
     * @param olGeometry Ol linestring or polygon
     */
    /**
     * Clear the draw source and track the geometry being drawn
     * @private
     * @param {?} olGeometry Ol linestring or polygon
     * @return {?}
     */
    MeasurerComponent.prototype.onDrawStart = /**
     * Clear the draw source and track the geometry being drawn
     * @private
     * @param {?} olGeometry Ol linestring or polygon
     * @return {?}
     */
    function (olGeometry) {
        this.activeOlGeometry = olGeometry;
    };
    /**
     * Clear the draw source and track the geometry being draw
     * @param olGeometry Ol linestring or polygon
     */
    /**
     * Clear the draw source and track the geometry being draw
     * @private
     * @param {?} olGeometry Ol linestring or polygon
     * @return {?}
     */
    MeasurerComponent.prototype.onDrawEnd = /**
     * Clear the draw source and track the geometry being draw
     * @private
     * @param {?} olGeometry Ol linestring or polygon
     * @return {?}
     */
    function (olGeometry) {
        this.activeOlGeometry = undefined;
        this.finalizeMeasureOfOlGeometry(olGeometry);
        this.addFeatureToStore(olGeometry);
        this.clearTooltipsOfOlGeometry(olGeometry);
        this.olDrawSource.clear(true);
    };
    /**
     * Update measures observables and map tooltips
     * @param olGeometry Ol linestring or polygon
     */
    /**
     * Update measures observables and map tooltips
     * @private
     * @param {?} olGeometry Ol linestring or polygon
     * @return {?}
     */
    MeasurerComponent.prototype.onDrawChanges = /**
     * Update measures observables and map tooltips
     * @private
     * @param {?} olGeometry Ol linestring or polygon
     * @return {?}
     */
    function (olGeometry) {
        /** @type {?} */
        var measure = measureOlGeometry(olGeometry, this.projection);
        this.updateMeasureOfOlGeometry(olGeometry, Object.assign({}, measure, {
            area: undefined // We don't want to display an area tooltip while drawing.
        }));
        this.measure$.next(measure);
    };
    /**
     * Activate a given control
     * @param modifyControl Modify control
     */
    /**
     * Activate a given control
     * @private
     * @return {?}
     */
    MeasurerComponent.prototype.activateModifyControl = /**
     * Activate a given control
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var selection = (/** @type {?} */ (this.store.getStrategyOfType(FeatureStoreSelectionStrategy)));
        selection.deactivate();
        selection.clear();
        this.modifyStart$$ = this.modifyControl.start$
            .subscribe((/**
         * @param {?} olGeometry
         * @return {?}
         */
        function (olGeometry) { return _this.onModifyStart(olGeometry); }));
        this.modifyEnd$$ = this.modifyControl.end$
            .subscribe((/**
         * @param {?} olGeometry
         * @return {?}
         */
        function (olGeometry) { return _this.onModifyEnd(olGeometry); }));
        this.modifyChanges$$ = this.modifyControl.changes$
            .subscribe((/**
         * @param {?} olGeometry
         * @return {?}
         */
        function (olGeometry) { return _this.onModifyChanges(olGeometry); }));
        this.modifyControl.setOlMap(this.map.ol);
    };
    /**
     * Deactivate the active modify control
     */
    /**
     * Deactivate the active modify control
     * @private
     * @return {?}
     */
    MeasurerComponent.prototype.deactivateModifyControl = /**
     * Deactivate the active modify control
     * @private
     * @return {?}
     */
    function () {
        if (this.modifyStart$$ !== undefined) {
            this.modifyStart$$.unsubscribe();
        }
        if (this.modifyEnd$$ !== undefined) {
            this.modifyEnd$$.unsubscribe();
        }
        if (this.modifyChanges$$ !== undefined) {
            this.modifyChanges$$.unsubscribe();
        }
        if (this.activeOlGeometry !== undefined) {
            if (this.selectedFeatures$.value.length === 1) {
                /** @type {?} */
                var feature = this.selectedFeatures$.value[0];
                this.addFeatureToStore(this.activeOlGeometry, feature);
            }
            this.finalizeMeasureOfOlGeometry(this.activeOlGeometry);
        }
        this.olDrawSource.clear();
        this.store.activateStrategyOfType(FeatureStoreSelectionStrategy);
        this.activeOlGeometry = undefined;
        this.modifyControl.setOlMap(undefined);
    };
    /**
     * Clear the draw source and track the geometry being drawn
     * @param olGeometry Ol linestring or polygon
     */
    /**
     * Clear the draw source and track the geometry being drawn
     * @private
     * @param {?} olGeometry Ol linestring or polygon
     * @return {?}
     */
    MeasurerComponent.prototype.onModifyStart = /**
     * Clear the draw source and track the geometry being drawn
     * @private
     * @param {?} olGeometry Ol linestring or polygon
     * @return {?}
     */
    function (olGeometry) {
        this.onDrawStart(olGeometry);
    };
    /**
     * Update measures observables and map tooltips
     * @param olGeometry Ol linestring or polygon
     */
    /**
     * Update measures observables and map tooltips
     * @private
     * @param {?} olGeometry Ol linestring or polygon
     * @return {?}
     */
    MeasurerComponent.prototype.onModifyChanges = /**
     * Update measures observables and map tooltips
     * @private
     * @param {?} olGeometry Ol linestring or polygon
     * @return {?}
     */
    function (olGeometry) {
        this.onDrawChanges(olGeometry);
    };
    /**
     * Clear the draw source and track the geometry being draw
     * @param olGeometry Ol linestring or polygon
     */
    /**
     * Clear the draw source and track the geometry being draw
     * @private
     * @param {?} olGeometry Ol linestring or polygon
     * @return {?}
     */
    MeasurerComponent.prototype.onModifyEnd = /**
     * Clear the draw source and track the geometry being draw
     * @private
     * @param {?} olGeometry Ol linestring or polygon
     * @return {?}
     */
    function (olGeometry) {
        this.finalizeMeasureOfOlGeometry(olGeometry);
    };
    /**
     * @private
     * @param {?} olGeometry
     * @return {?}
     */
    MeasurerComponent.prototype.finalizeMeasureOfOlGeometry = /**
     * @private
     * @param {?} olGeometry
     * @return {?}
     */
    function (olGeometry) {
        /** @type {?} */
        var measure = measureOlGeometry(olGeometry, this.projection);
        if (olGeometry instanceof OlPolygon) {
            measure = Object.assign({}, measure, {
                lengths: [] // We don't want to display an area tooltip while drawing.
            });
        }
        this.updateMeasureOfOlGeometry(olGeometry, measure);
    };
    /**
     * Update measures observables
     * @param olGeometry Ol linestring or polygon
     * @param measure Measure
     */
    /**
     * Update measures observables
     * @private
     * @param {?} olGeometry Ol linestring or polygon
     * @param {?} measure Measure
     * @return {?}
     */
    MeasurerComponent.prototype.updateMeasureOfOlGeometry = /**
     * Update measures observables
     * @private
     * @param {?} olGeometry Ol linestring or polygon
     * @param {?} measure Measure
     * @return {?}
     */
    function (olGeometry, measure) {
        olGeometry.setProperties({ _measure: measure }, true);
        this.updateTooltipsOfOlGeometry(olGeometry);
    };
    /**
     * Clear the measures observables
     */
    /**
     * Clear the measures observables
     * @private
     * @return {?}
     */
    MeasurerComponent.prototype.clearMeasures = /**
     * Clear the measures observables
     * @private
     * @return {?}
     */
    function () {
        this.measure$.next({});
    };
    /**
     * Add a feature with measures to the store. The loading stragegy of the store
     * will trigger and add the feature to the map.
     * @internal
     */
    /**
     * Add a feature with measures to the store. The loading stragegy of the store
     * will trigger and add the feature to the map.
     * \@internal
     * @private
     * @param {?} olGeometry
     * @param {?=} feature
     * @return {?}
     */
    MeasurerComponent.prototype.addFeatureToStore = /**
     * Add a feature with measures to the store. The loading stragegy of the store
     * will trigger and add the feature to the map.
     * \@internal
     * @private
     * @param {?} olGeometry
     * @param {?=} feature
     * @return {?}
     */
    function (olGeometry, feature) {
        /** @type {?} */
        var featureId = feature ? feature.properties.id : uuid();
        /** @type {?} */
        var projection = this.map.ol.getView().getProjection();
        /** @type {?} */
        var geometry = new OlGeoJSON().writeGeometryObject(olGeometry, {
            featureProjection: projection,
            dataProjection: projection
        });
        this.store.update({
            type: FEATURE,
            geometry: geometry,
            projection: projection.getCode(),
            properties: {
                id: featureId,
                measure: olGeometry.get('_measure')
            },
            meta: {
                id: featureId
            }
        });
    };
    /**
     * Update all the tooltips of an OL geometry
     * @param olGeometry OL Geometry
     * @param lengths Lengths of the OL geometry's segments
     * @param measureUnit Display tooltip measure in those units
     */
    /**
     * Update all the tooltips of an OL geometry
     * @private
     * @param {?} olGeometry OL Geometry
     * @return {?}
     */
    MeasurerComponent.prototype.updateTooltipsOfOlGeometry = /**
     * Update all the tooltips of an OL geometry
     * @private
     * @param {?} olGeometry OL Geometry
     * @return {?}
     */
    function (olGeometry) {
        /** @type {?} */
        var measure = olGeometry.get('_measure');
        /** @type {?} */
        var lengths = measure.lengths;
        /** @type {?} */
        var area = measure.area;
        /** @type {?} */
        var olMidpointsTooltips = updateOlTooltipsAtMidpoints(olGeometry);
        if (lengths.length === olMidpointsTooltips.length) {
            for (var i = 0; i < olMidpointsTooltips.length; i++) {
                /** @type {?} */
                var length_1 = lengths[i];
                if (length_1 !== undefined) {
                    this.updateOlTooltip(olMidpointsTooltips[i], metersToUnit(length_1, this.activeLengthUnit), this.activeLengthUnit, MeasureType.Length);
                }
            }
        }
        if (area !== undefined) {
            this.updateOlTooltip(updateOlTooltipAtCenter(olGeometry), squareMetersToUnit(area, this.activeAreaUnit), this.activeAreaUnit, MeasureType.Area);
        }
    };
    /**
     * Show the map tooltips of a geoemtry
     */
    /**
     * Show the map tooltips of a geoemtry
     * @private
     * @param {?} olGeometry
     * @return {?}
     */
    MeasurerComponent.prototype.showTooltipsOfOlGeometry = /**
     * Show the map tooltips of a geoemtry
     * @private
     * @param {?} olGeometry
     * @return {?}
     */
    function (olGeometry) {
        var _this = this;
        getTooltipsOfOlGeometry(olGeometry).forEach((/**
         * @param {?} olTooltip
         * @return {?}
         */
        function (olTooltip) {
            if (_this.shouldShowTooltip(olTooltip)) {
                _this.map.ol.addOverlay(olTooltip);
            }
        }));
    };
    /**
     * Clear the tooltips of an OL geometrys
     * @param olGeometry OL geometry with tooltips
     */
    /**
     * Clear the tooltips of an OL geometrys
     * @private
     * @param {?} olGeometry OL geometry with tooltips
     * @return {?}
     */
    MeasurerComponent.prototype.clearTooltipsOfOlGeometry = /**
     * Clear the tooltips of an OL geometrys
     * @private
     * @param {?} olGeometry OL geometry with tooltips
     * @return {?}
     */
    function (olGeometry) {
        var _this = this;
        getTooltipsOfOlGeometry(olGeometry).forEach((/**
         * @param {?} olTooltip
         * @return {?}
         */
        function (olTooltip) {
            if (olTooltip !== undefined && olTooltip.getMap() !== undefined) {
                _this.map.ol.removeOverlay(olTooltip);
            }
        }));
    };
    /**
     * Show the map tooltips of all the geometries of a source
     */
    /**
     * Show the map tooltips of all the geometries of a source
     * @private
     * @param {?} olSource
     * @return {?}
     */
    MeasurerComponent.prototype.updateTooltipsOfOlSource = /**
     * Show the map tooltips of all the geometries of a source
     * @private
     * @param {?} olSource
     * @return {?}
     */
    function (olSource) {
        var _this = this;
        olSource.forEachFeature((/**
         * @param {?} olFeature
         * @return {?}
         */
        function (olFeature) {
            _this.updateTooltipsOfOlGeometry(olFeature.getGeometry());
        }));
    };
    /**
     * Show the map tooltips of all the geometries of a source
     */
    /**
     * Show the map tooltips of all the geometries of a source
     * @private
     * @param {?} olSource
     * @return {?}
     */
    MeasurerComponent.prototype.showTooltipsOfOlSource = /**
     * Show the map tooltips of all the geometries of a source
     * @private
     * @param {?} olSource
     * @return {?}
     */
    function (olSource) {
        var _this = this;
        olSource.forEachFeature((/**
         * @param {?} olFeature
         * @return {?}
         */
        function (olFeature) {
            _this.showTooltipsOfOlGeometry(olFeature.getGeometry());
        }));
    };
    /**
     * Clear the map tooltips
     * @param olDrawSource OL vector source
     */
    /**
     * Clear the map tooltips
     * @private
     * @param {?} olSource
     * @return {?}
     */
    MeasurerComponent.prototype.clearTooltipsOfOlSource = /**
     * Clear the map tooltips
     * @private
     * @param {?} olSource
     * @return {?}
     */
    function (olSource) {
        var _this = this;
        olSource.forEachFeature((/**
         * @param {?} olFeature
         * @return {?}
         */
        function (olFeature) {
            /** @type {?} */
            var olGeometry = olFeature.getGeometry();
            if (olGeometry !== undefined) {
                _this.clearTooltipsOfOlGeometry(olFeature.getGeometry());
            }
        }));
    };
    /**
     * Update an OL tooltip properties and inner HTML and add it to the map if possible
     * @param olTooltip OL tooltip
     * @param measure The measure valeu ti display
     * @param measureUnit Display tooltip measure in those units
     */
    /**
     * Update an OL tooltip properties and inner HTML and add it to the map if possible
     * @private
     * @param {?} olTooltip OL tooltip
     * @param {?} measure The measure valeu ti display
     * @param {?} unit
     * @param {?} type
     * @return {?}
     */
    MeasurerComponent.prototype.updateOlTooltip = /**
     * Update an OL tooltip properties and inner HTML and add it to the map if possible
     * @private
     * @param {?} olTooltip OL tooltip
     * @param {?} measure The measure valeu ti display
     * @param {?} unit
     * @param {?} type
     * @return {?}
     */
    function (olTooltip, measure, unit, type) {
        olTooltip.setProperties({ _measure: measure, _unit: unit, _type: type }, true);
        olTooltip.getElement().innerHTML = this.computeTooltipInnerHTML(olTooltip);
        if (this.shouldShowTooltip(olTooltip)) {
            this.map.ol.addOverlay(olTooltip);
        }
    };
    /**
     * Compute a tooltip's content
     * @param olTooltip OL overlay
     * @returns Inner HTML
     */
    /**
     * Compute a tooltip's content
     * @private
     * @param {?} olTooltip OL overlay
     * @return {?} Inner HTML
     */
    MeasurerComponent.prototype.computeTooltipInnerHTML = /**
     * Compute a tooltip's content
     * @private
     * @param {?} olTooltip OL overlay
     * @return {?} Inner HTML
     */
    function (olTooltip) {
        /** @type {?} */
        var properties = (/** @type {?} */ (olTooltip.getProperties()));
        return formatMeasure(properties._measure, {
            decimal: 1,
            unit: properties._unit,
            unitAbbr: true,
            locale: 'fr'
        }, this.languageService);
    };
    /**
     * Whether a tooltip should be showned based on the length
     * of the segment it is bound to.
     * @param olTooltip OL overlay
     * @returns True if the tooltip should be shown
     */
    /**
     * Whether a tooltip should be showned based on the length
     * of the segment it is bound to.
     * @private
     * @param {?} olTooltip OL overlay
     * @return {?} True if the tooltip should be shown
     */
    MeasurerComponent.prototype.shouldShowTooltip = /**
     * Whether a tooltip should be showned based on the length
     * of the segment it is bound to.
     * @private
     * @param {?} olTooltip OL overlay
     * @return {?} True if the tooltip should be shown
     */
    function (olTooltip) {
        if (this.showTooltips === false) {
            return false;
        }
        /** @type {?} */
        var properties = (/** @type {?} */ (olTooltip.getProperties()));
        /** @type {?} */
        var measure = properties._measure;
        if (measure === undefined) {
            return false;
        }
        if (properties._unit === MeasureType.Length) {
            /** @type {?} */
            var minSegmentLength = metersToUnit(this.minSegmentLength, properties._unit) || 0;
            return measure > Math.max(minSegmentLength, 0);
        }
        return true;
    };
    MeasurerComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igo-measurer',
                    template: "<div>\r\n  <div class=\"measure-type-toggle mat-typography\">\r\n    <mat-button-toggle-group\r\n      [value]=\"activeMeasureType\"\r\n      (change)=\"onMeasureTypeChange($event.value)\">\r\n      <mat-button-toggle [value]=\"measureType.Length\">\r\n        {{('igo.geo.measure.' + measureType.Length) | translate}}\r\n      </mat-button-toggle>\r\n      <mat-button-toggle [value]=\"measureType.Area\">\r\n        {{('igo.geo.measure.' + measureType.Area) | translate}}\r\n      </mat-button-toggle>\r\n    </mat-button-toggle-group>\r\n  </div>\r\n\r\n  <div class=\"measure-options mat-typography\">\r\n    <mat-slide-toggle\r\n      [checked]=\"drawControlIsActive\"\r\n      [labelPosition]=\"'before'\"\r\n      (change)=\"onToggleDrawControl($event.checked)\">\r\n      {{'igo.geo.measure.toggleActive' | translate}}\r\n    </mat-slide-toggle>\r\n\r\n    <mat-slide-toggle\r\n      [checked]=\"showTooltips\"\r\n      [labelPosition]=\"'before'\"\r\n      (change)=\"onToggleTooltips($event.checked)\">\r\n      {{'igo.geo.measure.toggleMapTooltips' | translate}}\r\n    </mat-slide-toggle>\r\n\r\n    <mat-slide-toggle\r\n      [checked]=\"measureUnitsAuto\"\r\n      [labelPosition]=\"'before'\"\r\n      (change)=\"onToggleMeasureUnitsAuto($event.checked)\">\r\n      {{'igo.geo.measure.toggleAutoUnits' | translate}}\r\n    </mat-slide-toggle>\r\n  </div>\r\n\r\n  <ng-container *ngIf=\"measure$ | async as measure\">\r\n    <igo-measurer-item\r\n      [measureType]=\"measureType.Length\"\r\n      [measureUnit]=\"measureLengthUnit.Meters\"\r\n      [measure]=\"measure.length\"\r\n      [auto]=\"measureUnitsAuto\"\r\n      [placeholder]=\"(activeMeasureType === measureType.Area ? 'igo.geo.measure.perimeter' : 'igo.geo.measure.length') | translate\"\r\n      (measureUnitChange)=\"onLengthUnitChange($event)\">\r\n    </igo-measurer-item>\r\n\r\n    <igo-measurer-item\r\n      [measureType]=\"measureType.Area\"\r\n      [measureUnit]=\"measureAreaUnit.SquareMeters\"\r\n      [measure]=\"measure.area\"\r\n      [auto]=\"measureUnitsAuto\"\r\n      [placeholder]=\"'igo.geo.measure.area' | translate\"\r\n      (measureUnitChange)=\"onAreaUnitChange($event)\">\r\n    </igo-measurer-item>\r\n  </ng-container>\r\n\r\n  <div class=\"measure-store-buttons\">\r\n    <button\r\n      mat-icon-button\r\n      [matTooltip]=\"'igo.geo.measure.actionbar.calculate.tooltip' | translate\"\r\n      [disabled]=\"(selectedFeatures$ | async).length === 0\"\r\n      (click)=\"onCalculateClick()\">\r\n      <mat-icon svgIcon=\"calculator\"></mat-icon>\r\n    </button>\r\n\r\n    <button\r\n      mat-icon-button\r\n      [matTooltip]=\"'igo.geo.measure.actionbar.delete.tooltip' | translate\"\r\n      [disabled]=\"(selectedFeatures$ | async).length === 0\"\r\n      (click)=\"onDeleteClick()\">\r\n      <mat-icon svgIcon=\"delete\"></mat-icon>\r\n    </button>\r\n\r\n    <!--button\r\n      mat-icon-button\r\n      [matTooltip]=\"'igo.geo.measure.actionbar.modify.tooltip' | translate\"\r\n      [disabled]=\"(selectedFeatures$ | async).length !== 1\"\r\n      (click)=\"onModifyClick()\">\r\n      <mat-icon svgIcon=\"edit\"></mat-icon>\r\n    </button-->\r\n  </div>\r\n\r\n  <igo-entity-table\r\n    #table\r\n    class=\"table-compact\"\r\n    [store]=\"store\"\r\n    [template]=\"tableTemplate\">\r\n  </igo-entity-table>\r\n</div>\r\n",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: [".measure-type-toggle{padding:10px;text-align:center}.measure-type-toggle mat-button-toggle-group{width:100%}.measure-type-toggle mat-button-toggle-group mat-button-toggle{width:50%}.measure-options{overflow-x:hidden}.measure-options mat-slide-toggle{width:100%;margin:10px}.measure-options mat-slide-toggle ::ng-deep .mat-slide-toggle-content{width:calc(100% - 60px)}.measure-store-buttons{width:100%;border-top:1px solid #ddd;border-bottom:1px solid #ddd}.measure-store-buttons button:first-of-type{margin-left:14px}.table-compact ::ng-deep .mat-header-cell.mat-column-selectionCheckbox{width:52px}"]
                }] }
    ];
    /** @nocollapse */
    MeasurerComponent.ctorParameters = function () { return [
        { type: LanguageService },
        { type: MatDialog }
    ]; };
    MeasurerComponent.propDecorators = {
        map: [{ type: Input }],
        store: [{ type: Input }],
        activeMeasureType: [{ type: Input }],
        minSegmentLength: [{ type: Input }],
        table: [{ type: ViewChild, args: ['table',] }]
    };
    return MeasurerComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * This pipe returns a measure converted from meters (or square meters)
 * to the specified unit. It also keeps a certain number of decimals.
 */
var MeasureFormatPipe = /** @class */ (function () {
    function MeasureFormatPipe() {
    }
    /**
     * @ignore
     */
    /**
     * @ignore
     * @param {?} value
     * @param {?} unit
     * @param {?=} unitAbbr
     * @param {?=} decimal
     * @return {?}
     */
    MeasureFormatPipe.prototype.transform = /**
     * @ignore
     * @param {?} value
     * @param {?} unit
     * @param {?=} unitAbbr
     * @param {?=} decimal
     * @return {?}
     */
    function (value, unit, unitAbbr, decimal) {
        if (unitAbbr === void 0) { unitAbbr = false; }
        if (decimal === void 0) { decimal = 1; }
        /** @type {?} */
        var out;
        if (Object.values(MeasureAreaUnit).indexOf(unit) >= 0) {
            out = squareMetersToUnit(value, (/** @type {?} */ (unit)));
        }
        else if (Object.values(MeasureLengthUnit).indexOf(unit) >= 0) {
            out = metersToUnit(value, (/** @type {?} */ (unit)));
        }
        return out ? formatMeasure(out, {
            decimal: 1,
            unit: unit,
            unitAbbr: unitAbbr,
            locale: 'fr'
        }) : out;
    };
    MeasureFormatPipe.decorators = [
        { type: Pipe, args: [{
                    name: 'measureFormat'
                },] }
    ];
    return MeasureFormatPipe;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * This input allows a user to draw a new geometry or to edit
 * an existing one on a map. A text input is also displayed in the
 * form with some instructions.
 * This is still WIP.
 */
var GeometryFormFieldInputComponent = /** @class */ (function () {
    function GeometryFormFieldInputComponent(cdRef, ngControl) {
        this.cdRef = cdRef;
        this.ngControl = ngControl;
        this.olGeoJSON = new OlGeoJSON();
        this.ready = false;
        this.olTooltip = OlOverlay;
        /**
         * The drawGuide around the mouse pointer to help drawing
         */
        this.drawGuide = null;
        /**
         * Whether a measure tooltip should be displayed
         */
        this.measure = false;
        this._drawControlIsActive = true;
        /**
         * Control options
         */
        this.controlOptions = {};
        this.onChange = (/**
         * @return {?}
         */
        function () { });
        this.onTouched = (/**
         * @return {?}
         */
        function () { });
        if (this.ngControl !== undefined) {
            // Setting the value accessor directly (instead of using
            // the providers) to avoid running into a circular import.
            this.ngControl.valueAccessor = this;
        }
    }
    Object.defineProperty(GeometryFormFieldInputComponent.prototype, "geometryType", {
        get: /**
         * @return {?}
         */
        function () { return this._geometryType; },
        /**
         * The geometry type
         */
        set: /**
         * The geometry type
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._geometryType = value;
            if (this.ready === false) {
                return;
            }
            this.deactivateControl();
            this.createDrawControl();
            this.drawControl.freehand$.next(this.freehandDrawIsActive);
            this.toggleControl();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GeometryFormFieldInputComponent.prototype, "drawControlIsActive", {
        /**
         * Whether draw control should be active or not
         */
        get: /**
         * Whether draw control should be active or not
         * @return {?}
         */
        function () { return this._drawControlIsActive; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._drawControlIsActive = value;
            if (this.ready === false) {
                return;
            }
            this.deactivateControl();
            if (!this._drawControlIsActive) {
                return;
            }
            else {
                this.toggleControl();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GeometryFormFieldInputComponent.prototype, "freehandDrawIsActive", {
        /**
         * Whether freehand draw control should be active or not
         */
        get: /**
         * Whether freehand draw control should be active or not
         * @return {?}
         */
        function () { return this._freehandDrawIsActive; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._freehandDrawIsActive = value;
            this.deactivateControl();
            this.createDrawControl();
            this.createModifyControl();
            this.drawControl.freehand$.next(this.freehandDrawIsActive);
            if (this.ready === false) {
                return;
            }
            if (!this.drawControlIsActive) {
                return;
            }
            this.toggleControl();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GeometryFormFieldInputComponent.prototype, "drawStyle", {
        get: /**
         * @return {?}
         */
        function () { return this._drawStyle; },
        /**
         * Style for the draw control (applies while the geometry is being drawn)
         */
        set: /**
         * Style for the draw control (applies while the geometry is being drawn)
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value === undefined) {
                value = createDrawInteractionStyle();
            }
            this._drawStyle = value;
            /** @type {?} */
            var olGuideStyle = this.getGuideStyleFromDrawStyle(value);
            if (olGuideStyle !== undefined) {
                this.defaultDrawStyleRadius = olGuideStyle.getImage().getRadius();
            }
            else {
                this.defaultDrawStyleRadius = null;
            }
            this.deactivateControl();
            this.createDrawControl();
            this.createModifyControl();
            this.drawControl.freehand$.next(this.freehandDrawIsActive);
            this.toggleControl();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GeometryFormFieldInputComponent.prototype, "overlayStyle", {
        get: /**
         * @return {?}
         */
        function () { return this._overlayStyle; },
        /**
         * Style for the overlay layer (applies once the geometry is added to the map)
         * If not specified, drawStyle applies
         */
        set: /**
         * Style for the overlay layer (applies once the geometry is added to the map)
         * If not specified, drawStyle applies
         * @param {?} value
         * @return {?}
         */
        function (value) { this._overlayStyle = value; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GeometryFormFieldInputComponent.prototype, "value", {
        get: /**
         * @return {?}
         */
        function () { return this._value; },
        /**
         * The geometry value (GeoJSON)
         * Implemented as part of ControlValueAccessor.
         */
        set: /**
         * The geometry value (GeoJSON)
         * Implemented as part of ControlValueAccessor.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._value = value;
            if (this.ready === false) {
                return;
            }
            if (value) {
                this.addGeoJSONToOverlay(value);
            }
            else {
                this.olOverlaySource.clear(true);
            }
            this.onChange(value);
            this.toggleControl();
            this.cdRef.detectChanges();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GeometryFormFieldInputComponent.prototype, "olOverlaySource", {
        /**
         * The vector source to add the geometry to
         * @internal
         */
        get: /**
         * The vector source to add the geometry to
         * \@internal
         * @return {?}
         */
        function () {
            return this.olOverlayLayer.getSource();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GeometryFormFieldInputComponent.prototype, "radius", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            var _this = this;
            if (this.ready === false) {
                return;
            }
            if (this.modifyControl.getSource()) {
                this.modifyControl.getSource().refresh();
            }
            if (this.freehandDrawIsActive) {
                /** @type {?} */
                var olModify_1;
                setTimeout((/**
                 * @return {?}
                 */
                function () {
                    olModify_1 = _this.modifyControl.olModifyInteraction;
                    if (olModify_1) {
                        if (olModify_1.features_) {
                            olModify_1.features_.clear();
                        }
                    }
                }), 0);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Create an overlay layer, add the initial geometry to it (if any)
     * and toggle the right interaction.
     * @internal
     */
    /**
     * Create an overlay layer, add the initial geometry to it (if any)
     * and toggle the right interaction.
     * \@internal
     * @return {?}
     */
    GeometryFormFieldInputComponent.prototype.ngOnInit = /**
     * Create an overlay layer, add the initial geometry to it (if any)
     * and toggle the right interaction.
     * \@internal
     * @return {?}
     */
    function () {
        if (this.drawStyle === undefined) {
            this.drawStyle = createDrawInteractionStyle();
        }
        if (this.overlayStyle === undefined) {
            this.overlayStyle = this.drawStyle;
        }
        this.addOlOverlayLayer();
        this.createMeasureTooltip();
        this.createDrawControl();
        this.createModifyControl();
        if (this.value) {
            this.addGeoJSONToOverlay(this.value);
        }
        this.toggleControl();
        this.ready = true;
    };
    /**
     * Clear the overlay layer and any interaction added by this component.
     * @internal
     */
    /**
     * Clear the overlay layer and any interaction added by this component.
     * \@internal
     * @return {?}
     */
    GeometryFormFieldInputComponent.prototype.ngOnDestroy = /**
     * Clear the overlay layer and any interaction added by this component.
     * \@internal
     * @return {?}
     */
    function () {
        // This is mandatory when the form control is reused after
        // this component has been destroyed. It seems like the control
        // keeps a reference to this component even after it's destroyed
        // and it attempts to set it's value
        this.ready = false;
        this.deactivateControl();
        this.olOverlaySource.clear();
        this.map.ol.removeLayer(this.olOverlayLayer);
    };
    /**
     * Implemented as part of ControlValueAccessor.
     */
    // tslint:disable-next-line:ban-types
    /**
     * Implemented as part of ControlValueAccessor.
     * @param {?} fn
     * @return {?}
     */
    // tslint:disable-next-line:ban-types
    GeometryFormFieldInputComponent.prototype.registerOnChange = /**
     * Implemented as part of ControlValueAccessor.
     * @param {?} fn
     * @return {?}
     */
    // tslint:disable-next-line:ban-types
    function (fn) {
        this.onChange = fn;
    };
    /**
     * Implemented as part of ControlValueAccessor.
     */
    // tslint:disable-next-line:ban-types
    /**
     * Implemented as part of ControlValueAccessor.
     * @param {?} fn
     * @return {?}
     */
    // tslint:disable-next-line:ban-types
    GeometryFormFieldInputComponent.prototype.registerOnTouched = /**
     * Implemented as part of ControlValueAccessor.
     * @param {?} fn
     * @return {?}
     */
    // tslint:disable-next-line:ban-types
    function (fn) {
        this.onTouched = fn;
    };
    /**
     * Implemented as part of ControlValueAccessor.
     */
    /**
     * Implemented as part of ControlValueAccessor.
     * @param {?} value
     * @return {?}
     */
    GeometryFormFieldInputComponent.prototype.writeValue = /**
     * Implemented as part of ControlValueAccessor.
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.value = value;
    };
    /**
     * Add an overlay layer to the map
     */
    /**
     * Add an overlay layer to the map
     * @private
     * @return {?}
     */
    GeometryFormFieldInputComponent.prototype.addOlOverlayLayer = /**
     * Add an overlay layer to the map
     * @private
     * @return {?}
     */
    function () {
        this.olOverlayLayer = new OlVectorLayer({
            source: new OlVectorSource(),
            zIndex: 500,
            style: null
        });
        this.map.ol.addLayer(this.olOverlayLayer);
    };
    /**
     * Create a draw control and subscribe to it's geometry
     */
    /**
     * Create a draw control and subscribe to it's geometry
     * @private
     * @return {?}
     */
    GeometryFormFieldInputComponent.prototype.createDrawControl = /**
     * Create a draw control and subscribe to it's geometry
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var controlOptions = Object.assign({}, this.controlOptions, {
            geometryType: this.geometryType || 'Point',
            layer: this.olOverlayLayer,
            drawStyle: typeof this.drawStyle === 'function' ? this.drawStyle : (/**
             * @param {?} olFeature
             * @param {?} resolution
             * @return {?}
             */
            function (olFeature, resolution) {
                /** @type {?} */
                var style$$1 = _this.drawStyle;
                _this.updateDrawStyleWithDrawGuide(style$$1, resolution);
                return style$$1;
            })
        });
        this.drawControl = new DrawControl(controlOptions);
    };
    /**
     * Create a modify control and subscribe to it's geometry
     */
    /**
     * Create a modify control and subscribe to it's geometry
     * @private
     * @return {?}
     */
    GeometryFormFieldInputComponent.prototype.createModifyControl = /**
     * Create a modify control and subscribe to it's geometry
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var controlOptions = Object.assign({}, this.controlOptions, {
            layer: this.olOverlayLayer,
            drawStyle: typeof this.drawStyle === 'function' ? this.drawStyle : (/**
             * @param {?} olFeature
             * @param {?} resolution
             * @return {?}
             */
            function (olFeature, resolution) {
                /** @type {?} */
                var style$$1 = _this.drawStyle;
                _this.updateDrawStyleWithDrawGuide(style$$1, resolution);
                return style$$1;
            })
        });
        this.modifyControl = new ModifyControl(controlOptions);
    };
    /**
     * Toggle the proper control (draw or modify)
     */
    /**
     * Toggle the proper control (draw or modify)
     * @private
     * @return {?}
     */
    GeometryFormFieldInputComponent.prototype.toggleControl = /**
     * Toggle the proper control (draw or modify)
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var activate;
        if (!this.value && this.geometryType) {
            activate = this.drawControl;
        }
        else {
            activate = this.modifyControl;
        }
        // If the control that should be activated
        // is not the same as the current active control,
        // deactivate the current control and activate the new one
        // Otherwise, do nothing and keep the current control active
        if (activate !== this.activeControl) {
            this.deactivateControl();
            this.activateControl(activate);
        }
    };
    /**
     * Activate a given control
     * @param control Control
     */
    /**
     * Activate a given control
     * @private
     * @param {?} control Control
     * @return {?}
     */
    GeometryFormFieldInputComponent.prototype.activateControl = /**
     * Activate a given control
     * @private
     * @param {?} control Control
     * @return {?}
     */
    function (control) {
        var _this = this;
        this.activeControl = control;
        this.olGeometryEnds$$ = control.end$
            .subscribe((/**
         * @param {?} olGeometry
         * @return {?}
         */
        function (olGeometry) { return _this.onOlGeometryEnds(olGeometry); }));
        if (this.measure === true && control === this.drawControl) {
            this.olGeometryChanges$$ = control.changes$
                .subscribe((/**
             * @param {?} olGeometry
             * @return {?}
             */
            function (olGeometry) { return _this.onOlGeometryChanges(olGeometry); }));
        }
        control.setOlMap(this.map.ol);
    };
    /**
     * Deactivate the active control
     */
    /**
     * Deactivate the active control
     * @private
     * @return {?}
     */
    GeometryFormFieldInputComponent.prototype.deactivateControl = /**
     * Deactivate the active control
     * @private
     * @return {?}
     */
    function () {
        this.removeMeasureTooltip();
        if (this.activeControl !== undefined) {
            this.activeControl.setOlMap(undefined);
        }
        if (this.olGeometryEnds$$ !== undefined) {
            this.olGeometryEnds$$.unsubscribe();
        }
        if (this.olGeometryChanges$$ !== undefined) {
            this.olGeometryChanges$$.unsubscribe();
        }
        this.activeControl = undefined;
    };
    /**
     * Update measures observables and map tooltips
     * @param olGeometry Ol linestring or polygon
     */
    /**
     * Update measures observables and map tooltips
     * @private
     * @param {?} olGeometry Ol linestring or polygon
     * @return {?}
     */
    GeometryFormFieldInputComponent.prototype.onOlGeometryEnds = /**
     * Update measures observables and map tooltips
     * @private
     * @param {?} olGeometry Ol linestring or polygon
     * @return {?}
     */
    function (olGeometry) {
        this.removeMeasureTooltip();
        this.setOlGeometry(olGeometry);
    };
    /**
     * Update measures observables and map tooltips
     * @param olGeometry Ol linestring or polygon
     */
    /**
     * Update measures observables and map tooltips
     * @private
     * @param {?} olGeometry Ol linestring or polygon
     * @return {?}
     */
    GeometryFormFieldInputComponent.prototype.onOlGeometryChanges = /**
     * Update measures observables and map tooltips
     * @private
     * @param {?} olGeometry Ol linestring or polygon
     * @return {?}
     */
    function (olGeometry) {
        if (olGeometry.getType() !== 'Point') {
            this.updateMeasureTooltip(olGeometry);
        }
    };
    /**
     * When drawing ends, convert the output value to GeoJSON and keep it.
     * Restore the double click interaction.
     * @param olGeometry OL geometry
     */
    /**
     * When drawing ends, convert the output value to GeoJSON and keep it.
     * Restore the double click interaction.
     * @private
     * @param {?} olGeometry OL geometry
     * @return {?}
     */
    GeometryFormFieldInputComponent.prototype.setOlGeometry = /**
     * When drawing ends, convert the output value to GeoJSON and keep it.
     * Restore the double click interaction.
     * @private
     * @param {?} olGeometry OL geometry
     * @return {?}
     */
    function (olGeometry) {
        /** @type {?} */
        var value;
        if (olGeometry === undefined) {
            return;
        }
        if (olGeometry.getType() === 'Circle') { // Because Circle doesn't exist as a GeoJSON object
            olGeometry = this.circleToPoint(olGeometry);
        }
        value = this.olGeoJSON.writeGeometryObject(olGeometry, {
            featureProjection: this.map.projection,
            dataProjection: 'EPSG:4326'
        });
        if (olGeometry.get('radius')) {
            value.radius = olGeometry.get('radius');
            olGeometry._radius = value.radius;
        }
        this.writeValue(value);
    };
    /**
     * @private
     * @param {?} olGeometry
     * @return {?}
     */
    GeometryFormFieldInputComponent.prototype.circleToPoint = /**
     * @private
     * @param {?} olGeometry
     * @return {?}
     */
    function (olGeometry) {
        /** @type {?} */
        var center = olGeometry.getCenter();
        /** @type {?} */
        var coordinates = transform(center, this.map.projection, 'EPSG:4326');
        /** @type {?} */
        var radius = Math.round(olGeometry.getRadius() * (Math.cos((Math.PI / 180) * coordinates[1])));
        // Convert it to a point object
        olGeometry = new OlPoint(center);
        olGeometry.set('radius', radius, true);
        return olGeometry;
    };
    /**
     * Add a GeoJSON geometry to the overlay
     * @param geometry GeoJSON geometry
     */
    /**
     * Add a GeoJSON geometry to the overlay
     * @private
     * @param {?} geometry GeoJSON geometry
     * @return {?}
     */
    GeometryFormFieldInputComponent.prototype.addGeoJSONToOverlay = /**
     * Add a GeoJSON geometry to the overlay
     * @private
     * @param {?} geometry GeoJSON geometry
     * @return {?}
     */
    function (geometry) {
        /** @type {?} */
        var olGeometry = this.olGeoJSON.readGeometry(geometry, {
            dataProjection: 'EPSG:4326',
            featureProjection: this.map.projection
        });
        /** @type {?} */
        var olFeature = new OlFeature({
            geometry: olGeometry
        });
        olFeature.setStyle(this.overlayStyle);
        this.olOverlaySource.clear();
        this.olOverlaySource.addFeature(olFeature);
    };
    /**
     * Create the measure tooltip
     */
    /**
     * Create the measure tooltip
     * @private
     * @return {?}
     */
    GeometryFormFieldInputComponent.prototype.createMeasureTooltip = /**
     * Create the measure tooltip
     * @private
     * @return {?}
     */
    function () {
        this.olTooltip = new OlOverlay({
            element: document.createElement('div'),
            offset: [-30, -10],
            className: [
                'igo-map-tooltip',
                'igo-map-tooltip-measure'
            ].join(' '),
            stopEvent: false
        });
    };
    /**
     * Update the measure tooltip of an OL geometry
     * @param olGeometry OL Geometry
     */
    /**
     * Update the measure tooltip of an OL geometry
     * @private
     * @param {?} olGeometry OL Geometry
     * @return {?}
     */
    GeometryFormFieldInputComponent.prototype.updateMeasureTooltip = /**
     * Update the measure tooltip of an OL geometry
     * @private
     * @param {?} olGeometry OL Geometry
     * @return {?}
     */
    function (olGeometry) {
        /** @type {?} */
        var measure = measureOlGeometry(olGeometry, this.map.projection);
        /** @type {?} */
        var lengths = measure.lengths;
        /** @type {?} */
        var lastIndex = olGeometry.getType() === 'Polygon' ? lengths.length - 2 : lengths.length - 1;
        /** @type {?} */
        var lastLength = lengths[lastIndex];
        /** @type {?} */
        var olMidpoints = updateOlGeometryMidpoints(olGeometry);
        /** @type {?} */
        var olLastMidpoint = olMidpoints[lastIndex];
        if (olMidpoints.length === 0 || olLastMidpoint === undefined) {
            this.removeMeasureTooltip();
            return;
        }
        this.olTooltip.setPosition(olLastMidpoint.flatCoordinates);
        /** @type {?} */
        var innerHtml = formatMeasure(lastLength, {
            decimal: 1,
            unit: MeasureLengthUnit.Meters,
            unitAbbr: true,
            locale: 'fr'
        });
        this.olTooltip.getElement().innerHTML = innerHtml;
        if (this.olTooltip.getMap() === undefined) {
            this.map.ol.addOverlay(this.olTooltip);
        }
    };
    /**
     * Remove the measure tooltip from the map
     */
    /**
     * Remove the measure tooltip from the map
     * @private
     * @return {?}
     */
    GeometryFormFieldInputComponent.prototype.removeMeasureTooltip = /**
     * Remove the measure tooltip from the map
     * @private
     * @return {?}
     */
    function () {
        if (this.olTooltip.getMap && this.olTooltip.getMap() !== undefined) {
            this.map.ol.removeOverlay(this.olTooltip);
            this.olTooltip.setMap(undefined);
        }
    };
    /**
     * Adjust the draw style with the specified draw guide distance, if possible
     * @param olStyle Draw style to update
     * @param resolution Resolution (to make the screen size of symbol fit the drawGuide value)
     */
    /**
     * Adjust the draw style with the specified draw guide distance, if possible
     * @private
     * @param {?} olStyle Draw style to update
     * @param {?} resolution Resolution (to make the screen size of symbol fit the drawGuide value)
     * @return {?}
     */
    GeometryFormFieldInputComponent.prototype.updateDrawStyleWithDrawGuide = /**
     * Adjust the draw style with the specified draw guide distance, if possible
     * @private
     * @param {?} olStyle Draw style to update
     * @param {?} resolution Resolution (to make the screen size of symbol fit the drawGuide value)
     * @return {?}
     */
    function (olStyle, resolution) {
        /** @type {?} */
        var olGuideStyle = this.getGuideStyleFromDrawStyle(olStyle);
        if (olGuideStyle === undefined) {
            return;
        }
        /** @type {?} */
        var drawGuide = this.drawGuide;
        /** @type {?} */
        var radius;
        if (!drawGuide || drawGuide < 0) {
            radius = this.defaultDrawStyleRadius;
        }
        else {
            radius = drawGuide > 0 ? drawGuide / resolution : drawGuide;
        }
        olGuideStyle.getImage().setRadius(radius);
    };
    /**
     * Returns wether a given Open Layers style has a radius property that can be set (used to set draw guide)
     * @param olStyle The style on which to perform the check
     */
    /**
     * Returns wether a given Open Layers style has a radius property that can be set (used to set draw guide)
     * @private
     * @param {?} olStyle The style on which to perform the check
     * @return {?}
     */
    GeometryFormFieldInputComponent.prototype.isStyleWithRadius = /**
     * Returns wether a given Open Layers style has a radius property that can be set (used to set draw guide)
     * @private
     * @param {?} olStyle The style on which to perform the check
     * @return {?}
     */
    function (olStyle) {
        return typeof olStyle !== 'function' && olStyle.getImage && olStyle.getImage().setRadius;
    };
    /**
     * Returns wether a given Open Layers style has a radius property that can be set (used to set draw guide)
     * @param olStyle The style on which to perform the check
     */
    /**
     * Returns wether a given Open Layers style has a radius property that can be set (used to set draw guide)
     * @private
     * @param {?} olStyle The style on which to perform the check
     * @return {?}
     */
    GeometryFormFieldInputComponent.prototype.getGuideStyleFromDrawStyle = /**
     * Returns wether a given Open Layers style has a radius property that can be set (used to set draw guide)
     * @private
     * @param {?} olStyle The style on which to perform the check
     * @return {?}
     */
    function (olStyle) {
        if (Array.isArray(olStyle)) {
            olStyle = olStyle[0];
        }
        if (this.isStyleWithRadius(olStyle)) {
            return olStyle;
        }
        return undefined;
    };
    GeometryFormFieldInputComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igo-geometry-form-field-input',
                    template: "<ng-template></ng-template>",
                    changeDetection: ChangeDetectionStrategy.OnPush
                }] }
    ];
    /** @nocollapse */
    GeometryFormFieldInputComponent.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: NgControl, decorators: [{ type: Optional }, { type: Self }] }
    ]; };
    GeometryFormFieldInputComponent.propDecorators = {
        map: [{ type: Input }],
        geometryType: [{ type: Input }],
        drawGuide: [{ type: Input }],
        measure: [{ type: Input }],
        drawControlIsActive: [{ type: Input }],
        freehandDrawIsActive: [{ type: Input }],
        controlOptions: [{ type: Input }],
        drawStyle: [{ type: Input }],
        overlayStyle: [{ type: Input }],
        value: [{ type: Input }],
        radius: [{ type: Input }]
    };
    return GeometryFormFieldInputComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @ignore
 */
var IgoGeometryFormFieldModule = /** @class */ (function () {
    function IgoGeometryFormFieldModule() {
    }
    IgoGeometryFormFieldModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        FormsModule,
                        ReactiveFormsModule,
                        MatIconModule,
                        MatFormFieldModule,
                        MatInputModule,
                        MatButtonModule,
                        MatButtonToggleModule,
                        IgoLanguageModule
                    ],
                    exports: [
                        GeometryFormFieldComponent,
                        GeometryFormFieldInputComponent
                    ],
                    declarations: [
                        GeometryFormFieldComponent,
                        GeometryFormFieldInputComponent
                    ]
                },] }
    ];
    return IgoGeometryFormFieldModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgoGeometryModule = /** @class */ (function () {
    function IgoGeometryModule() {
    }
    IgoGeometryModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        IgoGeometryFormFieldModule
                    ],
                    exports: [
                        IgoGeometryFormFieldModule
                    ],
                    declarations: [],
                    providers: [],
                    entryComponents: [
                        GeometryFormFieldComponent
                    ]
                },] }
    ];
    return IgoGeometryModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var TimeFilterButtonComponent = /** @class */ (function () {
    function TimeFilterButtonComponent() {
        this.color = 'primary';
        this.header = true;
        this.timeFilterCollapse = false;
    }
    Object.defineProperty(TimeFilterButtonComponent.prototype, "badge", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var filter = (/** @type {?} */ (this.options.timeFilter));
            if (filter && filter.enabled) {
                return 1;
            }
            else {
                return;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeFilterButtonComponent.prototype, "layer", {
        get: /**
         * @return {?}
         */
        function () {
            return this._layer;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._layer = value;
            if (value) {
                this.options = (/** @type {?} */ (this.layer.dataSource.options));
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    TimeFilterButtonComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.options = (/** @type {?} */ (this.layer.dataSource.options));
    };
    TimeFilterButtonComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igo-time-filter-button',
                    template: "<button *ngIf=\"header && options.timeFilterable && options.timeFilter\"\r\n  mat-icon-button\r\n  collapsibleButton\r\n  tooltip-position=\"below\"\r\n  matTooltipShowDelay=\"500\"\r\n  [matTooltip]=\"'igo.geo.filter.filterBy' | translate\"\r\n  [color]=\"color\">\r\n  <mat-icon [matBadge]=\"badge\" matBadgeColor=\"warn\" matBadgeSize=\"medium\" svgIcon=\"history\"></mat-icon>\r\n</button>\r\n\r\n<div #ogcFilter class=\"igo-layer-actions-container\"\r\n*ngIf=\"header && options.timeFilterable && options.timeFilter\">\r\n  <igo-time-filter-item\r\n    *ngIf=\"timeFilterCollapse && options.timeFilter\"\r\n    igoListItem\r\n    [header]=\"false\"\r\n    [layer]=\"layer\">\r\n  </igo-time-filter-item>\r\n</div>\r\n",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: [""]
                }] }
    ];
    /** @nocollapse */
    TimeFilterButtonComponent.ctorParameters = function () { return []; };
    TimeFilterButtonComponent.propDecorators = {
        layer: [{ type: Input }],
        map: [{ type: Input }],
        color: [{ type: Input }],
        header: [{ type: Input }]
    };
    return TimeFilterButtonComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var TimeFilterFormComponent = /** @class */ (function () {
    function TimeFilterFormComponent(dateAdapter) {
        this.dateAdapter = dateAdapter;
        this.color = 'primary';
        this.listYears = [];
        this.startListYears = [];
        this.endListYears = [];
        this.playIcon = 'play-circle';
        this.resetIcon = 'replay';
        this.change = new EventEmitter();
        this.yearChange = new EventEmitter();
        this.dateAdapter.setLocale('fr');
    }
    Object.defineProperty(TimeFilterFormComponent.prototype, "currentValue", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value) {
                if (this.type !== TimeFilterType.YEAR) {
                    /** @type {?} */
                    var valueArray = value.split('/');
                    if (valueArray.length > 0) {
                        /** @type {?} */
                        var startDate = new Date(valueArray[0]);
                        /** @type {?} */
                        var endDate = new Date(valueArray[1]);
                        if (!isNaN(startDate.valueOf())) {
                            this.startDate = startDate;
                        }
                        if (!isNaN(endDate.valueOf())) {
                            this.endDate = endDate;
                        }
                    }
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeFilterFormComponent.prototype, "type", {
        get: /**
         * @return {?}
         */
        function () {
            return this.options.type === undefined
                ? TimeFilterType.DATE
                : this.options.type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeFilterFormComponent.prototype, "isRange", {
        get: /**
         * @return {?}
         */
        function () {
            return this.options.range === undefined ||
                this.options.style === TimeFilterStyle.SLIDER
                ? false
                : this.options.range;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeFilterFormComponent.prototype, "style", {
        get: /**
         * @return {?}
         */
        function () {
            return this.options.style === undefined
                ? TimeFilterStyle.SLIDER
                : this.options.style;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeFilterFormComponent.prototype, "step", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var step = 10800000;
            if (this.options.step === undefined) {
                switch (this.type) {
                    case TimeFilterType.DATE:
                    case TimeFilterType.DATETIME:
                        step = 10800000;
                        break;
                    case TimeFilterType.TIME:
                        step = 3600000;
                        break;
                    case TimeFilterType.YEAR:
                        step = 31536000000;
                        break;
                    default:
                        step = 10800000;
                }
            }
            else {
                step = this.getStepDefinition(this.options.step);
            }
            return step;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeFilterFormComponent.prototype, "timeInterval", {
        get: /**
         * @return {?}
         */
        function () {
            return this.options.timeInterval === undefined
                ? 2000
                : this.options.timeInterval;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeFilterFormComponent.prototype, "min", {
        get: /**
         * @return {?}
         */
        function () {
            if (this.options.min) {
                /** @type {?} */
                var min = new Date(this.options.min);
                return new Date(min.getTime() + min.getTimezoneOffset() * 60000);
            }
            else {
                return undefined;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeFilterFormComponent.prototype, "max", {
        get: /**
         * @return {?}
         */
        function () {
            if (this.options.max) {
                /** @type {?} */
                var max = new Date(this.options.max);
                return new Date(max.getTime() + max.getTimezoneOffset() * 60000);
            }
            else {
                return undefined;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeFilterFormComponent.prototype, "is", {
        get: /**
         * @return {?}
         */
        function () {
            return this.options.range === undefined ? false : this.options.range;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    TimeFilterFormComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (this.startDate === undefined) {
            this.startDate = new Date(this.min);
        }
        if (this.endDate === undefined) {
            this.endDate = new Date(this.max);
        }
        if (this.startYear === undefined) {
            this.startYear = new Date(this.startDate).getFullYear();
            this.initStartYear = this.startYear;
        }
        if (this.endYear === undefined) {
            this.endYear = new Date(this.endDate).getFullYear();
            this.initEndYear = this.endYear;
        }
        if (!this.isRange) {
            for (var i = this.startYear; i <= this.endYear + 1; i++) {
                this.listYears.push(i);
            }
        }
        else {
            for (var i = this.startYear; i < this.endYear; i++) {
                this.startListYears.push(i);
            }
            for (var i = this.startYear + 1; i <= this.endYear; i++) {
                this.endListYears.push(i);
            }
        }
        this.options.enabled =
            this.options.enabled === undefined ? true : this.options.enabled;
        this.checkFilterValue();
        if (this.options.enabled) {
            if (!this.isRange && this.style === 'slider' && this.type === 'year') {
                this.yearChange.emit(this.year);
            }
        }
        else {
            this.storeCurrentFilterValue();
            this.yearChange.emit(undefined); // TODO: FIX THIS for ALL OTHER TYPES STYLES OR RANGE.
        }
    };
    /**
     * @return {?}
     */
    TimeFilterFormComponent.prototype.storeCurrentFilterValue = /**
     * @return {?}
     */
    function () {
        // TODO: FIX THIS for ALL OTHER TYPES STYLES OR RANGE.
        if (!this.isRange &&
            this.style === TimeFilterStyle.SLIDER &&
            this.type === TimeFilterType.YEAR) {
            this.options.value = this.year.toString();
        }
    };
    /**
     * @return {?}
     */
    TimeFilterFormComponent.prototype.checkFilterValue = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var timeFromWms = this.layer.dataSource.ol.getParams().TIME;
        if (!this.isRange &&
            this.style === TimeFilterStyle.SLIDER &&
            this.type === TimeFilterType.YEAR) {
            if (timeFromWms) {
                this.year = new Date(timeFromWms.toString()).getFullYear() + 1;
            }
            else if (this.options.value) {
                this.year = new Date(this.options.value.toString()).getFullYear() + 1;
            }
            else {
                this.year = new Date(this.min).getFullYear() + 1;
            }
        }
        else if (this.isRange &&
            this.style === TimeFilterStyle.CALENDAR &&
            this.type === TimeFilterType.YEAR) {
            if (timeFromWms) {
                this.startYear = parseInt(timeFromWms.substr(0, 4), 10);
                this.endYear = parseInt(timeFromWms.substr(5, 4), 10);
                /** @type {?} */
                var newStartListYears = [];
                /** @type {?} */
                var newEndListYears = [];
                for (var i = this.initStartYear; i < this.endYear; i++) {
                    newStartListYears.push(i);
                }
                for (var i = this.startYear + 1; i <= this.initEndYear; i++) {
                    newEndListYears.push(i);
                }
                this.startListYears = newStartListYears;
                this.endListYears = newEndListYears;
            }
        }
        // TODO: FIX THIS for ALL OTHER TYPES STYLES OR RANGE.
    };
    /**
     * @param {?} event
     * @return {?}
     */
    TimeFilterFormComponent.prototype.handleDateChange = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.setupDateOutput();
        this.applyTypeChange();
        // Only if is range, use 2 dates to make the range
        if (this.isRange) {
            this.change.emit([this.startDate, this.endDate]);
        }
        else {
            this.change.emit(this.startDate);
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    TimeFilterFormComponent.prototype.handleYearChange = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.isRange) {
            this.endListYears = [];
            for (var i = this.startYear + 1; i <= this.initEndYear; i++) {
                this.endListYears.push(i);
            }
            this.startListYears = [];
            for (var i = this.initStartYear + 1; i < this.endYear; i++) {
                this.startListYears.push(i);
            }
            this.yearChange.emit([this.startYear, this.endYear]);
        }
        else {
            this.yearChange.emit(this.year);
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    TimeFilterFormComponent.prototype.handleListYearChange = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.handleYearChange([this.startYear, this.endYear]);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    TimeFilterFormComponent.prototype.handleListYearStartChange = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.change.emit([this.startDate, this.endDate]);
    };
    /**
     * @param {?} date
     * @return {?}
     */
    TimeFilterFormComponent.prototype.dateToNumber = /**
     * @param {?} date
     * @return {?}
     */
    function (date) {
        /** @type {?} */
        var newDate;
        if (date) {
            newDate = new Date(date);
        }
        else {
            newDate = new Date(this.min);
        }
        return newDate.getTime();
    };
    /**
     * @param {?} label
     * @return {?}
     */
    TimeFilterFormComponent.prototype.setSliderThumbLabel = /**
     * @param {?} label
     * @return {?}
     */
    function (label) {
        /** @type {?} */
        var thumbLabel = this.findThumbLabel(this.mySlider._elementRef.nativeElement.childNodes);
        if (thumbLabel) {
            thumbLabel.textContent = label;
        }
    };
    /**
     * @param {?} test
     * @return {?}
     */
    TimeFilterFormComponent.prototype.findThumbLabel = /**
     * @param {?} test
     * @return {?}
     */
    function (test) {
        var _this = this;
        /** @type {?} */
        var thumbLabel;
        test.forEach((/**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value.className === 'mat-slider-thumb-label-text') {
                thumbLabel = value;
            }
            if (value.children.length > 0 && !thumbLabel) {
                thumbLabel = _this.findThumbLabel(value.childNodes);
            }
        }), this);
        return thumbLabel;
    };
    /**
     * @return {?}
     */
    TimeFilterFormComponent.prototype.toggleFilterState = /**
     * @return {?}
     */
    function () {
        this.options.enabled = !this.options.enabled;
        if (this.options.enabled) {
            if (!this.isRange &&
                TimeFilterStyle.SLIDER &&
                this.type === TimeFilterType.YEAR) {
                this.yearChange.emit(this.year);
            }
        }
        else {
            this.stopFilter();
            this.storeCurrentFilterValue();
            this.change.emit(undefined); // TODO: FIX THIS for ALL OTHER TYPES STYLES OR RANGE.
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    TimeFilterFormComponent.prototype.resetFilter = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.date = new Date(this.min);
        this.year = this.date.getFullYear() + 1;
        if (!this.isRange &&
            TimeFilterStyle.SLIDER &&
            this.type === TimeFilterType.YEAR) {
            this.yearChange.emit(this.year);
        }
        else {
            this.setupDateOutput();
            this.change.emit(undefined); // TODO: FIX THIS for ALL OTHER TYPES STYLES OR RANGE.
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    TimeFilterFormComponent.prototype.playFilter = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.interval) {
            this.stopFilter();
        }
        else {
            this.playIcon = 'pause-circle';
            this.interval = setInterval((/**
             * @param {?} that
             * @return {?}
             */
            function (that) {
                /** @type {?} */
                var newMinDateNumber;
                /** @type {?} */
                var maxDateNumber = new Date(that.max);
                newMinDateNumber =
                    that.date === undefined ? that.min.getTime() : that.date.getTime();
                newMinDateNumber += that.mySlider.step;
                that.date = new Date(newMinDateNumber);
                if (newMinDateNumber > maxDateNumber.getTime()) {
                    that.stopFilter();
                }
                that.handleDateChange({ value: that.date, date: that.date });
            }), this.timeInterval, this);
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    TimeFilterFormComponent.prototype.playYear = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.year + this.mySlider.step >
            this.max.getFullYear() + this.mySlider.step) {
            this.stopFilter();
            this.resetFilter(event);
        }
        if (this.interval) {
            this.stopFilter();
        }
        else {
            this.playIcon = 'pause-circle';
            this.interval = setInterval((
            // tslint:disable-next-line:only-arrow-functions
            /**
             * @param {?} that
             * @return {?}
             */
            function (that) {
                that.year = that.year + that.mySlider.step;
                if (that.year > that.max.getFullYear()) {
                    that.stopFilter();
                }
                that.yearChange.emit(that.year);
            }), this.timeInterval, this);
        }
    };
    /**
     * @return {?}
     */
    TimeFilterFormComponent.prototype.stopFilter = /**
     * @return {?}
     */
    function () {
        if (this.interval) {
            clearInterval(this.interval);
        }
        this.interval = undefined;
        this.playIcon = 'play-circle';
    };
    /**
     * @param {?} event
     * @return {?}
     */
    TimeFilterFormComponent.prototype.handleSliderDateChange = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.date = new Date(event.value);
        this.setSliderThumbLabel(this.handleSliderTooltip());
        this.handleDateChange(event);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    TimeFilterFormComponent.prototype.handleSliderYearChange = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.year = event.value;
        this.yearChange.emit(this.year);
    };
    /**
     * @return {?}
     */
    TimeFilterFormComponent.prototype.handleSliderValue = /**
     * @return {?}
     */
    function () {
        if (this.options.current === true || !this.min) {
            /** @type {?} */
            var currentDate = new Date();
            this.date = this.getRoundedDate(currentDate);
        }
        if (this.type === TimeFilterType.YEAR) {
            return this.year;
        }
        else {
            return this.date === undefined ? this.min.getTime() : this.date.getTime();
        }
    };
    /**
     * @return {?}
     */
    TimeFilterFormComponent.prototype.handleSliderTooltip = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var label;
        switch (this.type) {
            case TimeFilterType.DATE:
                label =
                    this.date === undefined
                        ? this.min.toDateString()
                        : this.date.toDateString();
                break;
            case TimeFilterType.TIME:
                label =
                    this.date === undefined
                        ? this.min.toTimeString()
                        : this.date.toTimeString();
                break;
            // datetime
            default:
                label =
                    this.date === undefined
                        ? this.min.toUTCString()
                        : this.date.toUTCString();
                break;
        }
        return label;
    };
    /**
     * @return {?}
     */
    TimeFilterFormComponent.prototype.setupDateOutput = /**
     * @return {?}
     */
    function () {
        if (this.style === TimeFilterStyle.SLIDER) {
            this.startDate = new Date(this.date);
            this.startDate.setSeconds(-(this.step / 1000));
            this.endDate = new Date(this.startDate);
            this.endDate.setSeconds(this.step / 1000);
        }
        else if (!this.isRange && !!this.date) {
            this.endDate = new Date(this.date);
            this.startDate = new Date(this.date);
        }
        else if (this.isRange && (!!this.date || !this.date)) {
            this.startDate =
                this.startDate === undefined ? new Date(this.min) : this.startDate;
            this.endDate =
                this.endDate === undefined ? new Date(this.max) : this.endDate;
        }
        else if (!this.date) {
            this.startDate =
                this.startDate === undefined ? new Date(this.min) : this.startDate;
            this.endDate =
                this.endDate === undefined ? new Date(this.max) : this.endDate;
        }
    };
    /**
     * @return {?}
     */
    TimeFilterFormComponent.prototype.applyTypeChange = /**
     * @return {?}
     */
    function () {
        switch (this.type) {
            case TimeFilterType.DATE:
                if (this.startDate !== undefined || this.endDate !== undefined) {
                    this.startDate.setHours(0);
                    this.startDate.setMinutes(0);
                    this.startDate.setSeconds(0);
                    this.endDate.setHours(23);
                    this.endDate.setMinutes(59);
                    this.endDate.setSeconds(59);
                }
                break;
            case TimeFilterType.TIME:
                if (this.style === TimeFilterStyle.CALENDAR) {
                    if (this.startDate.getDay() !== this.min.getDay()) {
                        /** @type {?} */
                        var selectedHour = this.startDate.getHours();
                        /** @type {?} */
                        var selectedMinute = this.startDate.getMinutes();
                        this.startDate = this.min;
                        this.startDate.setHours(selectedHour);
                        this.startDate.setMinutes(selectedMinute);
                    }
                    if (this.endDate.getDay() !== this.min.getDay()) {
                        /** @type {?} */
                        var selectedHour = this.endDate.getHours();
                        /** @type {?} */
                        var selectedMinute = this.endDate.getMinutes();
                        this.endDate = this.min;
                        this.endDate.setHours(selectedHour);
                        this.endDate.setMinutes(selectedMinute);
                    }
                }
                if (!this.isRange && this.step > 60 * 60 * 1000) {
                    this.startDate.setMinutes(0);
                    this.startDate.setSeconds(0);
                    this.endDate.setMinutes(59);
                    this.endDate.setSeconds(59);
                }
                break;
            // datetime
            default:
            // do nothing
        }
    };
    /**
     * @return {?}
     */
    TimeFilterFormComponent.prototype.getRangeMinDate = /**
     * @return {?}
     */
    function () {
        return this.startDate === undefined ? this.min : this.startDate;
    };
    /**
     * @return {?}
     */
    TimeFilterFormComponent.prototype.getRangeMaxDate = /**
     * @return {?}
     */
    function () {
        return this.endDate === undefined ? this.max : this.endDate;
    };
    /**
     * Round date at a certain time, 10 minutes by Default
     * @param date - Date to Round
     * @param atMinute - round to closest 'atMinute' minute, rounded 10 by default
     * @return the rounded date
     */
    /**
     * Round date at a certain time, 10 minutes by Default
     * @param {?} date - Date to Round
     * @param {?=} atMinute - round to closest 'atMinute' minute, rounded 10 by default
     * @return {?} the rounded date
     */
    TimeFilterFormComponent.prototype.getRoundedDate = /**
     * Round date at a certain time, 10 minutes by Default
     * @param {?} date - Date to Round
     * @param {?=} atMinute - round to closest 'atMinute' minute, rounded 10 by default
     * @return {?} the rounded date
     */
    function (date, atMinute) {
        if (atMinute === void 0) { atMinute = 10; }
        /** @type {?} */
        var coeff = 1000 * 60 * atMinute;
        return new Date(Math.round(date.getTime() / coeff) * coeff);
    };
    /**
     * Get the step (period) definition from the layer dimension tag
     * @param step The step as ISO 8601 example: PT10M for 10 Minutes
     * @return the duration in milliseconds
     */
    /**
     * Get the step (period) definition from the layer dimension tag
     * @param {?} step The step as ISO 8601 example: PT10M for 10 Minutes
     * @return {?} the duration in milliseconds
     */
    TimeFilterFormComponent.prototype.getStepDefinition = /**
     * Get the step (period) definition from the layer dimension tag
     * @param {?} step The step as ISO 8601 example: PT10M for 10 Minutes
     * @return {?} the duration in milliseconds
     */
    function (step) {
        return duration(step).asMilliseconds();
    };
    TimeFilterFormComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igo-time-filter-form',
                    template: "<div *ngIf=\"style === 'calendar' && type !=='year'\">\r\n  <div *ngIf=\"!isRange\" class=\"igo-col igo-col-100 igo-col-100-m\">\r\n    <mat-form-field>\r\n      <mat-datetimepicker-toggle [for]=\"datetimePicker\" matSuffix></mat-datetimepicker-toggle>\r\n      <mat-datetimepicker #datetimePicker type=\"{{type}}\" openOnFocus=\"true\" timeInterval=\"5\"></mat-datetimepicker>\r\n      <input matInput autocomplete=\"false\"\r\n        placeholder=\"{{'igo.geo.timeFilter.date' | translate}}\"\r\n        [matDatetimepicker]=\"datetimePicker\"\r\n        [(ngModel)]=\"date\"\r\n        [min]=\"min\"\r\n        [max]=\"max\"\r\n        readonly=\"readonly\"\r\n        (dateChange)=\"handleDateChange($event)\">\r\n    </mat-form-field>\r\n\r\n  </div>\r\n\r\n  <div *ngIf=\"isRange\">\r\n    <div class=\"igo-col igo-col-100\">\r\n      <mat-form-field>\r\n        <mat-datetimepicker-toggle [for]=\"minDatetimePicker\" matSuffix></mat-datetimepicker-toggle>\r\n        <mat-datetimepicker #minDatetimePicker type=\"{{type}}\" openOnFocus=\"true\" timeInterval=\"5\"></mat-datetimepicker>\r\n        <input matInput autocomplete=\"false\"\r\n          placeholder=\"{{'igo.geo.timeFilter.startDate' | translate}}\"\r\n          [matDatetimepicker]=\"minDatetimePicker\"\r\n          [(ngModel)]=\"startDate\"\r\n          [min]=\"min\"\r\n          [max]=\"getRangeMaxDate()\"\r\n          readonly=\"readonly\"\r\n          (input)=\"startDate\"\r\n          (dateChange)=\"handleDateChange($event)\">\r\n      </mat-form-field>\r\n    </div>\r\n\r\n    <div class=\"igo-col igo-col-100\">\r\n      <mat-form-field>\r\n        <mat-datetimepicker-toggle [for]=\"maxDatetimePicker\" matSuffix></mat-datetimepicker-toggle>\r\n        <mat-datetimepicker #maxDatetimePicker type=\"{{type}}\" openOnFocus=\"true\" timeInterval=\"5\"></mat-datetimepicker>\r\n        <input matInput autocomplete=\"false\"\r\n          placeholder=\"{{'igo.geo.timeFilter.endDate' | translate}}\"\r\n          [matDatetimepicker]=\"maxDatetimePicker\"\r\n          [(ngModel)]=\"endDate\"\r\n          [min]=\"getRangeMinDate()\"\r\n          [max]=\"max\"\r\n          readonly=\"readonly\"\r\n          (dateChange)=\"handleDateChange($event)\">\r\n      </mat-form-field>\r\n    </div>\r\n  </div>\r\n</div>\r\n\r\n<div *ngIf=\"style === 'calendar' && type ==='year'\">\r\n\r\n  <div *ngIf=\"!isRange\" class=\"igo-col igo-col-100 igo-col-100-m\">\r\n        <mat-form-field>\r\n            <mat-select placeholder=\"{{'igo.geo.timeFilter.date' | translate}}\" [(ngModel)]=\"year\" (selectionChange)=\"handleYearChange($event)\">\r\n                  <mat-option [value]=\"year\" *ngFor=\"let year of listYears\">{{year}}</mat-option>\r\n            </mat-select>\r\n        </mat-form-field>\r\n  </div>\r\n\r\n  <div *ngIf=\"isRange\">\r\n    <div class=\"igo-col igo-col-100\">\r\n        <mat-form-field>\r\n            <mat-select placeholder=\"{{'igo.geo.timeFilter.startDate' | translate}}\" [(ngModel)]=\"startYear\" (selectionChange)=\"handleYearChange($event)\">\r\n              <mat-option [value]=\"startYear\" *ngFor=\"let startYear of startListYears\">{{startYear}}</mat-option>\r\n            </mat-select>\r\n      </mat-form-field>\r\n    </div>\r\n\r\n    <div class=\"igo-col igo-col-100\">\r\n    <mat-form-field>\r\n        <mat-select placeholder=\"{{'igo.geo.timeFilter.endDate' | translate}}\" [(ngModel)]=\"endYear\" (selectionChange)=\"handleYearChange($event)\">\r\n              <mat-option [value]=\"endYear\" *ngFor=\"let endYear of endListYears\">{{endYear}}</mat-option>\r\n        </mat-select>\r\n      </mat-form-field>\r\n    </div>\r\n  </div>\r\n\r\n</div>\r\n\r\n\r\n  <br>\r\n  <div *ngIf=\"!isRange && style === 'slider' && type === 'year'\" class=\"igo-col igo-col-100 igo-col-100-m mat-typography\">\r\n    <span>{{startYear}}</span>\r\n    <mat-slider\r\n        id=\"time-slider\"\r\n        tickInterval=\"auto\"\r\n        step=\"{{step}}\"\r\n        [min]=\"startYear\"\r\n        [max]=\"endYear\"\r\n        [value]=\"handleSliderValue()\"\r\n        [color]=\"color\"\r\n        thumbLabel\r\n        (input)=\"handleSliderYearChange($event)\"\r\n        (change)=\"handleSliderYearChange($event)\"\r\n        [disabled]= \"!options.enabled || !layer.visible\">\r\n    </mat-slider>\r\n    <span>{{endYear}}</span>\r\n    <p *ngIf= \"options.enabled\" class=\"date-below\">{{year}}</p>\r\n    <div #actions class=\"igo-layer-actions-container\">\r\n      <mat-slide-toggle (change)=\"toggleFilterState()\" tooltip-position=\"below\" matTooltipShowDelay=\"500\"\r\n        [matTooltip]=\"'igo.geo.filter.toggleFilterState' | translate\" [color]=\"color\" [checked]=\"options.enabled\"\r\n        [disabled]=\"!layer.visible\">\r\n      </mat-slide-toggle>\r\n      <button [disabled]= \"!options.enabled  || !layer.visible\" mat-icon-button color=\"primary\" (click)=\"playYear($event)\">\r\n        <mat-icon svgIcon=\"{{playIcon}}\"></mat-icon>\r\n       </button>\r\n      <button [disabled]=\"!options.enabled  || !layer.visible\" mat-icon-button color=\"primary\" (click)=\"resetFilter($event)\">\r\n        <mat-icon svgIcon=\"{{resetIcon}}\"></mat-icon>\r\n      </button>\r\n    </div>\r\n  </div>\r\n\r\n<div *ngIf=\"style === 'slider' && type !== 'year'\" class=\"igo-col igo-col-100 igo-col-100-m\">\r\n  <mat-slider\r\n      id=\"time-slider\"\r\n      tickInterval=\"auto\"\r\n      step=\"{{step}}\"\r\n      [min]=\"dateToNumber(min)\"\r\n      [max]=\"dateToNumber(max)\"\r\n      [value]=\"handleSliderValue()\"\r\n      thumbLabel\r\n      (input)=\"handleSliderDateChange($event)\"\r\n      (selectionChange)=\"handleSliderDateChange($event)\">\r\n  </mat-slider>\r\n  <p class=\"date-below\">{{handleSliderTooltip()}}</p>\r\n  <button mat-icon-button color=\"primary\" (click)=\"playFilter($event)\">\r\n   <mat-icon svgIcon=\"{{playIcon}}\"></mat-icon>\r\n  </button>\r\n</div>\r\n",
                    styles: [".igo-layer-filters-container{padding-left:5px}mat-slider>>>div.mat-slider-thumb-label{width:32px;height:32px;margin:0 auto}mat-slider>>>span.mat-slider-thumb-label-text{font-size:10px}#time-slider{width:70%;margin:0 auto}@media only screen and (orientation:portrait) and (max-width:599px),only screen and (orientation:landscape) and (max-width:959px){#time-slider{width:60%;margin:0 auto}}.date-below{margin:0}mat-form-field{text-align:center}mat-datetimepicker-toggle ::ng-deep .mat-icon{padding-bottom:30px}.igo-layer-actions-container>.mat-slide-toggle{vertical-align:middle}"]
                }] }
    ];
    /** @nocollapse */
    TimeFilterFormComponent.ctorParameters = function () { return [
        { type: DateAdapter }
    ]; };
    TimeFilterFormComponent.propDecorators = {
        layer: [{ type: Input }],
        options: [{ type: Input }],
        currentValue: [{ type: Input }],
        change: [{ type: Output }],
        yearChange: [{ type: Output }],
        mySlider: [{ type: ViewChild, args: [MatSlider,] }]
    };
    return TimeFilterFormComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var TimeFilterItemComponent = /** @class */ (function () {
    function TimeFilterItemComponent(timeFilterService) {
        this.timeFilterService = timeFilterService;
        this.color = 'primary';
        this.showLegend$ = new BehaviorSubject(false);
        this.filtersCollapsed = false;
        this.header = true;
    }
    Object.defineProperty(TimeFilterItemComponent.prototype, "datasource", {
        get: /**
         * @return {?}
         */
        function () {
            return (/** @type {?} */ (this.layer.dataSource));
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} year
     * @return {?}
     */
    TimeFilterItemComponent.prototype.handleYearChange = /**
     * @param {?} year
     * @return {?}
     */
    function (year) {
        this.timeFilterService.filterByYear(this.datasource, year);
    };
    /**
     * @param {?} date
     * @return {?}
     */
    TimeFilterItemComponent.prototype.handleDateChange = /**
     * @param {?} date
     * @return {?}
     */
    function (date) {
        this.timeFilterService.filterByDate(this.datasource, date);
    };
    /**
     * @private
     * @param {?} collapsed
     * @return {?}
     */
    TimeFilterItemComponent.prototype.toggleLegend = /**
     * @private
     * @param {?} collapsed
     * @return {?}
     */
    function (collapsed) {
        this.layer.legendCollapsed = collapsed;
        this.showLegend$.next(!collapsed);
    };
    /**
     * @return {?}
     */
    TimeFilterItemComponent.prototype.toggleLegendOnClick = /**
     * @return {?}
     */
    function () {
        if (!this.filtersCollapsed) {
            this.toggleLegend(this.showLegend$.value);
        }
    };
    /**
     * @return {?}
     */
    TimeFilterItemComponent.prototype.setVisible = /**
     * @return {?}
     */
    function () {
        this.layer.visible = true;
    };
    /**
     * @return {?}
     */
    TimeFilterItemComponent.prototype.toggleFiltersCollapsed = /**
     * @return {?}
     */
    function () {
        this.filtersCollapsed = !this.filtersCollapsed;
    };
    TimeFilterItemComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igo-time-filter-item',
                    template: "<mat-list-item *ngIf=\"header\">\r\n  <mat-icon\r\n    class=\"igo-chevron\"\r\n    mat-list-avatar\r\n    igoCollapse\r\n    [target]=\"filters\"\r\n    [collapsed]=\"filtersCollapsed\"\r\n    (click)=\"toggleFiltersCollapsed()\"\r\n    svgIcon=\"chevron-up\" >\r\n  </mat-icon>\r\n  <h4 (click)=\"toggleLegendOnClick()\" [ngStyle]=\"{'cursor': filtersCollapsed ? 'default' : 'pointer'}\"  matLine>{{layer.title}}</h4>\r\n  \r\n  <button *ngIf=\"!layer.visible\" mat-icon-button tooltip-position=\"below\" matTooltipShowDelay=\"500\"\r\n    [matTooltip]=\"'igo.geo.layer.showLayer' | translate\" color=\"color\" (click)=\"setVisible()\">\r\n    <mat-icon svgIcon=\"eye-off\"></mat-icon>\r\n  </button>\r\n\r\n</mat-list-item>\r\n\r\n<div #filters class=\"igo-datasource-filters-container\">\r\n  <div #legend class=\"igo-layer-legend-container\">\r\n    <igo-layer-legend *ngIf=\"showLegend$ | async\" [layer]=\"layer\">\r\n    </igo-layer-legend>\r\n  </div>\r\n  <igo-time-filter-form\r\n    [layer]= \"layer\"\r\n    [options]=\"datasource.options.timeFilter\"\r\n    [currentValue]=\"datasource.options.params.TIME\"\r\n    (change)=\"handleDateChange($event)\"\r\n    (yearChange)=\"handleYearChange($event)\">\r\n  </igo-time-filter-form>\r\n</div>\r\n",
                    styles: [":host{overflow:hidden}.igo-datasource-filters-container{text-align:center;width:100%;display:inline-block;padding-top:5px}.igo-layer-legend-container{padding-left:1.125em;width:calc(100% - 18px)}"]
                }] }
    ];
    /** @nocollapse */
    TimeFilterItemComponent.ctorParameters = function () { return [
        { type: TimeFilterService }
    ]; };
    TimeFilterItemComponent.propDecorators = {
        header: [{ type: Input }],
        layer: [{ type: Input }]
    };
    return TimeFilterItemComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var TimeFilterListComponent = /** @class */ (function () {
    function TimeFilterListComponent(cdRef) {
        this.cdRef = cdRef;
        this._layers = [];
    }
    Object.defineProperty(TimeFilterListComponent.prototype, "layers", {
        get: /**
         * @return {?}
         */
        function () {
            return this._layers;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._layers = value;
            this.cdRef.detectChanges();
        },
        enumerable: true,
        configurable: true
    });
    TimeFilterListComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igo-time-filter-list',
                    template: "<igo-list [navigation]=\"false\" [selection]=\"false\">\r\n  <ng-template ngFor let-layer [ngForOf]=\"layers | filterableDataSource: 'time'\">\r\n    <igo-time-filter-item [header]=\"true\" igoListItem [layer]=\"layer\"></igo-time-filter-item>\r\n  </ng-template>\r\n</igo-list>\r\n",
                    changeDetection: ChangeDetectionStrategy.OnPush
                }] }
    ];
    /** @nocollapse */
    TimeFilterListComponent.ctorParameters = function () { return [
        { type: ChangeDetectorRef }
    ]; };
    TimeFilterListComponent.propDecorators = {
        layers: [{ type: Input }]
    };
    return TimeFilterListComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var TimeFilterListBindingDirective = /** @class */ (function () {
    function TimeFilterListBindingDirective(component, mapService) {
        this.mapService = mapService;
        this.component = component;
    }
    /**
     * @return {?}
     */
    TimeFilterListBindingDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // Override input layers
        this.component.layers = [];
        this.layers$$ = this.mapService.getMap().layers$.subscribe((/**
         * @param {?} layers
         * @return {?}
         */
        function (layers) {
            _this.component.layers = layers;
        }));
    };
    /**
     * @return {?}
     */
    TimeFilterListBindingDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.layers$$.unsubscribe();
    };
    TimeFilterListBindingDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igoTimeFilterListBinding]'
                },] }
    ];
    /** @nocollapse */
    TimeFilterListBindingDirective.ctorParameters = function () { return [
        { type: TimeFilterListComponent, decorators: [{ type: Self }] },
        { type: MapService }
    ]; };
    return TimeFilterListBindingDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var WktService = /** @class */ (function () {
    function WktService() {
    }
    /**
     * @param {?} wkt
     * @param {?} wktProj
     * @param {?} featureProj
     * @return {?}
     */
    WktService.prototype.wktToFeature = /**
     * @param {?} wkt
     * @param {?} wktProj
     * @param {?} featureProj
     * @return {?}
     */
    function (wkt, wktProj, featureProj) {
        return new olWKT().readFeature(wkt, {
            dataProjection: wktProj,
            featureProjection: featureProj
        });
    };
    /**
     * @param {?} epsgTO
     * @param {?} extent
     * @param {?} extentProj
     * @return {?}
     */
    WktService.prototype.extentToWkt = /**
     * @param {?} epsgTO
     * @param {?} extent
     * @param {?} extentProj
     * @return {?}
     */
    function (epsgTO, extent, extentProj) {
        /** @type {?} */
        var currentExtent = transformExtent(extent, extentProj, epsgTO);
        currentExtent = this.roundCoordinateArray(currentExtent, epsgTO, 0);
        /** @type {?} */
        var wktPoly = "POLYGON((\n      " + extent[0] + " " + extent[1] + ",\n      " + extent[0] + " " + extent[3] + ",\n      " + extent[2] + " " + extent[3] + ",\n      " + extent[2] + " " + extent[1] + ",\n      " + extent[0] + " " + extent[1] + "))";
        /** @type {?} */
        var wktLine = "LINESTRING(\n      " + extent[0] + " " + extent[1] + ",\n      " + extent[0] + " " + extent[3] + ",\n      " + extent[2] + " " + extent[3] + ",\n      " + extent[2] + " " + extent[1] + ",\n      " + extent[0] + " " + extent[1] + ")";
        /** @type {?} */
        var wktMultiPoints = "MULTIPOINT(\n        " + extent[0] + " " + extent[1] + ",\n        " + extent[0] + " " + extent[3] + ",\n        " + extent[2] + " " + extent[3] + ",\n        " + extent[2] + " " + extent[1] + ")";
        return {
            wktPoly: wktPoly,
            wktLine: wktLine,
            wktMultiPoints: wktMultiPoints
        };
    };
    /**
     * @private
     * @param {?} coordinateArray
     * @param {?} projection
     * @param {?=} decimal
     * @return {?}
     */
    WktService.prototype.roundCoordinateArray = /**
     * @private
     * @param {?} coordinateArray
     * @param {?} projection
     * @param {?=} decimal
     * @return {?}
     */
    function (coordinateArray, projection, decimal) {
        if (decimal === void 0) { decimal = 0; }
        /** @type {?} */
        var lproj = get(projection);
        /** @type {?} */
        var units = lproj.getUnits();
        /** @type {?} */
        var olUnits = ['ft', 'm', 'us-ft'];
        if (olUnits.indexOf(units) !== -1) {
            coordinateArray = this.roundArray(coordinateArray, decimal);
        }
        return coordinateArray;
    };
    /**
     * @private
     * @param {?} array
     * @param {?=} decimal
     * @return {?}
     */
    WktService.prototype.roundArray = /**
     * @private
     * @param {?} array
     * @param {?=} decimal
     * @return {?}
     */
    function (array, decimal) {
        if (decimal === void 0) { decimal = 0; }
        /** @type {?} */
        var x = 0;
        while (x < array.length) {
            array[x] = array[x].toFixed(decimal);
            x++;
        }
        return array;
    };
    /**
     * @param {?} snrc
     * @param {?} epsgTO
     * @return {?}
     */
    WktService.prototype.snrcToWkt = /**
     * @param {?} snrc
     * @param {?} epsgTO
     * @return {?}
     */
    function (snrc, epsgTO) {
        snrc = snrc.toLowerCase();
        /** @type {?} */
        var wktPoly;
        /** @type {?} */
        var ew = {
            1: { from: -56, to: -64 },
            2: { from: -64, to: -72 },
            3: { from: -72, to: -80 },
            4: { from: -80, to: -88 },
            5: { from: -88, to: -96 },
            6: { from: -96, to: -104 },
            7: { from: -104, to: -112 },
            8: { from: -112, to: -120 },
            9: { from: -120, to: -128 },
            10: { from: -128, to: -136 }
        };
        /** @type {?} */
        var sn = {
            1: { from: 44, to: 48 },
            2: { from: 48, to: 52 },
            3: { from: 52, to: 56 },
            4: { from: 56, to: 60 },
            5: { from: 60, to: 64 },
            6: { from: 64, to: 68 },
            7: { from: 68, to: 72 },
            8: { from: 72, to: 76 },
            9: { from: 76, to: -128 }
        };
        /** @type {?} */
        var snrc250kIndex = [
            ['m', 'n', 'o', 'p'],
            ['l', 'k', 'j', 'i'],
            ['e', 'f', 'g', 'h'],
            ['d', 'c', 'b', 'a']
        ];
        /** @type {?} */
        var snrc50kIndex = [
            ['13', '14', '15', '16'],
            ['12', '11', '10', '09'],
            ['05', '06', '07', '08'],
            ['04', '03', '02', '01']
        ];
        /** @type {?} */
        var checkSNRC50k = /\d{2,3}[a-p][0,1][0-9]/gi;
        /** @type {?} */
        var checkSNRC250k = /\d{2,3}[a-p]/gi;
        /** @type {?} */
        var checkSNRC1m = /\d{2,3}/gi;
        /** @type {?} */
        var snrc1m = false;
        /** @type {?} */
        var snrc250k = false;
        /** @type {?} */
        var snrc50k = false;
        if (checkSNRC50k.test(snrc)) {
            snrc50k = true;
        }
        else {
            if (checkSNRC250k.test(snrc)) {
                snrc250k = true;
            }
            else {
                if (checkSNRC1m.test(snrc)) {
                    snrc1m = true;
                }
            }
        }
        if (snrc1m) {
            snrc += 'a01';
        }
        else if (snrc250k) {
            snrc += '01';
        }
        if (/\d{2,3}[a-p][0,1][0-9]/gi.test(snrc)) {
            /** @type {?} */
            var regex1m = /(?=[a-p])/gi;
            /** @type {?} */
            var ar1m = snrc.split(regex1m);
            /** @type {?} */
            var part1m = ar1m[0];
            /** @type {?} */
            var part250k_1 = ar1m[1][0];
            /** @type {?} */
            var part50k_1 = ar1m[1].split(part250k_1)[1];
            /** @type {?} */
            var separator = 1;
            if (part1m.length === 3) {
                separator = 2;
            }
            /** @type {?} */
            var partEW = part1m.substring(0, separator);
            /** @type {?} */
            var partSN = part1m.substring(separator);
            /** @type {?} */
            var unit1mEW = 8;
            /** @type {?} */
            var unit1mSN = 4;
            /** @type {?} */
            var unit250kEW = 2;
            /** @type {?} */
            var unit250kSN = 1;
            /** @type {?} */
            var unit50kEW = 0.5;
            /** @type {?} */
            var unit50kSN = 0.25;
            /** @type {?} */
            var index250kEW_1 = 0;
            /** @type {?} */
            var index250kSN_1 = 0;
            /** @type {?} */
            var index50kEW_1 = 0;
            /** @type {?} */
            var index50kSN_1 = 0;
            snrc250kIndex.forEach((/**
             * @param {?} element
             * @return {?}
             */
            function (element) {
                if (element.indexOf(part250k_1) !== -1) {
                    index250kSN_1 = snrc250kIndex.indexOf(element);
                    index250kEW_1 = element.indexOf(part250k_1);
                }
            }));
            snrc50kIndex.forEach((/**
             * @param {?} element
             * @return {?}
             */
            function (element) {
                if (element.indexOf(part50k_1) !== -1) {
                    index50kSN_1 = snrc50kIndex.indexOf(element);
                    index50kEW_1 = element.indexOf(part50k_1);
                }
            }));
            /** @type {?} */
            var increment250kEW = 0;
            /** @type {?} */
            var increment250kSN = 0;
            /** @type {?} */
            var increment50kEW = 0;
            /** @type {?} */
            var increment50kSN = 0;
            /** @type {?} */
            var unitPerTypeEW = unit1mEW;
            /** @type {?} */
            var unitPerTypeSN = unit1mSN;
            if (snrc250k) {
                increment250kEW = index250kEW_1 * unit250kEW;
                increment250kSN = index250kSN_1 * unit250kSN;
                increment50kEW = 0;
                increment50kSN = 0;
                unitPerTypeEW = unit250kEW;
                unitPerTypeSN = unit250kSN;
            }
            else if (snrc50k) {
                increment250kEW = index250kEW_1 * unit250kEW;
                increment250kSN = index250kSN_1 * unit250kSN;
                increment50kEW = index50kEW_1 * unit50kEW;
                increment50kSN = index50kSN_1 * unit50kSN;
                unitPerTypeEW = unit50kEW;
                unitPerTypeSN = unit50kSN;
            }
            /** @type {?} */
            var coord = {
                ul: [
                    ew[partEW].to + increment250kEW + increment50kEW,
                    sn[partSN].to - increment250kSN - increment50kSN
                ]
            };
            coord.lr = [
                coord.ul[0] + unitPerTypeEW,
                coord.ul[1] - unitPerTypeSN
            ];
            coord.ur = [coord.ul[0], coord.ul[1] - unitPerTypeSN];
            coord.ll = [coord.ul[0] + unitPerTypeEW, coord.ul[1]];
            coord.ul = transform([coord.ul[0], coord.ul[1]], 'EPSG:4326', epsgTO);
            coord.lr = transform([coord.lr[0], coord.lr[1]], 'EPSG:4326', epsgTO);
            coord.ur = transform([coord.ur[0], coord.ur[1]], 'EPSG:4326', epsgTO);
            coord.ll = transform([coord.ll[0], coord.ll[1]], 'EPSG:4326', epsgTO);
            // Rounded coordinate to shorten url in get
            coord.ul = this.roundCoordinateArray(coord.ul, epsgTO, 0);
            coord.lr = this.roundCoordinateArray(coord.lr, epsgTO, 0);
            coord.ur = this.roundCoordinateArray(coord.ur, epsgTO, 0);
            coord.ll = this.roundCoordinateArray(coord.ll, epsgTO, 0);
            wktPoly =
                'POLYGON((' +
                    [
                        coord.ul.join(' '),
                        coord.ur.join(' '),
                        coord.lr.join(' '),
                        coord.ll.join(' '),
                        coord.ul.join(' ')
                    ].join(',') +
                    '))';
            /** @type {?} */
            var wktLine = 'LINESTRING(' +
                [
                    coord.ul.join(' '),
                    coord.ur.join(' '),
                    coord.lr.join(' '),
                    coord.ll.join(' '),
                    coord.ul.join(' ')
                ].join(',') +
                ')';
            /** @type {?} */
            var wktMultiPoints = 'MULTIPOINT(' +
                [
                    coord.ul.join(' '),
                    coord.ur.join(' '),
                    coord.lr.join(' '),
                    coord.ll.join(' ')
                ].join(',') +
                ')';
            return {
                wktPoly: wktPoly,
                wktLine: wktLine,
                wktMultiPoints: wktMultiPoints
            };
        }
    };
    WktService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    WktService.ctorParameters = function () { return []; };
    /** @nocollapse */ WktService.ngInjectableDef = defineInjectable({ factory: function WktService_Factory() { return new WktService(); }, token: WktService, providedIn: "root" });
    return WktService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var OgcFilterFormComponent = /** @class */ (function () {
    function OgcFilterFormComponent(wktService) {
        this.wktService = wktService;
        this.ogcFilterOperators$ = new BehaviorSubject(undefined);
        this.value = '';
        // public fields: any[];
        this.fields$ = new BehaviorSubject([]);
        this.color = 'primary';
        this.snrc = '';
        this.baseOverlayName = 'ogcFilterOverlay_';
        this.currentFilter$ = new BehaviorSubject(undefined);
        this.floatLabel = 'never';
        // TODO: Filter permitted operator based on wfscapabilities
        // Need to work on regex on XML capabilities because
        // comaparison operator's name varies between WFS servers...
        // Ex: IsNull vs PropertyIsNull vs IsNil ...
        this.allOgcFilterOperators = new OgcFilterWriter().operators;
        this.ogcFilterOperators$.next(this.allOgcFilterOperators);
        this.igoSpatialSelectors = [
            {
                type: 'fixedExtent'
            },
            {
                type: 'snrc'
            }
        ];
        // TODO: selectFeature & drawFeature
    }
    Object.defineProperty(OgcFilterFormComponent.prototype, "currentFilter", {
        get: /**
         * @return {?}
         */
        function () {
            return this.currentFilter$.value;
        },
        set: /**
         * @param {?} currentFilter
         * @return {?}
         */
        function (currentFilter) {
            this.currentFilter$.next(currentFilter);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OgcFilterFormComponent.prototype, "activeFilters", {
        get: /**
         * @return {?}
         */
        function () {
            return this.datasource.options.ogcFilters.interfaceOgcFilters.filter((/**
             * @param {?} f
             * @return {?}
             */
            function (f) { return f.active === true; }));
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OgcFilterFormComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.updateField();
    };
    /**
     * @return {?}
     */
    OgcFilterFormComponent.prototype.updateField = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (!this.datasource.options.sourceFields) {
            return;
        }
        /** @type {?} */
        var fields = this.datasource.options.sourceFields
            .filter((/**
         * @param {?} sf
         * @return {?}
         */
        function (sf) { return (sf.excludeFromOgcFilters === undefined || !sf.excludeFromOgcFilters); }));
        fields.filter((/**
         * @param {?} f
         * @return {?}
         */
        function (f) { return f.name === _this.currentFilter.propertyName; }))
            .forEach((/**
         * @param {?} element
         * @return {?}
         */
        function (element) {
            _this.values = element.values !== undefined ? element.values.sort() : [];
        }));
        this.fields$.next(fields);
        /** @type {?} */
        var allowedOperators = new OgcFilterWriter().computeAllowedOperators(fields, this.currentFilter.propertyName, this.datasource.options.ogcFilters.allowedOperatorsType);
        this.ogcFilterOperators$.next(allowedOperators);
        if (Object.keys(allowedOperators).indexOf(this.currentFilter$.value.operator) === -1) {
            this.currentFilter$.value.operator = Object.keys(allowedOperators)[0];
        }
        this.refreshFilters();
    };
    /**
     * @param {?} event
     * @param {?} filter
     * @param {?} property
     * @return {?}
     */
    OgcFilterFormComponent.prototype.toggleFilterState = /**
     * @param {?} event
     * @param {?} filter
     * @param {?} property
     * @return {?}
     */
    function (event, filter, property) {
        this.updateField();
        if (event.checked) {
            this.datasource.options.ogcFilters.interfaceOgcFilters
                .filter((/**
             * @param {?} f
             * @return {?}
             */
            function (f) { return f.filterid === filter.filterid; }))
                .forEach((/**
             * @param {?} element
             * @return {?}
             */
            function (element) {
                element[property] = true;
            }));
        }
        else {
            this.removeOverlayByID(filter.filterid);
            this.datasource.options.ogcFilters.interfaceOgcFilters
                .filter((/**
             * @param {?} f
             * @return {?}
             */
            function (f) { return f.filterid === filter.filterid; }))
                .forEach((/**
             * @param {?} element
             * @return {?}
             */
            function (element) {
                element[property] = false;
            }));
        }
        this.refreshFilters();
    };
    /**
     * @param {?} filter
     * @return {?}
     */
    OgcFilterFormComponent.prototype.deleteFilter = /**
     * @param {?} filter
     * @return {?}
     */
    function (filter) {
        /** @type {?} */
        var ogcFilters = this.datasource.options.ogcFilters;
        ogcFilters.interfaceOgcFilters = ogcFilters.interfaceOgcFilters.filter((/**
         * @param {?} f
         * @return {?}
         */
        function (f) { return f.filterid !== filter.filterid; }));
        this.removeOverlayByID(filter.filterid);
        this.refreshFilters();
    };
    /**
     * @param {?} filter
     * @param {?} property
     * @param {?} value
     * @return {?}
     */
    OgcFilterFormComponent.prototype.changeNumericProperty = /**
     * @param {?} filter
     * @param {?} property
     * @param {?} value
     * @return {?}
     */
    function (filter, property, value) {
        this.changeProperty(filter, property, parseFloat(value));
        this.refreshFilters();
    };
    /**
     * @private
     * @param {?} id
     * @return {?}
     */
    OgcFilterFormComponent.prototype.removeOverlayByID = /**
     * @private
     * @param {?} id
     * @return {?}
     */
    function (id) {
        /** @type {?} */
        var overlayId = this.baseOverlayName + id;
        if (this.map.overlay.dataSource.ol.getFeatureById(overlayId)) {
            this.map.overlay.dataSource.ol.removeFeature(this.map.overlay.dataSource.ol.getFeatureById(overlayId));
        }
    };
    /**
     * @param {?} filter
     * @return {?}
     */
    OgcFilterFormComponent.prototype.changeOperator = /**
     * @param {?} filter
     * @return {?}
     */
    function (filter) {
        if (this.ogcFilterOperators$.value[filter.operator].spatial === false) {
            this.removeOverlayByID(filter.filterid);
        }
        this.refreshFilters();
    };
    // Issue with mapserver 7.2 and Postgis layers. Fixed in 7.4
    // Due to this issue, the checkbox is hide.
    // Issue with mapserver 7.2 and Postgis layers. Fixed in 7.4
    // Due to this issue, the checkbox is hide.
    /**
     * @param {?} matchCase
     * @return {?}
     */
    OgcFilterFormComponent.prototype.changeCaseSensitive = 
    // Issue with mapserver 7.2 and Postgis layers. Fixed in 7.4
    // Due to this issue, the checkbox is hide.
    /**
     * @param {?} matchCase
     * @return {?}
     */
    function (matchCase) {
        this.currentFilter.matchCase = matchCase.checked;
        this.refreshFilters();
    };
    /**
     * @param {?} filter
     * @param {?} property
     * @param {?} value
     * @return {?}
     */
    OgcFilterFormComponent.prototype.changeProperty = /**
     * @param {?} filter
     * @param {?} property
     * @param {?} value
     * @return {?}
     */
    function (filter, property, value) {
        this.datasource.options.ogcFilters.interfaceOgcFilters
            .filter((/**
         * @param {?} f
         * @return {?}
         */
        function (f) { return f.filterid === filter.filterid; }))
            .forEach((/**
         * @param {?} element
         * @return {?}
         */
        function (element) {
            element[property] = value;
        }));
        this.refreshFilters();
    };
    /**
     * @param {?} filter
     * @param {?=} value
     * @return {?}
     */
    OgcFilterFormComponent.prototype.changeGeometry = /**
     * @param {?} filter
     * @param {?=} value
     * @return {?}
     */
    function (filter, value) {
        var _this = this;
        /** @type {?} */
        var checkSNRC50k = /\d{2,3}[a-l][0,1][0-9]/gi;
        /** @type {?} */
        var checkSNRC250k = /\d{2,3}[a-p]/gi;
        /** @type {?} */
        var checkSNRC1m = /\d{2,3}/gi;
        /** @type {?} */
        var mapProjection = this.map.projection;
        this.removeOverlayByID(filter.filterid);
        this.datasource.options.ogcFilters.interfaceOgcFilters
            .filter((/**
         * @param {?} f
         * @return {?}
         */
        function (f) { return f.filterid === filter.filterid; }))
            .forEach((/**
         * @param {?} element
         * @return {?}
         */
        function (element) {
            /** @type {?} */
            var wktPoly;
            if (filter.igoSpatialSelector === 'snrc') {
                if (value === '' && _this.snrc !== '') {
                    wktPoly = _this.wktService.snrcToWkt(_this.snrc, _this.map.projection).wktPoly;
                    element.wkt_geometry = wktPoly;
                }
                else if (value !== '' &&
                    (checkSNRC1m.test(value) ||
                        checkSNRC250k.test(value) ||
                        checkSNRC50k.test(value))) {
                    wktPoly = _this.wktService.snrcToWkt(value, _this.map.projection).wktPoly;
                    element.wkt_geometry = wktPoly;
                }
            }
            else if (filter.igoSpatialSelector === 'fixedExtent') {
                wktPoly = _this.wktService.extentToWkt(mapProjection, _this.map.viewController.getExtent(), mapProjection).wktPoly;
                element.wkt_geometry = wktPoly;
            }
        }));
        this.refreshFilters();
    };
    OgcFilterFormComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igo-ogc-filter-form',
                    template: "<mat-list-item class=\"mat-typography\">\r\n\r\n  <div class=\"igo-col igo-col-90 igo-col-100-m\">\r\n    <mat-select class=\"logical\" [disabled]=\"!currentFilter.active\" (selectionChange)=\"refreshFilters()\" [(ngModel)]=\"currentFilter.parentLogical\"\r\n      *ngIf=\"activeFilters.indexOf(currentFilter) !== 0 && currentFilter.active===true\">\r\n      <mat-option tooltip-position=\"above\" matTooltipShowDelay=\"500\" [matTooltip]=\"'igo.geo.operators.tooltip.And' | translate\" value=\"And\">{{'igo.geo.operators.And' | translate}}</mat-option>\r\n      <mat-option tooltip-position=\"above\" matTooltipShowDelay=\"500\" [matTooltip]=\"'igo.geo.operators.tooltip.Or' | translate\" value=\"Or\">{{'igo.geo.operators.Or' | translate}}</mat-option>\r\n    </mat-select>\r\n  </div>\r\n  <!-- NON SPATIAL -->\r\n  <div class=\"igo-col igo-col-90 igo-col-100-m\" *ngIf=\"(currentFilter.operator !== 'Intersects' && currentFilter.operator !== 'Contains' && currentFilter.operator !== 'Within')\">\r\n    <span *ngIf=\"(fields$ | async) && (fields$| async).length > 0 && (fields$| async)[0].name !== ''\">\r\n      <mat-select [disabled]=\"!currentFilter.active\" *ngIf=\"['Contains','Intersects','Within'].indexOf(currentFilter.operator) === -1\"\r\n        [(ngModel)]=\"currentFilter.propertyName\" tooltip-position=\"below\" matTooltipShowDelay=\"500\" [matTooltip]=\"'igo.geo.sourceFields.selectField' | translate\"\r\n        (selectionChange)=\"updateField()\">\r\n        <mat-option *ngFor=\"let field of  (fields$| async)\" [value]=\"field.name\">{{field.alias}}</mat-option>\r\n      </mat-select>\r\n    </span>\r\n    <span *ngIf=\" (fields$| async) &&  (fields$| async).length === 1 &&  (fields$| async)[0].name === ''\">\r\n      <mat-form-field>\r\n        <input [disabled]=\"!currentFilter.active\" matInput #fieldPerUser (keyup)=\"changeProperty(currentFilter,'propertyName',fieldPerUser.value)\"\r\n          (blur)=\"changeProperty(currentFilter,'propertyName',fieldPerUser.value)\" [(ngModel)]=\"currentFilter.propertyName\">\r\n\r\n        <button mat-button *ngIf=\"currentFilter.propertyName\" matSuffix mat-icon-button aria-label=\"Clear\" (click)=\"currentFilter.propertyName=''\">\r\n          <mat-icon svgIcon=\"close\"></mat-icon>\r\n        </button>\r\n      </mat-form-field>\r\n\r\n    </span>\r\n  </div>\r\n\r\n  <div class=\"igo-col igo-col-90 igo-col-100-m\" *ngIf=\"(currentFilter.operator !== 'Intersects' && currentFilter.operator !== 'Contains' && currentFilter.operator !== 'Within')\">\r\n    <mat-select \r\n    tooltip-position=\"below\" matTooltipShowDelay=\"500\" [matTooltip]=\"'igo.geo.filter.selectOperator' | translate\"\r\n    [disabled]=\"!currentFilter.active\" [(ngModel)]=\"currentFilter.operator\" (selectionChange)=\"changeOperator(currentFilter)\">\r\n      <mat-option *ngFor=\"let operator of (ogcFilterOperators$ | async) | keyvalue\" [value]=\"operator.key\" tooltip-position=\"above\" matTooltipShowDelay=\"500\" [matTooltip]=\"('igo.geo.operators.tooltip.'+ operator.key) | translate\" >{{('igo.geo.operators.'+ operator.key) | translate}}</mat-option>\r\n    </mat-select>\r\n  </div>\r\n\r\n  <div class=\"igo-col igo-col-90 igo-col-100-m\" *ngIf=\"(currentFilter.operator !== 'Intersects' && currentFilter.operator !== 'Contains' && currentFilter.operator !== 'Within')\">\r\n\r\n    <!-- PropertyIsEqualTo -->\r\n    <span *ngIf=\"currentFilter.operator === 'PropertyIsEqualTo' || currentFilter.operator === 'PropertyIsNotEqualTo'\">\r\n      <mat-form-field [floatLabel]=\"floatLabel\">\r\n        <input [placeholder]=\"'igo.geo.filter.placeholder' | translate\" [disabled]=\"!currentFilter.active\" matInput [matAutocomplete]=\"auto\" #expressionequalto (keyup)=\"changeProperty(currentFilter,'expression',expressionequalto.value)\"\r\n          (ngModelChange)=\"changeProperty(currentFilter,'expression',expressionequalto.value)\" [ngModel]=\"currentFilter.expression\">\r\n        <mat-autocomplete #auto=\"matAutocomplete\">\r\n          <mat-option *ngFor=\"let value of values\" [value]=\"value\" matTooltipShowDelay=\"500\" [matTooltip]=\"value\">\r\n            <span>{{ value }}</span>\r\n          </mat-option>\r\n        </mat-autocomplete>\r\n        <button mat-button *ngIf=\"currentFilter.expression\" matSuffix mat-icon-button aria-label=\"Clear\" (click)=\"currentFilter.expression=''\">\r\n          <mat-icon svgIcon=\"close\"></mat-icon>\r\n        </button>\r\n      </mat-form-field>\r\n\r\n    </span>\r\n    <!-- PropertyIsEqualTo  -->\r\n\r\n\r\n    <!-- PropertyIsLike  -->\r\n    <span *ngIf=\"currentFilter.operator === 'PropertyIsLike'\">\r\n      <mat-form-field [floatLabel]=\"floatLabel\">\r\n        <input [placeholder]=\"'igo.geo.filter.placeholder' | translate\" [disabled]=\"!currentFilter.active\" matInput [matAutocomplete]=\"auto\" #pattern (keyup)=\"changeProperty(currentFilter,'pattern',pattern.value)\"\r\n          (ngModelChange)=\"changeProperty(currentFilter,'pattern',pattern.value)\" [ngModel]=\"currentFilter.pattern\">\r\n        <mat-autocomplete #auto=\"matAutocomplete\">\r\n          <mat-option *ngFor=\"let value of values\" [value]=\"value\" matTooltipShowDelay=\"500\" [matTooltip]=\"value\">\r\n            <span>{{ value }}</span>\r\n          </mat-option>\r\n        </mat-autocomplete>\r\n        <button mat-button *ngIf=\"currentFilter.pattern\" matSuffix mat-icon-button aria-label=\"Clear\" (click)=\"currentFilter.pattern=''\">\r\n          <mat-icon svgIcon=\"close\"></mat-icon>\r\n        </button>\r\n      </mat-form-field>\r\n\r\n    </span>\r\n    <!-- PropertyIsLike  -->\r\n\r\n    <!-- PropertyIsNull  -->\r\n    <span *ngIf=\"currentFilter.operator === 'PropertyIsNull'\"></span>\r\n    <!-- PropertyIsNull  -->\r\n\r\n    <!-- PropertyIs_Than  -->\r\n    <span *ngIf=\"currentFilter.operator === 'PropertyIsGreaterThan' || currentFilter.operator === 'PropertyIsGreaterThanOrEqualTo' || currentFilter.operator === 'PropertyIsLessThan' || currentFilter.operator === 'PropertyIsLessThanOrEqualTo'\">\r\n      <mat-form-field [floatLabel]=\"floatLabel\">\r\n        <input [placeholder]=\"'igo.geo.filter.placeholder' | translate\" [disabled]=\"!currentFilter.active\" matInput [matAutocomplete]=\"auto\" #expressionthan type=\"number\" (keyup)=\"changeNumericProperty(currentFilter,'expression',expressionthan.value)\"\r\n          (ngModelChange)=\"changeNumericProperty(currentFilter,'expression',expressionthan.value)\" [ngModel]=\"currentFilter.expression\">\r\n        <mat-autocomplete #auto=\"matAutocomplete\">\r\n          <mat-option *ngFor=\"let value of values\" [value]=\"value\" matTooltipShowDelay=\"500\" [matTooltip]=\"value\">\r\n            <span>{{ value }}</span>\r\n          </mat-option>\r\n        </mat-autocomplete>\r\n        <button mat-button *ngIf=\"currentFilter.expression\" matSuffix mat-icon-button aria-label=\"Clear\" (click)=\"currentFilter.expression=''\">\r\n          <mat-icon svgIcon=\"close\"></mat-icon>\r\n        </button>\r\n      </mat-form-field>\r\n    </span>\r\n    <!-- PropertyIs_Than  -->\r\n\r\n\r\n    <!-- PropertyIsBetween -->\r\n    <span *ngIf=\"currentFilter.operator === 'PropertyIsBetween'\">\r\n      <mat-form-field [floatLabel]=\"floatLabel\">\r\n        <input [placeholder]=\"'igo.geo.filter.placeholder' | translate\" [disabled]=\"!currentFilter.active\" matInput [matAutocomplete]=\"auto\" #lowerBoundary type=\"number\" (keyup)=\"changeNumericProperty(currentFilter,'lowerBoundary',lowerBoundary.value)\"\r\n          (ngModelChange)=\"changeNumericProperty(currentFilter,'lowerBoundary',lowerBoundary.value)\" [ngModel]=\"currentFilter.lowerBoundary\">\r\n        <mat-autocomplete #auto=\"matAutocomplete\">\r\n          <mat-option *ngFor=\"let value of values\" [value]=\"value\" matTooltipShowDelay=\"500\" [matTooltip]=\"value\">\r\n            <span>{{ value }}</span>\r\n          </mat-option>\r\n        </mat-autocomplete>\r\n        <button mat-button *ngIf=\"currentFilter.lowerBoundary\" matSuffix mat-icon-button aria-label=\"Clear\" (click)=\"currentFilter.lowerBoundary=''\">\r\n          <mat-icon svgIcon=\"close\"></mat-icon>\r\n        </button>\r\n      </mat-form-field>\r\n      <mat-form-field [floatLabel]=\"floatLabel\">\r\n        <input [placeholder]=\"'igo.geo.filter.placeholder' | translate\" [disabled]=\"!currentFilter.active\" matInput [matAutocomplete]=\"auto\" #upperBoundary type=\"number\" (keyup)=\"changeNumericProperty(currentFilter,'upperBoundary',upperBoundary.value)\"\r\n          (ngModelChange)=\"changeNumericProperty(currentFilter,'upperBoundary',upperBoundary.value)\" [ngModel]=\"currentFilter.upperBoundary\">\r\n        <mat-autocomplete #auto=\"matAutocomplete\">\r\n          <mat-option *ngFor=\"let value of values\" [value]=\"value\" matTooltipShowDelay=\"500\" [matTooltip]=\"value\">\r\n            <span>{{ value }}</span>\r\n          </mat-option>\r\n        </mat-autocomplete>\r\n        <button mat-button *ngIf=\"currentFilter.upperBoundary\" matSuffix mat-icon-button aria-label=\"Clear\" (click)=\"currentFilter.upperBoundary=''\">\r\n          <mat-icon svgIcon=\"close\"></mat-icon>\r\n        </button>\r\n      </mat-form-field>\r\n\r\n    </span>\r\n    <!-- PropertyIsBetween  -->\r\n\r\n\r\n    <!-- During -->\r\n    <span *ngIf=\"currentFilter.operator === 'During'\">\r\n      <mat-form-field [floatLabel]=\"floatLabel\">\r\n        <input [placeholder]=\"'igo.geo.filter.placeholder' | translate\" [disabled]=\"!currentFilter.active\" matInput [matAutocomplete]=\"auto\" #begin (keyup)=\"changeProperty(currentFilter,'begin',begin.value)\"\r\n          (ngModelChange)=\"changeProperty(currentFilter,'begin',begin.value)\" [ngModel]=\"currentFilter.begin\">\r\n        <mat-autocomplete #auto=\"matAutocomplete\">\r\n          <mat-option *ngFor=\"let value of values \" [value]=\"value\" matTooltipShowDelay=\"500\" [matTooltip]=\"value\">\r\n            <span>{{ value }}</span>\r\n          </mat-option>\r\n        </mat-autocomplete>\r\n        <button mat-button *ngIf=\"currentFilter.begin\" matSuffix mat-icon-button aria-label=\"Clear\" (click)=\"currentFilter.begin=''\">\r\n          <mat-icon svgIcon=\"close\"></mat-icon>\r\n        </button>\r\n      </mat-form-field>\r\n\r\n      <mat-form-field [floatLabel]=\"floatLabel\">\r\n        <input [placeholder]=\"'igo.geo.filter.placeholder' | translate\" [disabled]=\"!currentFilter.active\" matInput [matAutocomplete]=\"auto\" #end (keyup)=\"changeProperty(currentFilter,'end',end.value)\"\r\n          (ngModelChange)=\"changeProperty(currentFilter,'end',end.value)\" [ngModel]=\"currentFilter.end\">\r\n        <mat-autocomplete #auto=\"matAutocomplete\">\r\n          <mat-option *ngFor=\"let value of values\" [value]=\"value\" matTooltipShowDelay=\"500\" [matTooltip]=\"value\">\r\n            <span>{{ value }}</span>\r\n          </mat-option>\r\n        </mat-autocomplete>\r\n        <button mat-button *ngIf=\"currentFilter.end\" matSuffix mat-icon-button aria-label=\"Clear\" (click)=\"currentFilter.end=''\">\r\n          <mat-icon svgIcon=\"close\"></mat-icon>\r\n        </button>\r\n      </mat-form-field>\r\n\r\n\r\n    </span>\r\n    <!-- During  -->\r\n  </div>\r\n  <!-- NON SPATIAL -->\r\n\r\n\r\n  <!-- PropertySpatial  -->\r\n  <div class=\"igo-col igo-col-90 igo-col-100-m\" *ngIf=\"(currentFilter.operator === 'Intersects' || currentFilter.operator === 'Contains' || currentFilter.operator === 'Within')\">\r\n    <mat-select  \r\n      matTooltipShowDelay=\"500\" [matTooltip]=\"'igo.geo.filter.selectOperator' | translate\" tooltip-position=\"below\"\r\n      [disabled]=\"!currentFilter.active\" [(ngModel)]=\"currentFilter.operator\" (selectionChange)=\"changeOperator(currentFilter)\">\r\n      <mat-option *ngFor=\"let operator of (ogcFilterOperators$ | async) | keyvalue\" [value]=\"operator.key\"  tooltip-position=\"above\" matTooltipShowDelay=\"500\" [matTooltip]=\"('igo.geo.operators.tooltip.'+ operator.key) | translate\" >{{('igo.geo.operators.'+ operator.key) | translate}}</mat-option>\r\n    </mat-select>\r\n  </div>\r\n  <div class=\"igo-col igo-col-90 igo-col-100-m\" *ngIf=\"(currentFilter.operator === 'Intersects' || currentFilter.operator === 'Contains' || currentFilter.operator === 'Within')\">\r\n    <mat-select [disabled]=\"!currentFilter.active\" [(ngModel)]=\"currentFilter.igoSpatialSelector\" (selectionChange)=\"changeGeometry(currentFilter,value)\">\r\n      <mat-option *ngFor=\"let igoSpatialSelector of igoSpatialSelectors\" [value]=\"igoSpatialSelector.type\">{{('igo.geo.spatialSelector.'+ igoSpatialSelector.type) | translate}}</mat-option>\r\n    </mat-select>\r\n  </div>\r\n\r\n  <div class=\"igo-col igo-col-90 igo-col-100-m\" *ngIf=\"(currentFilter.operator === 'Intersects' || currentFilter.operator === 'Contains' || currentFilter.operator === 'Within')\">\r\n    <button mat-button [disabled]=\"!currentFilter.active\" *ngIf=\"currentFilter.igoSpatialSelector === 'fixedExtent'\"\r\n      matSuffix mat-icon-button aria-label=\"Clear\" (click)=\"changeGeometry(currentFilter,value)\" tooltip-position=\"below\" matTooltipShowDelay=\"500\"\r\n      [matTooltip]=\"'igo.geo.spatialSelector.btnSetExtent' | translate\">\r\n      <mat-icon svgIcon=\"arrow-expand-all\"></mat-icon>\r\n    </button>\r\n\r\n\r\n    <mat-form-field *ngIf=\"currentFilter.igoSpatialSelector === 'snrc'\" [floatLabel]=\"floatLabel\">\r\n      <input [placeholder]=\"'igo.geo.filter.placeholderSnrc' | translate\" matInput #htmlSnrc (keyup)=\"changeGeometry(currentFilter,htmlSnrc.value)\" (blur)=\"changeGeometry(currentFilter,htmlSnrc.value)\"\r\n        [(ngModel)]=\"snrc\">\r\n      <button mat-button *ngIf=\"snrc\" matSuffix mat-icon-button aria-label=\"Clear\" (click)=\"snrc=''\">\r\n        <mat-icon svgIcon=\"close\"></mat-icon>\r\n      </button>\r\n    </mat-form-field>\r\n  </div>\r\n  <!-- PropertySpatial  -->\r\n\r\n  <!-- <mat-checkbox labelPosition='before' (change)=\"changeCaseSensitive($event)\" [(ngModel)]=\"currentFilter.matchCase\">\r\n    {{('igo.geo.operators.caseSensitive') | translate}}\r\n  </mat-checkbox> -->\r\n\r\n  <div class=\"igo-col igo-col-100 igo-col-100-m\">\r\n    <div class=\"igo-layer-button-group\">\r\n      <mat-slide-toggle class=\"example-margin\" (change)=\"toggleFilterState($event,currentFilter,'active')\" tooltip-position=\"below\"\r\n        matTooltipShowDelay=\"500\" [matTooltip]=\"'igo.geo.filter.toggleFilterState' | translate\" [color]=\"color\" [checked]=\"currentFilter.active\"\r\n        [disabled]=\"disabled\">\r\n      </mat-slide-toggle>\r\n      <button mat-icon-button tooltip-position=\"below\" matTooltipShowDelay=\"500\" [matTooltip]=\"'igo.geo.filter.removeFilter' | translate\"\r\n        color=\"warn\" (click)=\"deleteFilter(currentFilter)\">\r\n        <mat-icon svgIcon=\"delete\"></mat-icon>\r\n      </button>\r\n    </div>\r\n  </div>\r\n  <mat-divider></mat-divider>\r\n</mat-list-item>\r\n",
                    styles: [":host{overflow:hidden}.mat-list-item{height:auto}.mat-form-field{width:100%}.mat-list-item>>>div.mat-list-item-content{display:inline-table;width:100%}.logical{font-weight:700}input,mat-select{margin-top:10px;text-align:center}.igo-layer-actions-container{width:100%;display:inline-block}.igo-layer-actions-container>div{text-align:center}.igo-layer-button-group{float:center;padding:0 3px}@media only screen and (orientation:portrait) and (max-width:599px),only screen and (orientation:landscape) and (max-width:959px){.igo-layer-button-group{float:none}}mat-icon.disabled{color:rgba(0,0,0,.38)}"]
                }] }
    ];
    /** @nocollapse */
    OgcFilterFormComponent.ctorParameters = function () { return [
        { type: WktService }
    ]; };
    OgcFilterFormComponent.propDecorators = {
        refreshFilters: [{ type: Input }],
        datasource: [{ type: Input }],
        map: [{ type: Input }],
        currentFilter: [{ type: Input }],
        floatLabel: [{ type: Input }]
    };
    return OgcFilterFormComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var OgcFilterableFormComponent = /** @class */ (function () {
    function OgcFilterableFormComponent() {
        this.color = 'primary';
    }
    Object.defineProperty(OgcFilterableFormComponent.prototype, "refreshFunc", {
        get: /**
         * @return {?}
         */
        function () {
            return this.refreshFilters;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OgcFilterableFormComponent.prototype, "advancedOgcFilters", {
        get: /**
         * @return {?}
         */
        function () {
            if (this.datasource.options.ogcFilters) {
                return this.datasource.options.ogcFilters.advancedOgcFilters;
            }
            return;
        },
        enumerable: true,
        configurable: true
    });
    OgcFilterableFormComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igo-ogc-filterable-form',
                    template: "<igo-list *ngIf=\"!advancedOgcFilters\" [navigation]=\"false\" [selection]=\"true\">\r\n  <igo-ogc-filter-toggle-button igoListItem [datasource]=\"datasource\" [map]=\"map\" [refreshFilters]=\"refreshFunc\">\r\n  </igo-ogc-filter-toggle-button>\r\n</igo-list>\r\n\r\n<igo-list *ngIf=\"advancedOgcFilters && datasource.options.ogcFilters.editable \" [navigation]=\"false\" [selection]=\"true\">\r\n  <ng-template ngFor let-currentFilter [ngForOf]=\"datasource.options.ogcFilters.interfaceOgcFilters\">\r\n    <igo-ogc-filter-form igoListItem [color]=\"color\" [currentFilter]=\"currentFilter\" [datasource]=\"datasource\"\r\n      [map]=\"map\" [refreshFilters]=\"refreshFunc\">\r\n    </igo-ogc-filter-form>\r\n  </ng-template>\r\n</igo-list>\r\n"
                }] }
    ];
    /** @nocollapse */
    OgcFilterableFormComponent.ctorParameters = function () { return []; };
    OgcFilterableFormComponent.propDecorators = {
        datasource: [{ type: Input }],
        map: [{ type: Input }],
        refreshFilters: [{ type: Input }]
    };
    return OgcFilterableFormComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var OgcFilterableItemComponent = /** @class */ (function () {
    function OgcFilterableItemComponent(ogcFilterService, downloadService) {
        this.ogcFilterService = ogcFilterService;
        this.downloadService = downloadService;
        this.color = 'primary';
        this.defaultLogicalParent = 'And';
        this.hasActiveSpatialFilter = false;
        this.filtersAreEditable = true;
        this.filtersCollapsed = true;
        this.hasPushButton = false;
        this.showLegend$ = new BehaviorSubject(false);
        this.header = true;
        this.ogcFilterWriter = new OgcFilterWriter();
    }
    Object.defineProperty(OgcFilterableItemComponent.prototype, "refreshFunc", {
        get: /**
         * @return {?}
         */
        function () {
            return this.refreshFilters.bind(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OgcFilterableItemComponent.prototype, "datasource", {
        get: /**
         * @return {?}
         */
        function () {
            return (/** @type {?} */ (this.layer.dataSource));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OgcFilterableItemComponent.prototype, "downloadable", {
        get: /**
         * @return {?}
         */
        function () {
            return ((/** @type {?} */ (this.datasource.options))).download;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OgcFilterableItemComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var ogcFilters = this.datasource.options.ogcFilters;
        if (ogcFilters.pushButtons && ogcFilters.pushButtons.bundles.length > 0) {
            if (ogcFilters.advancedOgcFilters === undefined) {
                ogcFilters.advancedOgcFilters = false;
            }
            this.hasPushButton = true;
        }
        switch (this.datasource.options.type) {
            case 'wms':
                this.ogcFilterService.setOgcWMSFiltersOptions(this.datasource);
                break;
            case 'wfs':
                this.ogcFilterService.setOgcWFSFiltersOptions(this.datasource);
                break;
            default:
                break;
        }
        if (ogcFilters) {
            if (ogcFilters.interfaceOgcFilters) {
                this.lastRunOgcFilter = JSON.parse(JSON.stringify(ogcFilters.interfaceOgcFilters));
                if (ogcFilters.interfaceOgcFilters.filter((/**
                 * @param {?} f
                 * @return {?}
                 */
                function (f) { return f.wkt_geometry; })).length >= 1) {
                    this.hasActiveSpatialFilter = true;
                }
            }
            this.filtersAreEditable = ogcFilters.editable
                ? ogcFilters.editable
                : false;
        }
    };
    /**
     * @return {?}
     */
    OgcFilterableItemComponent.prototype.addFilterToSequence = /**
     * @return {?}
     */
    function () {
        this.filtersCollapsed = false;
        /** @type {?} */
        var interfaceOgcFilters = this.datasource
            .options.ogcFilters.interfaceOgcFilters;
        /** @type {?} */
        var arr = interfaceOgcFilters || [];
        /** @type {?} */
        var lastLevel = arr.length === 0 ? 0 : arr[arr.length - 1].level;
        /** @type {?} */
        var firstFieldName = '';
        /** @type {?} */
        var includedFields = this.datasource.options.sourceFields.filter((/**
         * @param {?} f
         * @return {?}
         */
        function (f) { return !f.excludeFromOgcFilters; }));
        if (includedFields.length > 0) {
            firstFieldName =
                includedFields[0].name === undefined ? '' : includedFields[0].name;
        }
        /** @type {?} */
        var fieldNameGeometry;
        /** @type {?} */
        var datasourceOptions = (/** @type {?} */ (this.datasource
            .options));
        if (datasourceOptions.fieldNameGeometry) {
            fieldNameGeometry = datasourceOptions.fieldNameGeometry;
        }
        else if (((/** @type {?} */ (this.datasource.options))).paramsWFS &&
            ((/** @type {?} */ (this.datasource.options))).paramsWFS.fieldNameGeometry) {
            fieldNameGeometry = ((/** @type {?} */ (this.datasource.options))).paramsWFS
                .fieldNameGeometry;
        }
        /** @type {?} */
        var status = arr.length === 0 ? true : false;
        /** @type {?} */
        var allowedOperators = this.ogcFilterWriter.computeAllowedOperators(this.datasource.options.sourceFields, firstFieldName, this.datasource.options.ogcFilters.allowedOperatorsType);
        /** @type {?} */
        var firstOperatorName = Object.keys(allowedOperators)[0];
        arr.push(this.ogcFilterWriter.addInterfaceFilter((/** @type {?} */ ({
            propertyName: firstFieldName,
            operator: firstOperatorName,
            active: status,
            igoSpatialSelector: 'fixedExtent',
            srsName: this.map.projection,
        })), fieldNameGeometry, lastLevel, this.defaultLogicalParent));
        this.datasource.options.ogcFilters.interfaceOgcFilters = arr;
    };
    /**
     * @return {?}
     */
    OgcFilterableItemComponent.prototype.openDownload = /**
     * @return {?}
     */
    function () {
        this.downloadService.open(this.layer);
    };
    /**
     * @param {?=} force
     * @return {?}
     */
    OgcFilterableItemComponent.prototype.refreshFilters = /**
     * @param {?=} force
     * @return {?}
     */
    function (force) {
        if (force === true) {
            this.lastRunOgcFilter = undefined;
        }
        /** @type {?} */
        var ogcFilters = this.datasource.options.ogcFilters;
        /** @type {?} */
        var activeFilters = ogcFilters.interfaceOgcFilters.filter((/**
         * @param {?} f
         * @return {?}
         */
        function (f) { return f.active === true; }));
        if (activeFilters.length === 0) {
            ogcFilters.filters = undefined;
            ogcFilters.filtered = false;
        }
        if (activeFilters.length > 1) {
            activeFilters[0].parentLogical = activeFilters[1].parentLogical;
        }
        if (activeFilters.filter((/**
         * @param {?} af
         * @return {?}
         */
        function (af) { return ['Contains', 'Intersects', 'Within'].indexOf(af.operator) !== -1; })).length === 0) {
            this.hasActiveSpatialFilter = false;
        }
        else {
            this.hasActiveSpatialFilter = true;
        }
        if (!(JSON.stringify(this.lastRunOgcFilter) === JSON.stringify(activeFilters))) {
            if (this.layer.dataSource.options.type === 'wfs') {
                /** @type {?} */
                var ogcDataSource = this.layer.dataSource;
                /** @type {?} */
                var ogcLayer = ogcDataSource.options.ogcFilters;
                ogcLayer.filters = this.ogcFilterWriter.rebuiltIgoOgcFilterObjectFromSequence(activeFilters);
                this.layer.dataSource.ol.clear();
            }
            else if (this.layer.dataSource.options.type === 'wms' &&
                ogcFilters.enabled) {
                /** @type {?} */
                var rebuildFilter = '';
                if (activeFilters.length >= 1) {
                    /** @type {?} */
                    var ogcDataSource = this.layer.dataSource;
                    /** @type {?} */
                    var ogcLayer = ogcDataSource.options.ogcFilters;
                    ogcLayer.filters = this.ogcFilterWriter.rebuiltIgoOgcFilterObjectFromSequence(activeFilters);
                    rebuildFilter = this.ogcFilterWriter.buildFilter(ogcLayer.filters, undefined, undefined, ((/** @type {?} */ (this.layer.dataSource.options))).fieldNameGeometry);
                }
                this.ogcFilterService.filterByOgc((/** @type {?} */ (this.datasource)), rebuildFilter);
                this.datasource.options.ogcFilters.filtered =
                    activeFilters.length === 0 ? false : true;
            }
            this.lastRunOgcFilter = JSON.parse(JSON.stringify(activeFilters));
        }
    };
    /**
     * @return {?}
     */
    OgcFilterableItemComponent.prototype.setVisible = /**
     * @return {?}
     */
    function () {
        this.layer.visible = true;
    };
    /**
     * @return {?}
     */
    OgcFilterableItemComponent.prototype.isAdvancedOgcFilters = /**
     * @return {?}
     */
    function () {
        return this.datasource.options.ogcFilters.advancedOgcFilters;
    };
    /**
     * @return {?}
     */
    OgcFilterableItemComponent.prototype.addFilterDisabled = /**
     * @return {?}
     */
    function () {
        return (!this.datasource.options.sourceFields ||
            this.datasource.options.sourceFields.length === 0);
    };
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    OgcFilterableItemComponent.prototype.changeOgcFiltersAdvancedOgcFilters = /**
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.datasource.options.ogcFilters.advancedOgcFilters = value;
    };
    /**
     * @param {?} isAdvancedOgcFilters
     * @return {?}
     */
    OgcFilterableItemComponent.prototype.changeOgcFilterType = /**
     * @param {?} isAdvancedOgcFilters
     * @return {?}
     */
    function (isAdvancedOgcFilters) {
        this.changeOgcFiltersAdvancedOgcFilters(isAdvancedOgcFilters.checked);
        if (isAdvancedOgcFilters.checked) {
            this.refreshFilters(true);
        }
    };
    /**
     * @private
     * @param {?} collapsed
     * @return {?}
     */
    OgcFilterableItemComponent.prototype.toggleLegend = /**
     * @private
     * @param {?} collapsed
     * @return {?}
     */
    function (collapsed) {
        this.layer.legendCollapsed = collapsed;
        this.showLegend$.next(!collapsed);
    };
    /**
     * @return {?}
     */
    OgcFilterableItemComponent.prototype.toggleLegendOnClick = /**
     * @return {?}
     */
    function () {
        if (!this.filtersCollapsed) {
            this.toggleLegend(this.showLegend$.value);
        }
    };
    /**
     * @return {?}
     */
    OgcFilterableItemComponent.prototype.toggleFiltersCollapsed = /**
     * @return {?}
     */
    function () {
        this.filtersCollapsed = !this.filtersCollapsed;
    };
    OgcFilterableItemComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igo-ogc-filterable-item',
                    template: "<mat-list-item>\r\n\r\n  <mat-icon\r\n    *ngIf=\"header\"\r\n    class=\"igo-chevron\"\r\n    mat-list-avatar\r\n    igoCollapse [target]=\"ogcFilters\"\r\n    [collapsed]=\"filtersCollapsed\"\r\n    (click)=\"toggleFiltersCollapsed()\"\r\n    svgIcon=\"chevron-up\">\r\n  </mat-icon>\r\n  <h4 (click)=\"toggleLegendOnClick()\" *ngIf=\"header\" [ngStyle]=\"{'cursor': filtersCollapsed ? 'default' : 'pointer'}\" matLine [matTooltip]=\"layer.title\" matTooltipShowDelay=\"500\">{{layer.title}}</h4>\r\n\r\n    <span *ngIf=\"downloadable && header\">\r\n      <button mat-icon-button tooltip-position=\"below\" matTooltipShowDelay=\"500\" [matTooltip]=\"'igo.geo.download.action' | translate\"\r\n        [color]=\"color\" (click)=\"openDownload()\">\r\n        <mat-icon svgIcon=\"download\"></mat-icon>\r\n      </button>\r\n    </span>\r\n    <button *ngIf=\"isAdvancedOgcFilters() && filtersAreEditable\" [disabled]=\"addFilterDisabled()\" mat-icon-button tooltip-position=\"below\" matTooltipShowDelay=\"500\"\r\n      [matTooltip]=\"'igo.geo.filter.addFilter' | translate\" [color]=\"color\" (click)=\"addFilterToSequence()\">\r\n      <mat-icon svgIcon=\"plus\"></mat-icon>\r\n    </button>\r\n    <button *ngIf=\"!layer.visible && header\" mat-icon-button tooltip-position=\"below\"\r\n      matTooltipShowDelay=\"500\" [matTooltip]=\"'igo.geo.layer.showLayer' | translate\" color=\"color\" (click)=\"setVisible()\">\r\n      <mat-icon svgIcon=\"eye-off\"></mat-icon>\r\n    </button>\r\n</mat-list-item>\r\n\r\n<div #ogcFilters class=\"igo-datasource-filters-container\">\r\n    <div *ngIf=\"header\" #legend class=\"igo-layer-legend-container\">\r\n      <igo-layer-legend *ngIf=\"showLegend$ | async\" [layer]=\"layer\">\r\n      </igo-layer-legend>\r\n    </div>\r\n  <igo-ogc-filterable-form [datasource]=\"datasource\" [map]=\"map\" [refreshFilters]=\"refreshFunc\">\r\n  </igo-ogc-filterable-form>\r\n\r\n  <section class=\"mat-typography\">\r\n  <mat-checkbox labelPosition='before' *ngIf=\"hasPushButton && filtersAreEditable\" (change)=\"changeOgcFilterType($event)\"\r\n    [(ngModel)]=\"datasource.options.ogcFilters.advancedOgcFilters\">\r\n    {{'igo.geo.filter.advancedOgcFilters' | translate}}\r\n  </mat-checkbox>\r\n</section>\r\n</div>\r\n",
                    styles: [":host{overflow:hidden}.igo-datasource-filters-container{text-align:center;width:100%;display:inline-block}.mat-list-item{height:auto}.igo-layer-legend-container{padding-left:1.125em;width:calc(100% - 18px)}mat-icon.disabled{color:rgba(0,0,0,.38)}"]
                }] }
    ];
    /** @nocollapse */
    OgcFilterableItemComponent.ctorParameters = function () { return [
        { type: OGCFilterService },
        { type: DownloadService }
    ]; };
    OgcFilterableItemComponent.propDecorators = {
        layer: [{ type: Input }],
        map: [{ type: Input }],
        header: [{ type: Input }]
    };
    return OgcFilterableItemComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var OgcFilterableListComponent = /** @class */ (function () {
    function OgcFilterableListComponent() {
    }
    OgcFilterableListComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igo-ogc-filterable-list',
                    template: "<igo-list [navigation]=\"false\" [selection]=\"false\">\r\n  <ng-template ngFor let-layer [ngForOf]=\"layers | filterableDataSource: 'ogc'\">\r\n    <igo-ogc-filterable-item igoListItem [header]=\"true\" [layer]=\"layer\" \r\n    [map]=\"layer.map\" ></igo-ogc-filterable-item>\r\n  </ng-template>\r\n</igo-list>\r\n",
                    changeDetection: ChangeDetectionStrategy.OnPush
                }] }
    ];
    /** @nocollapse */
    OgcFilterableListComponent.ctorParameters = function () { return []; };
    OgcFilterableListComponent.propDecorators = {
        layers: [{ type: Input }],
        map: [{ type: Input }]
    };
    return OgcFilterableListComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var OgcFilterableListBindingDirective = /** @class */ (function () {
    function OgcFilterableListBindingDirective(component, mapService) {
        this.mapService = mapService;
        this.component = component;
    }
    /**
     * @return {?}
     */
    OgcFilterableListBindingDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // Override input layers
        this.component.layers = [];
        this.layers$$ = this.mapService.getMap().layers$.subscribe((/**
         * @param {?} layers
         * @return {?}
         */
        function (layers) {
            _this.component.layers = layers;
        }));
    };
    /**
     * @return {?}
     */
    OgcFilterableListBindingDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.layers$$.unsubscribe();
    };
    OgcFilterableListBindingDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igoOgcFilterableListBinding]'
                },] }
    ];
    /** @nocollapse */
    OgcFilterableListBindingDirective.ctorParameters = function () { return [
        { type: OgcFilterableListComponent, decorators: [{ type: Self }] },
        { type: MapService }
    ]; };
    return OgcFilterableListBindingDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var OgcFilterButtonComponent = /** @class */ (function () {
    function OgcFilterButtonComponent() {
        this.color = 'primary';
        this.ogcFilterCollapse = false;
    }
    Object.defineProperty(OgcFilterButtonComponent.prototype, "badge", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var filter = (/** @type {?} */ (this.options.ogcFilters));
            if (filter && !filter.advancedOgcFilters) {
                if (filter.pushButtons) {
                    /** @type {?} */
                    var pushButtons = (/** @type {?} */ (filter.pushButtons));
                    /** @type {?} */
                    var currentPushButtonGroup = pushButtons.groups.find((/**
                     * @param {?} gr
                     * @return {?}
                     */
                    function (gr) { return gr.enabled; }));
                    /** @type {?} */
                    var cntPushButtons_1 = 0;
                    if (currentPushButtonGroup) {
                        currentPushButtonGroup.computedButtons.map((/**
                         * @param {?} cb
                         * @return {?}
                         */
                        function (cb) { return cntPushButtons_1 += cb.buttons.filter((/**
                         * @param {?} button
                         * @return {?}
                         */
                        function (button) { return button.enabled; })).length; }));
                    }
                    return cntPushButtons_1 > 0 ? cntPushButtons_1 : undefined;
                }
                else {
                    return;
                }
            }
            else if (filter && filter.filters && !filter.filters.filters) {
                return 1;
            }
            else if (filter && filter.filters && filter.filters.filters) {
                return filter.filters.filters.length;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OgcFilterButtonComponent.prototype, "layer", {
        get: /**
         * @return {?}
         */
        function () {
            return this._layer;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._layer = value;
            if (value) {
                this.options = (/** @type {?} */ (this.layer.dataSource.options));
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OgcFilterButtonComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.options = (/** @type {?} */ (this.layer.dataSource.options));
    };
    OgcFilterButtonComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igo-ogc-filter-button',
                    template: "<button \r\n  *ngIf=\"header && options.ogcFilters && options.ogcFilters.enabled &&\r\n  (options.ogcFilters.pushButtons || options.ogcFilters.editable)\"\r\n  mat-icon-button\r\n  collapsibleButton\r\n  tooltip-position=\"below\"\r\n  matTooltipShowDelay=\"500\"\r\n  [matTooltip]=\"'igo.geo.filter.filterBy' | translate\"\r\n  [color]=\"color\">\r\n  <mat-icon [matBadge]=\"badge\" matBadgeColor=\"warn\" matBadgeSize=\"medium\" svgIcon=\"filter\"></mat-icon>\r\n</button>\r\n\r\n<div #ogcFilter class=\"igo-layer-actions-container\"\r\n*ngIf=\"options.ogcFilters && options.ogcFilters.enabled &&\r\n(options.ogcFilters.pushButtons || options.ogcFilters.editable)\">\r\n  <igo-ogc-filterable-item\r\n    *ngIf=\"ogcFilterCollapse && options.ogcFilters.enabled\"\r\n    igoListItem\r\n    [header]=\"false\"\r\n    [map]=\"layer.map\"\r\n    [layer]=\"layer\">\r\n  </igo-ogc-filterable-item>\r\n</div>\r\n",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: [""]
                }] }
    ];
    /** @nocollapse */
    OgcFilterButtonComponent.ctorParameters = function () { return []; };
    OgcFilterButtonComponent.propDecorators = {
        layer: [{ type: Input }],
        map: [{ type: Input }],
        color: [{ type: Input }],
        header: [{ type: Input }]
    };
    return OgcFilterButtonComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var OgcFilterToggleButtonComponent = /** @class */ (function () {
    function OgcFilterToggleButtonComponent(ogcFilterService) {
        this.ogcFilterService = ogcFilterService;
        this.color = 'primary';
        this.ogcFilterWriter = new OgcFilterWriter();
    }
    /**
     * @return {?}
     */
    OgcFilterToggleButtonComponent.prototype.getPushButtonsGroups = /**
     * @return {?}
     */
    function () {
        return this.datasource.options.ogcFilters.pushButtons.groups;
    };
    /**
     * @return {?}
     */
    OgcFilterToggleButtonComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (this.datasource.options.ogcFilters &&
            this.datasource.options.ogcFilters.pushButtons) {
            this.currentPushButtonGroup =
                this.datasource.options.ogcFilters.pushButtons.groups.find((/**
                 * @param {?} g
                 * @return {?}
                 */
                function (g) { return g.enabled; })) ||
                    this.datasource.options.ogcFilters.pushButtons.groups[0];
        }
        this.applyFilters();
    };
    /**
     * @param {?} pb
     * @return {?}
     */
    OgcFilterToggleButtonComponent.prototype.getToolTip = /**
     * @param {?} pb
     * @return {?}
     */
    function (pb) {
        /** @type {?} */
        var tt;
        if (pb.tooltip) {
            if (Array.isArray(pb.tooltip)) {
                tt = pb.tooltip.join('\n');
            }
            else {
                tt = pb.tooltip;
            }
        }
        return tt || '';
    };
    /**
     * @param {?} pb
     * @return {?}
     */
    OgcFilterToggleButtonComponent.prototype.getButtonColor = /**
     * @param {?} pb
     * @return {?}
     */
    function (pb) {
        /** @type {?} */
        var styles;
        if (pb.color) {
            styles = {
                'background-color': pb.enabled ? "rgba(" + pb.color + ")" : "rgba(255,255,255,0)",
            };
        }
        return styles;
    };
    /**
     * @param {?} bundle
     * @return {?}
     */
    OgcFilterToggleButtonComponent.prototype.bundleIsVertical = /**
     * @param {?} bundle
     * @return {?}
     */
    function (bundle) {
        return bundle.vertical ? bundle.vertical : false;
    };
    /**
     * @return {?}
     */
    OgcFilterToggleButtonComponent.prototype.onChangeGroup = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.getPushButtonsGroups().map((/**
         * @param {?} g
         * @return {?}
         */
        function (g) { return g.enabled = false; }));
        this.getPushButtonsGroups().find((/**
         * @param {?} g
         * @return {?}
         */
        function (g) { return g === _this.currentPushButtonGroup; })).enabled = true;
        this.applyFilters();
    };
    /**
     * @param {?=} currentOgcPushButton
     * @return {?}
     */
    OgcFilterToggleButtonComponent.prototype.applyFilters = /**
     * @param {?=} currentOgcPushButton
     * @return {?}
     */
    function (currentOgcPushButton) {
        if (currentOgcPushButton) {
            currentOgcPushButton.enabled = !currentOgcPushButton.enabled;
        }
        /** @type {?} */
        var filterQueryString = '';
        /** @type {?} */
        var conditions = [];
        this.currentPushButtonGroup.computedButtons.map((/**
         * @param {?} buttonBundle
         * @return {?}
         */
        function (buttonBundle) {
            /** @type {?} */
            var bundleCondition = [];
            buttonBundle.buttons
                .filter((/**
             * @param {?} ogcpb
             * @return {?}
             */
            function (ogcpb) { return ogcpb.enabled === true; }))
                .forEach((/**
             * @param {?} enabledPb
             * @return {?}
             */
            function (enabledPb) { return bundleCondition.push(enabledPb.filters); }));
            if (bundleCondition.length >= 1) {
                if (bundleCondition.length === 1) {
                    conditions.push(bundleCondition[0]);
                }
                else {
                    conditions.push({ logical: buttonBundle.logical, filters: bundleCondition });
                }
            }
        }));
        if (conditions.length >= 1) {
            filterQueryString = this.ogcFilterWriter
                .buildFilter(conditions.length === 1 ?
                conditions[0] : (/** @type {?} */ ({ logical: 'And', filters: conditions })));
        }
        if (this.datasource.options.type === 'wms') {
            this.ogcFilterService.filterByOgc((/** @type {?} */ (this.datasource)), filterQueryString);
        }
        if (this.datasource.options.type === 'wfs') {
            // TODO: Check how to prevent wfs to refresh when filter icon is pushed...
            this.datasource.ol.clear();
        }
    };
    OgcFilterToggleButtonComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igo-ogc-filter-toggle-button',
                    template: "<div *ngIf=\"getPushButtonsGroups().length > 1\">\r\n    <mat-form-field>\r\n      <mat-select tooltip-position=\"below\" matTooltipShowDelay=\"500\"\r\n        [matTooltip]=\"'igo.geo.layer.legend.selectStyle' | translate\" [(ngModel)]=\"currentPushButtonGroup\"\r\n        (selectionChange)=\"onChangeGroup()\">\r\n        <mat-option *ngFor=\"let pbg of getPushButtonsGroups()\" [value]=\"pbg\">{{pbg.title}}</mat-option>\r\n      </mat-select>\r\n  </mat-form-field>\r\n</div>\r\n<ng-container *ngFor=\"let bundle of currentPushButtonGroup.computedButtons\">\r\n        <mat-button-toggle-group \r\n        class=\"mat-typography\"\r\n        appearance=\"legacy\" vertical={{bundleIsVertical(bundle)}} multiple=\"true\">\r\n            <mat-button-toggle [ngStyle]=\"getButtonColor(ogcPushButton)\" [checked]=\"ogcPushButton.enabled\"\r\n                (change)=\"applyFilters(ogcPushButton)\" tooltip-position=\"below\" matTooltipShowDelay=\"500\"\r\n                [matTooltip]=\"getToolTip(ogcPushButton)\" matTooltipClass=\"material-tooltip\" \r\n                *ngFor=\"let ogcPushButton of bundle.buttons\" [value]=\"ogcPushButton\">{{ogcPushButton.title}}\r\n            </mat-button-toggle>\r\n        </mat-button-toggle-group>\r\n</ng-container>\r\n",
                    styles: [".mat-button-toggle-group{margin:5px;flex-wrap:wrap}.mat-button-toggle{display:-webkit-inline-box;display:inline-flex}::ng-deep .material-tooltip{white-space:pre-line}"]
                }] }
    ];
    /** @nocollapse */
    OgcFilterToggleButtonComponent.ctorParameters = function () { return [
        { type: OGCFilterService }
    ]; };
    OgcFilterToggleButtonComponent.propDecorators = {
        refreshFilters: [{ type: Input }],
        datasource: [{ type: Input }],
        map: [{ type: Input }]
    };
    return OgcFilterToggleButtonComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Spatial Filter Type
 */
var SpatialFilterTypeComponent = /** @class */ (function () {
    function SpatialFilterTypeComponent() {
        this.queryType = ['Arrond', 'CircFed', 'CircProv', 'DirReg', 'Mun', 'MRC', 'AdmRegion', 'RegTour'];
        this.selectedTypeIndex = new FormControl(0);
        /**
         * Reference to the SpatialFIlterType enum
         * \@internal
         */
        this.spatialType = SpatialFilterType;
        this.activeDrawType = this.spatialType.Polygon;
        this.eventType = new EventEmitter();
        this.eventQueryType = new EventEmitter();
        this.zoneChange = new EventEmitter();
    }
    Object.defineProperty(SpatialFilterTypeComponent.prototype, "store", {
        get: /**
         * @return {?}
         */
        function () {
            return this._store;
        },
        set: /**
         * @param {?} store
         * @return {?}
         */
        function (store) {
            this._store = store;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    SpatialFilterTypeComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (this.selectedTypeIndex.value === 0) {
            this.type = this.spatialType.Predefined;
        }
        if (this.selectedTypeIndex.value === 1) {
            this.type = this.activeDrawType;
        }
        this.eventType.emit(this.type);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    SpatialFilterTypeComponent.prototype.onTypeChange = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.selectedTypeIndex.value === 0) {
            this.type = SpatialFilterType.Predefined;
        }
        if (this.selectedTypeIndex.value === 1) {
            this.type = this.activeDrawType;
        }
        this.eventType.emit(this.type);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    SpatialFilterTypeComponent.prototype.onQueryTypeChange = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.eventQueryType.emit(this.selectedQueryType);
    };
    /**
     * @param {?} feature
     * @return {?}
     */
    SpatialFilterTypeComponent.prototype.onZoneChange = /**
     * @param {?} feature
     * @return {?}
     */
    function (feature) {
        this.zoneChange.emit(feature);
    };
    /**
     * @param {?} spatialType
     * @return {?}
     */
    SpatialFilterTypeComponent.prototype.onDrawTypeChange = /**
     * @param {?} spatialType
     * @return {?}
     */
    function (spatialType) {
        this.activeDrawType = spatialType;
        this.eventType.emit(this.activeDrawType);
    };
    SpatialFilterTypeComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igo-spatial-filter-type',
                    template: "<mat-tab-group\r\n  [selectedIndex]=\"selectedTypeIndex.value\"\r\n  (selectedIndexChange)=\"selectedTypeIndex.setValue($event)\"\r\n  (selectedTabChange)=\"onTypeChange($event)\">\r\n\r\n  <mat-tab [label]=\"'igo.geo.spatialFilter.predefined' |\u00A0translate\">\r\n    <mat-form-field>\r\n      <mat-label>{{'igo.geo.spatialFilter.searchLabel' | translate}}</mat-label>\r\n      <mat-select (selectionChange)=\"onQueryTypeChange($event)\" [(value)]=\"selectedQueryType\">\r\n        <mat-option *ngFor=\"let queryType of queryType\" [value]=\"queryType\">\r\n          {{('igo.geo.terrapi.' + queryType) | translate}}\r\n        </mat-option>\r\n      </mat-select>\r\n    </mat-form-field>\r\n    <igo-spatial-filter-list\r\n      [store]=\"store\"\r\n      [queryType]=\"selectedQueryType\"\r\n      [selectedZone]=\"zone\"\r\n      (zoneChange)=\"onZoneChange($event)\">\r\n    </igo-spatial-filter-list>\r\n  </mat-tab>\r\n\r\n  <mat-tab [label]=\"'igo.geo.spatialFilter.draw' |\u00A0translate\">\r\n    <div class=\"spatial-type-toggle\">\r\n      <mat-button-toggle-group\r\n        [value]=\"activeDrawType\"\r\n        (change)=\"onDrawTypeChange($event.value)\">\r\n        <mat-button-toggle [value]=\"spatialType.Polygon\" [matTooltip]=\"'igo.geo.spatialFilter.drawPolygon' |\u00A0translate\">\r\n            <mat-icon svgIcon=\"pentagon-outline\"></mat-icon>\r\n        </mat-button-toggle>\r\n        <mat-button-toggle [value]=\"spatialType.Point\" [matTooltip]=\"'igo.geo.spatialFilter.drawCircle' |\u00A0translate\">\r\n            <mat-icon svgIcon=\"record-circle-outline\"></mat-icon>\r\n        </mat-button-toggle>\r\n      </mat-button-toggle-group>\r\n    </div>\r\n  </mat-tab>\r\n\r\n</mat-tab-group>\r\n",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: [".mat-form-field{padding:5px;width:95%;margin-left:2px}.mat-tab-group ::ng-deep .mat-tab-body-content{overflow:hidden}.mat-tab-group ::ng-deep .mat-tab-label{padding:10px}.mat-tab-group ::ng-deep .mat-tab-body-wrapper{margin-top:5px}.spatial-type-toggle{padding:10px;text-align:center}.spatial-type-toggle mat-button-toggle-group,.spatial-type-toggle mat-button-toggle-group mat-button-toggle{width:50%}"]
                }] }
    ];
    /** @nocollapse */
    SpatialFilterTypeComponent.ctorParameters = function () { return []; };
    SpatialFilterTypeComponent.propDecorators = {
        store: [{ type: Input }],
        selectedQueryType: [{ type: Input }],
        zone: [{ type: Input }],
        eventType: [{ type: Output }],
        eventQueryType: [{ type: Output }],
        zoneChange: [{ type: Output }]
    };
    return SpatialFilterTypeComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SpatialFilterListComponent = /** @class */ (function () {
    function SpatialFilterListComponent(spatialFilterService) {
        this.spatialFilterService = spatialFilterService;
        this.formControl = new FormControl();
        this.zoneChange = new EventEmitter();
    }
    Object.defineProperty(SpatialFilterListComponent.prototype, "store", {
        get: /**
         * @return {?}
         */
        function () {
            return this._store;
        },
        set: /**
         * @param {?} store
         * @return {?}
         */
        function (store) {
            this._store = store;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpatialFilterListComponent.prototype, "queryType", {
        get: /**
         * @return {?}
         */
        function () {
            return this._queryType;
        },
        set: /**
         * @param {?} queryType
         * @return {?}
         */
        function (queryType) {
            this.formControl.setValue('');
            this._queryType = queryType;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    SpatialFilterListComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.formValueChanges$$ = this.formControl.valueChanges.subscribe((/**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value.length) {
                _this.store.view.filter((/**
                 * @param {?} feature
                 * @return {?}
                 */
                function (feature) {
                    /** @type {?} */
                    var filterNormalized = value.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
                    /** @type {?} */
                    var featureNameNormalized = feature.properties.nom.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
                    return featureNameNormalized.includes(filterNormalized);
                }));
            }
        }));
    };
    /**
     * @return {?}
     */
    SpatialFilterListComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.formValueChanges$$.unsubscribe();
    };
    /**
     * @param {?=} feature
     * @return {?}
     */
    SpatialFilterListComponent.prototype.displayFn = /**
     * @param {?=} feature
     * @return {?}
     */
    function (feature) {
        return feature ? feature.properties.nom : undefined;
    };
    /**
     * @param {?} feature
     * @return {?}
     */
    SpatialFilterListComponent.prototype.onZoneChange = /**
     * @param {?} feature
     * @return {?}
     */
    function (feature) {
        var _this = this;
        if (feature && this.queryType) {
            this.spatialFilterService.loadItemById(feature, this.queryType)
                .subscribe((/**
             * @param {?} featureGeom
             * @return {?}
             */
            function (featureGeom) {
                _this.selectedZone = featureGeom;
                _this.zoneChange.emit(featureGeom);
            }));
        }
    };
    SpatialFilterListComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igo-spatial-filter-list',
                    template: "<form class=\"form-list\">\r\n    <mat-form-field>\r\n        <input #input type=\"text\" placeholder=\"{{'igo.geo.spatialFilter.listLabel' |\u00A0translate}}\" matInput\r\n        [formControl]=\"formControl\" [matAutocomplete]=\"auto\">\r\n        <mat-autocomplete #auto=\"matAutocomplete\" (optionSelected)=\"onZoneChange($event.option.value)\"\r\n        [displayWith]=\"displayFn\">\r\n            <mat-option *ngFor=\"let entities of this.store.view.all$() | async\" [value]=\"entities\">\r\n                {{entities.properties.nom}}\r\n            </mat-option>\r\n        </mat-autocomplete>\r\n    </mat-form-field>\r\n<form>\r\n",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: [".mat-form-field{padding:5px;width:95%;margin-left:2px}"]
                }] }
    ];
    /** @nocollapse */
    SpatialFilterListComponent.ctorParameters = function () { return [
        { type: SpatialFilterService }
    ]; };
    SpatialFilterListComponent.propDecorators = {
        store: [{ type: Input }],
        queryType: [{ type: Input }],
        selectedZone: [{ type: Input }],
        zoneChange: [{ type: Output }]
    };
    return SpatialFilterListComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Spatial-Filter-Item (search parameters)
 */
var SpatialFilterItemComponent = /** @class */ (function () {
    function SpatialFilterItemComponent(cdRef, spatialFilterService, messageService, languageService) {
        this.cdRef = cdRef;
        this.spatialFilterService = spatialFilterService;
        this.messageService = messageService;
        this.languageService = languageService;
        this.layers = [];
        this.toggleSearch = new EventEmitter();
        this.itemTypeChange = new EventEmitter();
        this.thematicChange = new EventEmitter();
        this.drawZoneEvent = new EventEmitter();
        this.radiusEvent = new EventEmitter();
        this.freehandControl = new EventEmitter();
        this.clearButtonEvent = new EventEmitter();
        this.clearSearchEvent = new EventEmitter();
        this.export = new EventEmitter();
        this.itemType = [SpatialFilterItemType.Address, SpatialFilterItemType.Thematics];
        this.selectedItemType = SpatialFilterItemType.Address;
        this.treeControl = new NestedTreeControl((/**
         * @param {?} node
         * @return {?}
         */
        function (node) { return node.children; }));
        // For thematics and results tables
        this.displayedColumns = ['name', 'select'];
        this.childrens = [];
        this.groups = [];
        this.thematics = [];
        this.dataSource = new MatTreeNestedDataSource();
        this.selectedThematics = new SelectionModel(true, []);
        this.displayedColumnsResults = ['typeResults', 'nameResults'];
        // For geometry form field input
        this.value$ = new BehaviorSubject(undefined);
        this.drawGuide$ = new BehaviorSubject(null);
        this.overlayStyle$ = new BehaviorSubject(undefined);
        this.drawStyle$ = new BehaviorSubject(undefined);
        this.formControl = new FormControl();
        this.geometryTypeField = false;
        this.geometryTypes = ['Point', 'Polygon'];
        this.drawGuideField = false;
        this.drawGuide = null;
        this.drawGuidePlaceholder = '';
        this.measure = false;
        this.drawControlIsActive = true;
        this.freehandDrawIsActive = false;
        this.radiusFormControl = new FormControl();
        this.measureUnit = MeasureLengthUnit.Meters;
    }
    Object.defineProperty(SpatialFilterItemComponent.prototype, "type", {
        get: /**
         * @return {?}
         */
        function () {
            return this._type;
        },
        set: /**
         * @param {?} type
         * @return {?}
         */
        function (type) {
            var _this = this;
            this._type = type;
            /** @type {?} */
            var index = this.geometryTypes.findIndex((/**
             * @param {?} geom
             * @return {?}
             */
            function (geom) { return geom === _this.type; }));
            this.geometryType = this.geometryTypes[index];
            this.formControl.reset();
            this.radius = undefined;
            this.drawGuide$.next(null);
            this.drawStyle$.next(undefined);
            // Necessary to keep reference to the geometry form field input
            if (this.type === SpatialFilterType.Predefined) {
                /** @type {?} */
                var geojson = {
                    type: 'Point',
                    coordinates: ''
                };
                this.formControl.setValue(geojson);
            }
            // Necessary to apply the right style when geometry type is Point
            if (this.type === SpatialFilterType.Point) {
                this.radius = 1000; // Base radius
                this.radiusFormControl.setValue(this.radius);
                this.PointStyle = (/**
                 * @param {?} feature
                 * @param {?} resolution
                 * @return {?}
                 */
                function (feature, resolution) {
                    /** @type {?} */
                    var coordinates = transform(feature.getGeometry().getCoordinates(), _this.map.projection, 'EPSG:4326');
                    return new Style({
                        image: new Circle({
                            radius: _this.radius / (Math.cos((Math.PI / 180) * coordinates[1])) / resolution,
                            // Latitude correction
                            stroke: new Stroke({
                                width: 2,
                                color: 'rgba(0, 153, 255)'
                            }),
                            fill: new Fill({
                                color: 'rgba(0, 153, 255, 0.2)'
                            })
                        })
                    });
                });
                this.overlayStyle = this.PointStyle;
                this.drawStyle$.next(this.overlayStyle);
            }
            else {
                // If geometry types is Polygon
                this.radius = undefined;
                this.PolyStyle = (/**
                 * @param {?} feature
                 * @param {?} resolution
                 * @return {?}
                 */
                function (feature, resolution) {
                    return new Style({
                        stroke: new Stroke({
                            width: 2,
                            color: 'rgba(0, 153, 255)'
                        }),
                        fill: new Fill({
                            color: 'rgba(0, 153, 255, 0.2)'
                        })
                    });
                });
                this.overlayStyle = this.PolyStyle;
            }
            this.overlayStyle$.next(this.overlayStyle);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpatialFilterItemComponent.prototype, "store", {
        get: /**
         * @return {?}
         */
        function () {
            return this._store;
        },
        set: /**
         * @param {?} store
         * @return {?}
         */
        function (store) {
            var _this = this;
            this._store = store;
            this._store.entities$.subscribe((/**
             * @return {?}
             */
            function () { _this.cdRef.detectChanges(); }));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpatialFilterItemComponent.prototype, "measureUnits", {
        /**
         * Available measure units for the measure type given
         * @internal
         */
        get: /**
         * Available measure units for the measure type given
         * \@internal
         * @return {?}
         */
        function () {
            return [MeasureLengthUnit.Meters];
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    SpatialFilterItemComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.spatialFilterService.loadThematicsList()
            .subscribe((/**
         * @param {?} items
         * @return {?}
         */
        function (items) {
            var e_1, _a;
            try {
                for (var items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
                    var item = items_1_1.value;
                    _this.childrens.push(item);
                    _this.childrens.sort((/**
                     * @param {?} a
                     * @param {?} b
                     * @return {?}
                     */
                    function (a, b) {
                        return a.name.localeCompare(b.name);
                    }));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (items_1_1 && !items_1_1.done && (_a = items_1.return)) _a.call(items_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            _this.childrens.forEach((/**
             * @param {?} child
             * @return {?}
             */
            function (child) {
                if (child.group && (_this.groups.indexOf(child.group) === -1)) {
                    _this.groups.push(child.group);
                    /** @type {?} */
                    var thematic = {
                        name: child.group,
                        children: []
                    };
                    _this.thematics.push(thematic);
                }
                if (!child.group) {
                    /** @type {?} */
                    var thematic = {
                        name: child.name,
                        children: [],
                        source: child.source
                    };
                    _this.thematics.push(thematic);
                }
                _this.thematics.sort((/**
                 * @param {?} a
                 * @param {?} b
                 * @return {?}
                 */
                function (a, b) {
                    return a.name.localeCompare(b.name);
                }));
            }));
            _this.thematics.forEach((/**
             * @param {?} thematic
             * @return {?}
             */
            function (thematic) {
                var e_2, _a;
                try {
                    for (var _b = __values(_this.childrens), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var child = _c.value;
                        if (child.group === thematic.name) {
                            thematic.children.push(child);
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }));
        }));
        this.dataSource.data = this.thematics;
        this.drawGuide$.next(null);
        this.value$.next(this.formControl.value ? this.formControl.value : undefined);
        this.value$$ = this.formControl.valueChanges.subscribe((/**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            _this.value$.next(value ? value : undefined);
        }));
        this.value$.subscribe((/**
         * @return {?}
         */
        function () {
            _this.getRadius();
            _this.cdRef.detectChanges();
        }));
        this.radiusChanges$$ = this.radiusFormControl.valueChanges.subscribe((/**
         * @return {?}
         */
        function () {
            _this.getRadius();
            _this.cdRef.detectChanges();
        }));
    };
    /**
     * Unsubscribe to the value stream
     * @internal
     */
    /**
     * Unsubscribe to the value stream
     * \@internal
     * @return {?}
     */
    SpatialFilterItemComponent.prototype.ngOnDestroy = /**
     * Unsubscribe to the value stream
     * \@internal
     * @return {?}
     */
    function () {
        this.value$$.unsubscribe();
        this.cdRef.detach();
    };
    /**
     * @param {?} event
     * @return {?}
     */
    SpatialFilterItemComponent.prototype.onItemTypeChange = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.selectedItemType = event.value;
        this.itemTypeChange.emit(this.selectedItemType);
    };
    /**
     * Set the measure unit
     * @internal
     */
    /**
     * Set the measure unit
     * \@internal
     * @param {?} unit
     * @return {?}
     */
    SpatialFilterItemComponent.prototype.onMeasureUnitChange = /**
     * Set the measure unit
     * \@internal
     * @param {?} unit
     * @return {?}
     */
    function (unit) {
        this.measureUnit = unit;
    };
    /**
     * @return {?}
     */
    SpatialFilterItemComponent.prototype.isPredefined = /**
     * @return {?}
     */
    function () {
        return this.type === SpatialFilterType.Predefined;
    };
    /**
     * @return {?}
     */
    SpatialFilterItemComponent.prototype.isPolygon = /**
     * @return {?}
     */
    function () {
        return this.type === SpatialFilterType.Polygon;
    };
    /**
     * @return {?}
     */
    SpatialFilterItemComponent.prototype.isPoint = /**
     * @return {?}
     */
    function () {
        return this.type === SpatialFilterType.Point;
    };
    /**
     * @param {?} _
     * @param {?} node
     * @return {?}
     */
    SpatialFilterItemComponent.prototype.hasChild = /**
     * @param {?} _
     * @param {?} node
     * @return {?}
     */
    function (_, node) {
        if (node.children) {
            return node.children.length;
        }
        return false;
    };
    /**
     * @param {?} node
     * @return {?}
     */
    SpatialFilterItemComponent.prototype.onToggleClick = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        this.treeControl.isExpanded(node) ? this.treeControl.collapse(node) : this.treeControl.expand(node);
    };
    /**
     * @param {?=} node
     * @return {?}
     */
    SpatialFilterItemComponent.prototype.isAllSelected = /**
     * @param {?=} node
     * @return {?}
     */
    function (node) {
        var _this = this;
        /** @type {?} */
        var numSelected;
        /** @type {?} */
        var numNodes = 0;
        if (!node) {
            numSelected = this.selectedThematics.selected.length;
            this.thematics.forEach((/**
             * @param {?} thematic
             * @return {?}
             */
            function (thematic) {
                if (_this.groups.indexOf(thematic.name) === -1) {
                    numNodes++;
                }
            }));
            this.childrens.forEach((/**
             * @param {?} children
             * @return {?}
             */
            function (children) {
                if (!_this.thematics.find((/**
                 * @param {?} thematic
                 * @return {?}
                 */
                function (thematic) { return thematic.source === children.source; }))) {
                    numNodes++;
                }
            }));
        }
        else {
            numSelected = node.children.length;
            node.children.forEach((/**
             * @param {?} children
             * @return {?}
             */
            function (children) {
                if (_this.selectedThematics.selected.find((/**
                 * @param {?} thematic
                 * @return {?}
                 */
                function (thematic) { return thematic === children; }))) {
                    numNodes++;
                }
            }));
        }
        if (numNodes >= 1) {
            return numSelected === numNodes;
        }
        else {
            return false;
        }
    };
    /**
     * @param {?} node
     * @return {?}
     */
    SpatialFilterItemComponent.prototype.hasChildrenSelected = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        var _this = this;
        /** @type {?} */
        var bool = false;
        node.children.forEach((/**
         * @param {?} child
         * @return {?}
         */
        function (child) {
            if (_this.selectedThematics.selected.find((/**
             * @param {?} thematic
             * @return {?}
             */
            function (thematic) { return thematic.source === child.source; }))) {
                bool = true;
            }
        }));
        return bool;
    };
    /**
     * Apply header checkbox
     */
    /**
     * Apply header checkbox
     * @return {?}
     */
    SpatialFilterItemComponent.prototype.masterToggle = /**
     * Apply header checkbox
     * @return {?}
     */
    function () {
        var _this = this;
        var e_3, _a;
        this.isAllSelected() ?
            this.selectedThematics.clear() :
            this.selectAll();
        /** @type {?} */
        var selectedThematicsName = [];
        try {
            for (var _b = __values(this.selectedThematics.selected), _c = _b.next(); !_c.done; _c = _b.next()) {
                var thematic = _c.value;
                selectedThematicsName.push(thematic);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
        if (this.isAllSelected()) {
            this.thematics.forEach((/**
             * @param {?} thematic
             * @return {?}
             */
            function (thematic) {
                if (_this.hasChild(0, thematic)) {
                    _this.treeControl.expand(thematic);
                }
            }));
        }
        else {
            this.thematics.forEach((/**
             * @param {?} thematic
             * @return {?}
             */
            function (thematic) {
                if (_this.hasChild(0, thematic)) {
                    _this.treeControl.collapse(thematic);
                }
            }));
        }
        this.thematicChange.emit(selectedThematicsName);
    };
    /**
     * @param {?=} node
     * @return {?}
     */
    SpatialFilterItemComponent.prototype.selectAll = /**
     * @param {?=} node
     * @return {?}
     */
    function (node) {
        var _this = this;
        if (!node) {
            this.thematics.forEach((/**
             * @param {?} thematic
             * @return {?}
             */
            function (thematic) {
                if (_this.groups.indexOf(thematic.name) === -1) {
                    _this.selectedThematics.select(thematic);
                }
            }));
            this.childrens.forEach((/**
             * @param {?} children
             * @return {?}
             */
            function (children) {
                if (!_this.selectedThematics.selected.find((/**
                 * @param {?} thematic
                 * @return {?}
                 */
                function (thematic) { return thematic.source === children.source; }))) {
                    _this.selectedThematics.select(children);
                }
            }));
        }
        else {
            if (this.hasChild(0, node)) {
                node.children.forEach((/**
                 * @param {?} children
                 * @return {?}
                 */
                function (children) { return _this.selectedThematics.select(children); }));
            }
        }
    };
    /**
     * @param {?} node
     * @return {?}
     */
    SpatialFilterItemComponent.prototype.childrensToggle = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        var _this = this;
        var e_4, _a;
        this.isAllSelected(node) ?
            node.children.forEach((/**
             * @param {?} child
             * @return {?}
             */
            function (child) { return _this.selectedThematics.deselect(child); })) :
            this.selectAll(node);
        /** @type {?} */
        var selectedThematicsName = [];
        try {
            for (var _b = __values(this.selectedThematics.selected), _c = _b.next(); !_c.done; _c = _b.next()) {
                var thematic = _c.value;
                selectedThematicsName.push(thematic);
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_4) throw e_4.error; }
        }
        this.treeControl.expand(node);
        this.thematicChange.emit(selectedThematicsName);
    };
    /**
     * Apply changes to the thematics selected tree and emit event
     */
    /**
     * Apply changes to the thematics selected tree and emit event
     * @param {?} nodeSelected
     * @return {?}
     */
    SpatialFilterItemComponent.prototype.onToggleChange = /**
     * Apply changes to the thematics selected tree and emit event
     * @param {?} nodeSelected
     * @return {?}
     */
    function (nodeSelected) {
        var _this = this;
        var e_5, _a;
        /** @type {?} */
        var selected = false;
        if (this.selectedThematics.selected.find((/**
         * @param {?} thematic
         * @return {?}
         */
        function (thematic) { return thematic.source === nodeSelected.source; })) !== undefined) {
            selected = true;
        }
        this.childrens.forEach((/**
         * @param {?} children
         * @return {?}
         */
        function (children) {
            if (children === nodeSelected && selected === false) {
                _this.selectedThematics.select(children);
            }
            if (children === nodeSelected && selected === true) {
                _this.selectedThematics.deselect(children);
            }
        }));
        this.thematics.forEach((/**
         * @param {?} thematic
         * @return {?}
         */
        function (thematic) {
            if (thematic === nodeSelected && selected === false) {
                _this.selectedThematics.select(thematic);
            }
            if (thematic === nodeSelected && selected === true) {
                _this.selectedThematics.deselect(thematic);
            }
        }));
        /** @type {?} */
        var selectedThematicsName = [];
        try {
            for (var _b = __values(this.selectedThematics.selected), _c = _b.next(); !_c.done; _c = _b.next()) {
                var thematic = _c.value;
                selectedThematicsName.push(thematic);
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_5) throw e_5.error; }
        }
        this.thematicChange.emit(selectedThematicsName);
    };
    /**
     * @return {?}
     */
    SpatialFilterItemComponent.prototype.onDrawControlChange = /**
     * @return {?}
     */
    function () {
        this.drawControlIsActive = !this.drawControlIsActive;
    };
    /**
     * @return {?}
     */
    SpatialFilterItemComponent.prototype.onfreehandControlChange = /**
     * @return {?}
     */
    function () {
        this.freehandDrawIsActive = !this.freehandDrawIsActive;
        this.freehandControl.emit(this.freehandDrawIsActive);
    };
    /**
     * Launch search button
     */
    /**
     * Launch search button
     * @return {?}
     */
    SpatialFilterItemComponent.prototype.toggleSearchButton = /**
     * Launch search button
     * @return {?}
     */
    function () {
        if (this.isPolygon() || this.isPoint()) {
            this.drawZone = (/** @type {?} */ (this.formControl.value));
            this.drawZone.meta = {
                id: undefined,
                title: 'Zone'
            };
            this.drawZone.properties = {
                nom: 'Zone'
            };
            this.drawZoneEvent.emit(this.drawZone);
        }
        this.radiusEvent.emit(this.radius);
        this.toggleSearch.emit();
    };
    /**
     * Launch clear button (clear store and map layers)
     */
    /**
     * Launch clear button (clear store and map layers)
     * @return {?}
     */
    SpatialFilterItemComponent.prototype.clearButton = /**
     * Launch clear button (clear store and map layers)
     * @return {?}
     */
    function () {
        this.loading = true;
        this.map.removeLayers(this.layers);
        this.loading = false;
        if (this.store) {
            this.store.clear();
        }
        this.clearButtonEvent.emit([]);
    };
    /**
     * Launch clear search (clear field if type is predefined)
     */
    /**
     * Launch clear search (clear field if type is predefined)
     * @return {?}
     */
    SpatialFilterItemComponent.prototype.clearSearch = /**
     * Launch clear search (clear field if type is predefined)
     * @return {?}
     */
    function () {
        this.selectedThematics.clear();
        this.thematicChange.emit([]);
        this.clearSearchEvent.emit();
    };
    /**
     * Verify conditions of incomplete fields or busy service
     */
    /**
     * Verify conditions of incomplete fields or busy service
     * @return {?}
     */
    SpatialFilterItemComponent.prototype.disableSearchButton = /**
     * Verify conditions of incomplete fields or busy service
     * @return {?}
     */
    function () {
        if (this.type === SpatialFilterType.Predefined) {
            if (this.selectedItemType === SpatialFilterItemType.Address) {
                if (this.queryType !== undefined && this.zone !== undefined) {
                    return this.loading;
                }
            }
            if (this.selectedItemType === SpatialFilterItemType.Thematics) {
                if (this.queryType !== undefined && this.zone !== undefined && this.selectedThematics.selected.length > 0) {
                    return this.loading;
                }
            }
        }
        if (this.type === SpatialFilterType.Polygon || this.type === SpatialFilterType.Point) {
            if (this.selectedItemType === SpatialFilterItemType.Address && this.formControl.value !== null) {
                return this.loading;
            }
            if (this.selectedItemType === SpatialFilterItemType.Thematics) {
                if (this.selectedThematics.selected.length > 0 && this.formControl.value !== null) {
                    return this.loading;
                }
            }
        }
        return true;
    };
    /**
     * Manage radius value at user change
     */
    /**
     * Manage radius value at user change
     * @return {?}
     */
    SpatialFilterItemComponent.prototype.getRadius = /**
     * Manage radius value at user change
     * @return {?}
     */
    function () {
        /** @type {?} */
        var formValue;
        this.formControl.value !== null ? formValue = this.formControl.value.radius : formValue = undefined;
        if (this.type === SpatialFilterType.Point) {
            if (!this.freehandDrawIsActive) {
                if (this.radiusFormControl.value >= 10000 || this.radiusFormControl.value < 0) {
                    this.messageService.alert(this.languageService.translate.instant('igo.geo.spatialFilter.radiusAlert'), this.languageService.translate.instant('igo.geo.spatialFilter.warning'));
                    this.radius = 1000;
                    this.radiusFormControl.setValue(this.radius);
                    this.drawGuide$.next(this.radius);
                    return;
                }
            }
            else {
                if (this.radiusFormControl.value >= 10000 || this.radiusFormControl.value < 0) {
                    this.messageService.alert(this.languageService.translate.instant('igo.geo.spatialFilter.radiusAlert'), this.languageService.translate.instant('igo.geo.spatialFilter.warning'));
                    this.radius = 1000;
                    this.radiusFormControl.setValue(this.radius);
                    this.drawGuide$.next(this.radius);
                    return;
                }
                if (formValue >= 10000) {
                    this.messageService.alert(this.languageService.translate.instant('igo.geo.spatialFilter.radiusAlert'), this.languageService.translate.instant('igo.geo.spatialFilter.warning'));
                    this.formControl.reset();
                    return;
                }
                if (formValue) {
                    if (formValue !== this.radiusFormControl.value) {
                        this.radiusFormControl.setValue(formValue);
                    }
                    this.formControl.value.radius = undefined;
                }
            }
            this.radius = this.radiusFormControl.value;
            this.drawGuide$.next(this.radius);
            this.overlayStyle$.next(this.PointStyle);
            this.drawStyle$.next(this.PointStyle);
        }
    };
    SpatialFilterItemComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igo-spatial-filter-item',
                    template: "<igo-geometry-form-field-input\r\n  [formControl]=\"formControl\"\r\n  [map]=\"map\"\r\n  [geometryType]=\"geometryType\"\r\n  [drawGuide]=\"drawGuide$ | async\"\r\n  [measure]=\"measure\"\r\n  [drawControlIsActive]=\"drawControlIsActive\"\r\n  [freehandDrawIsActive]=\"freehandDrawIsActive\"\r\n  [drawStyle]=\"drawStyle$ | async\"\r\n  [overlayStyle]=\"overlayStyle$ | async\"\r\n  [radius]=\"radius\">\r\n</igo-geometry-form-field-input>\r\n\r\n<div class=\"header\">\r\n    <mat-slide-toggle *ngIf=\"!isPredefined()\"\r\n      [checked]=\"drawControlIsActive\"\r\n      [labelPosition]=\"'before'\"\r\n      (change)=\"onDrawControlChange()\">\r\n      {{'igo.geo.spatialFilter.drawControl' | translate}}\r\n    </mat-slide-toggle>\r\n    <mat-slide-toggle *ngIf=\"!isPredefined()\"\r\n      [checked]=\"freehandDrawIsActive\"\r\n      [labelPosition]=\"'before'\"\r\n      (change)=\"onfreehandControlChange()\">\r\n      {{'igo.geo.spatialFilter.freehandControl' | translate}}\r\n    </mat-slide-toggle>\r\n</div>\r\n\r\n  <div class=\"radius-unit\" *ngIf=\"isPoint()\">\r\n    <form class=\"radius-form\">\r\n      <mat-form-field class=\"radius\">\r\n        <input type=\"number\" matInput placeholder=\"{{'igo.geo.spatialFilter.radius' | translate}}\" [formControl]=\"radiusFormControl\"\r\n        [value]=\"1000\" (input)=\"getRadius()\" [readonly]=\"this.freehandDrawIsActive && this.formControl.value === null\">\r\n        <label class=\"unit-field\">\r\n          {{('igo.geo.measure.' + measureUnit) | translate}}\r\n        </label>\r\n      </mat-form-field>\r\n    </form>\r\n  </div>\r\n\r\n  <mat-label class=\"title mat-typography\">{{'igo.geo.spatialFilter.search' | translate}} : </mat-label>\r\n  <mat-radio-group [value]=\"selectedItemType\">\r\n      <mat-radio-button *ngFor=\"let item of itemType\"\r\n        [value]=\"item\"\r\n        (change)=\"onItemTypeChange($event)\">\r\n        {{'igo.geo.spatialFilter.' + item | translate}}\r\n      </mat-radio-button>\r\n  </mat-radio-group>\r\n\r\n<div class=\"thematics\" *ngIf=\"selectedItemType==='Thematics'\">\r\n  <mat-table>\r\n      <!-- Name Column -->\r\n      <ng-container matColumnDef=\"name\">\r\n        <mat-header-cell *matHeaderCellDef class=\"thematics-header\">{{'igo.geo.spatialFilter.Thematics' | translate}}</mat-header-cell>\r\n      </ng-container>\r\n\r\n      <!-- Select Column -->\r\n      <ng-container matColumnDef=\"select\">\r\n        <mat-header-cell *matHeaderCellDef class=\"checks-header\">\r\n          <mat-checkbox (change)=\"$event ? masterToggle() : null\"\r\n                        [checked]=\"isAllSelected()\"\r\n                        [indeterminate]=\"selectedThematics.hasValue() && !isAllSelected()\">\r\n          </mat-checkbox>\r\n        </mat-header-cell>\r\n    </ng-container>\r\n\r\n    <mat-header-row *matHeaderRowDef=\"displayedColumns\"></mat-header-row>\r\n    <mat-row *matRowDef=\"let row; columns: displayedColumns;\"></mat-row>\r\n\r\n  </mat-table>\r\n\r\n  <mat-tree [dataSource]=\"dataSource\" [treeControl]=\"treeControl\">\r\n    <!-- This is the tree node template for leaf nodes -->\r\n    <mat-tree-node *matTreeNodeDef=\"let node\" matTreeNodeToggle>\r\n      <li class=\"mat-tree-node\">\r\n        <!-- use a disabled button to provide padding for tree leaf -->\r\n        <button mat-icon-button disabled></button>\r\n        {{node.name}}\r\n        <mat-checkbox class=\"tree-check\" (click)=\"$event.stopPropagation()\"\r\n                      (change)=\"$event ? onToggleChange(node) : null\"\r\n                      [checked]=\"selectedThematics.isSelected(node)\">\r\n        </mat-checkbox>\r\n      </li>\r\n    </mat-tree-node>\r\n\r\n    <!-- This is the tree node template for expandable nodes -->\r\n    <mat-nested-tree-node *matTreeNodeDef=\"let node; when: hasChild\">\r\n        <div class=\"mat-tree-node\">\r\n          <button mat-icon-button\r\n            (click)=\"onToggleClick(node)\">\r\n            <mat-icon [svgIcon]=\"treeControl.isExpanded(node) ? 'chevron-down' : 'chevron-right'\"></mat-icon>\r\n          </button>\r\n          {{node.name}}\r\n          <mat-checkbox class=\"tree-check-2\" (change)=\"$event ? childrensToggle(node) : null\"\r\n                        [checked]=\"isAllSelected(node)\"\r\n                        [indeterminate]=\"hasChildrenSelected(node) && !isAllSelected(node)\">\r\n          </mat-checkbox>\r\n        </div>\r\n        <ul class=\"tree-ul\" [class.example-tree-invisible]=\"!treeControl.isExpanded(node)\">\r\n          <ng-container matTreeNodeOutlet></ng-container>\r\n        </ul>\r\n    </mat-nested-tree-node>\r\n\r\n  </mat-tree>\r\n</div>\r\n\r\n<div class=\"buttons\">\r\n\r\n    <button *ngIf=\"isPredefined()\" mat-raised-button class=\"clear-search-button\" [disabled]=\"!queryType && !zone\"\r\n      (click)=\"clearSearch()\">\r\n        {{'igo.geo.spatialFilter.clearSearch' | translate}}\r\n    </button>\r\n\r\n  <button *ngIf=\"isPolygon() || isPoint()\" mat-raised-button class=\"clear-form-button\" [disabled]=\"this.formControl.value === null\"\r\n    (click)=\"this.formControl.reset()\">\r\n    {{'igo.geo.spatialFilter.clearForm' | translate}}\r\n  </button>\r\n\r\n  <button mat-raised-button class=\"search-button\" [disabled]=\"disableSearchButton()\" color=\"primary\"\r\n    (click)=\"toggleSearchButton()\">\r\n    {{'igo.geo.spatialFilter.goSearch' | translate}}\r\n  </button>\r\n\r\n  <button mat-raised-button class=\"remove-button\" [disabled]=\"!store.entities$.getValue().length\" (click)=\"clearButton()\">\r\n    {{'igo.geo.spatialFilter.removeLayer' | translate}}\r\n  </button>\r\n\r\n  <button mat-raised-button class=\"export-button\" [disabled]=\"!store.entities$.getValue().length\" (click)=\"export.emit()\">\r\n    {{'igo.geo.spatialFilter.exportLayer' | translate}}\r\n  </button>\r\n\r\n</div>\r\n\r\n<div class=\"results\" *ngIf=\"store\">\r\n  <mat-table class=\"results-list\" [dataSource]=\"store.entities$.value\">\r\n\r\n    <!-- Type Column -->\r\n    <ng-container matColumnDef=\"typeResults\">\r\n        <mat-header-cell *matHeaderCellDef>{{'igo.geo.spatialFilter.type' | translate}}</mat-header-cell>\r\n        <mat-cell *matCellDef=\"let result\"> {{result.meta.title}} </mat-cell>\r\n      </ng-container>\r\n\r\n    <!-- Name Column -->\r\n    <ng-container matColumnDef=\"nameResults\">\r\n      <mat-header-cell *matHeaderCellDef>{{'igo.geo.spatialFilter.searchResults' | translate}}</mat-header-cell>\r\n      <mat-cell *matCellDef=\"let result\"> {{result.properties.nom}} </mat-cell>\r\n    </ng-container>\r\n\r\n    <mat-header-row *matHeaderRowDef=\"displayedColumnsResults\"></mat-header-row>\r\n    <mat-row *matRowDef=\"let row; columns: displayedColumnsResults;\"></mat-row>\r\n  </mat-table>\r\n</div>",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: [".header{margin-top:5px;width:100%}.mat-slide-toggle{padding:5px;margin-bottom:15px;width:98%}.mat-slide-toggle ::ng-deep .mat-slide-toggle-content{width:calc(100% - 20px)}.radius-form,.title{margin-left:5px}.title{font-size:initial}.mat-radio-group{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column;padding-top:10px}.mat-radio-button{display:-webkit-inline-box;display:inline-flex;position:relative;margin-left:16px;margin-top:10px}.mat-form-field{margin-top:5px}.mat-column-select{overflow:auto}.buttons{margin-top:10px}.search-button{left:25px;width:150px}.remove-button{margin:12px;width:150px}.clear-form-button,.clear-search-button{left:10px;width:150px}.thematics{max-height:150px;overflow:auto;margin-top:5px;width:98%}.results{overflow:auto;max-height:250px;width:98%}.mat-column-typeResults{max-width:100px;margin-right:5px}.radius{width:90%}.radius ::ng-deep .mat-form-field-infix{display:-webkit-inline-box;display:inline-flex}.unit-field{padding-left:5px;padding-right:5px}.example-tree-invisible{display:none}.tree-ul{margin:0;padding:0 0 0 20px;list-style-type:none}.tree-check,.tree-check-2{position:relative;margin-left:auto;margin-right:5px}.thematics-header{max-width:250px}.checks-header{padding:none;max-width:calc(100% - 316px);overflow:hidden}.mat-checkbox{padding:5px}.mat-tree-node{position:relative;min-height:42px;width:280px}.mat-header-cell{height:56px}"]
                }] }
    ];
    /** @nocollapse */
    SpatialFilterItemComponent.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: SpatialFilterService },
        { type: MessageService },
        { type: LanguageService }
    ]; };
    SpatialFilterItemComponent.propDecorators = {
        map: [{ type: Input }],
        type: [{ type: Input }],
        queryType: [{ type: Input }],
        zone: [{ type: Input }],
        loading: [{ type: Input }],
        store: [{ type: Input }],
        layers: [{ type: Input }],
        toggleSearch: [{ type: Output }],
        itemTypeChange: [{ type: Output }],
        thematicChange: [{ type: Output }],
        drawZoneEvent: [{ type: Output }],
        radiusEvent: [{ type: Output }],
        freehandControl: [{ type: Output }],
        clearButtonEvent: [{ type: Output }],
        clearSearchEvent: [{ type: Output }],
        export: [{ type: Output }]
    };
    return SpatialFilterItemComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgoFilterModule = /** @class */ (function () {
    function IgoFilterModule() {
    }
    /**
     * @return {?}
     */
    IgoFilterModule.forRoot = /**
     * @return {?}
     */
    function () {
        return {
            ngModule: IgoFilterModule,
            providers: [
                {
                    provide: MAT_DATE_LOCALE,
                    useValue: 'fr-FR'
                }
            ]
        };
    };
    IgoFilterModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        FormsModule,
                        ReactiveFormsModule,
                        MatAutocompleteModule,
                        MatIconModule,
                        MatButtonModule,
                        MatTabsModule,
                        MatRadioModule,
                        MatMenuModule,
                        MatTableModule,
                        MatTreeModule,
                        MatButtonToggleModule,
                        MatCheckboxModule,
                        MatSliderModule,
                        MatSlideToggleModule,
                        MatFormFieldModule,
                        MatInputModule,
                        MatOptionModule,
                        MatSelectModule,
                        MatListModule,
                        MatTooltipModule,
                        MatDatepickerModule,
                        MatNativeDateModule,
                        MatDatetimepickerModule,
                        MatNativeDatetimeModule,
                        IgoLanguageModule,
                        IgoLayerModule,
                        IgoCollapsibleModule,
                        IgoListModule,
                        IgoKeyValueModule,
                        IgoGeometryModule,
                        MatBadgeModule
                    ],
                    exports: [
                        FilterableDataSourcePipe,
                        TimeFilterButtonComponent,
                        TimeFilterFormComponent,
                        TimeFilterItemComponent,
                        TimeFilterListComponent,
                        TimeFilterListBindingDirective,
                        OgcFilterFormComponent,
                        OgcFilterButtonComponent,
                        OgcFilterToggleButtonComponent,
                        OgcFilterableFormComponent,
                        OgcFilterableItemComponent,
                        OgcFilterableListComponent,
                        OgcFilterableListBindingDirective,
                        SpatialFilterTypeComponent,
                        SpatialFilterListComponent,
                        SpatialFilterItemComponent
                    ],
                    declarations: [
                        FilterableDataSourcePipe,
                        TimeFilterButtonComponent,
                        TimeFilterFormComponent,
                        TimeFilterItemComponent,
                        TimeFilterListComponent,
                        TimeFilterListBindingDirective,
                        OgcFilterFormComponent,
                        OgcFilterButtonComponent,
                        OgcFilterToggleButtonComponent,
                        OgcFilterableFormComponent,
                        OgcFilterableItemComponent,
                        OgcFilterableListComponent,
                        OgcFilterableListBindingDirective,
                        SpatialFilterTypeComponent,
                        SpatialFilterListComponent,
                        SpatialFilterItemComponent
                    ],
                    providers: [TimeFilterService, OGCFilterService, SpatialFilterService]
                },] }
    ];
    return IgoFilterModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ExportButtonComponent = /** @class */ (function () {
    function ExportButtonComponent() {
        this._color = 'primary';
    }
    Object.defineProperty(ExportButtonComponent.prototype, "layer", {
        get: /**
         * @return {?}
         */
        function () {
            return this._layer;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._layer = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ExportButtonComponent.prototype, "color", {
        get: /**
         * @return {?}
         */
        function () {
            return this._color;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._color = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ExportButtonComponent.prototype, "options", {
        get: /**
         * @return {?}
         */
        function () {
            if (!this.layer) {
                return;
            }
            return this.layer.dataSource.options;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ExportButtonComponent.prototype.layerIsExportable = /**
     * @return {?}
     */
    function () {
        if ((this.layer instanceof VectorLayer && this.layer.exportable === true) ||
            (this.layer.dataSource.options.download && this.layer.dataSource.options.download.url)) {
            return true;
        }
        return false;
    };
    ExportButtonComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igo-export-button',
                    template: "<button\r\n  *ngIf=\"layerIsExportable()\"\r\n  mat-icon-button\r\n  tooltip-position=\"below\"\r\n  matTooltipShowDelay=\"500\"\r\n  [matTooltip]=\"'igo.geo.download.action' | translate\"\r\n  [color]=\"color\">\r\n  <!-- (click)=\"openDownload(layer)\"> -->\r\n  <mat-icon svgIcon=\"file-export\"></mat-icon>\r\n</button>\r\n\r\n",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: [""]
                }] }
    ];
    /** @nocollapse */
    ExportButtonComponent.ctorParameters = function () { return []; };
    ExportButtonComponent.propDecorators = {
        layer: [{ type: Input }],
        color: [{ type: Input }]
    };
    return ExportButtonComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ExportError = /** @class */ (function (_super) {
    __extends(ExportError, _super);
    function ExportError() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ExportError;
}(Error));
var ExportInvalidFileError = /** @class */ (function (_super) {
    __extends(ExportInvalidFileError, _super);
    function ExportInvalidFileError() {
        var _this = _super.call(this, 'Invalid file') || this;
        Object.setPrototypeOf(_this, ExportInvalidFileError.prototype);
        return _this;
    }
    return ExportInvalidFileError;
}(ExportError));
var ExportNothingToExportError = /** @class */ (function (_super) {
    __extends(ExportNothingToExportError, _super);
    function ExportNothingToExportError() {
        var _this = _super.call(this, 'Nothing to export') || this;
        Object.setPrototypeOf(_this, ExportNothingToExportError.prototype);
        return _this;
    }
    return ExportNothingToExportError;
}(ExportError));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} error
 * @param {?} messageService
 * @param {?} languageService
 * @return {?}
 */
function handleFileExportError(error, messageService, languageService) {
    if (error instanceof ExportNothingToExportError) {
        handleNothingToExportError(messageService, languageService);
        return;
    }
    /** @type {?} */
    var translate = languageService.translate;
    /** @type {?} */
    var title = translate.instant('igo.geo.export.failed.title');
    /** @type {?} */
    var message = translate.instant('igo.geo.export.failed.text');
    messageService.error(message, title);
}
/**
 * @param {?} messageService
 * @param {?} languageService
 * @return {?}
 */
function handleFileExportSuccess(messageService, languageService) {
    /** @type {?} */
    var translate = languageService.translate;
    /** @type {?} */
    var title = translate.instant('igo.geo.export.success.title');
    /** @type {?} */
    var message = translate.instant('igo.geo.export.success.text');
    messageService.success(message, title);
}
/**
 * @param {?} messageService
 * @param {?} languageService
 * @return {?}
 */
function handleNothingToExportError(messageService, languageService) {
    /** @type {?} */
    var translate = languageService.translate;
    /** @type {?} */
    var title = translate.instant('igo.geo.export.nothing.title');
    /** @type {?} */
    var message = translate.instant('igo.geo.export.nothing.text');
    messageService.error(message, title);
}
/**
 * Export array to CSV
 *
 * @param {?} rows Array of arrays to export as CSV
 * @param {?} fileName
 * @param {?=} separator Cell separator
 * @return {?}
 */
function exportToCSV(rows, fileName, separator) {
    if (separator === void 0) { separator = ';'; }
    /** @type {?} */
    var lines = rows.map((/**
     * @param {?} row
     * @param {?} index
     * @return {?}
     */
    function (row, index) { return row.join(separator); }));
    /** @type {?} */
    var csvContent = lines.join('\n');
    downloadContent(csvContent, 'text/csv;charset=utf-8', fileName);
}
/**
 * Return an array of values from an array of entities.
 *
 * @param {?} entities Array of entities
 * @param {?} columns
 * @return {?}
 */
function entitiesToRowData(entities, columns) {
    return entities.map((/**
     * @param {?} entity
     * @return {?}
     */
    function (entity) {
        return columns.map((/**
         * @param {?} column
         * @return {?}
         */
        function (column) {
            /** @type {?} */
            var valueAccessor;
            if (column.renderer === undefined || column.renderer === EntityTableColumnRenderer.Default) {
                valueAccessor = column.valueAccessor;
            }
            valueAccessor = valueAccessor ? valueAccessor : getEntityProperty;
            return valueAccessor(entity, column.name);
        }));
    }));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var ExportFormat = strEnum(['GeoJSON', 'GML', 'GPX', 'KML', 'Shapefile', 'CSVcomma', 'CSVsemicolon', 'URL']);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ExportService = /** @class */ (function () {
    function ExportService(config) {
        this.config = config;
        this.aggregateInComment = true;
        this.ogreUrl = this.config.getConfig('importExport.url');
        /** @type {?} */
        var gpxAggregateInComment = this.config.getConfig('importExport.gpxAggregateInComment');
        if (gpxAggregateInComment !== undefined) {
            this.aggregateInComment = gpxAggregateInComment;
        }
    }
    /**
     * @param {?} olFeatures
     * @param {?} format
     * @param {?} title
     * @param {?=} projectionIn
     * @param {?=} projectionOut
     * @return {?}
     */
    ExportService.prototype.export = /**
     * @param {?} olFeatures
     * @param {?} format
     * @param {?} title
     * @param {?=} projectionIn
     * @param {?=} projectionOut
     * @return {?}
     */
    function (olFeatures, format, title, projectionIn, projectionOut) {
        if (projectionIn === void 0) { projectionIn = 'EPSG:4326'; }
        if (projectionOut === void 0) { projectionOut = 'EPSG:4326'; }
        /** @type {?} */
        var exportOlFeatures = this.generateFeature(olFeatures, format);
        return this.exportAsync(exportOlFeatures, format, title, projectionIn, projectionOut);
    };
    /**
     * @private
     * @param {?} olFeatures
     * @param {?} format
     * @return {?}
     */
    ExportService.prototype.generateFeature = /**
     * @private
     * @param {?} olFeatures
     * @param {?} format
     * @return {?}
     */
    function (olFeatures, format) {
        if (format === ExportFormat.GPX && this.aggregateInComment) {
            return this.generateAggratedFeature(olFeatures);
        }
        return olFeatures.map((/**
         * @param {?} olFeature
         * @return {?}
         */
        function (olFeature) {
            /** @type {?} */
            var keys = olFeature
                .getKeys()
                .filter((/**
             * @param {?} key
             * @return {?}
             */
            function (key) { return !key.startsWith('_'); }));
            /** @type {?} */
            var properties = keys.reduce((/**
             * @param {?} acc
             * @param {?} key
             * @return {?}
             */
            function (acc, key) {
                acc[key] = olFeature.get(key);
                return acc;
            }), { geometry: olFeature.getGeometry() });
            return new OlFeature(properties);
        }));
    };
    /**
     * @private
     * @param {?} olFeatures
     * @return {?}
     */
    ExportService.prototype.generateAggratedFeature = /**
     * @private
     * @param {?} olFeatures
     * @return {?}
     */
    function (olFeatures) {
        return olFeatures.map((/**
         * @param {?} olFeature
         * @return {?}
         */
        function (olFeature) {
            /** @type {?} */
            var keys = olFeature
                .getKeys()
                .filter((/**
             * @param {?} key
             * @return {?}
             */
            function (key) { return !key.startsWith('_'); }));
            /** @type {?} */
            var comment = '';
            /** @type {?} */
            var properties = keys.reduce((/**
             * @param {?} acc
             * @param {?} key
             * @return {?}
             */
            function (acc, key) {
                if (key !== undefined && key !== 'geometry') {
                    comment += key + ':' + olFeature.get(key) + '   \r\n';
                }
                acc[key] = olFeature.get(key);
                return acc;
            }), { geometry: olFeature.getGeometry() });
            /** @type {?} */
            var newFeature = new OlFeature(properties);
            newFeature.set('name', olFeature.getId());
            newFeature.set('cmt', comment);
            return newFeature;
        }));
    };
    /**
     * @private
     * @param {?} olFeatures
     * @param {?} format
     * @param {?} title
     * @param {?} projectionIn
     * @param {?} projectionOut
     * @return {?}
     */
    ExportService.prototype.exportAsync = /**
     * @private
     * @param {?} olFeatures
     * @param {?} format
     * @param {?} title
     * @param {?} projectionIn
     * @param {?} projectionOut
     * @return {?}
     */
    function (olFeatures, format, title, projectionIn, projectionOut) {
        var _this = this;
        /** @type {?} */
        var doExport = (/**
         * @param {?} observer
         * @return {?}
         */
        function (observer) {
            /** @type {?} */
            var nothingToExport = _this.nothingToExport(olFeatures, format);
            if (nothingToExport === true) {
                observer.error(new ExportNothingToExportError());
                return;
            }
            /** @type {?} */
            var ogreFormats = Object.keys(ExportService.ogreFormats);
            if (ogreFormats.indexOf(format) >= 0) {
                if (_this.ogreUrl === undefined) {
                    if (ExportService.noOgreFallbacks.indexOf(format) >= 0) {
                        _this.exportToFile(olFeatures, observer, format, title, projectionIn, projectionOut);
                    }
                    else {
                        observer.error(new ExportInvalidFileError());
                    }
                    return;
                }
                _this.exportWithOgre(olFeatures, observer, format, title, projectionIn, projectionOut);
            }
            else {
                _this.exportToFile(olFeatures, observer, format, title, projectionIn, projectionOut);
            }
        });
        return new Observable(doExport);
    };
    /**
     * @protected
     * @param {?} olFeatures
     * @param {?} observer
     * @param {?} format
     * @param {?} title
     * @param {?} projectionIn
     * @param {?} projectionOut
     * @return {?}
     */
    ExportService.prototype.exportToFile = /**
     * @protected
     * @param {?} olFeatures
     * @param {?} observer
     * @param {?} format
     * @param {?} title
     * @param {?} projectionIn
     * @param {?} projectionOut
     * @return {?}
     */
    function (olFeatures, observer, format, title, projectionIn, projectionOut) {
        /** @type {?} */
        var olFormat = new olformat[format]();
        /** @type {?} */
        var featuresText = olFormat.writeFeatures(olFeatures, {
            dataProjection: projectionOut,
            featureProjection: projectionIn,
            featureType: 'feature',
            featureNS: 'http://example.com/feature'
        });
        /** @type {?} */
        var fileName = title + "." + format.toLowerCase();
        downloadContent(featuresText, 'text/plain;charset=utf-8', fileName);
        observer.complete();
    };
    /**
     * @private
     * @param {?} olFeatures
     * @param {?} observer
     * @param {?} format
     * @param {?} title
     * @param {?} projectionIn
     * @param {?} projectionOut
     * @return {?}
     */
    ExportService.prototype.exportWithOgre = /**
     * @private
     * @param {?} olFeatures
     * @param {?} observer
     * @param {?} format
     * @param {?} title
     * @param {?} projectionIn
     * @param {?} projectionOut
     * @return {?}
     */
    function (olFeatures, observer, format, title, projectionIn, projectionOut) {
        /** @type {?} */
        var featuresText = new GeoJSON().writeFeatures(olFeatures, {
            dataProjection: projectionOut,
            featureProjection: projectionIn,
            featureType: 'feature',
            featureNS: 'http://example.com/feature'
        });
        /** @type {?} */
        var url = this.ogreUrl + "/convertJson";
        /** @type {?} */
        var form = document.createElement('form');
        form.style.display = 'none';
        document.body.appendChild(form);
        form.setAttribute('method', 'post');
        form.setAttribute('target', '_blank');
        form.setAttribute('action', url);
        form.acceptCharset = 'UTF-8';
        form.enctype = 'application/x-www-form-urlencoded; charset=utf-8;';
        if (format === 'CSVsemicolon') {
            /** @type {?} */
            var options = document.createElement('input');
            options.setAttribute('type', 'hidden');
            options.setAttribute('name', 'lco');
            options.setAttribute('value', 'SEPARATOR=SEMICOLON');
            form.appendChild(options);
        }
        /** @type {?} */
        var geojsonField = document.createElement('input');
        geojsonField.setAttribute('type', 'hidden');
        geojsonField.setAttribute('name', 'json');
        geojsonField.setAttribute('value', featuresText);
        form.appendChild(geojsonField);
        /** @type {?} */
        var outputNameField = document.createElement('input');
        /** @type {?} */
        var outputName = format === 'Shapefile'
            ? title + ".zip"
            : title + "." + format.toLowerCase();
        if (format === 'CSVcomma' || format === 'CSVsemicolon') {
            outputName = title + ".csv";
        }
        outputName = outputName.replace(' ', '_');
        outputName = outputName.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
        outputNameField.setAttribute('type', 'hidden');
        outputNameField.setAttribute('name', 'outputName');
        outputNameField.setAttribute('value', outputName);
        form.appendChild(outputNameField);
        /** @type {?} */
        var ogreFormat = ExportService.ogreFormats[format];
        if (format === 'CSVcomma' || format === 'CSVsemicolon') {
            ogreFormat = 'CSV';
        }
        /** @type {?} */
        var outputFormatField = document.createElement('input');
        outputFormatField.setAttribute('type', 'hidden');
        outputFormatField.setAttribute('name', 'format');
        outputFormatField.setAttribute('value', ogreFormat);
        form.appendChild(outputFormatField);
        form.submit();
        document.body.removeChild(form);
        observer.complete();
    };
    /**
     * @private
     * @param {?} olFeatures
     * @param {?} format
     * @return {?}
     */
    ExportService.prototype.nothingToExport = /**
     * @private
     * @param {?} olFeatures
     * @param {?} format
     * @return {?}
     */
    function (olFeatures, format) {
        if (olFeatures.length === 0) {
            return true;
        }
        if (format === 'GPX') {
            /** @type {?} */
            var pointOrLine = olFeatures.find((/**
             * @param {?} olFeature
             * @return {?}
             */
            function (olFeature) {
                return (['Point', 'LineString', 'MultiLineString'].indexOf(olFeature.getGeometry().getType()) >=
                    0);
            }));
            return pointOrLine === undefined;
        }
        return false;
    };
    ExportService.ogreFormats = {
        GML: 'gml',
        GPX: 'gpx',
        KML: 'kml',
        Shapefile: 'ESRI Shapefile',
        CSVcomma: 'CSVcomma',
        CSVsemicolon: 'CSVsemicolon'
    };
    ExportService.noOgreFallbacks = ['GML', 'GPX', 'KML'];
    ExportService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    ExportService.ctorParameters = function () { return [
        { type: ConfigService }
    ]; };
    /** @nocollapse */ ExportService.ngInjectableDef = defineInjectable({ factory: function ExportService_Factory() { return new ExportService(inject(ConfigService)); }, token: ExportService, providedIn: "root" });
    return ExportService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ImportError = /** @class */ (function (_super) {
    __extends(ImportError, _super);
    function ImportError() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ImportError;
}(Error));
var ImportInvalidFileError = /** @class */ (function (_super) {
    __extends(ImportInvalidFileError, _super);
    function ImportInvalidFileError() {
        var _this = _super.call(this, 'Invalid file') || this;
        Object.setPrototypeOf(_this, ImportInvalidFileError.prototype);
        return _this;
    }
    return ImportInvalidFileError;
}(ImportError));
var ImportUnreadableFileError = /** @class */ (function (_super) {
    __extends(ImportUnreadableFileError, _super);
    function ImportUnreadableFileError() {
        var _this = _super.call(this, 'Failed to read file') || this;
        Object.setPrototypeOf(_this, ImportUnreadableFileError.prototype);
        return _this;
    }
    return ImportUnreadableFileError;
}(ImportError));
var ImportNothingToImportError = /** @class */ (function (_super) {
    __extends(ImportNothingToImportError, _super);
    function ImportNothingToImportError() {
        var _this = _super.call(this, 'Nothing to import') || this;
        Object.setPrototypeOf(_this, ImportNothingToImportError.prototype);
        return _this;
    }
    return ImportNothingToImportError;
}(ImportError));
var ImportSizeError = /** @class */ (function (_super) {
    __extends(ImportSizeError, _super);
    function ImportSizeError() {
        var _this = _super.call(this, 'File is too large') || this;
        Object.setPrototypeOf(_this, ImportNothingToImportError.prototype);
        return _this;
    }
    return ImportSizeError;
}(ImportError));
var ImportSRSError = /** @class */ (function (_super) {
    __extends(ImportSRSError, _super);
    function ImportSRSError() {
        var _this = _super.call(this, 'Invalid SRS definition') || this;
        Object.setPrototypeOf(_this, ImportNothingToImportError.prototype);
        return _this;
    }
    return ImportSRSError;
}(ImportError));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} features
 * @param {?} map
 * @param {?} layerTitle
 * @return {?}
 */
function addLayerAndFeaturesToMap(features, map$$1, layerTitle) {
    /** @type {?} */
    var olFeatures = features.map((/**
     * @param {?} feature
     * @return {?}
     */
    function (feature) { return featureToOl(feature, map$$1.projection); }));
    /** @type {?} */
    var r = Math.floor(Math.random() * 255);
    /** @type {?} */
    var g = Math.floor(Math.random() * 255);
    /** @type {?} */
    var b = Math.floor(Math.random() * 255);
    /** @type {?} */
    var stroke = new Stroke({
        color: [r, g, b, 1],
        width: 2
    });
    /** @type {?} */
    var fill = new Fill({
        color: [r, g, b, 0.4]
    });
    /** @type {?} */
    var sourceOptions = {
        type: 'vector',
        queryable: true
    };
    /** @type {?} */
    var source = new FeatureDataSource(sourceOptions);
    source.ol.addFeatures(olFeatures);
    /** @type {?} */
    var layer = new VectorLayer({
        title: layerTitle,
        source: source,
        style: new Style({
            stroke: stroke,
            fill: fill,
            image: new Circle({
                radius: 5,
                stroke: stroke,
                fill: fill
            })
        })
    });
    map$$1.addLayer(layer);
    moveToOlFeatures(map$$1, olFeatures);
    return layer;
}
/**
 * @param {?} features
 * @param {?} map
 * @param {?} layerTitle
 * @param {?} styleListService
 * @param {?} styleService
 * @return {?}
 */
function addLayerAndFeaturesStyledToMap(features, map$$1, layerTitle, styleListService, styleService) {
    /** @type {?} */
    var olFeatures = features.map((/**
     * @param {?} feature
     * @return {?}
     */
    function (feature) { return featureToOl(feature, map$$1.projection); }));
    /** @type {?} */
    var style$$1;
    /** @type {?} */
    var distance;
    if (styleListService.getStyleList(layerTitle.toString() + '.styleByAttribute')) {
        /** @type {?} */
        var styleByAttribute_1 = styleListService.getStyleList(layerTitle.toString() + '.styleByAttribute');
        style$$1 = (/**
         * @param {?} feature
         * @return {?}
         */
        function (feature) {
            return styleService.createStyleByAttribute(feature, styleByAttribute_1);
        });
    }
    else if (styleListService.getStyleList(layerTitle.toString() + '.clusterStyle')) {
        /** @type {?} */
        var clusterParam_1 = styleListService.getStyleList(layerTitle.toString() + '.clusterParam');
        distance = styleListService.getStyleList(layerTitle.toString() + '.distance');
        /** @type {?} */
        var baseStyle_1 = styleService.createStyle(styleListService.getStyleList(layerTitle.toString() + '.clusterStyle'));
        style$$1 = (/**
         * @param {?} feature
         * @return {?}
         */
        function (feature) {
            return styleService.createClusterStyle(feature, clusterParam_1, baseStyle_1);
        });
    }
    else if (styleListService.getStyleList(layerTitle.toString() + '.style')) {
        style$$1 = styleService.createStyle(styleListService.getStyleList(layerTitle.toString() + '.style'));
    }
    else if (styleListService.getStyleList('default.clusterStyle') && features[0].geometry.type === 'Point') {
        /** @type {?} */
        var clusterParam_2 = styleListService.getStyleList('default.clusterParam');
        distance = styleListService.getStyleList('default.distance');
        /** @type {?} */
        var baseStyle_2 = styleService.createStyle(styleListService.getStyleList('default.clusterStyle'));
        style$$1 = (/**
         * @param {?} feature
         * @return {?}
         */
        function (feature) {
            return styleService.createClusterStyle(feature, clusterParam_2, baseStyle_2);
        });
    }
    else {
        style$$1 = styleService.createStyle(styleListService.getStyleList('default.style'));
    }
    /** @type {?} */
    var source;
    if (styleListService.getStyleList(layerTitle.toString() + '.clusterStyle')) {
        /** @type {?} */
        var sourceOptions = {
            distance: distance,
            type: 'cluster',
            queryable: true
        };
        source = new ClusterDataSource(sourceOptions);
        source.ol.source.addFeatures(olFeatures);
    }
    else if (styleListService.getStyleList(layerTitle.toString())) {
        /** @type {?} */
        var sourceOptions = {
            type: 'vector',
            queryable: true
        };
        source = new FeatureDataSource(sourceOptions);
        source.ol.addFeatures(olFeatures);
    }
    else if (styleListService.getStyleList('default.clusterStyle') && features[0].geometry.type === 'Point') {
        /** @type {?} */
        var sourceOptions = {
            distance: distance,
            type: 'cluster',
            queryable: true
        };
        source = new ClusterDataSource(sourceOptions);
        source.ol.source.addFeatures(olFeatures);
    }
    else {
        /** @type {?} */
        var sourceOptions = {
            type: 'vector',
            queryable: true
        };
        source = new FeatureDataSource(sourceOptions);
        source.ol.addFeatures(olFeatures);
    }
    /** @type {?} */
    var layer = new VectorLayer({
        title: layerTitle,
        source: source,
        style: style$$1
    });
    map$$1.addLayer(layer);
    moveToOlFeatures(map$$1, olFeatures);
    return layer;
}
/**
 * @param {?} file
 * @param {?} features
 * @param {?} map
 * @param {?} messageService
 * @param {?} languageService
 * @param {?=} styleListService
 * @param {?=} styleService
 * @return {?}
 */
function handleFileImportSuccess(file, features, map$$1, messageService, languageService, styleListService, styleService) {
    if (features.length === 0) {
        handleNothingToImportError(file, messageService, languageService);
        return;
    }
    /** @type {?} */
    var layerTitle = computeLayerTitleFromFile(file);
    if (!styleListService) {
        addLayerAndFeaturesToMap(features, map$$1, layerTitle);
    }
    else {
        addLayerAndFeaturesStyledToMap(features, map$$1, layerTitle, styleListService, styleService);
    }
    /** @type {?} */
    var translate = languageService.translate;
    /** @type {?} */
    var messageTitle = translate.instant('igo.geo.dropGeoFile.success.title');
    /** @type {?} */
    var message = translate.instant('igo.geo.dropGeoFile.success.text', {
        value: layerTitle
    });
    messageService.success(message, messageTitle);
}
/**
 * @param {?} file
 * @param {?} error
 * @param {?} messageService
 * @param {?} languageService
 * @param {?=} sizeMb
 * @return {?}
 */
function handleFileImportError(file, error, messageService, languageService, sizeMb) {
    sizeMb = sizeMb ? sizeMb : 30;
    /** @type {?} */
    var errMapping = {
        'Invalid file': handleInvalidFileImportError,
        'File is too large': handleSizeFileImportError,
        'Failed to read file': handleUnreadbleFileImportError,
        'Invalid SRS definition': handleSRSImportError
    };
    errMapping[error.message](file, error, messageService, languageService, sizeMb);
}
/**
 * @param {?} file
 * @param {?} error
 * @param {?} messageService
 * @param {?} languageService
 * @return {?}
 */
function handleInvalidFileImportError(file, error, messageService, languageService) {
    /** @type {?} */
    var translate = languageService.translate;
    /** @type {?} */
    var title = translate.instant('igo.geo.dropGeoFile.invalid.title');
    /** @type {?} */
    var message = translate.instant('igo.geo.dropGeoFile.invalid.text', {
        value: file.name,
        mimeType: file.type
    });
    messageService.error(message, title);
}
/**
 * @param {?} file
 * @param {?} error
 * @param {?} messageService
 * @param {?} languageService
 * @return {?}
 */
function handleUnreadbleFileImportError(file, error, messageService, languageService) {
    /** @type {?} */
    var translate = languageService.translate;
    /** @type {?} */
    var title = translate.instant('igo.geo.dropGeoFile.unreadable.title');
    /** @type {?} */
    var message = translate.instant('igo.geo.dropGeoFile.unreadable.text', {
        value: file.name
    });
    messageService.error(message, title);
}
/**
 * @param {?} file
 * @param {?} error
 * @param {?} messageService
 * @param {?} languageService
 * @param {?} sizeMb
 * @return {?}
 */
function handleSizeFileImportError(file, error, messageService, languageService, sizeMb) {
    /** @type {?} */
    var translate = languageService.translate;
    /** @type {?} */
    var title = translate.instant('igo.geo.dropGeoFile.tooLarge.title');
    /** @type {?} */
    var message = translate.instant('igo.geo.dropGeoFile.tooLarge.text', {
        value: file.name,
        size: sizeMb
    });
    messageService.error(message, title);
}
/**
 * @param {?} file
 * @param {?} messageService
 * @param {?} languageService
 * @return {?}
 */
function handleNothingToImportError(file, messageService, languageService) {
    /** @type {?} */
    var translate = languageService.translate;
    /** @type {?} */
    var title = translate.instant('igo.geo.dropGeoFile.empty.title');
    /** @type {?} */
    var message = translate.instant('igo.geo.dropGeoFile.empty.text', {
        value: file.name,
        mimeType: file.type
    });
    messageService.error(message, title);
}
/**
 * @param {?} file
 * @param {?} messageService
 * @param {?} languageService
 * @return {?}
 */
function handleSRSImportError(file, messageService, languageService) {
    /** @type {?} */
    var translate = languageService.translate;
    /** @type {?} */
    var title = translate.instant('igo.geo.dropGeoFile.invalidSRS.title');
    /** @type {?} */
    var message = translate.instant('igo.geo.dropGeoFile.invalidSRS.text', {
        value: file.name,
        mimeType: file.type
    });
    messageService.error(message, title);
}
/**
 * @param {?} file
 * @return {?}
 */
function getFileExtension(file) {
    return file.name.split('.').pop().toLowerCase();
}
/**
 * @param {?} file
 * @return {?}
 */
function computeLayerTitleFromFile(file) {
    return file.name.substr(0, file.name.lastIndexOf('.'));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ImportService = /** @class */ (function () {
    function ImportService(http, config) {
        this.http = http;
        this.config = config;
        this.ogreUrl = this.config.getConfig('importExport.url');
        /** @type {?} */
        var configFileSizeMb = this.config.getConfig('importExport.clientSideFileSizeMaxMb');
        this.clientSideFileSizeMax = (configFileSizeMb ? configFileSizeMb : 30) * Math.pow(1024, 2);
    }
    /**
     * @param {?} file
     * @param {?=} projectionIn
     * @param {?=} projectionOut
     * @return {?}
     */
    ImportService.prototype.import = /**
     * @param {?} file
     * @param {?=} projectionIn
     * @param {?=} projectionOut
     * @return {?}
     */
    function (file, projectionIn, projectionOut) {
        if (projectionIn === void 0) { projectionIn = 'EPSG:4326'; }
        if (projectionOut === void 0) { projectionOut = 'EPSG:4326'; }
        return this.importAsync(file, projectionIn, projectionOut);
    };
    /**
     * @private
     * @param {?} file
     * @return {?}
     */
    ImportService.prototype.getFileImporter = /**
     * @private
     * @param {?} file
     * @return {?}
     */
    function (file) {
        /** @type {?} */
        var extension = getFileExtension(file);
        /** @type {?} */
        var mimeType = file.type;
        /** @type {?} */
        var allowedMimeTypes = __spread(ImportService.allowedMimeTypes, ImportService.allowedZipMimeTypes);
        /** @type {?} */
        var allowedExtensions = ImportService.allowedExtensions;
        if (allowedMimeTypes.indexOf(mimeType) < 0 &&
            allowedExtensions.indexOf(extension) < 0) {
            return undefined;
        }
        else if (mimeType === 'application/json' ||
            ['json', 'geojson', 'kml', 'gpx'].indexOf(extension) >= 0) {
            return this.importFile;
        }
        else if (this.ogreUrl !== undefined) {
            return this.importFileWithOgre;
        }
        return undefined;
    };
    /**
     * @private
     * @param {?} file
     * @param {?} projectionIn
     * @param {?} projectionOut
     * @return {?}
     */
    ImportService.prototype.importAsync = /**
     * @private
     * @param {?} file
     * @param {?} projectionIn
     * @param {?} projectionOut
     * @return {?}
     */
    function (file, projectionIn, projectionOut) {
        var _this = this;
        /** @type {?} */
        var doImport = (/**
         * @param {?} observer
         * @return {?}
         */
        function (observer) {
            if (file.size >= _this.clientSideFileSizeMax) {
                observer.error(new ImportSizeError());
                return;
            }
            /** @type {?} */
            var importer = _this.getFileImporter(file);
            if (importer === undefined) {
                observer.error(new ImportInvalidFileError());
                return;
            }
            importer.call(_this, file, observer, projectionIn, projectionOut);
        });
        return new Observable(doImport);
    };
    /**
     * @private
     * @param {?} file
     * @param {?} observer
     * @param {?} projectionIn
     * @param {?} projectionOut
     * @return {?}
     */
    ImportService.prototype.importFile = /**
     * @private
     * @param {?} file
     * @param {?} observer
     * @param {?} projectionIn
     * @param {?} projectionOut
     * @return {?}
     */
    function (file, observer, projectionIn, projectionOut) {
        var _this = this;
        /** @type {?} */
        var reader = new FileReader();
        reader.onload = (/**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            try {
                /** @type {?} */
                var features = _this.parseFeaturesFromFile(file, event.target.result, projectionIn, projectionOut);
                observer.next(features);
            }
            catch (e) {
                observer.error(new ImportUnreadableFileError());
            }
            observer.complete();
        });
        reader.onerror = (/**
         * @param {?} evt
         * @return {?}
         */
        function (evt) {
            observer.error(new ImportUnreadableFileError());
        });
        reader.readAsText(file, 'UTF-8');
    };
    /**
     * @private
     * @param {?} file
     * @param {?} observer
     * @param {?} projectionIn
     * @param {?} projectionOut
     * @return {?}
     */
    ImportService.prototype.importFileWithOgre = /**
     * @private
     * @param {?} file
     * @param {?} observer
     * @param {?} projectionIn
     * @param {?} projectionOut
     * @return {?}
     */
    function (file, observer, projectionIn, projectionOut) {
        var _this = this;
        /** @type {?} */
        var url = this.ogreUrl + "/convert";
        /** @type {?} */
        var formData = new FormData();
        formData.append('upload', file);
        formData.append('sourceSrs', projectionIn);
        formData.append('targetSrs', projectionOut);
        formData.append('formatOutput', 'GEOJSON');
        formData.append('skipFailures', '');
        this.http.post(url, formData, { headers: new HttpHeaders() }).subscribe((/**
         * @param {?} response
         * @return {?}
         */
        function (response) {
            if (response === null) {
                observer.error(new ImportUnreadableFileError());
                return;
            }
            /** @type {?} */
            var errors = ((/** @type {?} */ (response))).errors || [];
            if (errors.length > 0) {
                observer.error(new ImportUnreadableFileError());
            }
            else {
                /** @type {?} */
                var features = _this.parseFeaturesFromGeoJSON(file, response, projectionOut);
                observer.next(features);
                observer.complete();
            }
        }), (/**
         * @param {?} error
         * @return {?}
         */
        function (error) {
            error.error.caught = true;
            /** @type {?} */
            var errMsg = error.error.msg || '';
            if (errMsg === 'No valid files found') {
                observer.error(new ImportInvalidFileError());
            }
            else if (errMsg.startWith('ERROR 1: Failed to process SRS definition')) {
                observer.error(new ImportSRSError());
            }
            else {
                observer.error(new ImportUnreadableFileError());
            }
        }));
    };
    /**
     * @private
     * @param {?} file
     * @param {?} data
     * @param {?} projectionIn
     * @param {?} projectionOut
     * @return {?}
     */
    ImportService.prototype.parseFeaturesFromFile = /**
     * @private
     * @param {?} file
     * @param {?} data
     * @param {?} projectionIn
     * @param {?} projectionOut
     * @return {?}
     */
    function (file, data, projectionIn, projectionOut) {
        /** @type {?} */
        var extension = getFileExtension(file);
        /** @type {?} */
        var mimeType = file.type;
        /** @type {?} */
        var GeoJSON$$1 = new GeoJSON();
        /** @type {?} */
        var format;
        if (mimeType === 'application/vnd.google-earth.kml+xml') {
            format = new KML();
        }
        else if (mimeType === 'application/gml+xml') {
            format = new GML();
        }
        else if (mimeType === 'application/gpx+xml') {
            format = new GPX();
        }
        else {
            switch (extension) {
                case 'kml':
                    format = new KML();
                    break;
                case 'gpx':
                    format = new GPX();
                    break;
                case 'gml':
                    format = new GML();
                    break;
                default:
                    format = GeoJSON$$1;
                    break;
            }
        }
        /** @type {?} */
        var olFeatures = format.readFeatures(data, {
            dataProjection: projectionIn,
            featureProjection: projectionOut
        });
        /** @type {?} */
        var features = olFeatures.map((/**
         * @param {?} olFeature
         * @return {?}
         */
        function (olFeature) {
            return Object.assign(GeoJSON$$1.writeFeatureObject(olFeature), {
                projection: projectionOut,
                meta: {
                    id: uuid(),
                    title: computeLayerTitleFromFile(file)
                }
            });
        }));
        return features;
    };
    /**
     * @private
     * @param {?} file
     * @param {?} data
     * @param {?} projectionOut
     * @return {?}
     */
    ImportService.prototype.parseFeaturesFromGeoJSON = /**
     * @private
     * @param {?} file
     * @param {?} data
     * @param {?} projectionOut
     * @return {?}
     */
    function (file, data, projectionOut) {
        /** @type {?} */
        var olFormat = new GeoJSON();
        /** @type {?} */
        var olFeatures = olFormat.readFeatures(data);
        /** @type {?} */
        var features = olFeatures.map((/**
         * @param {?} olFeature
         * @return {?}
         */
        function (olFeature) {
            return Object.assign(olFormat.writeFeatureObject(olFeature), {
                projection: projectionOut,
                meta: {
                    id: uuid(),
                    title: computeLayerTitleFromFile(file)
                }
            });
        }));
        return features;
    };
    ImportService.allowedMimeTypes = [
        'application/gml+xml',
        'application/vnd.google-earth.kml+xml',
        'application/gpx+xml',
        'application/json'
    ];
    ImportService.allowedZipMimeTypes = [
        'application/zip',
        'application/x-zip-compressed',
        'application/x-zip'
    ];
    ImportService.allowedExtensions = ['geojson', 'kml', 'gpx', 'json', 'gml'];
    ImportService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    ImportService.ctorParameters = function () { return [
        { type: HttpClient },
        { type: ConfigService }
    ]; };
    /** @nocollapse */ ImportService.ngInjectableDef = defineInjectable({ factory: function ImportService_Factory() { return new ImportService(inject(HttpClient), inject(ConfigService)); }, token: ImportService, providedIn: "root" });
    return ImportService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var StyleListService = /** @class */ (function () {
    function StyleListService(injector) {
        this.injector = injector;
        this.styleList = {};
    }
    /**
     * Use to get the data found in styleList file
     */
    /**
     * Use to get the data found in styleList file
     * @param {?} key
     * @return {?}
     */
    StyleListService.prototype.getStyleList = /**
     * Use to get the data found in styleList file
     * @param {?} key
     * @return {?}
     */
    function (key) {
        return ObjectUtils.resolve(this.styleList, key);
    };
    /**
     * This method loads "[path]" to get all styleList's variables
     */
    /**
     * This method loads "[path]" to get all styleList's variables
     * @param {?} options
     * @return {?}
     */
    StyleListService.prototype.load = /**
     * This method loads "[path]" to get all styleList's variables
     * @param {?} options
     * @return {?}
     */
    function (options) {
        var _this = this;
        /** @type {?} */
        var baseStyleList = options.default || {};
        if (!options.path) {
            this.styleList = baseStyleList;
            return true;
        }
        /** @type {?} */
        var http = this.injector.get(HttpClient);
        return new Promise((/**
         * @param {?} resolve
         * @param {?} _reject
         * @return {?}
         */
        function (resolve, _reject) {
            http
                .get(options.path)
                .pipe(catchError((/**
             * @param {?} error
             * @return {?}
             */
            function (error) {
                console.log("StyleList file " + options.path + " could not be read");
                resolve(true);
                return throwError(error.error || 'Server error');
            })))
                .subscribe((/**
             * @param {?} styleListResponse
             * @return {?}
             */
            function (styleListResponse) {
                _this.styleList = ObjectUtils.mergeDeep(baseStyleList, styleListResponse);
                resolve(true);
            }));
        }));
    };
    StyleListService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    StyleListService.ctorParameters = function () { return [
        { type: Injector }
    ]; };
    /** @nocollapse */ StyleListService.ngInjectableDef = defineInjectable({ factory: function StyleListService_Factory() { return new StyleListService(inject(INJECTOR)); }, token: StyleListService, providedIn: "root" });
    return StyleListService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ImportExportComponent = /** @class */ (function () {
    function ImportExportComponent(importService, exportService, languageService, messageService, styleListService, styleService, formBuilder, config) {
        this.importService = importService;
        this.exportService = exportService;
        this.languageService = languageService;
        this.messageService = messageService;
        this.styleListService = styleListService;
        this.styleService = styleService;
        this.formBuilder = formBuilder;
        this.config = config;
        this.formats$ = new BehaviorSubject(undefined);
        this.exportableLayers$ = new BehaviorSubject([]);
        this.inputProj = 'EPSG:4326';
        this.loading$ = new BehaviorSubject(false);
        this.forceNaming = false;
        this.espgCodeRegex = new RegExp('^\\d{4,6}');
        this.activeImportExport = 'import';
        this.previousLayerSpecs$ = new BehaviorSubject(undefined);
        this.selectedIndex = 0;
        this.selectedTabIndex = new EventEmitter();
        this.exportOptions$ = new BehaviorSubject(undefined);
        this.exportOptionsChange = new EventEmitter();
        this.loadConfig();
        this.buildForm();
        console.log(this);
        console.log(this.form);
        console.log(this.form);
    }
    /**
     * @return {?}
     */
    ImportExportComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.layers$$ = this.map.layers$.subscribe((/**
         * @param {?} layers
         * @return {?}
         */
        function (layers) {
            _this.exportableLayers$.next((/** @type {?} */ (layers.filter((/**
             * @param {?} layer
             * @return {?}
             */
            function (layer) {
                return ((layer instanceof VectorLayer && layer.exportable === true) ||
                    (layer.dataSource.options.download &&
                        layer.dataSource.options.download.url));
            })))));
        }));
        /** @type {?} */
        var configFileSizeMb = this.config.getConfig('importExport.clientSideFileSizeMaxMb');
        this.clientSideFileSizeMax =
            (configFileSizeMb ? configFileSizeMb : 30) * Math.pow(1024, 2);
        this.fileSizeMb = this.clientSideFileSizeMax / Math.pow(1024, 2);
        this.exportOptions$$ = this.exportOptions$
            .pipe(skipWhile((/**
         * @param {?} exportOptions
         * @return {?}
         */
        function (exportOptions) { return !exportOptions; })))
            .subscribe((/**
         * @param {?} exportOptions
         * @return {?}
         */
        function (exportOptions) {
            _this.form.patchValue(exportOptions, { emitEvent: true });
            if (exportOptions.layer) {
                _this.computeFormats(exportOptions.layer.map((/**
                 * @param {?} l
                 * @return {?}
                 */
                function (l) { return _this.map.getLayerById(l); })));
            }
        }));
        this.formLayer$$ = this.form
            .get('layer')
            .valueChanges.subscribe((/**
         * @param {?} layerId
         * @return {?}
         */
        function (layerId) {
            _this.handlePreviousLayerSpecs();
            /** @type {?} */
            var layers = layerId.map((/**
             * @param {?} l
             * @return {?}
             */
            function (l) { return _this.map.getLayerById(l); }));
            _this.computeFormats(layers);
            if (Object.keys(_this.formats$.value).indexOf(_this.form.value.format) ===
                -1) {
                _this.form.patchValue({ format: undefined });
            }
            _this.loading$.next(true);
            /** @type {?} */
            var previousSpecs = [];
            layers.forEach((/**
             * @param {?} layer
             * @return {?}
             */
            function (layer) {
                if (layer instanceof VectorLayer &&
                    layer.dataSource.ol.getFeatures().length === 0) {
                    previousSpecs.push({
                        id: layer.id,
                        visible: layer.visible,
                        opacity: layer.opacity,
                        queryable: ((/** @type {?} */ (layer))).queryable
                    });
                    layer.opacity = 0;
                    layer.visible = true;
                }
            }));
            _this.previousLayerSpecs$.next(previousSpecs);
            setTimeout((/**
             * @return {?}
             */
            function () {
                _this.loading$.next(false);
            }), 500);
        }));
        this.formats$$ = this.formats$
            .pipe(skipWhile((/**
         * @param {?} formats
         * @return {?}
         */
        function (formats) { return !formats; })))
            .subscribe((/**
         * @param {?} formats
         * @return {?}
         */
        function (formats) {
            if (Object.keys(formats).length === 1) {
                _this.form.patchValue({ format: formats[Object.keys(formats)[0]] });
            }
        }));
        this.exportableLayers$$ = this.exportableLayers$
            .pipe(skipWhile((/**
         * @param {?} layers
         * @return {?}
         */
        function (layers) { return !layers; })))
            .subscribe((/**
         * @param {?} layers
         * @return {?}
         */
        function (layers) {
            if (layers.length === 1) {
                _this.form.patchValue({ layer: layers[0].id });
            }
        }));
    };
    /**
     * @return {?}
     */
    ImportExportComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.layers$$.unsubscribe();
        this.exportableLayers$$.unsubscribe();
        this.formats$$.unsubscribe();
        this.formLayer$$.unsubscribe();
        if (this.exportOptions$$) {
            this.exportOptions$$.unsubscribe();
        }
        this.exportOptionsChange.emit(this.form.value);
        this.handlePreviousLayerSpecs();
    };
    /**
     * @private
     * @return {?}
     */
    ImportExportComponent.prototype.handlePreviousLayerSpecs = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var previousSpecs = this.previousLayerSpecs$.value;
        if (previousSpecs && previousSpecs.length) {
            previousSpecs.forEach((/**
             * @param {?} specs
             * @return {?}
             */
            function (specs) {
                /** @type {?} */
                var previousLayer = _this.map.getLayerById(specs.id);
                previousLayer.visible = specs.visible;
                previousLayer.opacity = specs.opacity;
                ((/** @type {?} */ (previousLayer))).queryable = specs.queryable;
            }));
        }
        this.previousLayerSpecs$.next(undefined);
    };
    /**
     * @param {?} files
     * @return {?}
     */
    ImportExportComponent.prototype.importFiles = /**
     * @param {?} files
     * @return {?}
     */
    function (files) {
        var _this = this;
        var e_1, _a;
        /** @type {?} */
        var inputProj = this.inputProj;
        if (this.espgCodeRegex.test(inputProj)) {
            inputProj = "EPSG:" + inputProj;
        }
        this.loading$.next(true);
        var _loop_1 = function (file) {
            this_1.importService.import(file, inputProj).subscribe((/**
             * @param {?} features
             * @return {?}
             */
            function (features) { return _this.onFileImportSuccess(file, features); }), (/**
             * @param {?} error
             * @return {?}
             */
            function (error) { return _this.onFileImportError(file, error); }), (/**
             * @return {?}
             */
            function () {
                _this.loading$.next(false);
            }));
        };
        var this_1 = this;
        try {
            for (var files_1 = __values(files), files_1_1 = files_1.next(); !files_1_1.done; files_1_1 = files_1.next()) {
                var file = files_1_1.value;
                _loop_1(file);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (files_1_1 && !files_1_1.done && (_a = files_1.return)) _a.call(files_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    /**
     * @param {?} data
     * @return {?}
     */
    ImportExportComponent.prototype.handleExportFormSubmit = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        var _this = this;
        this.loading$.next(true);
        data.layer.forEach((/**
         * @param {?} layer
         * @return {?}
         */
        function (layer) {
            /** @type {?} */
            var lay = _this.map.getLayerById(layer);
            /** @type {?} */
            var filename = lay.title;
            if (data.name !== undefined) {
                filename = data.name;
            }
            /** @type {?} */
            var dSOptions = lay.dataSource.options;
            if (data.format === ExportFormat.URL &&
                dSOptions.download &&
                dSOptions.download.url) {
                setTimeout((/**
                 * @return {?}
                 */
                function () {
                    // better look an feel
                    window.open(dSOptions.download.url, '_blank');
                    _this.loading$.next(false);
                }), 500);
                return;
            }
            /** @type {?} */
            var olFeatures;
            if (data.featureInMapExtent) {
                olFeatures = lay.dataSource.ol.getFeaturesInExtent(lay.map.viewController.getExtent());
            }
            else {
                olFeatures = lay.dataSource.ol.getFeatures();
            }
            if (lay.dataSource instanceof ClusterDataSource) {
                olFeatures = olFeatures.flatMap((/**
                 * @param {?} cluster
                 * @return {?}
                 */
                function (cluster) {
                    return cluster.get('features');
                }));
            }
            _this.exportService
                .export(olFeatures, data.format, filename, _this.map.projection)
                .subscribe((/**
             * @return {?}
             */
            function () { }), (/**
             * @param {?} error
             * @return {?}
             */
            function (error) { return _this.onFileExportError(error); }), (/**
             * @return {?}
             */
            function () {
                _this.onFileExportSuccess();
                _this.loading$.next(false);
            }));
        }));
    };
    /**
     * @private
     * @return {?}
     */
    ImportExportComponent.prototype.buildForm = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.forceNaming) {
            this.form = this.formBuilder.group({
                format: ['', [Validators.required]],
                layer: ['', [Validators.required]],
                featureInMapExtent: [false, [Validators.required]],
                name: ['', [Validators.required]]
            });
        }
        else {
            this.form = this.formBuilder.group({
                format: ['', [Validators.required]],
                layer: ['', [Validators.required]],
                featureInMapExtent: [false, [Validators.required]]
            });
        }
    };
    /**
     * @private
     * @param {?} file
     * @param {?} features
     * @return {?}
     */
    ImportExportComponent.prototype.onFileImportSuccess = /**
     * @private
     * @param {?} file
     * @param {?} features
     * @return {?}
     */
    function (file, features) {
        if (!this.config.getConfig('importWithStyle')) {
            handleFileImportSuccess(file, features, this.map, this.messageService, this.languageService);
        }
        else {
            handleFileImportSuccess(file, features, this.map, this.messageService, this.languageService, this.styleListService, this.styleService);
        }
    };
    /**
     * @private
     * @param {?} file
     * @param {?} error
     * @return {?}
     */
    ImportExportComponent.prototype.onFileImportError = /**
     * @private
     * @param {?} file
     * @param {?} error
     * @return {?}
     */
    function (file, error) {
        this.loading$.next(false);
        handleFileImportError(file, error, this.messageService, this.languageService, this.fileSizeMb);
    };
    /**
     * @private
     * @param {?} error
     * @return {?}
     */
    ImportExportComponent.prototype.onFileExportError = /**
     * @private
     * @param {?} error
     * @return {?}
     */
    function (error) {
        this.loading$.next(false);
        handleFileExportError(error, this.messageService, this.languageService);
    };
    /**
     * @private
     * @return {?}
     */
    ImportExportComponent.prototype.loadConfig = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.config.getConfig('importExport.forceNaming') !== undefined) {
            this.forceNaming = this.config.getConfig('importExport.forceNaming');
        }
        this.computeFormats();
    };
    /**
     * @private
     * @param {?=} layers
     * @return {?}
     */
    ImportExportComponent.prototype.computeFormats = /**
     * @private
     * @param {?=} layers
     * @return {?}
     */
    function (layers) {
        if (layers && layers.length) {
            /** @type {?} */
            var formatsType_1 = {
                onlyUrl: false,
                onlyVector: false,
                vectorAndUrl: false
            };
            layers.forEach((/**
             * @param {?} layer
             * @return {?}
             */
            function (layer) {
                if (!layer) {
                    return;
                }
                if (!(layer instanceof VectorLayer) &&
                    layer.dataSource.options.download &&
                    layer.dataSource.options.download.url) {
                    formatsType_1.onlyUrl = true;
                }
                else if (layer.dataSource.options.download &&
                    layer.dataSource.options.download.url) {
                    formatsType_1.vectorAndUrl = true;
                }
                else if (layer instanceof VectorLayer) {
                    formatsType_1.onlyVector = true;
                }
            }));
            if (formatsType_1.onlyUrl === true && formatsType_1.onlyVector === false) {
                this.formats$.next(strEnum(['URL']));
            }
            else if (formatsType_1.onlyVector === true &&
                formatsType_1.onlyUrl === false) {
                this.computeFormats(); // reset
                if (ExportFormat.URL in this.formats$.value) {
                    /** @type {?} */
                    var keys = Object.keys(this.formats$.value).filter((/**
                     * @param {?} key
                     * @return {?}
                     */
                    function (key) { return key !== 'URL'; }));
                    this.formats$.next(strEnum(keys));
                }
            }
            else if (formatsType_1.vectorAndUrl === true &&
                formatsType_1.onlyUrl === false &&
                formatsType_1.onlyVector === false) {
                this.computeFormats(); // reset
                if (!(ExportFormat.URL in this.formats$.value)) {
                    /** @type {?} */
                    var keys = Object.keys(this.formats$.value);
                    keys.push('URL');
                    this.formats$.next(strEnum(keys));
                }
            }
            else {
                this.formats$.next([]);
                this.messageService.alert(this.languageService.translate.instant('igo.geo.export.noFormat.text'), this.languageService.translate.instant('igo.geo.export.noFormat.title'));
            }
            return;
        }
        if (this.config.getConfig('importExport.formats') !== undefined) {
            /** @type {?} */
            var validatedListFormat = this.validateListFormat(this.config.getConfig('importExport.formats'));
            this.formats$.next(strEnum(validatedListFormat));
        }
        else {
            this.formats$.next(ExportFormat);
        }
    };
    /**
     * @private
     * @param {?} formats
     * @return {?}
     */
    ImportExportComponent.prototype.validateListFormat = /**
     * @private
     * @param {?} formats
     * @return {?}
     */
    function (formats) {
        return formats
            .filter((/**
         * @param {?} format
         * @return {?}
         */
        function (format) {
            if (format.toUpperCase() === ExportFormat.CSVcomma.toUpperCase() ||
                format.toUpperCase() === ExportFormat.CSVsemicolon.toUpperCase() ||
                format.toUpperCase() === ExportFormat.GML.toUpperCase() ||
                format.toUpperCase() === ExportFormat.GPX.toUpperCase() ||
                format.toUpperCase() === ExportFormat.GeoJSON.toUpperCase() ||
                format.toUpperCase() === ExportFormat.KML.toUpperCase() ||
                format.toUpperCase() === ExportFormat.Shapefile.toUpperCase() ||
                format.toUpperCase() === ExportFormat.URL.toUpperCase()) {
                return format;
            }
        }))
            .map((/**
         * @param {?} format
         * @return {?}
         */
        function (format) {
            if (format.toUpperCase() === ExportFormat.CSVcomma.toUpperCase()) {
                format = ExportFormat.CSVcomma;
                return format;
            }
            if (format.toUpperCase() === ExportFormat.CSVsemicolon.toUpperCase()) {
                format = ExportFormat.CSVsemicolon;
                return format;
            }
            if (format.toUpperCase() === ExportFormat.GML.toUpperCase()) {
                format = ExportFormat.GML;
                return format;
            }
            if (format.toUpperCase() === ExportFormat.GPX.toUpperCase()) {
                format = ExportFormat.GPX;
                return format;
            }
            if (format.toUpperCase() === ExportFormat.GeoJSON.toUpperCase()) {
                format = ExportFormat.GeoJSON;
                return format;
            }
            if (format.toUpperCase() === ExportFormat.KML.toUpperCase()) {
                format = ExportFormat.KML;
                return format;
            }
            if (format.toUpperCase() === ExportFormat.Shapefile.toUpperCase()) {
                format = ExportFormat.Shapefile;
                return format;
            }
            if (format.toUpperCase() === ExportFormat.URL.toUpperCase()) {
                format = ExportFormat.URL;
                return format;
            }
        }));
    };
    /**
     * @param {?} tab
     * @return {?}
     */
    ImportExportComponent.prototype.tabChanged = /**
     * @param {?} tab
     * @return {?}
     */
    function (tab) {
        this.selectedTabIndex.emit(tab.index);
    };
    /**
     * @private
     * @return {?}
     */
    ImportExportComponent.prototype.onFileExportSuccess = /**
     * @private
     * @return {?}
     */
    function () {
        handleFileExportSuccess(this.messageService, this.languageService);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    ImportExportComponent.prototype.onImportExportChange = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.activeImportExport = event.value;
    };
    ImportExportComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igo-import-export',
                    template: "<div class=\"import-export-toggle mat-typography\">\r\n  <mat-button-toggle-group\r\n        [value]=\"activeImportExport\"\r\n        (change)=\"onImportExportChange($event)\">\r\n        <mat-button-toggle [value]=\"'import'\">\r\n          {{'igo.geo.importExportForm.importTabTitle' | translate}}\r\n        </mat-button-toggle>\r\n        <mat-button-toggle [value]=\"'export'\">\r\n          {{'igo.geo.importExportForm.exportTabTitle' | translate}}\r\n        </mat-button-toggle>\r\n  </mat-button-toggle-group>\r\n</div>\r\n\r\n<form class=\"igo-form\" *ngIf=\"activeImportExport === 'import'\">\r\n  <div class=\"igo-input-container\">\r\n    <mat-form-field>\r\n      <input\r\n        matInput\r\n        placeholder=\"{{'igo.geo.importExportForm.importProjPlaceholder' | translate}}\"\r\n        name=\"inputProj\"\r\n        [(ngModel)]=\"inputProj\">\r\n    </mat-form-field>\r\n  </div>\r\n\r\n  <div class=\"igo-form-button-group\">\r\n    <button mat-raised-button type=\"button\" (click)=\"fileInput.click()\" [disabled]=\"loading$ | async\">\r\n      {{'igo.geo.importExportForm.importButton' | translate}}\r\n    </button>\r\n    <igo-spinner [shown]=\"loading$ | async\"></igo-spinner>\r\n    <input\r\n      hidden\r\n      #fileInput\r\n      type=\"file\"\r\n      [style.display]=\"'none'\"\r\n      (click)=\"fileInput.value = null\"\r\n      (change)=\"importFiles($event.target.files)\">\r\n  </div>\r\n</form>\r\n<section class=\"mat-typography\" *ngIf=\"activeImportExport === 'import'\">\r\n  <h4>{{'igo.geo.importExportForm.importClarifications' | translate}}</h4>\r\n  <ul>\r\n    <li>{{'igo.geo.importExportForm.importSizeMax' | translate: {size: fileSizeMb} }}</li>\r\n    <li>{{'igo.geo.importExportForm.importFormatAuthorized' | translate}}</li>\r\n    <li>{{'igo.geo.importExportForm.importShpZip' | translate}}</li>\r\n  </ul>\r\n</section>\r\n\r\n<section class=\"mat-typography\" *ngIf=\"(exportableLayers$ | async).length === 0 && activeImportExport === 'export'\">\r\n  <h4>{{'igo.geo.importExportForm.exportNoLayersExportable' | translate}}</h4>\r\n</section>\r\n\r\n<form class=\"igo-form\" [formGroup]=\"form\" *ngIf=\"(exportableLayers$ | async).length > 0 && activeImportExport === 'export'\">\r\n  <div class=\"igo-input-container\">\r\n    <mat-form-field>\r\n      <mat-label>{{'igo.geo.importExportForm.exportLayerPlaceholder' | translate}}</mat-label>\r\n      <mat-select\r\n        [formControl]=\"form.controls.layer\" multiple>\r\n        <mat-option *ngFor=\"let layer of (exportableLayers$ | async)\" [value]=\"layer.id\">\r\n          {{layer.title}}\r\n        </mat-option>\r\n      </mat-select>\r\n    </mat-form-field>\r\n  </div>\r\n\r\n  <div class=\"igo-input-container\">\r\n    <mat-form-field>\r\n      <mat-label>{{'igo.geo.importExportForm.exportFormatPlaceholder' | translate}}</mat-label>\r\n      <mat-select\r\n        formControlName=\"format\">\r\n        <ng-container *ngIf=\"(formats$ | async).length !== 0\">\r\n          <mat-option *ngFor=\"let format of (formats$ | async) | keyvalue\" [value]=\"format.key\">\r\n            {{'igo.geo.export.format.' + format.value | translate}}\r\n          </mat-option>\r\n        </ng-container>\r\n        <mat-option *ngIf=\"(formats$ | async).length === 0\" disabled=\"true\">\r\n          {{'igo.geo.export.noFormat.title' | translate}}\r\n        </mat-option>\r\n      </mat-select>\r\n    </mat-form-field>\r\n  </div>\r\n\r\n  <div class=\"igo-input-container\" *ngIf=\"forceNaming && form.value.format !== 'URL'\">\r\n    <mat-form-field>\r\n        <input matInput formControlName=\"name\" placeholder=\"{{'igo.geo.importExportForm.exportFileNamePlaceholder' | translate}}\">\r\n    </mat-form-field>\r\n  </div>\r\n\r\n  <div class=\"export-options mat-typography\" *ngIf=\"form.value.format !== 'URL'\">\r\n    <mat-slide-toggle\r\n        formControlName=\"featureInMapExtent\"\r\n        [labelPosition]=\"'before'\">\r\n          {{'igo.geo.importExportForm.exportFeatureInExtent' | translate}}\r\n    </mat-slide-toggle>\r\n  </div>\r\n\r\n  <div class=\"igo-form-button-group\">\r\n    <button\r\n      mat-raised-button\r\n      type=\"button\"\r\n      [disabled]=\"!form.valid || (loading$ | async)\"\r\n      (click)=\"handleExportFormSubmit(form.value)\">\r\n      {{form.value.format !== 'URL'  ? ('igo.geo.importExportForm.exportButton' | translate): ('igo.geo.importExportForm.exportButtonLink' | translate)}}\r\n    </button>\r\n    <igo-spinner [shown]=\"loading$ | async\"></igo-spinner>\r\n  </div>\r\n\r\n</form>\r\n",
                    styles: [".import-export-toggle{padding:10px;text-align:center}.import-export-toggle mat-button-toggle-group{width:100%}.import-export-toggle mat-button-toggle-group mat-button-toggle{width:50%}h4{padding:0 5px}.igo-form{padding:15px 5px}.igo-input-container mat-form-field{width:100%}.igo-form-button-group{text-align:center;padding-top:10px}igo-spinner{position:absolute;padding-left:10px}.export-options{overflow-x:hidden}.export-options mat-slide-toggle{width:100%;margin:10px}.export-options mat-slide-toggle ::ng-deep .mat-slide-toggle-content{width:calc(100% - 60px)}"]
                }] }
    ];
    /** @nocollapse */
    ImportExportComponent.ctorParameters = function () { return [
        { type: ImportService },
        { type: ExportService },
        { type: LanguageService },
        { type: MessageService },
        { type: StyleListService },
        { type: StyleService },
        { type: FormBuilder },
        { type: ConfigService }
    ]; };
    ImportExportComponent.propDecorators = {
        map: [{ type: Input }],
        selectedIndex: [{ type: Input }],
        selectedTabIndex: [{ type: Output }],
        exportOptions$: [{ type: Input }],
        exportOptionsChange: [{ type: Output }]
    };
    return ImportExportComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var DropGeoFileDirective = /** @class */ (function (_super) {
    __extends(DropGeoFileDirective, _super);
    function DropGeoFileDirective(component, importService, languageService, styleListService, styleService, config, messageService) {
        var _this = _super.call(this) || this;
        _this.component = component;
        _this.importService = importService;
        _this.languageService = languageService;
        _this.styleListService = styleListService;
        _this.styleService = styleService;
        _this.config = config;
        _this.messageService = messageService;
        _this.filesDropped = new EventEmitter();
        _this.filesInvalid = new EventEmitter();
        return _this;
    }
    Object.defineProperty(DropGeoFileDirective.prototype, "map", {
        get: /**
         * @return {?}
         */
        function () {
            return this.component.map;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    DropGeoFileDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.filesDropped$$ = this.filesDropped.subscribe((/**
         * @param {?} files
         * @return {?}
         */
        function (files) {
            _this.onFilesDropped(files);
        }));
    };
    /**
     * @return {?}
     */
    DropGeoFileDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.filesDropped$$.unsubscribe();
    };
    /**
     * @param {?} evt
     * @return {?}
     */
    DropGeoFileDirective.prototype.onDragOver = /**
     * @param {?} evt
     * @return {?}
     */
    function (evt) {
        _super.prototype.onDragOver.call(this, evt);
    };
    /**
     * @param {?} evt
     * @return {?}
     */
    DropGeoFileDirective.prototype.onDragLeave = /**
     * @param {?} evt
     * @return {?}
     */
    function (evt) {
        _super.prototype.onDragLeave.call(this, evt);
    };
    /**
     * @param {?} evt
     * @return {?}
     */
    DropGeoFileDirective.prototype.onDrop = /**
     * @param {?} evt
     * @return {?}
     */
    function (evt) {
        _super.prototype.onDrop.call(this, evt);
    };
    /**
     * @private
     * @param {?} files
     * @return {?}
     */
    DropGeoFileDirective.prototype.onFilesDropped = /**
     * @private
     * @param {?} files
     * @return {?}
     */
    function (files) {
        var _this = this;
        var e_1, _a;
        var _loop_1 = function (file) {
            this_1.importService
                .import(file)
                .subscribe((/**
             * @param {?} features
             * @return {?}
             */
            function (features) { return _this.onFileImportSuccess(file, features); }), (/**
             * @param {?} error
             * @return {?}
             */
            function (error) { return _this.onFileImportError(file, error); }));
        };
        var this_1 = this;
        try {
            for (var files_1 = __values(files), files_1_1 = files_1.next(); !files_1_1.done; files_1_1 = files_1.next()) {
                var file = files_1_1.value;
                _loop_1(file);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (files_1_1 && !files_1_1.done && (_a = files_1.return)) _a.call(files_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    /**
     * @private
     * @param {?} file
     * @param {?} features
     * @return {?}
     */
    DropGeoFileDirective.prototype.onFileImportSuccess = /**
     * @private
     * @param {?} file
     * @param {?} features
     * @return {?}
     */
    function (file, features) {
        if (!this.config.getConfig('importWithStyle')) {
            handleFileImportSuccess(file, features, this.map, this.messageService, this.languageService);
        }
        else {
            handleFileImportSuccess(file, features, this.map, this.messageService, this.languageService, this.styleListService, this.styleService);
        }
    };
    /**
     * @private
     * @param {?} file
     * @param {?} error
     * @return {?}
     */
    DropGeoFileDirective.prototype.onFileImportError = /**
     * @private
     * @param {?} file
     * @param {?} error
     * @return {?}
     */
    function (file, error) {
        handleFileImportError(file, error, this.messageService, this.languageService, this.config.getConfig('importExport.clientSideFileSizeMaxMb'));
    };
    DropGeoFileDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igoDropGeoFile]'
                },] }
    ];
    /** @nocollapse */
    DropGeoFileDirective.ctorParameters = function () { return [
        { type: MapBrowserComponent },
        { type: ImportService },
        { type: LanguageService },
        { type: StyleListService },
        { type: StyleService },
        { type: ConfigService },
        { type: MessageService }
    ]; };
    DropGeoFileDirective.propDecorators = {
        onDragOver: [{ type: HostListener, args: ['dragover', ['$event'],] }],
        onDragLeave: [{ type: HostListener, args: ['dragleave', ['$event'],] }],
        onDrop: [{ type: HostListener, args: ['drop', ['$event'],] }]
    };
    return DropGeoFileDirective;
}(DragAndDropDirective));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var STYLELIST_OPTIONS = new InjectionToken('styleListOptions');
/**
 * @param {?} options
 * @return {?}
 */
function provideStyleListOptions(options) {
    return {
        provide: STYLELIST_OPTIONS,
        useValue: options
    };
}
/**
 * @param {?} styleListService
 * @param {?} options
 * @return {?}
 */
function styleListFactory(styleListService, options) {
    return (/**
     * @return {?}
     */
    function () { return styleListService.load(options); });
}
/**
 * @return {?}
 */
function provideStyleListLoader() {
    return {
        provide: APP_INITIALIZER,
        useFactory: styleListFactory,
        multi: true,
        deps: [StyleListService, STYLELIST_OPTIONS]
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgoStyleListModule = /** @class */ (function () {
    function IgoStyleListModule() {
    }
    /**
     * @return {?}
     */
    IgoStyleListModule.forRoot = /**
     * @return {?}
     */
    function () {
        return {
            ngModule: IgoStyleListModule,
            providers: [provideStyleListOptions({}), provideStyleListLoader()]
        };
    };
    IgoStyleListModule.decorators = [
        { type: NgModule, args: [{
                    imports: [],
                    declarations: [],
                    exports: []
                },] }
    ];
    return IgoStyleListModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgoImportExportModule = /** @class */ (function () {
    function IgoImportExportModule() {
    }
    /**
     * @return {?}
     */
    IgoImportExportModule.forRoot = /**
     * @return {?}
     */
    function () {
        return {
            ngModule: IgoImportExportModule
        };
    };
    IgoImportExportModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        MatIconModule,
                        MatTooltipModule,
                        FormsModule,
                        ReactiveFormsModule,
                        CommonModule,
                        MatButtonModule,
                        MatButtonToggleModule,
                        MatTabsModule,
                        MatSelectModule,
                        MatOptionModule,
                        MatFormFieldModule,
                        MatInputModule,
                        MatSlideToggleModule,
                        IgoLanguageModule,
                        IgoSpinnerModule,
                        IgoKeyValueModule,
                        IgoDrapDropModule,
                        IgoStyleListModule.forRoot()
                    ],
                    exports: [ImportExportComponent, DropGeoFileDirective, IgoStyleListModule, ExportButtonComponent],
                    declarations: [ImportExportComponent, DropGeoFileDirective, ExportButtonComponent]
                },] }
    ];
    return IgoImportExportModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgoMapModule = /** @class */ (function () {
    function IgoMapModule() {
    }
    IgoMapModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        IgoLanguageModule,
                        IgoConfirmDialogModule,
                        MatIconModule,
                        MatButtonModule,
                        MatTooltipModule
                    ],
                    exports: [
                        MapBrowserComponent,
                        ZoomButtonComponent,
                        GeolocateButtonComponent,
                        RotationButtonComponent,
                        BaseLayersSwitcherComponent,
                        MiniBaseMapComponent,
                        MapOfflineDirective,
                        OfflineButtonComponent,
                        PointerPositionDirective,
                        PointerPositionByKeyDirective
                    ],
                    declarations: [
                        MapBrowserComponent,
                        ZoomButtonComponent,
                        GeolocateButtonComponent,
                        RotationButtonComponent,
                        BaseLayersSwitcherComponent,
                        MiniBaseMapComponent,
                        MapOfflineDirective,
                        OfflineButtonComponent,
                        PointerPositionDirective,
                        PointerPositionByKeyDirective
                    ]
                },] }
    ];
    return IgoMapModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Measurer item
 */
var MeasurerItemComponent = /** @class */ (function () {
    function MeasurerItemComponent() {
        /**
         * Measure observable
         * \@internal
         */
        this.measure$ = new BehaviorSubject(undefined);
        this._auto = false;
        /**
         * Event emitted when the measure unit changes
         */
        this.measureUnitChange = new EventEmitter();
    }
    Object.defineProperty(MeasurerItemComponent.prototype, "measure", {
        get: /**
         * @return {?}
         */
        function () { return this.measure$.value; },
        /**
         * Measure
         */
        set: /**
         * Measure
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.measure$.next(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeasurerItemComponent.prototype, "auto", {
        get: /**
         * @return {?}
         */
        function () { return this._auto; },
        /**
         * Whther measure units should be automatically determined
         */
        set: /**
         * Whther measure units should be automatically determined
         * @param {?} value
         * @return {?}
         */
        function (value) { this.toggleAutoUnit(value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeasurerItemComponent.prototype, "measureUnits", {
        /**
         * Available measure units for the measure type given
         * @internal
         */
        get: /**
         * Available measure units for the measure type given
         * \@internal
         * @return {?}
         */
        function () {
            if (this.measureType === MeasureType.Area) {
                return Object.values(MeasureAreaUnit);
            }
            return Object.values(MeasureLengthUnit);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Toggle the auto unit off
     * @internal
     */
    /**
     * Toggle the auto unit off
     * \@internal
     * @return {?}
     */
    MeasurerItemComponent.prototype.ngOnDestroy = /**
     * Toggle the auto unit off
     * \@internal
     * @return {?}
     */
    function () {
        this.toggleAutoUnit(false);
    };
    /**
     * Set the measure unit
     * @internal
     */
    /**
     * Set the measure unit
     * \@internal
     * @param {?} unit
     * @return {?}
     */
    MeasurerItemComponent.prototype.onMeasureUnitChange = /**
     * Set the measure unit
     * \@internal
     * @param {?} unit
     * @return {?}
     */
    function (unit) {
        this.measureUnit = unit;
        this.measureUnitChange.emit(unit);
    };
    /**
     * @private
     * @param {?} toggle
     * @return {?}
     */
    MeasurerItemComponent.prototype.toggleAutoUnit = /**
     * @private
     * @param {?} toggle
     * @return {?}
     */
    function (toggle) {
        var _this = this;
        if (this.measure$$ !== undefined) {
            this.measure$$.unsubscribe();
        }
        if (toggle === true) {
            this.measure$$ = this.measure$.subscribe((/**
             * @param {?} measure
             * @return {?}
             */
            function (measure) {
                _this.computeBestMeasureUnit(measure);
            }));
        }
        this._auto = toggle;
    };
    /**
     * @private
     * @param {?} measure
     * @return {?}
     */
    MeasurerItemComponent.prototype.computeBestMeasureUnit = /**
     * @private
     * @param {?} measure
     * @return {?}
     */
    function (measure) {
        /** @type {?} */
        var measureUnit = this.measureUnit;
        if (this.measureType === MeasureType.Area) {
            measureUnit = computeBestAreaUnit(measure);
        }
        else if (this.measureType === MeasureType.Length) {
            measureUnit = computeBestLengthUnit(measure);
        }
        if (measureUnit !== this.measureUnit) {
            this.onMeasureUnitChange(measureUnit);
        }
    };
    MeasurerItemComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igo-measurer-item',
                    template: "<mat-form-field class=\"measure-field\">\r\n  <input\r\n    matInput\r\n    [readonly]=\"true\"\r\n    [placeholder]=\"placeholder\"\r\n    [value]=\"((measure$ | async) || 0) | measureFormat: measureUnit\">\r\n</mat-form-field>\r\n<mat-form-field class=\"unit-field\">\r\n  <mat-select\r\n    [value]=\"measureUnit\"\r\n    [disabled]=\"auto\"\r\n    (selectionChange)=\"onMeasureUnitChange($event.value)\">\r\n    <mat-option *ngFor=\"let measureUnit of measureUnits\" [value]=\"measureUnit\">\r\n      {{('igo.geo.measure.' + measureUnit) | translate}}\r\n    </mat-option>\r\n  </mat-select>\r\n</mat-form-field>\r\n",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: [":host{display:-webkit-box;display:flex;width:100%;padding:5px 10px}.measure-field{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-flow:column nowrap;width:100%}.unit-field{width:110px;margin-left:10px}"]
                }] }
    ];
    /** @nocollapse */
    MeasurerItemComponent.ctorParameters = function () { return []; };
    MeasurerItemComponent.propDecorators = {
        measureType: [{ type: Input }],
        measureUnit: [{ type: Input }],
        measure: [{ type: Input }],
        auto: [{ type: Input }],
        placeholder: [{ type: Input }],
        measureUnitChange: [{ type: Output }]
    };
    return MeasurerItemComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @ignore
 */
var IgoMeasurerModule = /** @class */ (function () {
    function IgoMeasurerModule() {
    }
    IgoMeasurerModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        MatButtonModule,
                        MatButtonToggleModule,
                        MatIconModule,
                        MatTooltipModule,
                        MatFormFieldModule,
                        MatInputModule,
                        MatSelectModule,
                        MatSlideToggleModule,
                        IgoLanguageModule,
                        IgoEntityTableModule
                    ],
                    declarations: [
                        MeasureFormatPipe,
                        MeasurerItemComponent,
                        MeasurerComponent,
                        MeasurerDialogComponent
                    ],
                    exports: [
                        MeasureFormatPipe,
                        MeasurerComponent
                    ],
                    entryComponents: [
                        MeasurerDialogComponent
                    ]
                },] }
    ];
    return IgoMeasurerModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgoMeasureModule = /** @class */ (function () {
    function IgoMeasureModule() {
    }
    IgoMeasureModule.decorators = [
        { type: NgModule, args: [{
                    imports: [],
                    declarations: [],
                    exports: [
                        IgoMeasurerModule
                    ]
                },] }
    ];
    return IgoMeasureModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgoOverlayModule = /** @class */ (function () {
    function IgoOverlayModule() {
    }
    /**
     * @return {?}
     */
    IgoOverlayModule.forRoot = /**
     * @return {?}
     */
    function () {
        return {
            ngModule: IgoOverlayModule
        };
    };
    IgoOverlayModule.decorators = [
        { type: NgModule, args: [{
                    imports: [],
                    exports: [OverlayDirective],
                    declarations: [OverlayDirective]
                },] }
    ];
    return IgoOverlayModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var PrintOutputFormat = strEnum(['Pdf', 'Image']);
/** @type {?} */
var PrintPaperFormat = strEnum([
    'A0',
    'A1',
    'A2',
    'A3',
    'A4',
    'A5',
    'Letter',
    'Legal'
]);
/** @type {?} */
var PrintOrientation = strEnum(['landscape', 'portrait']);
/** @type {?} */
var PrintResolution = strEnum(['72', '96', '150', '300']);
/** @type {?} */
var PrintSaveImageFormat = strEnum([
    'Bmp',
    'Gif',
    'Jpeg',
    'Png',
    'Tiff'
]);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var html2canvas = _html2canvas;
var PrintService = /** @class */ (function () {
    function PrintService(messageService, activityService, languageService) {
        this.messageService = messageService;
        this.activityService = activityService;
        this.languageService = languageService;
    }
    /**
     * @param {?} map
     * @param {?} options
     * @return {?}
     */
    PrintService.prototype.print = /**
     * @param {?} map
     * @param {?} options
     * @return {?}
     */
    function (map$$1, options) {
        var _this = this;
        /** @type {?} */
        var status$ = new Subject();
        /** @type {?} */
        var paperFormat = options.paperFormat;
        /** @type {?} */
        var resolution = +options.resolution;
        // Default is 96
        /** @type {?} */
        var orientation = options.orientation;
        this.activityId = this.activityService.register();
        /** @type {?} */
        var doc = new jsPDF({
            orientation: orientation,
            format: paperFormat.toLowerCase()
        });
        /** @type {?} */
        var dimensions = [
            doc.internal.pageSize.width,
            doc.internal.pageSize.height
        ];
        /** @type {?} */
        var margins = [20, 10, 20, 10];
        /** @type {?} */
        var width = dimensions[0] - margins[3] - margins[1];
        /** @type {?} */
        var height = dimensions[1] - margins[0] - margins[2];
        /** @type {?} */
        var size = [width, height];
        if (options.title !== undefined) {
            this.addTitle(doc, options.title, dimensions[0]);
        }
        if (options.showProjection === true || options.showScale === true) {
            this.addProjScale(doc, map$$1, resolution, options.showProjection, options.showScale);
        }
        if (options.comment !== '') {
            this.addComment(doc, options.comment);
        }
        this.addMap(doc, map$$1, resolution, size, margins).subscribe((/**
         * @param {?} status
         * @return {?}
         */
        function (status) {
            if (status === SubjectStatus.Done) {
                if (options.showLegend === true) {
                    _this.addLegend(doc, map$$1, margins, resolution);
                }
                else {
                    _this.saveDoc(doc);
                }
            }
            if (status === SubjectStatus.Done || status === SubjectStatus.Error) {
                _this.activityService.unregister(_this.activityId);
                status$.next(SubjectStatus.Done);
            }
        }));
        return status$;
    };
    /**
     * Get html code for all layers legend
     * @param  map IgoMap
     * @param  width The width that the legend need to be
     * @return Html code for the legend
     */
    /**
     * Get html code for all layers legend
     * @param {?} map IgoMap
     * @param {?} width The width that the legend need to be
     * @param {?} resolution
     * @return {?} Html code for the legend
     */
    PrintService.prototype.getLayersLegendHtml = /**
     * Get html code for all layers legend
     * @param {?} map IgoMap
     * @param {?} width The width that the legend need to be
     * @param {?} resolution
     * @return {?} Html code for the legend
     */
    function (map$$1, width, resolution) {
        /** @type {?} */
        var html = '';
        /** @type {?} */
        var legends = getLayersLegends(map$$1.layers, map$$1.viewController.getScale(resolution));
        if (legends.length === 0) {
            return html;
        }
        // Define important style to be sure that all container is convert
        // to image not just visible part
        html += '<style media="screen" type="text/css">';
        html += '.html2canvas-container { width: ' + width;
        html += 'mm !important; height: 2000px !important; }';
        html += '</style>';
        html += '<font size="2" face="Courier New" >';
        html += '<div style="display:inline-block;max-width:' + width + 'mm">';
        // For each legend, define an html table cell
        legends.forEach((/**
         * @param {?} legend
         * @return {?}
         */
        function (legend) {
            html +=
                '<table border=1 style="display:inline-block;vertical-align:top">';
            html += '<tr><th width="170px">' + legend.title + '</th>';
            html += '<td><img class="printImageLegend" src="' + legend.url + '">';
            html += '</td></tr></table>';
        }));
        html += '</div>';
        return html;
    };
    /**
     * Get all the legend in a single image
     * * @param  format - Image format. default value to "png"
     * @return The image of the legend
     */
    /**
     * Get all the legend in a single image
     * * \@param  format - Image format. default value to "png"
     * @param {?} map
     * @param {?=} format
     * @param {?=} doZipFile
     * @param {?=} resolution
     * @return {?} The image of the legend
     */
    PrintService.prototype.getLayersLegendImage = /**
     * Get all the legend in a single image
     * * \@param  format - Image format. default value to "png"
     * @param {?} map
     * @param {?=} format
     * @param {?=} doZipFile
     * @param {?=} resolution
     * @return {?} The image of the legend
     */
    function (map$$1, format, doZipFile, resolution) {
        if (format === void 0) { format = 'png'; }
        /** @type {?} */
        var status$ = new Subject();
        // Get html code for the legend
        /** @type {?} */
        var width = 200;
        // milimeters unit, originally define for document pdf
        /** @type {?} */
        var html = this.getLayersLegendHtml(map$$1, width, resolution);
        /** @type {?} */
        var that = this;
        format = format.toLowerCase();
        // If no legend show No LEGEND in an image
        if (html.length === 0) {
            html = '<font size="12" face="Courier New" >';
            html += '<div align="center"><b>NO LEGEND</b></div>';
        }
        // Create div to contain html code for legend
        /** @type {?} */
        var div = window.document.createElement('div');
        // Add html code to convert in the new window
        window.document.body.appendChild(div);
        div.innerHTML = html;
        // Define event to execute after all images are loaded to create the canvas
        setTimeout((/**
         * @return {?}
         */
        function () {
            html2canvas(div, { useCORS: true })
                .then((/**
             * @param {?} canvas
             * @return {?}
             */
            function (canvas) {
                /** @type {?} */
                var status = SubjectStatus.Done;
                try {
                    if (!doZipFile) {
                        // Save the canvas as file
                        that.saveCanvasImageAsFile(canvas, 'legendImage', format);
                    }
                    else {
                        // Add the canvas to zip
                        that.generateCanvaFileToZip(canvas, 'legendImage' + '.' + format);
                    }
                    div.parentNode.removeChild(div); // remove temp div (IE)
                }
                catch (err) {
                    status = SubjectStatus.Error;
                }
                status$.next(status);
            }))
                .catch((/**
             * @param {?} e
             * @return {?}
             */
            function (e) {
                console.log(e);
            }));
        }), 500);
    };
    /**
     * @private
     * @param {?} doc
     * @param {?} title
     * @param {?} pageWidth
     * @return {?}
     */
    PrintService.prototype.addTitle = /**
     * @private
     * @param {?} doc
     * @param {?} title
     * @param {?} pageWidth
     * @return {?}
     */
    function (doc, title, pageWidth) {
        /** @type {?} */
        var pdfResolution = 96;
        /** @type {?} */
        var titleSize = 32;
        /** @type {?} */
        var titleWidth = ((titleSize * 25.4) / pdfResolution) * title.length;
        /** @type {?} */
        var titleMarginLeft;
        if (titleWidth > pageWidth) {
            titleMarginLeft = 0;
        }
        else {
            titleMarginLeft = (pageWidth - titleWidth) / 2;
        }
        doc.setFont('courier');
        doc.setFontSize(32);
        doc.text(title, titleMarginLeft, 15);
    };
    /**
     * Add comment to the document
     * * @param  doc - pdf document
     * * @param  comment - Comment to add in the document
     * * @param  size - Size of the document
     */
    /**
     * Add comment to the document
     * * \@param  doc - pdf document
     * * \@param  comment - Comment to add in the document
     * * \@param  size - Size of the document
     * @private
     * @param {?} doc
     * @param {?} comment
     * @return {?}
     */
    PrintService.prototype.addComment = /**
     * Add comment to the document
     * * \@param  doc - pdf document
     * * \@param  comment - Comment to add in the document
     * * \@param  size - Size of the document
     * @private
     * @param {?} doc
     * @param {?} comment
     * @return {?}
     */
    function (doc, comment) {
        /** @type {?} */
        var commentSize = 16;
        /** @type {?} */
        var commentMarginLeft = 20;
        /** @type {?} */
        var marginBottom = 5;
        /** @type {?} */
        var heightPixels = doc.internal.pageSize.height - marginBottom;
        doc.setFont('courier');
        doc.setFontSize(commentSize);
        doc.text(comment, commentMarginLeft, heightPixels);
    };
    /**
     * Add projection and/or scale to the document
     * @param  doc - pdf document
     * @param  map - Map of the app
     * @param  dpi - DPI resolution of the document
     * @param  projection - Bool to indicate if projection need to be added
     * @param  scale - Bool to indicate if scale need to be added
     */
    /**
     * Add projection and/or scale to the document
     * @private
     * @param {?} doc - pdf document
     * @param {?} map - Map of the app
     * @param {?} dpi - DPI resolution of the document
     * @param {?} projection - Bool to indicate if projection need to be added
     * @param {?} scale - Bool to indicate if scale need to be added
     * @return {?}
     */
    PrintService.prototype.addProjScale = /**
     * Add projection and/or scale to the document
     * @private
     * @param {?} doc - pdf document
     * @param {?} map - Map of the app
     * @param {?} dpi - DPI resolution of the document
     * @param {?} projection - Bool to indicate if projection need to be added
     * @param {?} scale - Bool to indicate if scale need to be added
     * @return {?}
     */
    function (doc, map$$1, dpi, projection, scale) {
        /** @type {?} */
        var translate = this.languageService.translate;
        /** @type {?} */
        var projScaleSize = 16;
        /** @type {?} */
        var projScaleMarginLeft = 20;
        /** @type {?} */
        var marginBottom = 15;
        /** @type {?} */
        var heightPixels = doc.internal.pageSize.height - marginBottom;
        /** @type {?} */
        var textProjScale = '';
        if (projection === true) {
            /** @type {?} */
            var projText = translate.instant('igo.geo.printForm.projection');
            textProjScale += projText + ': ' + map$$1.projection;
        }
        if (scale === true) {
            if (projection === true) {
                textProjScale += '   ';
            }
            /** @type {?} */
            var scaleText = translate.instant('igo.geo.printForm.scale');
            /** @type {?} */
            var mapScale = map$$1.viewController.getScale(dpi);
            textProjScale += scaleText + ': ~ 1 / ' + formatScale(mapScale);
        }
        doc.setFont('courier');
        doc.setFontSize(projScaleSize);
        doc.text(textProjScale, projScaleMarginLeft, heightPixels);
    };
    /**
     * Add the legend to the document
     * @param  doc - Pdf document where legend will be added
     * @param  map - Map of the app
     * @param  margins - Page margins
     */
    /**
     * Add the legend to the document
     * @private
     * @param {?} doc - Pdf document where legend will be added
     * @param {?} map - Map of the app
     * @param {?} margins - Page margins
     * @param {?} resolution
     * @return {?}
     */
    PrintService.prototype.addLegend = /**
     * Add the legend to the document
     * @private
     * @param {?} doc - Pdf document where legend will be added
     * @param {?} map - Map of the app
     * @param {?} margins - Page margins
     * @param {?} resolution
     * @return {?}
     */
    function (doc, map$$1, margins, resolution) {
        var _this = this;
        /** @type {?} */
        var that = this;
        // Get html code for the legend
        /** @type {?} */
        var width = doc.internal.pageSize.width;
        /** @type {?} */
        var html = this.getLayersLegendHtml(map$$1, width, resolution);
        // If no legend, save the map directly
        if (html === '') {
            this.saveDoc(doc);
            return true;
        }
        // Create div to contain html code for legend
        /** @type {?} */
        var div = window.document.createElement('div');
        html2canvas(div, { useCORS: true })
            .then((/**
         * @param {?} canvas
         * @return {?}
         */
        function (canvas) {
            /** @type {?} */
            var imgData;
            /** @type {?} */
            var position = 10;
            imgData = canvas.toDataURL('image/png');
            doc.addPage();
            /** @type {?} */
            var imageSize = _this.getImageSizeToFitPdf(doc, canvas, margins);
            doc.addImage(imgData, 'PNG', 10, position, imageSize[0], imageSize[1]);
            that.saveDoc(doc);
            div.parentNode.removeChild(div); // remove temp div (IE style)
        }))
            .catch((/**
         * @param {?} e
         * @return {?}
         */
        function (e) {
            console.log(e);
        }));
        // Add html code to convert in the new window
        window.document.body.appendChild(div);
        div.innerHTML = html;
    };
    /**
     * @private
     * @param {?} doc
     * @param {?} canvas
     * @param {?} margins
     * @return {?}
     */
    PrintService.prototype.addCanvas = /**
     * @private
     * @param {?} doc
     * @param {?} canvas
     * @param {?} margins
     * @return {?}
     */
    function (doc, canvas, margins) {
        /** @type {?} */
        var image;
        image = canvas.toDataURL('image/jpeg');
        if (image !== undefined) {
            /** @type {?} */
            var imageSize = this.getImageSizeToFitPdf(doc, canvas, margins);
            doc.addImage(image, 'JPEG', margins[3], margins[0], imageSize[0], imageSize[1]);
            doc.rect(margins[3], margins[0], imageSize[0], imageSize[1]);
        }
    };
    // TODO fix printing with image resolution
    // TODO fix printing with image resolution
    /**
     * @private
     * @param {?} doc
     * @param {?} map
     * @param {?} resolution
     * @param {?} size
     * @param {?} margins
     * @return {?}
     */
    PrintService.prototype.addMap = 
    // TODO fix printing with image resolution
    /**
     * @private
     * @param {?} doc
     * @param {?} map
     * @param {?} resolution
     * @param {?} size
     * @param {?} margins
     * @return {?}
     */
    function (doc, map$$1, resolution, size, margins) {
        var _this = this;
        /** @type {?} */
        var status$ = new Subject();
        /** @type {?} */
        var mapSize = map$$1.ol.getSize();
        /** @type {?} */
        var extent = map$$1.ol.getView().calculateExtent(mapSize);
        /** @type {?} */
        var widthPixels = Math.round((size[0] * resolution) / 25.4);
        /** @type {?} */
        var heightPixels = Math.round((size[1] * resolution) / 25.4);
        /** @type {?} */
        var timeout;
        map$$1.ol.once('postcompose', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            /** @type {?} */
            var canvas = event.context.canvas;
            /** @type {?} */
            var mapStatus$$ = map$$1.status$.subscribe((/**
             * @param {?} mapStatus
             * @return {?}
             */
            function (mapStatus) {
                clearTimeout(timeout);
                if (mapStatus !== SubjectStatus.Done) {
                    return;
                }
                mapStatus$$.unsubscribe();
                /** @type {?} */
                var status = SubjectStatus.Done;
                try {
                    _this.addCanvas(doc, canvas, margins);
                }
                catch (err) {
                    status = SubjectStatus.Error;
                    _this.messageService.error(_this.languageService.translate.instant('igo.geo.printForm.corsErrorMessageBody'), _this.languageService.translate.instant('igo.geo.printForm.corsErrorMessageHeader'), 'print');
                }
                _this.renderMap(map$$1, mapSize, extent);
                status$.next(status);
            }));
            // If no loading as started after 200ms, then probably no loading
            // is required.
            timeout = window.setTimeout((/**
             * @return {?}
             */
            function () {
                mapStatus$$.unsubscribe();
                /** @type {?} */
                var status = SubjectStatus.Done;
                try {
                    _this.addCanvas(doc, canvas, margins);
                }
                catch (err) {
                    status = SubjectStatus.Error;
                    _this.messageService.error(_this.languageService.translate.instant('igo.geo.printForm.corsErrorMessageBody'), _this.languageService.translate.instant('igo.geo.printForm.corsErrorMessageHeader'), 'print');
                }
                _this.renderMap(map$$1, mapSize, extent);
                status$.next(status);
            }), 200);
        }));
        this.renderMap(map$$1, [widthPixels, heightPixels], extent);
        return status$;
    };
    /**
     * @param {?} nbFileToProcess
     * @return {?}
     */
    PrintService.prototype.defineNbFileToProcess = /**
     * @param {?} nbFileToProcess
     * @return {?}
     */
    function (nbFileToProcess) {
        this.nbFileToProcess = nbFileToProcess;
    };
    /**
     * Download an image of the map with addition of informations
     * @param  map - Map of the app
     * @param  format - Image format. default value to "png"
     * @param  projection - Indicate if projection need to be add. Default to false
     * @param  scale - Indicate if scale need to be add. Default to false
     * @param  legend - Indicate if the legend of layers need to be download. Default to false
     * @param  title - Title to add for the map - Default to blank
     * @param  comment - Comment to add for the map - Default to blank
     * @param  doZipFile - Indicate if we do a zip with the file
     * @return Image file of the map with extension format given as parameter
     */
    /**
     * Download an image of the map with addition of informations
     * @param {?} map - Map of the app
     * @param {?} resolution
     * @param {?=} format - Image format. default value to "png"
     * @param {?=} projection - Indicate if projection need to be add. Default to false
     * @param {?=} scale - Indicate if scale need to be add. Default to false
     * @param {?=} legend - Indicate if the legend of layers need to be download. Default to false
     * @param {?=} title - Title to add for the map - Default to blank
     * @param {?=} comment - Comment to add for the map - Default to blank
     * @param {?=} doZipFile - Indicate if we do a zip with the file
     * @return {?} Image file of the map with extension format given as parameter
     */
    PrintService.prototype.downloadMapImage = /**
     * Download an image of the map with addition of informations
     * @param {?} map - Map of the app
     * @param {?} resolution
     * @param {?=} format - Image format. default value to "png"
     * @param {?=} projection - Indicate if projection need to be add. Default to false
     * @param {?=} scale - Indicate if scale need to be add. Default to false
     * @param {?=} legend - Indicate if the legend of layers need to be download. Default to false
     * @param {?=} title - Title to add for the map - Default to blank
     * @param {?=} comment - Comment to add for the map - Default to blank
     * @param {?=} doZipFile - Indicate if we do a zip with the file
     * @return {?} Image file of the map with extension format given as parameter
     */
    function (map$$1, resolution, format, projection, scale, legend, title, comment, doZipFile) {
        var _this = this;
        if (format === void 0) { format = 'png'; }
        if (projection === void 0) { projection = false; }
        if (scale === void 0) { scale = false; }
        if (legend === void 0) { legend = false; }
        if (title === void 0) { title = ''; }
        if (comment === void 0) { comment = ''; }
        if (doZipFile === void 0) { doZipFile = true; }
        /** @type {?} */
        var status$ = new Subject();
        // const resolution = map.ol.getView().getResolution();
        this.activityId = this.activityService.register();
        /** @type {?} */
        var translate = this.languageService.translate;
        map$$1.ol.once('postcompose', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            format = format.toLowerCase();
            /** @type {?} */
            var context = event.context;
            /** @type {?} */
            var newCanvas = document.createElement('canvas');
            /** @type {?} */
            var newContext = newCanvas.getContext('2d');
            // Postion in height to set the canvas in new canvas
            /** @type {?} */
            var positionHCanvas = 0;
            // Position in width to set the Proj/Scale in new canvas
            /** @type {?} */
            var positionWProjScale = 10;
            // Get height/width of map canvas
            /** @type {?} */
            var width = context.canvas.width;
            /** @type {?} */
            var height = context.canvas.height;
            // Set Font to calculate comment width
            newContext.font = '20px Calibri';
            /** @type {?} */
            var commentWidth = newContext.measureText(comment).width;
            // Add height for title if defined
            height = title !== '' ? height + 30 : height;
            // Add height for projection or scale (same line) if defined
            height = projection !== false || scale !== false ? height + 30 : height;
            /** @type {?} */
            var positionHProjScale = height - 10;
            // Define number of line depending of the comment length
            /** @type {?} */
            var commentNbLine = Math.ceil(commentWidth / width);
            // Add height for multiline comment if defined
            height = comment !== '' ? height + commentNbLine * 30 : height;
            /** @type {?} */
            var positionHComment = height - commentNbLine * 20 + 5;
            // Set the new canvas with the new calculated size
            newCanvas.width = width;
            newCanvas.height = height;
            // Patch Jpeg default black background to white
            if (format === 'jpeg') {
                newContext.fillStyle = '#ffffff';
                newContext.fillRect(0, 0, width, height);
                newContext.fillStyle = '#000000';
            }
            // If a title need to be added to canvas
            if (title !== '') {
                // Set font for title
                newContext.font = '26px Calibri';
                positionHCanvas = 30;
                newContext.textAlign = 'center';
                newContext.fillText(title, width / 2, 20);
            }
            // Set font for next section
            newContext.font = '20px Calibri';
            // If projection need to be added to canvas
            if (projection !== false) {
                /** @type {?} */
                var projText = translate.instant('igo.geo.printForm.projection');
                newContext.textAlign = 'start';
                newContext.fillText(projText + ': ' + map$$1.projection, positionWProjScale, positionHProjScale);
                positionWProjScale += 200; // Width position change for scale position
            }
            // If scale need to be added to canvas
            if (scale !== false) {
                /** @type {?} */
                var scaleText = translate.instant('igo.geo.printForm.scale');
                /** @type {?} */
                var mapScale = map$$1.viewController.getScale(resolution);
                newContext.textAlign = 'start';
                newContext.fillText(scaleText + ': ~ 1 / ' + formatScale(mapScale), positionWProjScale, positionHProjScale);
            }
            // If a comment need to be added to canvas
            if (comment !== '') {
                newContext.textAlign = 'center';
                // If only one line, no need to multiline the comment
                if (commentNbLine === 1) {
                    newContext.fillText(comment, width / 2, positionHComment);
                }
                else {
                    // Separate the setenses to be approx. the same length
                    /** @type {?} */
                    var nbCommentChar = comment.length;
                    /** @type {?} */
                    var CommentLengthToCut = Math.floor(nbCommentChar / commentNbLine);
                    /** @type {?} */
                    var commentCurrentLine = '';
                    /** @type {?} */
                    var positionFirstCutChar = 0;
                    /** @type {?} */
                    var positionLastBlank = void 0;
                    // Loop for the number of line calculated
                    for (var i = 0; i < commentNbLine; i++) {
                        // For all line except last
                        if (commentNbLine - 1 > i) {
                            // Get comment current line to find the right place tu cut comment
                            commentCurrentLine = comment.substr(positionFirstCutChar, CommentLengthToCut);
                            // Cut the setence at blank
                            positionLastBlank = commentCurrentLine.lastIndexOf(' ');
                            newContext.fillText(commentCurrentLine.substr(0, positionLastBlank), width / 2, positionHComment);
                            positionFirstCutChar += positionLastBlank;
                            // Go to next line for insertion
                            positionHComment += 20;
                        }
                        else {
                            // Don't cut last part
                            newContext.fillText(comment.substr(positionFirstCutChar), width / 2, positionHComment);
                        }
                    }
                }
            }
            // Add map to new canvas
            newContext.drawImage(context.canvas, 0, positionHCanvas);
            /** @type {?} */
            var status = SubjectStatus.Done;
            try {
                // Save the canvas as file
                if (!doZipFile) {
                    _this.saveCanvasImageAsFile(newCanvas, 'map', format);
                }
                else if (format.toLowerCase() === 'tiff') {
                    // Add the canvas to zip
                    _this.generateCanvaFileToZip(newCanvas, 'map' + map$$1.projection.replace(':', '_') + '.' + format);
                }
                else {
                    // Add the canvas to zip
                    _this.generateCanvaFileToZip(newCanvas, 'map' + '.' + format);
                }
            }
            catch (err) {
                status = SubjectStatus.Error;
            }
            status$.next(status);
            if (format.toLowerCase() === 'tiff') {
                /** @type {?} */
                var tiwContent = _this.getWorldFileInformation(map$$1);
                /** @type {?} */
                var blob = new Blob([tiwContent], {
                    type: 'text/plain;charset=utf-8'
                });
                if (!doZipFile) {
                    // saveAs automaticly replace ':' for '_'
                    saveAs(blob, 'map' + map$$1.projection + '.tfw');
                    _this.saveFileProcessing();
                }
                else {
                    // Add the canvas to zip
                    _this.addFileToZip('map' + map$$1.projection.replace(':', '_') + '.tfw', blob);
                }
            }
        }));
        map$$1.ol.renderSync();
    };
    /**
     * @private
     * @param {?} map
     * @param {?} size
     * @param {?} extent
     * @return {?}
     */
    PrintService.prototype.renderMap = /**
     * @private
     * @param {?} map
     * @param {?} size
     * @param {?} extent
     * @return {?}
     */
    function (map$$1, size, extent) {
        map$$1.ol.renderSync();
    };
    /**
     * Save document
     * @param  doc - Document to save
     */
    /**
     * Save document
     * @protected
     * @param {?} doc - Document to save
     * @return {?}
     */
    PrintService.prototype.saveDoc = /**
     * Save document
     * @protected
     * @param {?} doc - Document to save
     * @return {?}
     */
    function (doc) {
        doc.save('map.pdf');
    };
    /**
     * Calculate the best Image size to fit in pdf
     * @param doc - Pdf Document
     * @param canvas - Canvas of image
     * @param margins - Page margins
     */
    /**
     * Calculate the best Image size to fit in pdf
     * @private
     * @param {?} doc - Pdf Document
     * @param {?} canvas - Canvas of image
     * @param {?} margins - Page margins
     * @return {?}
     */
    PrintService.prototype.getImageSizeToFitPdf = /**
     * Calculate the best Image size to fit in pdf
     * @private
     * @param {?} doc - Pdf Document
     * @param {?} canvas - Canvas of image
     * @param {?} margins - Page margins
     * @return {?}
     */
    function (doc, canvas, margins) {
        // Define variable to calculate best size to fit in one page
        /** @type {?} */
        var pageHeight = doc.internal.pageSize.getHeight() - (margins[0] + margins[2]);
        /** @type {?} */
        var pageWidth = doc.internal.pageSize.getWidth() - (margins[1] + margins[3]);
        /** @type {?} */
        var canHeight = canvas.height;
        /** @type {?} */
        var canWidth = canvas.width;
        /** @type {?} */
        var heightRatio = canHeight / pageHeight;
        /** @type {?} */
        var widthRatio = canWidth / pageWidth;
        /** @type {?} */
        var maxRatio = heightRatio > widthRatio ? heightRatio : widthRatio;
        /** @type {?} */
        var imgHeigh = maxRatio > 1 ? canHeight / maxRatio : canHeight;
        /** @type {?} */
        var imgWidth = maxRatio > 1 ? canWidth / maxRatio : canWidth;
        return [imgWidth, imgHeigh];
    };
    /**
     * Get a world file information for tiff
     * @param  map - Map of the app
     */
    /**
     * Get a world file information for tiff
     * @private
     * @param {?} map - Map of the app
     * @return {?}
     */
    PrintService.prototype.getWorldFileInformation = /**
     * Get a world file information for tiff
     * @private
     * @param {?} map - Map of the app
     * @return {?}
     */
    function (map$$1) {
        /** @type {?} */
        var currentResolution = map$$1.viewController.getResolution();
        /** @type {?} */
        var currentExtent = map$$1.viewController.getExtent();
        return [
            currentResolution,
            0,
            0,
            -currentResolution,
            currentExtent[0] + currentResolution / 0.5,
            currentExtent[3] - currentResolution / 0.5
        ].join('\n');
    };
    /**
     * Save canvas image as file
     * @param canvas - Canvas to save
     * @param name - Name of the file
     * @param format - file format
     */
    /**
     * Save canvas image as file
     * @private
     * @param {?} canvas - Canvas to save
     * @param {?} name - Name of the file
     * @param {?} format - file format
     * @return {?}
     */
    PrintService.prototype.saveCanvasImageAsFile = /**
     * Save canvas image as file
     * @private
     * @param {?} canvas - Canvas to save
     * @param {?} name - Name of the file
     * @param {?} format - file format
     * @return {?}
     */
    function (canvas, name, format) {
        /** @type {?} */
        var blobFormat = 'image/' + format;
        /** @type {?} */
        var that = this;
        try {
            canvas.toDataURL(); // Just to make the catch trigger wihtout toBlob Error throw not catched
            // If navigator is Internet Explorer
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(canvas.msToBlob(), name + '.' + format);
                this.saveFileProcessing();
            }
            else {
                canvas.toBlob((/**
                 * @param {?} blob
                 * @return {?}
                 */
                function (blob) {
                    // download image
                    saveAs(blob, name + '.' + format);
                    that.saveFileProcessing();
                }), blobFormat);
            }
        }
        catch (err) {
            this.messageService.error(this.languageService.translate.instant('igo.geo.printForm.corsErrorMessageBody'), this.languageService.translate.instant('igo.geo.printForm.corsErrorMessageHeader'), 'print');
        }
    };
    /**
     * Add file to a zip
     * @param canvas - File to add to the zip
     * @param  name -Name of the fileoverview
     */
    /**
     * Add file to a zip
     * @private
     * @param {?} canvas - File to add to the zip
     * @param {?} name -Name of the fileoverview
     * @return {?}
     */
    PrintService.prototype.generateCanvaFileToZip = /**
     * Add file to a zip
     * @private
     * @param {?} canvas - File to add to the zip
     * @param {?} name -Name of the fileoverview
     * @return {?}
     */
    function (canvas, name) {
        /** @type {?} */
        var blobFormat = 'image/' + 'jpeg';
        /** @type {?} */
        var that = this;
        if (!this.hasOwnProperty('zipFile') ||
            typeof this.zipFile === 'undefined') {
            this.zipFile = new JSZip();
        }
        try {
            canvas.toDataURL(); // Just to make the catch trigger wihtout toBlob Error throw not catched
            if (navigator.msSaveBlob) {
                this.addFileToZip(name, canvas.msToBlob());
            }
            else {
                canvas.toBlob((/**
                 * @param {?} blob
                 * @return {?}
                 */
                function (blob) {
                    that.addFileToZip(name, blob);
                }), blobFormat);
            }
        }
        catch (err) {
            this.messageService.error(this.languageService.translate.instant('igo.geo.printForm.corsErrorMessageBody'), this.languageService.translate.instant('igo.geo.printForm.corsErrorMessageHeader'), 'print');
        }
    };
    /**
     * Add file to zip, if all file are zipped, download
     * @param name - Name of the files
     * @param blob - Contain of file
     */
    /**
     * Add file to zip, if all file are zipped, download
     * @private
     * @param {?} name - Name of the files
     * @param {?} blob - Contain of file
     * @return {?}
     */
    PrintService.prototype.addFileToZip = /**
     * Add file to zip, if all file are zipped, download
     * @private
     * @param {?} name - Name of the files
     * @param {?} blob - Contain of file
     * @return {?}
     */
    function (name, blob) {
        // add file to zip
        this.zipFile.file(name, blob);
        this.nbFileToProcess--;
        // If all files are proccessed
        if (this.nbFileToProcess === 0) {
            // Download zip file
            this.getZipFile();
            // Stop loading
            this.activityService.unregister(this.activityId);
        }
    };
    /**
     * @private
     * @return {?}
     */
    PrintService.prototype.saveFileProcessing = /**
     * @private
     * @return {?}
     */
    function () {
        this.nbFileToProcess--;
        // If all files are proccessed
        if (this.nbFileToProcess === 0) {
            // Stop loading
            this.activityService.unregister(this.activityId);
        }
    };
    /**
     * Get the zipped file
     * @return Retun a zip file
     */
    /**
     * Get the zipped file
     * @private
     * @return {?} Retun a zip file
     */
    PrintService.prototype.getZipFile = /**
     * Get the zipped file
     * @private
     * @return {?} Retun a zip file
     */
    function () {
        /** @type {?} */
        var that = this;
        this.zipFile.generateAsync({ type: 'blob' }).then((/**
         * @param {?} blob
         * @return {?}
         */
        function (blob) {
            // 1) generate the zip file
            saveAs(blob, 'map.zip');
            delete that.zipFile;
        }));
    };
    PrintService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    PrintService.ctorParameters = function () { return [
        { type: MessageService },
        { type: ActivityService },
        { type: LanguageService }
    ]; };
    /** @nocollapse */ PrintService.ngInjectableDef = defineInjectable({ factory: function PrintService_Factory() { return new PrintService(inject(MessageService), inject(ActivityService), inject(LanguageService)); }, token: PrintService, providedIn: "root" });
    return PrintService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var PrintComponent = /** @class */ (function () {
    function PrintComponent(printService) {
        this.printService = printService;
        this.disabled = false;
    }
    Object.defineProperty(PrintComponent.prototype, "map", {
        get: /**
         * @return {?}
         */
        function () {
            return this._map;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._map = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrintComponent.prototype, "outputFormat", {
        get: /**
         * @return {?}
         */
        function () {
            return this._outputFormat;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._outputFormat = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrintComponent.prototype, "paperFormat", {
        get: /**
         * @return {?}
         */
        function () {
            return this._paperFormat;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._paperFormat = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrintComponent.prototype, "orientation", {
        get: /**
         * @return {?}
         */
        function () {
            return this._orientation;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._orientation = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrintComponent.prototype, "imageFormat", {
        get: /**
         * @return {?}
         */
        function () {
            return this._imageFormat;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._imageFormat = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrintComponent.prototype, "resolution", {
        get: /**
         * @return {?}
         */
        function () {
            return this._resolution;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._resolution = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} data
     * @return {?}
     */
    PrintComponent.prototype.handleFormSubmit = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        this.disabled = true;
        if (data.isPrintService === true) {
            this.printService
                .print(this.map, data)
                .subscribe();
        }
        else {
            /** @type {?} */
            var nbFileToProcess = 1;
            if (data.showLegend) {
                nbFileToProcess++;
            }
            if (data.imageFormat.toLowerCase() === 'tiff') {
                nbFileToProcess++;
            }
            this.printService.defineNbFileToProcess(nbFileToProcess);
            /** @type {?} */
            var resolution = +data.resolution;
            this.printService.downloadMapImage(this.map, resolution, data.imageFormat, data.showProjection, data.showScale, data.showLegend, data.title, data.comment, data.doZipFile);
            if (data.showLegend) {
                this.printService.getLayersLegendImage(this.map, data.imageFormat, data.doZipFile, +resolution);
            }
        }
        this.disabled = false;
    };
    PrintComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igo-print',
                    template: "<igo-print-form\r\n  [outputFormat]=\"outputFormat\"\r\n  [paperFormat]=\"paperFormat\"\r\n  [orientation]=\"orientation\"\r\n  [imageFormat]=\"imageFormat\"\r\n  [resolution]=\"resolution\"\r\n  [disabled]=\"disabled\"\r\n  (submit)=\"handleFormSubmit($event)\">\r\n</igo-print-form>\r\n"
                }] }
    ];
    /** @nocollapse */
    PrintComponent.ctorParameters = function () { return [
        { type: PrintService }
    ]; };
    PrintComponent.propDecorators = {
        map: [{ type: Input }],
        outputFormat: [{ type: Input }],
        paperFormat: [{ type: Input }],
        orientation: [{ type: Input }],
        imageFormat: [{ type: Input }],
        resolution: [{ type: Input }]
    };
    return PrintComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var PrintFormComponent = /** @class */ (function () {
    function PrintFormComponent(formBuilder) {
        this.formBuilder = formBuilder;
        this.outputFormats = PrintOutputFormat;
        this.paperFormats = PrintPaperFormat;
        this.orientations = PrintOrientation;
        this.resolutions = PrintResolution;
        this.imageFormats = PrintSaveImageFormat;
        this.isPrintService = true;
        this._disabled = false;
        this.submit = new EventEmitter();
        this.form = this.formBuilder.group({
            title: ['', []],
            comment: ['', []],
            outputFormat: ['', [Validators.required]],
            paperFormat: ['', [Validators.required]],
            imageFormat: ['', [Validators.required]],
            resolution: ['', [Validators.required]],
            orientation: ['', [Validators.required]],
            showProjection: false,
            showScale: false,
            showLegend: false,
            doZipFile: [{ hidden: this.isPrintService }]
        });
    }
    Object.defineProperty(PrintFormComponent.prototype, "disabled", {
        get: /**
         * @return {?}
         */
        function () {
            return this._disabled;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._disabled = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrintFormComponent.prototype, "imageFormat", {
        get: /**
         * @return {?}
         */
        function () {
            return this.imageFormatField.value;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.imageFormatField.setValue(value || PrintSaveImageFormat.Jpeg, {
                onlySelf: true
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrintFormComponent.prototype, "outputFormat", {
        get: /**
         * @return {?}
         */
        function () {
            return this.outputFormatField.value;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.outputFormatField.setValue(value || PrintOutputFormat.Pdf, {
                onlySelf: true
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrintFormComponent.prototype, "paperFormat", {
        get: /**
         * @return {?}
         */
        function () {
            return this.paperFormatField.value;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.paperFormatField.setValue(value || PrintPaperFormat.Letter, {
                onlySelf: true
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrintFormComponent.prototype, "orientation", {
        get: /**
         * @return {?}
         */
        function () {
            return this.orientationField.value;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.orientationField.setValue(value || PrintOrientation.landscape, {
                onlySelf: true
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrintFormComponent.prototype, "resolution", {
        get: /**
         * @return {?}
         */
        function () {
            return this.resolutionField.value;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.resolutionField.setValue(value || PrintResolution['96'], {
                onlySelf: true
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrintFormComponent.prototype, "title", {
        get: /**
         * @return {?}
         */
        function () {
            return this.titleField.value;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.titleField.setValue(value, { onlySelf: true });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrintFormComponent.prototype, "comment", {
        get: /**
         * @return {?}
         */
        function () {
            return this.commentField.value;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.commentField.setValue(value, { onlySelf: true });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrintFormComponent.prototype, "showProjection", {
        get: /**
         * @return {?}
         */
        function () {
            return this.showProjectionField.value;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.showProjectionField.setValue(value, { onlySelf: true });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrintFormComponent.prototype, "showScale", {
        get: /**
         * @return {?}
         */
        function () {
            return this.showScaleField.value;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.showScaleField.setValue(value, { onlySelf: true });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrintFormComponent.prototype, "showLegend", {
        get: /**
         * @return {?}
         */
        function () {
            return this.showLegendField.value;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.showLegendField.setValue(value, { onlySelf: true });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrintFormComponent.prototype, "doZipFile", {
        get: /**
         * @return {?}
         */
        function () {
            return this.doZipFileField.value;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.doZipFileField.setValue(value, { onlySelf: true });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrintFormComponent.prototype, "outputFormatField", {
        get: /**
         * @return {?}
         */
        function () {
            return (/** @type {?} */ (((/** @type {?} */ (this.form.controls))).outputFormat));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrintFormComponent.prototype, "paperFormatField", {
        get: /**
         * @return {?}
         */
        function () {
            return (/** @type {?} */ (((/** @type {?} */ (this.form.controls))).paperFormat));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrintFormComponent.prototype, "imageFormatField", {
        get: /**
         * @return {?}
         */
        function () {
            return (/** @type {?} */ (((/** @type {?} */ (this.form.controls))).imageFormat));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrintFormComponent.prototype, "orientationField", {
        get: /**
         * @return {?}
         */
        function () {
            return (/** @type {?} */ (((/** @type {?} */ (this.form.controls))).orientation));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrintFormComponent.prototype, "resolutionField", {
        get: /**
         * @return {?}
         */
        function () {
            return (/** @type {?} */ (((/** @type {?} */ (this.form.controls))).resolution));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrintFormComponent.prototype, "commentField", {
        get: /**
         * @return {?}
         */
        function () {
            return (/** @type {?} */ (((/** @type {?} */ (this.form.controls))).comment));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrintFormComponent.prototype, "showProjectionField", {
        get: /**
         * @return {?}
         */
        function () {
            return (/** @type {?} */ (((/** @type {?} */ (this.form.controls))).showProjection));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrintFormComponent.prototype, "showScaleField", {
        get: /**
         * @return {?}
         */
        function () {
            return (/** @type {?} */ (((/** @type {?} */ (this.form.controls))).showScale));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrintFormComponent.prototype, "showLegendField", {
        get: /**
         * @return {?}
         */
        function () {
            return (/** @type {?} */ (((/** @type {?} */ (this.form.controls))).showLegend));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrintFormComponent.prototype, "doZipFileField", {
        get: /**
         * @return {?}
         */
        function () {
            return (/** @type {?} */ (((/** @type {?} */ (this.form.controls))).doZipFile));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrintFormComponent.prototype, "titleField", {
        get: /**
         * @return {?}
         */
        function () {
            return (/** @type {?} */ (((/** @type {?} */ (this.form.controls))).title));
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    PrintFormComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.doZipFileField.setValue(false);
    };
    /**
     * @param {?} data
     * @param {?} isValid
     * @return {?}
     */
    PrintFormComponent.prototype.handleFormSubmit = /**
     * @param {?} data
     * @param {?} isValid
     * @return {?}
     */
    function (data, isValid) {
        this.submitted = true;
        data.isPrintService = this.isPrintService;
        if (isValid) {
            this.submit.emit(data);
        }
    };
    /**
     * @return {?}
     */
    PrintFormComponent.prototype.toggleImageSaveProp = /**
     * @return {?}
     */
    function () {
        if (this.outputFormatField.value === 'Image') {
            this.isPrintService = false;
        }
        else {
            this.isPrintService = true;
        }
    };
    PrintFormComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igo-print-form',
                    template: "<form class=\"igo-form\" [formGroup]=\"form\">\r\n  <div class=\"igo-input-container\">\r\n    <mat-form-field>\r\n      <input\r\n        matInput\r\n        formControlName=\"title\"\r\n        placeholder=\"{{'igo.geo.printForm.title' | translate}}\">\r\n    </mat-form-field>\r\n  </div>\r\n\r\n  <div class=\"igo-input-container\">\r\n    <mat-form-field>\r\n      <input\r\n        matInput\r\n        formControlName=\"comment\"\r\n        placeholder=\"{{'igo.geo.printForm.comment' | translate}}\">\r\n    </mat-form-field>\r\n  </div>\r\n\r\n  <div class=\"igo-input-container\">\r\n    <div class=\"print-slide-toggle-container mat-typography\">\r\n      <mat-slide-toggle\r\n        class=\"print-option\"\r\n        formControlName=\"showProjection\"\r\n        [labelPosition]=\"'before'\">\r\n        {{'igo.geo.printForm.showProjection' | translate}}\r\n      </mat-slide-toggle>\r\n      <mat-slide-toggle\r\n        class=\"print-option\"\r\n        formControlName=\"showScale\"\r\n        [labelPosition]=\"'before'\">\r\n        {{'igo.geo.printForm.showScale' | translate}}\r\n      </mat-slide-toggle>\r\n      <mat-slide-toggle\r\n        class=\"print-option\"\r\n        formControlName=\"showLegend\"\r\n        [labelPosition]=\"'before'\">\r\n        {{'igo.geo.printForm.showLegend' | translate}}\r\n      </mat-slide-toggle>\r\n      <mat-slide-toggle\r\n        class=\"print-option\"\r\n        formControlName=\"doZipFile\"\r\n        [labelPosition]=\"'before'\"\r\n        [style.display]=\"isPrintService ? 'none' : ''\">\r\n        {{'igo.geo.printForm.doZipFile' | translate}}\r\n      </mat-slide-toggle>\r\n    </div>\r\n  </div>\r\n\r\n  <div class=\"igo-input-container\">\r\n    <mat-form-field>\r\n      <mat-select (selectionChange)=\"toggleImageSaveProp()\"\r\n        formControlName=\"outputFormat\"\r\n        placeholder=\"{{'igo.geo.printForm.outputFormat' | translate}}\">\r\n        <mat-option *ngFor=\"let outputFormat of outputFormats | keyvalue \" [value]=\"outputFormat.key\">\r\n            {{outputFormat.value}}\r\n        </mat-option>\r\n      </mat-select>\r\n    </mat-form-field>\r\n  </div>\r\n\r\n  <div class=\"igo-input-container\" [style.display]=\"isPrintService ? 'block' : 'none'\">\r\n    <mat-form-field>\r\n      <mat-select\r\n        formControlName=\"paperFormat\"\r\n        placeholder=\"{{'igo.geo.printForm.paperFormat' | translate}}\">\r\n        <mat-option *ngFor=\"let paperFormat of paperFormats | keyvalue \" [value]=\"paperFormat.key\">\r\n          {{('igo.geo.printForm.paperFormats.' + paperFormat.value) | translate}}\r\n        </mat-option>\r\n      </mat-select>\r\n    </mat-form-field>\r\n  </div>\r\n\r\n  <div class=\"igo-input-container\" [style.display]=\"isPrintService ? 'none' : 'block'\">\r\n    <mat-form-field>\r\n      <mat-select\r\n        formControlName=\"imageFormat\"\r\n        placeholder=\"{{'igo.geo.printForm.imageFormat' | translate}}\">\r\n        <mat-option *ngFor=\"let imageFormat of imageFormats | keyvalue \" [value]=\"imageFormat.key\">\r\n          {{imageFormat.value}}\r\n        </mat-option>\r\n      </mat-select>\r\n    </mat-form-field>\r\n  </div>\r\n\r\n  <div class=\"igo-input-container\" style=\"display: none;\">\r\n    <mat-form-field>\r\n      <mat-select\r\n        formControlName=\"resolution\"\r\n        placeholder=\"{{'igo.geo.printForm.resolution' | translate}}\">\r\n        <mat-option *ngFor=\"let resolution of resolutions | keyvalue \" [value]=\"resolution.key\">\r\n          {{resolution.value + ' PPI'}}\r\n        </mat-option>\r\n      </mat-select>\r\n    </mat-form-field>\r\n  </div>\r\n\r\n  <div class=\"igo-input-container\" [style.display]=\"isPrintService ? 'block' : 'none'\">\r\n    <mat-form-field>\r\n      <mat-select\r\n        formControlName=\"orientation\"\r\n        placeholder=\"{{'igo.geo.printForm.orientation' | translate}}\">\r\n        <mat-option *ngFor=\"let orientation of orientations | keyvalue \" [value]=\"orientation.key\">\r\n          {{('igo.geo.printForm.' + orientation.value) | translate}}\r\n        </mat-option>\r\n      </mat-select>\r\n    </mat-form-field>\r\n  </div>\r\n\r\n  <div class=\"igo-form-button-group print-button-top-padding\">\r\n    <button\r\n      mat-raised-button\r\n      type=\"button\"\r\n      [disabled]=\"!form.valid || disabled\"\r\n      (click)=\"handleFormSubmit(form.value, form.valid)\">\r\n      {{'igo.geo.printForm.saveBtn' | translate}}\r\n    </button>\r\n  </div>\r\n\r\n</form>\r\n",
                    styles: ["mat-form-field{width:100%}.print-slide-toggle-container{overflow-x:hidden}.print-slide-toggle-container mat-slide-toggle{width:100%;margin:10px}.print-slide-toggle-container mat-slide-toggle ::ng-deep .mat-slide-toggle-content{width:calc(100% - 60px)}.print-option{display:block;margin-right:10px;margin-bottom:15px}.print-button-top-padding{padding-top:25px}.igo-form{padding:10px 5px 5px}.igo-form-button-group{text-align:center}"]
                }] }
    ];
    /** @nocollapse */
    PrintFormComponent.ctorParameters = function () { return [
        { type: FormBuilder }
    ]; };
    PrintFormComponent.propDecorators = {
        disabled: [{ type: Input }],
        imageFormat: [{ type: Input }],
        outputFormat: [{ type: Input }],
        paperFormat: [{ type: Input }],
        orientation: [{ type: Input }],
        resolution: [{ type: Input }],
        title: [{ type: Input }],
        comment: [{ type: Input }],
        showProjection: [{ type: Input }],
        showScale: [{ type: Input }],
        showLegend: [{ type: Input }],
        doZipFile: [{ type: Input }],
        submit: [{ type: Output }]
    };
    return PrintFormComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgoPrintModule = /** @class */ (function () {
    function IgoPrintModule() {
    }
    IgoPrintModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        FormsModule,
                        ReactiveFormsModule,
                        MatIconModule,
                        MatButtonModule,
                        MatSelectModule,
                        MatOptionModule,
                        MatInputModule,
                        MatFormFieldModule,
                        MatSlideToggleModule,
                        IgoLanguageModule,
                        IgoKeyValueModule
                    ],
                    exports: [PrintComponent, PrintFormComponent],
                    declarations: [PrintComponent, PrintFormComponent]
                },] }
    ];
    return IgoPrintModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Map search source factory
 * @ignore
 * @param {?} config
 * @return {?}
 */
function querySearchSourceFactory(config) {
    return new QuerySearchSource(config.getConfig("searchSources." + QuerySearchSource.id) || {});
}
/**
 * Function that returns a provider for the map search source
 * @return {?}
 */
function provideQuerySearchSource() {
    return {
        provide: SearchSource,
        useFactory: querySearchSourceFactory,
        multi: true,
        deps: [ConfigService]
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgoQueryModule = /** @class */ (function () {
    function IgoQueryModule() {
    }
    /**
     * @return {?}
     */
    IgoQueryModule.forRoot = /**
     * @return {?}
     */
    function () {
        return {
            ngModule: IgoQueryModule,
            providers: [provideQuerySearchSource()]
        };
    };
    IgoQueryModule.decorators = [
        { type: NgModule, args: [{
                    imports: [CommonModule],
                    exports: [QueryDirective],
                    declarations: [QueryDirective],
                    providers: [QueryService]
                },] }
    ];
    return IgoQueryModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Service where all available search sources are registered.
 */
var  /**
 * Service where all available search sources are registered.
 */
SearchSourceService = /** @class */ (function () {
    function SearchSourceService(sources) {
        this.sources = sources;
    }
    /**
     * Return available search sources
     * @returns Search sources
     */
    /**
     * Return available search sources
     * @return {?} Search sources
     */
    SearchSourceService.prototype.getSources = /**
     * Return available search sources
     * @return {?} Search sources
     */
    function () {
        return this.sources;
    };
    /**
     * Return enabled search sources
     * @returns Search sources
     */
    /**
     * Return enabled search sources
     * @return {?} Search sources
     */
    SearchSourceService.prototype.getEnabledSources = /**
     * Return enabled search sources
     * @return {?} Search sources
     */
    function () {
        return this.getSources().filter((/**
         * @param {?} source
         * @return {?}
         */
        function (source) { return source.enabled === true; }));
    };
    /**
     * Enable search sources of given type
     * @param type Search type
     * @todo It would be better to track the enabled search sources
     *  without updating their 'enabled' property.
     */
    /**
     * Enable search sources of given type
     * \@todo It would be better to track the enabled search sources
     *  without updating their 'enabled' property.
     * @param {?} type Search type
     * @return {?}
     */
    SearchSourceService.prototype.enableSourcesByType = /**
     * Enable search sources of given type
     * \@todo It would be better to track the enabled search sources
     *  without updating their 'enabled' property.
     * @param {?} type Search type
     * @return {?}
     */
    function (type) {
        this.getSources().forEach((/**
         * @param {?} source
         * @return {?}
         */
        function (source) {
            if (((/** @type {?} */ (source.constructor))).type === type) {
                source.enabled = true;
            }
            else {
                source.enabled = false;
            }
        }));
    };
    /**
     * Set Param from the selected settings
     * @param source search-source
     * @param setting settings
     */
    /**
     * Set Param from the selected settings
     * @param {?} source search-source
     * @param {?} setting settings
     * @return {?}
     */
    SearchSourceService.prototype.setParamFromSetting = /**
     * Set Param from the selected settings
     * @param {?} source search-source
     * @param {?} setting settings
     * @return {?}
     */
    function (source, setting) {
        source.setParamFromSetting(setting);
    };
    return SearchSourceService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Function that checks whether a search source implements TextSearch
 * @param {?} source Search source
 * @return {?} True if the search source implements TextSearch
 */
function sourceCanSearch(source) {
    return ((/** @type {?} */ (source))).search !== undefined;
}
/**
 * Function that checks whether a search source implements ReverseSearch
 * @param {?} source Search source
 * @return {?} True if the search source implements ReverseSearch
 */
function sourceCanReverseSearch(source) {
    return ((/** @type {?} */ (source))).reverseSearch !== undefined;
}
/**
 * Function that checks whether a search source implements ReverseSearch AND is shown in the pointer summary
 * @param {?} source Search source
 * @return {?} True if the search source implements ReverseSearch AND is shown in the pointer summary
 */
function sourceCanReverseSearchAsSummary(source) {
    return ((/** @type {?} */ (source))).reverseSearch !== undefined && source.showInPointerSummary === true;
}
/**
 * Return a search result out of an Feature. This is used to adapt
 * the IGO query module to the new Feature/SearchResult interfaces
 * @param {?} feature feature
 * @param {?} source Search source
 * @return {?} SearchResult
 */
function featureToSearchResult(feature, source) {
    feature.sourceId = source.getId();
    return {
        source: source,
        data: feature,
        meta: {
            dataType: FEATURE,
            id: (/** @type {?} */ (feature.meta.id)),
            title: feature.meta.title,
            icon: feature.meta.icon || 'map-marker'
        }
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * This service perform researches in all the search sources enabled.
 * It returns Research objects who's 'request' property needs to be
 * subscribed to in order to trigger the research. This services has
 * keeps internal state of the researches it performed
 * and the results they yielded.
 */
var SearchService = /** @class */ (function () {
    function SearchService(searchSourceService, mapService) {
        this.searchSourceService = searchSourceService;
        this.mapService = mapService;
    }
    /**
     * Perform a research by text
     * @param term Any text
     * @returns Researches
     */
    /**
     * Perform a research by text
     * @param {?} term Any text
     * @param {?=} options
     * @return {?} Researches
     */
    SearchService.prototype.search = /**
     * Perform a research by text
     * @param {?} term Any text
     * @param {?=} options
     * @return {?} Researches
     */
    function (term, options) {
        if (options === void 0) { options = {}; }
        if (!this.termIsValid(term)) {
            return [];
        }
        /** @type {?} */
        var response = stringToLonLat(term, this.mapService.getMap().projection, {
            forceNA: options.forceNA
        });
        if (response.lonLat) {
            return this.reverseSearch(response.lonLat, { distance: response.radius });
        }
        else if (response.message) {
            console.log(response.message);
        }
        options.extent = this.mapService
            .getMap()
            .viewController.getExtent('EPSG:4326');
        /** @type {?} */
        var sources;
        if (options.getEnabledOnly || options.getEnabledOnly === undefined) {
            sources = this.searchSourceService.getEnabledSources();
        }
        else {
            sources = this.searchSourceService.getSources();
        }
        if (options.sourceId) {
            sources = sources.filter((/**
             * @param {?} source
             * @return {?}
             */
            function (source) { return source.getId() === options.sourceId; }));
        }
        else if (options.searchType) {
            sources = sources.filter((/**
             * @param {?} source
             * @return {?}
             */
            function (source) { return source.getType() === options.searchType; }));
        }
        sources = sources.filter(sourceCanSearch);
        return this.searchSources(sources, term, options);
    };
    /**
     * Perform a research by lon/lat
     * @param lonLat Any lon/lat coordinates
     * @returns Researches
     */
    /**
     * Perform a research by lon/lat
     * @param {?} lonLat Any lon/lat coordinates
     * @param {?=} options
     * @param {?=} asPointerSummary
     * @return {?} Researches
     */
    SearchService.prototype.reverseSearch = /**
     * Perform a research by lon/lat
     * @param {?} lonLat Any lon/lat coordinates
     * @param {?=} options
     * @param {?=} asPointerSummary
     * @return {?} Researches
     */
    function (lonLat, options, asPointerSummary) {
        if (asPointerSummary === void 0) { asPointerSummary = false; }
        /** @type {?} */
        var reverseSourceFonction = asPointerSummary
            ? sourceCanReverseSearchAsSummary
            : sourceCanReverseSearch;
        /** @type {?} */
        var sources = this.searchSourceService
            .getEnabledSources()
            .filter(reverseSourceFonction);
        return this.reverseSearchSources(sources, lonLat, options || {});
    };
    /**
     * Create a text research out of all given search sources
     * @param sources Search sources that implement TextSearch
     * @param term Search term
     * @returns Observable of Researches
     */
    /**
     * Create a text research out of all given search sources
     * @private
     * @param {?} sources Search sources that implement TextSearch
     * @param {?} term Search term
     * @param {?} options
     * @return {?} Observable of Researches
     */
    SearchService.prototype.searchSources = /**
     * Create a text research out of all given search sources
     * @private
     * @param {?} sources Search sources that implement TextSearch
     * @param {?} term Search term
     * @param {?} options
     * @return {?} Observable of Researches
     */
    function (sources, term, options) {
        return sources.map((/**
         * @param {?} source
         * @return {?}
         */
        function (source) {
            return {
                request: ((/** @type {?} */ (((/** @type {?} */ (source)))))).search(term, options),
                reverse: false,
                source: source
            };
        }));
    };
    /**
     * Create a reverse research out of all given search sources
     * @param sources Search sources that implement ReverseSearch
     * @param lonLat Any lon/lat coordinates
     * @returns Observable of Researches
     */
    /**
     * Create a reverse research out of all given search sources
     * @private
     * @param {?} sources Search sources that implement ReverseSearch
     * @param {?} lonLat Any lon/lat coordinates
     * @param {?} options
     * @return {?} Observable of Researches
     */
    SearchService.prototype.reverseSearchSources = /**
     * Create a reverse research out of all given search sources
     * @private
     * @param {?} sources Search sources that implement ReverseSearch
     * @param {?} lonLat Any lon/lat coordinates
     * @param {?} options
     * @return {?} Observable of Researches
     */
    function (sources, lonLat, options) {
        return sources.map((/**
         * @param {?} source
         * @return {?}
         */
        function (source) {
            return {
                request: ((/** @type {?} */ (((/** @type {?} */ (source)))))).reverseSearch(lonLat, options),
                reverse: true,
                source: source
            };
        }));
    };
    /**
     * Validate that a search term is valid
     * @param term Search term
     * @returns True if the search term is valid
     */
    /**
     * Validate that a search term is valid
     * @private
     * @param {?} term Search term
     * @return {?} True if the search term is valid
     */
    SearchService.prototype.termIsValid = /**
     * Validate that a search term is valid
     * @private
     * @param {?} term Search term
     * @return {?} True if the search term is valid
     */
    function (term) {
        return typeof term === 'string' && term !== '';
    };
    SearchService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    SearchService.ctorParameters = function () { return [
        { type: SearchSourceService },
        { type: MapService }
    ]; };
    /** @nocollapse */ SearchService.ngInjectableDef = defineInjectable({ factory: function SearchService_Factory() { return new SearchService(inject(SearchSourceService), inject(MapService)); }, token: SearchService, providedIn: "root" });
    return SearchService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
var  /**
 * @abstract
 */
DirectionsSource = /** @class */ (function () {
    function DirectionsSource() {
    }
    return DirectionsSource;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var DirectionsSourceService = /** @class */ (function () {
    function DirectionsSourceService(sources) {
        this.sources = sources;
    }
    return DirectionsSourceService;
}());
/**
 * @param {?} sources
 * @return {?}
 */
function directionsSourceServiceFactory(sources) {
    return new DirectionsSourceService(sources);
}
/**
 * @return {?}
 */
function provideDirectionsSourceService() {
    return {
        provide: DirectionsSourceService,
        useFactory: directionsSourceServiceFactory,
        deps: [DirectionsSource]
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var DirectionsService = /** @class */ (function () {
    function DirectionsService(directionsSourceService) {
        this.directionsSourceService = directionsSourceService;
    }
    /**
     * @param {?} coordinates
     * @param {?=} directionsOptions
     * @return {?}
     */
    DirectionsService.prototype.route = /**
     * @param {?} coordinates
     * @param {?=} directionsOptions
     * @return {?}
     */
    function (coordinates, directionsOptions) {
        var _this = this;
        if (directionsOptions === void 0) { directionsOptions = {}; }
        if (coordinates.length === 0) {
            return;
        }
        return this.directionsSourceService.sources
            .filter((/**
         * @param {?} source
         * @return {?}
         */
        function (source) { return source.enabled; }))
            .map((/**
         * @param {?} source
         * @return {?}
         */
        function (source) { return _this.routeSource(source, coordinates, directionsOptions); }));
    };
    /**
     * @param {?} source
     * @param {?} coordinates
     * @param {?=} directionsOptions
     * @return {?}
     */
    DirectionsService.prototype.routeSource = /**
     * @param {?} source
     * @param {?} coordinates
     * @param {?=} directionsOptions
     * @return {?}
     */
    function (source, coordinates, directionsOptions) {
        if (directionsOptions === void 0) { directionsOptions = {}; }
        /** @type {?} */
        var request = source.route(coordinates, directionsOptions);
        return request;
    };
    DirectionsService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    DirectionsService.ctorParameters = function () { return [
        { type: DirectionsSourceService }
    ]; };
    /** @nocollapse */ DirectionsService.ngInjectableDef = defineInjectable({ factory: function DirectionsService_Factory() { return new DirectionsService(inject(DirectionsSourceService)); }, token: DirectionsService, providedIn: "root" });
    return DirectionsService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var DirectionsFormService = /** @class */ (function () {
    function DirectionsFormService() {
    }
    /**
     * @return {?}
     */
    DirectionsFormService.prototype.getStopsCoordinates = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var stopsCoordinates = [];
        if (this.stops) {
            this.stops.forEach((/**
             * @param {?} stop
             * @return {?}
             */
            function (stop) {
                stopsCoordinates.push(stop.stopCoordinates);
            }));
        }
        return stopsCoordinates;
    };
    /**
     * @param {?} stops
     * @return {?}
     */
    DirectionsFormService.prototype.setStops = /**
     * @param {?} stops
     * @return {?}
     */
    function (stops) {
        this.stops = stops;
    };
    /**
     * @return {?}
     */
    DirectionsFormService.prototype.getStops = /**
     * @return {?}
     */
    function () {
        return this.stops;
    };
    DirectionsFormService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    DirectionsFormService.ctorParameters = function () { return []; };
    return DirectionsFormService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var DirectionsFormComponent = /** @class */ (function () {
    function DirectionsFormComponent(formBuilder, directionsService, languageService, messageService, searchService, queryService, directionsFormService, changeDetectorRefs, route) {
        this.formBuilder = formBuilder;
        this.directionsService = directionsService;
        this.languageService = languageService;
        this.messageService = messageService;
        this.searchService = searchService;
        this.queryService = queryService;
        this.directionsFormService = directionsFormService;
        this.changeDetectorRefs = changeDetectorRefs;
        this.route = route;
        this.invalidKeys = ['Control', 'Shift', 'Alt'];
        this.projection = 'EPSG:4326';
        this.routesQueries$$ = [];
        this.stream$ = new Subject();
        this.focusOnStop = false;
        this.focusKey = [];
        this.debounce = 200;
        this.length = 2;
        this.submit = new EventEmitter();
    }
    /**
     * @return {?}
     */
    DirectionsFormComponent.prototype.changeRoute = /**
     * @return {?}
     */
    function () {
        this.showRouteGeometry();
    };
    /**
     * @param {?} event
     * @return {?}
     */
    DirectionsFormComponent.prototype.prevent = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
    };
    /**
     * @return {?}
     */
    DirectionsFormComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.queryService.queryEnabled = false;
        this.focusOnStop = false;
        this.browserLanguage = this.languageService.getLanguage();
        this.stopsForm = this.formBuilder.group({
            directionsType: 'car',
            directionsMode: 'driving',
            // loop
            stopOrderPriority: true,
            directionsFixedStartEnd: false,
            stops: this.formBuilder.array([
                this.createStop('start'),
                this.createStop('end')
            ])
        });
        setTimeout((/**
         * @return {?}
         */
        function () {
            _this.initStores();
            _this.initOlInteraction();
        }), 1);
        this.subscribeToFormChange();
        this.routesQueries$$.push(this.stream$
            .pipe(debounceTime(this.debounce), distinctUntilChanged())
            .subscribe((/**
         * @param {?} term
         * @return {?}
         */
        function (term) { return _this.handleTermChanged(term); })));
    };
    /**
     * @return {?}
     */
    DirectionsFormComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.unsubscribeRoutesQueries();
        this.unlistenSingleClick();
        this.queryService.queryEnabled = true;
        this.freezeStores();
        this.writeStopsToFormService();
    };
    /**
     * @private
     * @return {?}
     */
    DirectionsFormComponent.prototype.initStores = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var loadingStrategy = new FeatureStoreLoadingStrategy({ motion: FeatureMotion.None });
        // STOP STORE
        /** @type {?} */
        var stopsStore = this.stopsStore;
        /** @type {?} */
        var stopsLayer = new VectorLayer({
            title: 'Directions - stops',
            zIndex: 911,
            source: new FeatureDataSource(),
            showInLayerList: false,
            exportable: false,
            browsable: false,
            style: stopMarker
        });
        tryBindStoreLayer(stopsStore, stopsLayer);
        tryAddLoadingStrategy(stopsStore, loadingStrategy);
        // ROUTE AND VERTEX STORE
        /** @type {?} */
        var routeStore = this.routeStore;
        /** @type {?} */
        var routeLayer = new VectorLayer({
            title: 'Directions - route and vertex',
            zIndex: 910,
            source: new FeatureDataSource(),
            showInLayerList: false,
            exportable: false,
            browsable: false,
            style: stopMarker
        });
        tryBindStoreLayer(routeStore, routeLayer);
        tryAddLoadingStrategy(routeStore, loadingStrategy);
    };
    /**
     * @private
     * @return {?}
     */
    DirectionsFormComponent.prototype.initOlInteraction = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var selectedStopFeature;
        /** @type {?} */
        var selectStop = new Select({
            layers: [this.stopsStore.layer.ol],
            condition: pointerMove,
            hitTolerance: 7,
            filter: (/**
             * @param {?} feature
             * @return {?}
             */
            function (feature) {
                return feature.get('type') === 'stop';
            })
        });
        selectStop.on('select', (/**
         * @param {?} evt
         * @return {?}
         */
        function (evt) {
            selectedStopFeature = evt.target.getFeatures()[0];
        }));
        /** @type {?} */
        var translateStop = new Translate({
            layers: [this.stopsStore.layer.ol],
            features: selectedStopFeature
            // TODO In Openlayers >= 6.x, filter is now allowed.
        });
        translateStop.on('translating', (/**
         * @param {?} evt
         * @return {?}
         */
        function (evt) {
            /** @type {?} */
            var features = evt.features;
            if (features.getLength() === 0) {
                return;
            }
            _this.executeTranslation(features, false, 50, true);
        }));
        translateStop.on('translateend', (/**
         * @param {?} evt
         * @return {?}
         */
        function (evt) {
            /** @type {?} */
            var features = evt.features;
            if (features.getLength() === 0) {
                return;
            }
            _this.executeTranslation(features, true, 0, false);
        }));
        /** @type {?} */
        var selectedRoute = new Select({
            layers: [this.routeStore.layer.ol],
            condition: click,
            hitTolerance: 7,
            filter: (/**
             * @param {?} feature
             * @return {?}
             */
            function (feature) {
                return feature.getId() === 'route';
            })
        });
        selectedRoute.on('select', (/**
         * @param {?} evt
         * @return {?}
         */
        function (evt) {
            if (_this.focusOnStop === false) {
                /** @type {?} */
                var selectCoordinates = transform(((/** @type {?} */ (evt))).mapBrowserEvent.coordinate, _this.map.projection, _this.projection);
                _this.addStop();
                /** @type {?} */
                var pos = _this.stops.length - 2;
                _this.stops.at(pos).patchValue({ stopCoordinates: selectCoordinates });
                _this.handleLocationProposals(selectCoordinates, pos);
                _this.addStopOverlay(selectCoordinates, pos);
                selectedRoute.getFeatures().clear();
            }
            selectedRoute.getFeatures().clear();
        }));
        this.map.ol.addInteraction(selectStop);
        this.map.ol.addInteraction(translateStop);
        this.map.ol.addInteraction(selectedRoute);
    };
    /**
     * @private
     * @return {?}
     */
    DirectionsFormComponent.prototype.subscribeToFormChange = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this.routesQueries$$.push(this.stopsForm.valueChanges
            .pipe(debounceTime(this.debounce))
            .subscribe((/**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            _this.writeStopsToFormService();
        })));
    };
    /**
     * Freeze any store, meaning the layer is removed, strategies are deactivated
     * and some listener removed
     * @internal
     */
    /**
     * Freeze any store, meaning the layer is removed, strategies are deactivated
     * and some listener removed
     * \@internal
     * @private
     * @return {?}
     */
    DirectionsFormComponent.prototype.freezeStores = /**
     * Freeze any store, meaning the layer is removed, strategies are deactivated
     * and some listener removed
     * \@internal
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var stopsStore = this.stopsStore;
        /** @type {?} */
        var routeStore = this.routeStore;
        this.map.removeLayer(stopsStore.layer);
        this.map.removeLayer(routeStore.layer);
        stopsStore.deactivateStrategyOfType(FeatureStoreLoadingStrategy);
        routeStore.deactivateStrategyOfType(FeatureStoreLoadingStrategy);
    };
    /**
     * @private
     * @param {?} features
     * @param {?=} reverseSearchProposal
     * @param {?=} delay
     * @param {?=} overview
     * @return {?}
     */
    DirectionsFormComponent.prototype.executeTranslation = /**
     * @private
     * @param {?} features
     * @param {?=} reverseSearchProposal
     * @param {?=} delay
     * @param {?=} overview
     * @return {?}
     */
    function (features, reverseSearchProposal, delay, overview) {
        var _this = this;
        if (reverseSearchProposal === void 0) { reverseSearchProposal = false; }
        if (delay === void 0) { delay = 0; }
        if (overview === void 0) { overview = false; }
        this.routeStore.clear();
        /** @type {?} */
        var firstFeature = features.getArray()[0];
        /** @type {?} */
        var translatedID = firstFeature.getId();
        /** @type {?} */
        var translatedPos = translatedID.split('_');
        /** @type {?} */
        var p;
        switch (translatedPos[1]) {
            case 'start':
                p = 0;
                break;
            case 'end':
                p = this.stops.length - 1;
                break;
            default:
                p = Number(translatedPos[1]);
                break;
        }
        /** @type {?} */
        var translationCoordinates = transform(firstFeature.getGeometry().getCoordinates(), this.map.projection, this.projection);
        this.stops
            .at(p)
            .patchValue({ stopCoordinates: translationCoordinates, stopProposals: [] });
        if (reverseSearchProposal) {
            this.handleLocationProposals(translationCoordinates, p);
        }
        /** @type {?} */
        var directionsOptions = (/** @type {?} */ ({
            steps: true,
            overview: false,
            alternatives: true
        }));
        if (overview) {
            directionsOptions.overview = true;
            directionsOptions.steps = false;
            directionsOptions.alternatives = false;
        }
        if (delay > 0) {
            if (typeof this.lastTimeoutRequest !== 'undefined') { // cancel timeout when the mouse moves
                clearTimeout(this.lastTimeoutRequest);
            }
            this.lastTimeoutRequest = setTimeout((/**
             * @return {?}
             */
            function () {
                _this.getRoutes(undefined, directionsOptions);
            }), delay);
        }
        else {
            clearTimeout(this.lastTimeoutRequest);
            this.getRoutes(undefined, directionsOptions);
        }
    };
    /**
     * @param {?} coordinates
     * @param {?} stopIndex
     * @return {?}
     */
    DirectionsFormComponent.prototype.handleLocationProposals = /**
     * @param {?} coordinates
     * @param {?} stopIndex
     * @return {?}
     */
    function (coordinates, stopIndex) {
        var _this = this;
        /** @type {?} */
        var groupedLocations = [];
        /** @type {?} */
        var roundedCoordinates = [coordinates[0].toFixed(5), coordinates[1].toFixed(5)];
        this.stops.at(stopIndex).patchValue({ stopPoint: roundedCoordinates.join(',') });
        this.searchService
            .reverseSearch(coordinates, { zoom: this.map.viewController.getZoom() })
            .map((/**
         * @param {?} res
         * @return {?}
         */
        function (res) {
            return _this.routesQueries$$.push(res.request.pipe(map((/**
             * @param {?} f
             * @return {?}
             */
            function (f) { return f; }))).subscribe((/**
             * @param {?} results
             * @return {?}
             */
            function (results) {
                results.forEach((/**
                 * @param {?} result
                 * @return {?}
                 */
                function (result) {
                    if (groupedLocations.filter((/**
                     * @param {?} f
                     * @return {?}
                     */
                    function (f) { return f.source === result.source; }))
                        .length === 0) {
                        groupedLocations.push({
                            source: result.source,
                            results: results.map((/**
                             * @param {?} r
                             * @return {?}
                             */
                            function (r) { return r.data; }))
                        });
                    }
                }));
                _this.stops
                    .at(stopIndex)
                    .patchValue({ stopProposals: groupedLocations });
                // TODO: Prefer another source?
                if (results[0]) {
                    if (results[0].source.getId() === 'icherchereverse') {
                        // prefer address type.
                        /** @type {?} */
                        var resultPos = 0;
                        for (var i = 0; i < results.length; i++) {
                            /** @type {?} */
                            var feature = results[i].data;
                            if (feature.properties.type === 'adresses') {
                                resultPos = i;
                                break;
                            }
                        }
                        _this.stops.at(stopIndex).patchValue({
                            stopPoint: getEntityTitle(results[resultPos])
                        });
                        if (results[resultPos].data.geometry.type === 'Point') {
                            _this.stops.at(stopIndex).patchValue({
                                stopCoordinates: results[resultPos].data.geometry.coordinates
                            });
                        }
                    }
                    else if (results[0].source.getId() === 'coordinatesreverse') {
                        _this.stops.at(stopIndex).patchValue({
                            stopPoint: [
                                results[0].data.geometry.coordinates[0].toFixed(5),
                                results[0].data.geometry.coordinates[1].toFixed(5)
                            ].join(',')
                        });
                        if (results[0].data.geometry.type === 'Point') {
                            _this.stops.at(stopIndex).patchValue({
                                stopCoordinates: results[0].data.geometry.coordinates
                            });
                        }
                    }
                }
                else {
                    _this.stops.at(stopIndex).patchValue({ stopPoint: roundedCoordinates.join(','), stopProposals: [] });
                }
                _this.changeDetectorRefs.detectChanges();
            })));
        }));
    };
    /**
     * @param {?} index
     * @param {?=} stopsCounts
     * @return {?}
     */
    DirectionsFormComponent.prototype.directionsText = /**
     * @param {?} index
     * @param {?=} stopsCounts
     * @return {?}
     */
    function (index, stopsCounts) {
        if (stopsCounts === void 0) { stopsCounts = this.stops.length; }
        if (index === 0) {
            return 'start';
        }
        else if (index === stopsCounts - 1 || stopsCounts === 1) {
            return 'end';
        }
        else {
            return 'intermediate';
        }
    };
    /**
     * @param {?} index
     * @return {?}
     */
    DirectionsFormComponent.prototype.raiseStop = /**
     * @param {?} index
     * @return {?}
     */
    function (index) {
        if (index > 0) {
            this.moveStop(index, -1);
        }
    };
    /**
     * @param {?} index
     * @return {?}
     */
    DirectionsFormComponent.prototype.lowerStop = /**
     * @param {?} index
     * @return {?}
     */
    function (index) {
        if (index < this.stops.length - 1) {
            this.moveStop(index, 1);
        }
    };
    /**
     * @private
     * @param {?} index
     * @param {?} diff
     * @return {?}
     */
    DirectionsFormComponent.prototype.moveStop = /**
     * @private
     * @param {?} index
     * @param {?} diff
     * @return {?}
     */
    function (index, diff) {
        /** @type {?} */
        var fromValue = this.stops.at(index);
        this.removeStop(index);
        this.stops.insert(index + diff, fromValue);
        this.stops.at(index).patchValue({ directionsText: this.directionsText(index) });
        this.stops
            .at(index + diff)
            .patchValue({ directionsText: this.directionsText(index + diff) });
        if (this.stops.at(index).value.stopCoordinates) {
            this.addStopOverlay(this.stops.at(index).value.stopCoordinates, index);
        }
        if (this.stops.at(index + diff).value.stopCoordinates) {
            this.addStopOverlay(this.stops.at(index + diff).value.stopCoordinates, index + diff);
        }
    };
    Object.defineProperty(DirectionsFormComponent.prototype, "stops", {
        get: /**
         * @return {?}
         */
        function () {
            return (/** @type {?} */ (this.stopsForm.get('stops')));
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    DirectionsFormComponent.prototype.writeStopsToFormService = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var stops = [];
        this.stops.value.forEach((/**
         * @param {?} stop
         * @return {?}
         */
        function (stop) {
            if (stop.stopCoordinates instanceof Array) {
                stops.push(stop);
            }
        }));
        this.directionsFormService.setStops(stops);
    };
    /**
     * @return {?}
     */
    DirectionsFormComponent.prototype.addStop = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var insertIndex = this.stops.length - 1;
        this.stops.insert(insertIndex, this.createStop());
    };
    /**
     * @param {?=} directionsPos
     * @return {?}
     */
    DirectionsFormComponent.prototype.createStop = /**
     * @param {?=} directionsPos
     * @return {?}
     */
    function (directionsPos) {
        if (directionsPos === void 0) { directionsPos = 'intermediate'; }
        return this.formBuilder.group({
            stopPoint: [''],
            stopProposals: [[]],
            directionsText: directionsPos,
            stopCoordinates: ['', [Validators.required]]
        });
    };
    /**
     * @param {?} index
     * @return {?}
     */
    DirectionsFormComponent.prototype.removeStop = /**
     * @param {?} index
     * @return {?}
     */
    function (index) {
        var _this = this;
        /** @type {?} */
        var id = this.getStopOverlayID(index);
        this.deleteStoreFeatureByID(this.stopsStore, id);
        this.stops.removeAt(index);
        /** @type {?} */
        var cnt = 0;
        this.stops.value.forEach((/**
         * @param {?} stop
         * @return {?}
         */
        function (stop) {
            _this.stops.at(cnt).patchValue({ directionsText: _this.directionsText(cnt) });
            _this.addStopOverlay(_this.stops.at(cnt).value.stopCoordinates, cnt);
            cnt++;
        }));
    };
    /**
     * @return {?}
     */
    DirectionsFormComponent.prototype.resetForm = /**
     * @return {?}
     */
    function () {
        this.routesResults = undefined;
        /** @type {?} */
        var nbStops = this.stops.length;
        for (var i = 0; i < nbStops; i++) {
            this.stops.removeAt(0);
        }
        this.stops.insert(0, this.createStop('start'));
        this.stops.insert(1, this.createStop('end'));
        this.stopsStore.clear();
        this.routeStore.clear();
    };
    /**
     * @param {?} step
     * @param {?} cnt
     * @return {?}
     */
    DirectionsFormComponent.prototype.formatStep = /**
     * @param {?} step
     * @param {?} cnt
     * @return {?}
     */
    function (step, cnt) {
        return this.formatInstruction(step.maneuver.type, step.maneuver.modifier, step.name, step.maneuver.bearing_after, cnt, step.maneuver.exit, cnt === this.activeRoute.steps.length - 1);
    };
    /**
     * @param {?} type
     * @param {?} modifier
     * @param {?} route
     * @param {?} direction
     * @param {?} stepPosition
     * @param {?} exit
     * @param {?=} lastStep
     * @return {?}
     */
    DirectionsFormComponent.prototype.formatInstruction = /**
     * @param {?} type
     * @param {?} modifier
     * @param {?} route
     * @param {?} direction
     * @param {?} stepPosition
     * @param {?} exit
     * @param {?=} lastStep
     * @return {?}
     */
    function (type, modifier, route, direction, stepPosition, exit, lastStep) {
        if (lastStep === void 0) { lastStep = false; }
        /** @type {?} */
        var directiveFr;
        /** @type {?} */
        var directiveEn;
        /** @type {?} */
        var image = 'forward';
        /** @type {?} */
        var cssClass = 'rotate-270';
        /** @type {?} */
        var translatedDirection = this.translateBearing(direction);
        /** @type {?} */
        var translatedModifier = this.translateModifier(modifier);
        /** @type {?} */
        var enPrefix = modifier === 'straight' ? '' : 'on the ';
        /** @type {?} */
        var frPrefix = modifier === 'straight' ? '' : 'à ';
        /** @type {?} */
        var frAggregatedDirection = frPrefix + translatedModifier;
        /** @type {?} */
        var enAggregatedDirection = enPrefix + translatedModifier;
        if (modifier && modifier.search('slight') >= 0) {
            enAggregatedDirection = translatedModifier;
        }
        if (modifier === 'uturn') {
            image = 'forward';
            cssClass = 'rotate-90';
        }
        else if (modifier === 'sharp right') {
            image = 'subdirectory-arrow-right';
            cssClass = 'icon-flipped';
        }
        else if (modifier === 'right') {
            image = 'subdirectory-arrow-right';
            cssClass = 'icon-flipped';
        }
        else if (modifier === 'slight right') {
            image = 'forward';
            cssClass = 'rotate-290';
        }
        else if (modifier === 'straight') {
            image = 'forward';
        }
        else if (modifier === 'slight left') {
            image = 'forward';
            cssClass = 'rotate-250';
        }
        else if (modifier === 'left') {
            image = 'subdirectory-arrow-left';
            cssClass = 'icon-flipped';
        }
        else if (modifier === 'sharp left') {
            image = 'subdirectory-arrow-left';
            cssClass = 'icon-flipped';
        }
        if (type === 'turn') {
            if (modifier === 'straight') {
                directiveFr = 'Continuer sur ' + route;
                directiveEn = 'Continue on ' + route;
            }
            else if (modifier === 'uturn') {
                directiveFr = 'Faire demi-tour sur ' + route;
                directiveEn = 'Make u-turn on ' + route;
            }
            else {
                directiveFr = 'Tourner ' + frAggregatedDirection + ' sur ' + route;
                directiveEn = 'Turn ' + translatedModifier + ' onto ' + route;
            }
        }
        else if (type === 'new name') {
            directiveFr =
                'Continuer en direction ' + translatedDirection + ' sur ' + route;
            directiveEn = 'Head ' + translatedDirection + ' on ' + route;
            image = 'compass';
            cssClass = '';
        }
        else if (type === 'depart') {
            directiveFr =
                'Aller en direction ' + translatedDirection + ' sur ' + route;
            directiveEn = 'Head ' + translatedDirection + ' on ' + route;
            image = 'compass';
            cssClass = '';
        }
        else if (type === 'arrive') {
            if (lastStep) {
                /** @type {?} */
                var coma = ', ';
                if (!translatedModifier) {
                    frAggregatedDirection = '';
                    enAggregatedDirection = '';
                    coma = '';
                }
                directiveFr = 'Vous êtes arrivé' + coma + frAggregatedDirection;
                directiveEn =
                    'You have reached your destination' + coma + enAggregatedDirection;
            }
            else {
                directiveFr = 'Vous atteignez le point intermédiare sur ' + route;
                directiveEn = 'You have reached the intermediate stop onto ' + route;
                image = 'map-marker';
                cssClass = '';
            }
        }
        else if (type === 'merge') {
            directiveFr = 'Continuer sur ' + route;
            directiveEn = 'Continue on ' + route;
            image = 'forward';
            cssClass = 'rotate-270';
        }
        else if (type === 'on ramp') {
            directiveFr = "Prendre l'entrée d'autoroute " + frAggregatedDirection;
            directiveEn = 'Take the ramp ' + enAggregatedDirection;
        }
        else if (type === 'off ramp') {
            directiveFr = "Prendre la sortie d'autoroute " + frAggregatedDirection;
            directiveEn = 'Take exit ' + enAggregatedDirection;
        }
        else if (type === 'fork') {
            if (modifier.search('left') >= 0) {
                directiveFr = 'Garder la gauche sur ' + route;
                directiveEn = 'Merge left onto ' + route;
            }
            else if (modifier.search('right') >= 0) {
                directiveFr = 'Garder la droite sur ' + route;
                directiveEn = 'Merge right onto ' + route;
            }
            else {
                directiveFr = 'Continuer sur ' + route;
                directiveEn = 'Continue on ' + route;
            }
        }
        else if (type === 'end of road') {
            directiveFr =
                'À la fin de la route, tourner ' + translatedModifier + ' sur ' + route;
            directiveEn =
                'At the end of the road, turn ' + translatedModifier + ' onto ' + route;
        }
        else if (type === 'use lane') {
            directiveFr = 'Prendre la voie de ... ';
            directiveEn = 'Take the lane ...';
        }
        else if (type === 'continue' && modifier !== 'uturn') {
            directiveFr = 'Continuer sur ' + route;
            directiveEn = 'Continue on ' + route;
            image = 'forward';
            cssClass = 'rotate-270';
        }
        else if (type === 'roundabout') {
            directiveFr = 'Au rond-point, prendre la ' + exit;
            directiveFr += exit === 1 ? 're' : 'e';
            directiveFr += ' sortie vers ' + route;
            directiveEn = 'At the roundabout, take the ' + exit;
            directiveEn += exit === 1 ? 'st' : 'rd';
            directiveEn += ' exit towards ' + route;
            image = 'chart-donut';
            cssClass = '';
        }
        else if (type === 'rotary') {
            directiveFr = 'Rond-point rotary....';
            directiveEn = 'Roundabout rotary....';
            image = 'chart-donut';
            cssClass = '';
        }
        else if (type === 'roundabout turn') {
            directiveFr = 'Rond-point, prendre la ...';
            directiveEn = 'Roundabout, take the ...';
            image = 'chart-donut';
            cssClass = '';
        }
        else if (type === 'exit roundabout') {
            directiveFr = 'Poursuivre vers ' + route;
            directiveEn = 'Continue to ' + route;
            image = 'forward';
            cssClass = 'rotate-270';
        }
        else if (type === 'notification') {
            directiveFr = 'notification ....';
            directiveEn = 'notification ....';
        }
        else if (modifier === 'uturn') {
            directiveFr =
                'Faire demi-tour et continuer en direction ' +
                    translatedDirection +
                    ' sur ' +
                    route;
            directiveEn =
                'Make u-turn and head ' + translatedDirection + ' on ' + route;
        }
        else {
            directiveFr = '???';
            directiveEn = '???';
        }
        if (lastStep) {
            image = 'flag-variant';
            cssClass = '';
        }
        if (stepPosition === 0) {
            image = 'compass';
            cssClass = '';
        }
        /** @type {?} */
        var directive;
        if (this.browserLanguage === 'fr') {
            directive = directiveFr;
        }
        else if (this.browserLanguage === 'en') {
            directive = directiveEn;
        }
        return { instruction: directive, image: image, cssClass: cssClass };
    };
    /**
     * @param {?} modifier
     * @return {?}
     */
    DirectionsFormComponent.prototype.translateModifier = /**
     * @param {?} modifier
     * @return {?}
     */
    function (modifier) {
        if (modifier === 'uturn') {
            return this.languageService.translate.instant('igo.geo.directions.uturn');
        }
        else if (modifier === 'sharp right') {
            return this.languageService.translate.instant('igo.geo.directions.sharp right');
        }
        else if (modifier === 'right') {
            return this.languageService.translate.instant('igo.geo.directions.right');
        }
        else if (modifier === 'slight right') {
            return this.languageService.translate.instant('igo.geo.directions.slight right');
        }
        else if (modifier === 'sharp left') {
            return this.languageService.translate.instant('igo.geo.directions.sharp left');
        }
        else if (modifier === 'left') {
            return this.languageService.translate.instant('igo.geo.directions.left');
        }
        else if (modifier === 'slight left') {
            return this.languageService.translate.instant('igo.geo.directions.slight left');
        }
        else if (modifier === 'straight') {
            return this.languageService.translate.instant('igo.geo.directions.straight');
        }
        else {
            return modifier;
        }
    };
    /**
     * @param {?} bearing
     * @return {?}
     */
    DirectionsFormComponent.prototype.translateBearing = /**
     * @param {?} bearing
     * @return {?}
     */
    function (bearing) {
        if (bearing >= 337 || bearing < 23) {
            return this.languageService.translate.instant('igo.geo.cardinalPoints.n');
        }
        else if (bearing < 67) {
            return this.languageService.translate.instant('igo.geo.cardinalPoints.ne');
        }
        else if (bearing < 113) {
            return this.languageService.translate.instant('igo.geo.cardinalPoints.e');
        }
        else if (bearing < 157) {
            return this.languageService.translate.instant('igo.geo.cardinalPoints.se');
        }
        else if (bearing < 203) {
            return this.languageService.translate.instant('igo.geo.cardinalPoints.s');
        }
        else if (bearing < 247) {
            return this.languageService.translate.instant('igo.geo.cardinalPoints.sw');
        }
        else if (bearing < 293) {
            return this.languageService.translate.instant('igo.geo.cardinalPoints.w');
        }
        else if (bearing < 337) {
            return this.languageService.translate.instant('igo.geo.cardinalPoints.nw');
        }
        else {
            return;
        }
    };
    /**
     * @param {?} distance
     * @return {?}
     */
    DirectionsFormComponent.prototype.formatDistance = /**
     * @param {?} distance
     * @return {?}
     */
    function (distance) {
        if (distance === 0) {
            return;
        }
        if (distance >= 100000) {
            return Math.round(distance / 1000) + ' km';
        }
        if (distance >= 10000) {
            return Math.round(distance / 100) / 10 + ' km';
        }
        if (distance >= 100) {
            return Math.round(distance / 100) / 10 + ' km';
        }
        return distance + ' m';
    };
    /**
     * @param {?} duration
     * @param {?=} summary
     * @return {?}
     */
    DirectionsFormComponent.prototype.formatDuration = /**
     * @param {?} duration
     * @param {?=} summary
     * @return {?}
     */
    function (duration$$1, summary) {
        if (summary === void 0) { summary = false; }
        if (duration$$1 >= 3600) {
            /** @type {?} */
            var hour = Math.floor(duration$$1 / 3600);
            /** @type {?} */
            var minute = Math.round((duration$$1 / 3600 - hour) * 60);
            if (minute === 60) {
                return hour + 1 + ' h';
            }
            return hour + ' h ' + minute + ' min';
        }
        if (duration$$1 >= 60) {
            return Math.round(duration$$1 / 60) + ' min';
        }
        return duration$$1 + ' s';
    };
    /**
     * @param {?} step
     * @param {?=} zoomToExtent
     * @return {?}
     */
    DirectionsFormComponent.prototype.showSegment = /**
     * @param {?} step
     * @param {?=} zoomToExtent
     * @return {?}
     */
    function (step, zoomToExtent) {
        if (zoomToExtent === void 0) { zoomToExtent = false; }
        this.showRouteSegmentGeometry(step.geometry.coordinates, zoomToExtent);
    };
    /**
     * @param {?} coordinates
     * @param {?=} zoomToExtent
     * @return {?}
     */
    DirectionsFormComponent.prototype.showRouteSegmentGeometry = /**
     * @param {?} coordinates
     * @param {?=} zoomToExtent
     * @return {?}
     */
    function (coordinates, zoomToExtent) {
        if (zoomToExtent === void 0) { zoomToExtent = false; }
        /** @type {?} */
        var vertexId = 'vertex';
        /** @type {?} */
        var geometry4326 = new LineString(coordinates);
        /** @type {?} */
        var geometryMapProjection = geometry4326.transform('EPSG:4326', this.map.projection);
        /** @type {?} */
        var routeSegmentCoordinates = ((/** @type {?} */ (geometryMapProjection))).getCoordinates();
        /** @type {?} */
        var lastPoint = routeSegmentCoordinates[0];
        /** @type {?} */
        var geometry = new Point(lastPoint);
        /** @type {?} */
        var feature = new OlFeature({ geometry: geometry });
        /** @type {?} */
        var geojsonGeom = new OlGeoJSON().writeGeometryObject(geometry, {
            featureProjection: this.map.projection,
            dataProjection: this.map.projection
        });
        /** @type {?} */
        var previousVertex = this.routeStore.get(vertexId);
        /** @type {?} */
        var previousVertexRevision = previousVertex ? previousVertex.meta.revision : 0;
        /** @type {?} */
        var vertexFeature = {
            type: FEATURE,
            geometry: geojsonGeom,
            projection: this.map.projection,
            properties: {
                id: vertexId,
                type: 'vertex'
            },
            meta: {
                id: vertexId,
                revision: previousVertexRevision + 1
            },
            ol: feature
        };
        this.routeStore.update(vertexFeature);
        if (zoomToExtent) {
            this.map.viewController.zoomToExtent(feature.getGeometry().getExtent());
        }
    };
    /**
     * @param {?=} extent
     * @return {?}
     */
    DirectionsFormComponent.prototype.zoomRoute = /**
     * @param {?=} extent
     * @return {?}
     */
    function (extent) {
        if (extent) {
            this.map.viewController.zoomToExtent(extent);
        }
        else {
            /** @type {?} */
            var routeFeature = this.routeStore.layer.ol.getSource().getFeatures().find((/**
             * @param {?} f
             * @return {?}
             */
            function (f) { return f.getId() === 'route'; }));
            if (routeFeature) {
                /** @type {?} */
                var routeExtent = routeFeature.getGeometry().getExtent();
                this.map.viewController.zoomToExtent(routeExtent);
            }
        }
    };
    /**
     * @private
     * @param {?=} moveToExtent
     * @return {?}
     */
    DirectionsFormComponent.prototype.showRouteGeometry = /**
     * @private
     * @param {?=} moveToExtent
     * @return {?}
     */
    function (moveToExtent) {
        if (moveToExtent === void 0) { moveToExtent = false; }
        /** @type {?} */
        var geom = this.activeRoute.geometry.coordinates;
        /** @type {?} */
        var geometry4326 = new LineString(geom);
        /** @type {?} */
        var geometryMapProjection = geometry4326.transform('EPSG:4326', this.map.projection);
        if (moveToExtent) {
            this.zoomRoute(geometryMapProjection.getExtent());
        }
        /** @type {?} */
        var geojsonGeom = new OlGeoJSON().writeGeometryObject(geometryMapProjection, {
            featureProjection: this.map.projection,
            dataProjection: this.map.projection
        });
        /** @type {?} */
        var previousRoute = this.routeStore.get('route');
        /** @type {?} */
        var previousRouteRevision = previousRoute ? previousRoute.meta.revision : 0;
        /** @type {?} */
        var routeFeature = {
            type: FEATURE,
            geometry: geojsonGeom,
            projection: this.map.projection,
            properties: {
                id: 'route',
                type: 'route'
            },
            meta: {
                id: 'route',
                revision: previousRouteRevision + 1
            },
            ol: new OlFeature({ geometry: geometryMapProjection })
        };
        this.routeStore.update(routeFeature);
    };
    /**
     * @param {?=} moveToExtent
     * @param {?=} directionsOptions
     * @return {?}
     */
    DirectionsFormComponent.prototype.getRoutes = /**
     * @param {?=} moveToExtent
     * @param {?=} directionsOptions
     * @return {?}
     */
    function (moveToExtent, directionsOptions) {
        var _this = this;
        if (moveToExtent === void 0) { moveToExtent = false; }
        if (directionsOptions === void 0) { directionsOptions = {}; }
        this.deleteStoreFeatureByID(this.routeStore, 'vertex');
        this.writeStopsToFormService();
        /** @type {?} */
        var coords = this.directionsFormService.getStopsCoordinates();
        if (coords.length < 2) {
            return;
        }
        /** @type {?} */
        var routeResponse = this.directionsService.route(coords, directionsOptions);
        if (routeResponse) {
            routeResponse.map((/**
             * @param {?} res
             * @return {?}
             */
            function (res) {
                return _this.routesQueries$$.push(res.subscribe((/**
                 * @param {?} route
                 * @return {?}
                 */
                function (route) {
                    _this.routesResults = route;
                    _this.activeRoute = (/** @type {?} */ (_this.routesResults[0]));
                    _this.showRouteGeometry(moveToExtent);
                    _this.changeDetectorRefs.detectChanges();
                })));
            }));
        }
    };
    /**
     * @private
     * @return {?}
     */
    DirectionsFormComponent.prototype.unlistenSingleClick = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.focusKey.length !== 0) {
            this.focusKey.forEach((/**
             * @param {?} key
             * @return {?}
             */
            function (key) {
                unByKey(key);
            }));
        }
    };
    /**
     * @private
     * @return {?}
     */
    DirectionsFormComponent.prototype.unsubscribeRoutesQueries = /**
     * @private
     * @return {?}
     */
    function () {
        this.routesQueries$$.forEach((/**
         * @param {?} sub
         * @return {?}
         */
        function (sub) { return sub.unsubscribe(); }));
        this.routesQueries$$ = [];
    };
    /**
     * @return {?}
     */
    DirectionsFormComponent.prototype.copyLinkToClipboard = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var successful = Clipboard.copy(this.getUrl());
        if (successful) {
            /** @type {?} */
            var translate = this.languageService.translate;
            /** @type {?} */
            var title = translate.instant('igo.geo.directionsForm.dialog.copyTitle');
            /** @type {?} */
            var msg = translate.instant('igo.geo.directionsForm.dialog.copyMsgLink');
            this.messageService.success(msg, title);
        }
    };
    /**
     * @return {?}
     */
    DirectionsFormComponent.prototype.copyDirectionsToClipboard = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var indent = '\t';
        /** @type {?} */
        var activeRouteDirective = this.languageService.translate.instant('igo.geo.directionsForm.instructions') + ':\n';
        /** @type {?} */
        var wayPointList = '';
        /** @type {?} */
        var summary = this.languageService.translate.instant('igo.geo.directionsForm.summary') +
            ': \n' +
            indent +
            this.activeRoute.title +
            '\n' +
            indent +
            this.formatDistance(this.activeRoute.distance) +
            '\n' +
            indent +
            this.formatDuration(this.activeRoute.duration) +
            '\n\n' +
            this.languageService.translate.instant('igo.geo.directionsForm.stopsList') +
            ':\n';
        /** @type {?} */
        var url = this.languageService.translate.instant('igo.geo.directionsForm.link') +
            ':\n' +
            indent +
            this.getUrl();
        /** @type {?} */
        var wayPointsCnt = 1;
        this.stops.value.forEach((/**
         * @param {?} stop
         * @return {?}
         */
        function (stop) {
            /** @type {?} */
            var coord = '';
            /** @type {?} */
            var stopPoint = '';
            if (stop.stopPoint !== stop.stopCoordinates) {
                stopPoint = stop.stopPoint;
                coord =
                    ' (' +
                        [stop.stopCoordinates[1], stop.stopCoordinates[0]].join(',') +
                        ')';
            }
            else {
                stopPoint = [stop.stopCoordinates[1], stop.stopCoordinates[0]].join(',');
            }
            wayPointList =
                wayPointList +
                    indent +
                    wayPointsCnt.toLocaleString() +
                    '. ' +
                    stopPoint +
                    coord +
                    '\n';
            wayPointsCnt++;
        }));
        // Directions
        /** @type {?} */
        var localCnt = 0;
        this.activeRoute.steps.forEach((/**
         * @param {?} step
         * @return {?}
         */
        function (step) {
            /** @type {?} */
            var instruction = _this.formatStep(step, localCnt).instruction;
            /** @type {?} */
            var distance = _this.formatDistance(step.distance) === undefined
                ? ''
                : ' (' + _this.formatDistance(step.distance) + ')';
            activeRouteDirective =
                activeRouteDirective +
                    indent +
                    (localCnt + 1).toLocaleString() +
                    '. ' +
                    instruction +
                    distance +
                    '\n';
            localCnt++;
        }));
        /** @type {?} */
        var directionsBody = summary + wayPointList + '\n' + url + '\n\n' + activeRouteDirective;
        /** @type {?} */
        var successful = Clipboard.copy(directionsBody);
        if (successful) {
            /** @type {?} */
            var translate = this.languageService.translate;
            /** @type {?} */
            var title = translate.instant('igo.geo.directionsForm.dialog.copyTitle');
            /** @type {?} */
            var msg = translate.instant('igo.geo.directionsForm.dialog.copyMsg');
            this.messageService.success(msg, title);
        }
    };
    /**
     * @private
     * @param {?} term
     * @return {?}
     */
    DirectionsFormComponent.prototype.handleTermChanged = /**
     * @private
     * @param {?} term
     * @return {?}
     */
    function (term) {
        var _this = this;
        if (term !== undefined || term.length !== 0) {
            /** @type {?} */
            var searchProposals_1 = [];
            if (this.search$$) {
                this.search$$.unsubscribe();
            }
            /** @type {?} */
            var researches = this.searchService.search(term, { searchType: 'Feature' });
            researches.map((/**
             * @param {?} res
             * @return {?}
             */
            function (res) {
                return _this.search$$ =
                    res.request.subscribe((/**
                     * @param {?} results
                     * @return {?}
                     */
                    function (results) {
                        results
                            .filter((/**
                         * @param {?} r
                         * @return {?}
                         */
                        function (r) { return r.data.geometry; }))
                            .forEach((/**
                         * @param {?} element
                         * @return {?}
                         */
                        function (element) {
                            if (searchProposals_1.filter((/**
                             * @param {?} r
                             * @return {?}
                             */
                            function (r) { return r.source === element.source; }))
                                .length === 0) {
                                searchProposals_1.push({
                                    source: element.source,
                                    meta: element.meta,
                                    results: results.map((/**
                                     * @param {?} r
                                     * @return {?}
                                     */
                                    function (r) { return r.data; }))
                                });
                            }
                        }));
                        _this.stops
                            .at(_this.currentStopIndex)
                            .patchValue({ stopProposals: searchProposals_1 });
                        _this.changeDetectorRefs.detectChanges();
                    }));
            }));
        }
    };
    /**
     * @param {?} term
     * @return {?}
     */
    DirectionsFormComponent.prototype.setTerm = /**
     * @param {?} term
     * @return {?}
     */
    function (term) {
        this.term = term;
        if (this.keyIsValid(term) &&
            (term.length >= this.length || term.length === 0)) {
            this.stream$.next(term);
        }
    };
    /**
     * @private
     * @param {?} key
     * @return {?}
     */
    DirectionsFormComponent.prototype.keyIsValid = /**
     * @private
     * @param {?} key
     * @return {?}
     */
    function (key) {
        return this.invalidKeys.find((/**
         * @param {?} value
         * @return {?}
         */
        function (value) { return value === key; })) === undefined;
    };
    /**
     * @param {?} i
     * @param {?} event
     * @return {?}
     */
    DirectionsFormComponent.prototype.keyup = /**
     * @param {?} i
     * @param {?} event
     * @return {?}
     */
    function (i, event) {
        var _this = this;
        /** @type {?} */
        var term = ((/** @type {?} */ (event.target))).value;
        this.setTerm(term);
        this.map.ol.un('singleclick', (/**
         * @param {?} evt
         * @return {?}
         */
        function (evt) {
            _this.handleMapClick(evt, i);
        }));
    };
    /**
     * @param {?} stopIndex
     * @return {?}
     */
    DirectionsFormComponent.prototype.clearStop = /**
     * @param {?} stopIndex
     * @return {?}
     */
    function (stopIndex) {
        // this.deleteDirectionsOverlaybyID(this.getStopOverlayID(stopIndex));
        /** @type {?} */
        var id = this.getStopOverlayID(stopIndex);
        this.deleteStoreFeatureByID(this.stopsStore, id);
        this.routeStore.clear();
        /** @type {?} */
        var stopsCounts = this.stops.length;
        this.stops.removeAt(stopIndex);
        this.stops.insert(stopIndex, this.createStop(this.directionsText(stopIndex, stopsCounts)));
        this.routesResults = undefined;
        this.getRoutes();
    };
    /**
     * @param {?} proposal
     * @param {?} i
     * @return {?}
     */
    DirectionsFormComponent.prototype.chooseProposal = /**
     * @param {?} proposal
     * @param {?} i
     * @return {?}
     */
    function (proposal, i) {
        if (proposal !== undefined) {
            /** @type {?} */
            var geomCoord = void 0;
            /** @type {?} */
            var geom = ((/** @type {?} */ (proposal))).geometry;
            if (geom.type === 'Point') {
                geomCoord = geom.coordinates;
            }
            else if (geom.type.search('Line') >= 0) {
                /** @type {?} */
                var line = (new OlGeoJSON()).readFeatures(geom);
                geomCoord = line[0].getGeometry().getFirstCoordinate();
                geomCoord = [geomCoord[0], geomCoord[1]];
            }
            else if (geom.type.search('Polygon') >= 0) {
                /** @type {?} */
                var poly = (new OlGeoJSON()).readFeatures(geom);
                geomCoord = poly[0].getGeometry().getInteriorPoints().getFirstCoordinate();
                geomCoord = [geomCoord[0], geomCoord[1]];
            }
            if (geomCoord !== undefined) {
                this.stops.at(i).patchValue({ stopCoordinates: geomCoord });
                this.addStopOverlay(geomCoord, i);
                /*  const proposalExtent = this.directionsStopsOverlayDataSource.ol
                    .getFeatureById(this.getStopOverlayID(i))
                    .getGeometry()
                    .getExtent();*/
                /* if (!olextent.intersects(proposalExtent, this.map.viewController.getExtent())) {
                   this.map.viewController.moveToExtent(proposalExtent);
                 }*/
            }
        }
    };
    /**
     * @param {?} i
     * @return {?}
     */
    DirectionsFormComponent.prototype.focus = /**
     * @param {?} i
     * @return {?}
     */
    function (i) {
        var _this = this;
        this.unlistenSingleClick();
        this.currentStopIndex = i;
        this.focusOnStop = true;
        this.focusKey.push(this.map.ol.once('singleclick', (/**
         * @param {?} evt
         * @return {?}
         */
        function (evt) {
            _this.handleMapClick(evt, i);
        })));
    };
    /**
     * @private
     * @param {?} event
     * @param {?=} indexPos
     * @return {?}
     */
    DirectionsFormComponent.prototype.handleMapClick = /**
     * @private
     * @param {?} event
     * @param {?=} indexPos
     * @return {?}
     */
    function (event, indexPos) {
        var _this = this;
        if (this.currentStopIndex === undefined) {
            this.addStop();
            indexPos = this.stops.length - 2;
            this.stops.at(indexPos).value.stopProposals = [];
        }
        else {
            indexPos = this.currentStopIndex;
        }
        /** @type {?} */
        var clickCoordinates = transform(event.coordinate, this.map.projection, this.projection);
        this.stops.at(indexPos).patchValue({ stopProposals: [], stopCoordinates: clickCoordinates });
        this.handleLocationProposals(clickCoordinates, indexPos);
        this.addStopOverlay(clickCoordinates, indexPos);
        setTimeout((/**
         * @return {?}
         */
        function () {
            _this.focusOnStop = false; // prevent to trigger map click and Select on routes at same time.
        }), 500);
    };
    /**
     * @param {?} index
     * @return {?}
     */
    DirectionsFormComponent.prototype.geolocateStop = /**
     * @param {?} index
     * @return {?}
     */
    function (index) {
        moveToOlFeatures(this.map, [this.map.geolocationFeature], FeatureMotion.Move);
        /** @type {?} */
        var geolocateCoordinates = this.map.viewController.getCenter(this.projection);
        this.stops.at(index).patchValue({ stopCoordinates: geolocateCoordinates });
        this.addStopOverlay(geolocateCoordinates, index);
        this.handleLocationProposals(geolocateCoordinates, index);
    };
    /**
     * @param {?} coordinates
     * @param {?} index
     * @return {?}
     */
    DirectionsFormComponent.prototype.addStopOverlay = /**
     * @param {?} coordinates
     * @param {?} index
     * @return {?}
     */
    function (coordinates, index) {
        /** @type {?} */
        var directionsText = this.directionsText(index);
        /** @type {?} */
        var stopColor;
        /** @type {?} */
        var stopText;
        if (directionsText === 'start') {
            stopColor = 'green';
            stopText = this.languageService.translate.instant('igo.geo.directionsForm.start');
        }
        else if (directionsText === 'end') {
            stopColor = 'red';
            stopText = this.languageService.translate.instant('igo.geo.directionsForm.end');
        }
        else {
            stopColor = 'yellow';
            stopText =
                this.languageService.translate.instant('igo.geo.directionsForm.intermediate') +
                    ' #' +
                    index;
        }
        /** @type {?} */
        var geometry = new Point(transform(coordinates, this.projection, this.map.projection));
        /** @type {?} */
        var stopID = this.getStopOverlayID(index);
        /** @type {?} */
        var geojsonGeom = new OlGeoJSON().writeGeometryObject(geometry, {
            featureProjection: this.map.projection,
            dataProjection: this.map.projection
        });
        /** @type {?} */
        var previousStop = this.stopsStore.get(stopID);
        /** @type {?} */
        var previousStopRevision = previousStop ? previousStop.meta.revision : 0;
        /** @type {?} */
        var stopFeature = {
            type: FEATURE,
            geometry: geojsonGeom,
            projection: this.map.projection,
            properties: {
                id: stopID,
                type: 'stop',
                stopText: stopText,
                stopColor: stopColor,
                stopOpacity: 1
            },
            meta: {
                id: stopID,
                revision: previousStopRevision + 1
            },
            ol: new OlFeature({ geometry: geometry })
        };
        this.stopsStore.update(stopFeature);
        this.getRoutes();
    };
    /**
     * @param {?} index
     * @return {?}
     */
    DirectionsFormComponent.prototype.getStopOverlayID = /**
     * @param {?} index
     * @return {?}
     */
    function (index) {
        /** @type {?} */
        var txt;
        if (index === 0) {
            txt = 'start';
        }
        else if (index === this.stops.length - 1) {
            txt = 'end';
        }
        else {
            txt = index;
        }
        return 'directionsStop_' + txt;
    };
    /**
     * @private
     * @param {?} store
     * @param {?} id
     * @return {?}
     */
    DirectionsFormComponent.prototype.deleteStoreFeatureByID = /**
     * @private
     * @param {?} store
     * @param {?} id
     * @return {?}
     */
    function (store, id) {
        /** @type {?} */
        var entity = store.get(id);
        if (entity) {
            store.delete(entity);
        }
    };
    /**
     * @private
     * @return {?}
     */
    DirectionsFormComponent.prototype.getUrl = /**
     * @private
     * @return {?}
     */
    function () {
        if (!this.route) {
            return;
        }
        /** @type {?} */
        var directionsKey = this.route.options.directionsCoordKey;
        /** @type {?} */
        var stopsCoordinates = [];
        if (this.directionsFormService &&
            this.directionsFormService.getStopsCoordinates() &&
            this.directionsFormService.getStopsCoordinates().length !== 0) {
            this.directionsFormService.getStopsCoordinates().forEach((/**
             * @param {?} coord
             * @return {?}
             */
            function (coord) {
                stopsCoordinates.push(roundCoordTo(coord, 6));
            }));
        }
        /** @type {?} */
        var directionsUrl = '';
        if (stopsCoordinates.length >= 2) {
            directionsUrl = directionsKey + "=" + stopsCoordinates.join(';');
        }
        return "" + location.origin + location.pathname + "?tool=directions&" + directionsUrl;
    };
    DirectionsFormComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igo-directions-form',
                    template: "<form class=\"igo-form\" [formGroup]=\"stopsForm\">\r\n  <!-- <div class=\"igo-form-button-group\">\r\n\r\n  </div> -->\r\n  <div #inputs formArrayName=\"stops\" *ngFor=\"let stop of stops.controls; let i = index;\">\r\n    <mat-list-item [formGroupName]=\"i\">\r\n\r\n      <div class=\"igo-input-container\">\r\n        <button *ngIf=\"map.geolocationFeature\" mat-icon-button tooltip-position=\"below\" matTooltipShowDelay=\"500\" [matTooltip]=\"'igo.geo.directionsForm.geolocate' | translate\" (click)=\"geolocateStop(i)\">\r\n          <mat-icon svgIcon=\"crosshairs-gps\"></mat-icon>\r\n        </button>\r\n        <mat-form-field>\r\n          <input matInput formControlName=\"stopPoint\" [matAutocomplete]=\"auto\"\r\n            placeholder=\"{{'igo.geo.directionsForm.'+stop.value.directionsText | translate}}\" (focus)=\"focus(i)\"\r\n            (keyup)=\"keyup(i,$event)\" (keydown.enter)=\"prevent($event)\">\r\n            <button \r\n              mat-button \r\n              *ngIf=\"stop.value && (stop.value.stopPoint.length > 0 || stop.value.stopProposals.length > 0)\"\r\n              matSuffix mat-icon-button color=\"warn\" aria-label=\"Clear\" (click)=\"clearStop(i)\">\r\n              <mat-icon svgIcon=\"close\"></mat-icon>\r\n            </button>\r\n\r\n          <mat-autocomplete #auto=\"matAutocomplete\">\r\n            <mat-optgroup *ngFor=\"let source of stop.value.stopProposals\" [label]=\"source.source.title\" [disabled]=\"source.source.enabled === false\">\r\n              <mat-option *ngFor=\"let result of source.results\" [value]=\"result.meta ? result.meta.title : ''\" \r\n              (onSelectionChange)=\"chooseProposal(result,i)\"\r\n              matTooltipShowDelay=\"500\" [matTooltip]=\"result.meta ? result.meta.title : ''\">\r\n                {{ result.meta ? result.meta.title : '' }}\r\n              </mat-option>\r\n            </mat-optgroup>\r\n          </mat-autocomplete>\r\n        </mat-form-field>\r\n\r\n        <!-- <div class=\"igo-form-button-group\"> -->\r\n\r\n\r\n          <!-- <button *ngIf=\"i !== 0\" mat-icon-button tooltip-position=\"below\" matTooltipShowDelay=\"500\" [matTooltip]=\"'igo.geo.directionsForm.raiseStop' | translate\"\r\n            [color]=\"color\" (click)=\"raiseStop(i)\">\r\n            <mat-icon svgIcon=\"arrow-upward\"></mat-icon>\r\n          </button>\r\n          <button *ngIf=\"i !== stops.length - 1\" mat-icon-button tooltip-position=\"below\" matTooltipShowDelay=\"500\" [matTooltip]=\"'igo.geo.directionsForm.lowerStop' | translate\"\r\n            [color]=\"color\" (click)=\"lowerStop(i)\">\r\n            <mat-icon svgIcon=\"arrow-downward\"></mat-icon>\r\n          </button> -->\r\n\r\n          <button *ngIf=\"i !== 0 && i !== stops.length - 1\" mat-icon-button tooltip-position=\"below\" matTooltipShowDelay=\"500\" [matTooltip]=\"'igo.geo.directionsForm.removeStop' | translate\"\r\n            color=\"warn\" (click)=\"removeStop(i)\">\r\n            <mat-icon svgIcon=\"delete\"></mat-icon>\r\n          </button>\r\n        <!-- </div> -->\r\n      </div>\r\n\r\n    </mat-list-item>\r\n  </div>\r\n  <div class=\"igo-form-button-group\">\r\n    <button mat-icon-button tooltip-position=\"below\" matTooltipShowDelay=\"500\"\r\n      [matTooltip]=\"'igo.geo.directionsForm.addStop' | translate\" color=\"primary\" (click)=\"addStop()\">\r\n      <mat-icon svgIcon=\"map-marker-plus\"></mat-icon>\r\n    </button>\r\n    <button mat-icon-button tooltip-position=\"below\" matTooltipShowDelay=\"500\"\r\n      [matTooltip]=\"'igo.geo.directionsForm.zoomRoute' | translate\" *ngIf=\"routesResults\" color=\"primary\"\r\n      (click)=\"zoomRoute()\">\r\n      <mat-icon svgIcon=\"magnify-plus-outline\"></mat-icon>\r\n    </button>\r\n    <button mat-icon-button tooltip-position=\"below\" matTooltipShowDelay=\"500\"\r\n      [matTooltip]=\"'igo.geo.directionsForm.resetDirectionsBtn' | translate\" *ngIf=\"routesResults\" color=\"warn\"\r\n      (click)=\"resetForm()\">\r\n      <mat-icon svgIcon=\"file-restore\"></mat-icon>\r\n    </button>\r\n    <button mat-icon-button *ngIf=\"routesResults\" tooltip-position=\"below\" matTooltipShowDelay=\"500\"\r\n      [matTooltip]=\"'igo.geo.directionsForm.copy' | translate\" color=\"primary\" (click)=\"copyDirectionsToClipboard()\">\r\n      <mat-icon svgIcon=\"content-copy\"></mat-icon>\r\n    </button>\r\n    <button mat-icon-button *ngIf=\"routesResults\" tooltip-position=\"below\" matTooltipShowDelay=\"500\"\r\n      [matTooltip]=\"'igo.geo.directionsForm.link' | translate\" color=\"primary\" (click)=\"copyLinkToClipboard()\">\r\n      <mat-icon svgIcon=\"link\"></mat-icon>\r\n    </button>\r\n  </div>\r\n\r\n</form>\r\n\r\n<div class=\"igo-input-container\" *ngIf=\"routesResults\">\r\n  <mat-form-field *ngIf=\"routesResults && routesResults.length > 1\">\r\n    <mat-select placeholder=\"{{'igo.geo.directionsForm.drivingOptions' | translate}}\" (selectionChange)=\"changeRoute()\" [(ngModel)]=\"activeRoute\">\r\n      <mat-option *ngFor=\"let pathDirections of routesResults; let cnt = index;\" [value]=\"pathDirections\">\r\n        Option {{cnt + 1}} : {{formatDistance(pathDirections.distance)}} ({{formatDuration(pathDirections.duration)}})\r\n      </mat-option>\r\n    </mat-select>\r\n  </mat-form-field>\r\n\r\n  <mat-divider *ngIf=\"routesResults && routesResults.length === 0\"></mat-divider>\r\n\r\n  <mat-list>\r\n    <h2 mat-header class=\"igo-route-title mat-typography\">{{activeRoute.title}}</h2>\r\n    <h2 mat-subheader>{{formatDistance(activeRoute.distance)}}, {{formatDuration(activeRoute.duration)}}</h2>\r\n\r\n    <mat-list-item \r\n    class=\"igo-steps\"\r\n    (mouseenter)=\"showSegment(step)\" \r\n    (click)=\"showSegment(step,true)\" \r\n    *ngFor=\"let step of activeRoute.steps; let cnt = index;\"\r\n      igoListItem>\r\n      <mat-icon [ngClass]=\"formatStep(step,cnt).cssClass\" mat-list-icon svgIcon=\"{{formatStep(step,cnt).image}}\"></mat-icon>\r\n\r\n      <h4 mat-line>{{cnt +1}}. {{formatStep(step,cnt).instruction}}</h4>\r\n      <h4 mat-line class=\"right\">{{formatDistance(step.distance)}}</h4>\r\n    </mat-list-item>\r\n\r\n    <mat-divider></mat-divider>\r\n\r\n  </mat-list>\r\n\r\n</div>\r\n",
                    styles: ["mat-form-field{width:85%}.igo-route-title{font-weight:700}.igo-steps{cursor:pointer}form{padding:10px}h3{padding-left:5px;padding-right:5px}.mat-line{word-wrap:break-word!important;white-space:pre-wrap!important}.mat-line.right{text-align:right}.rotate-90{-webkit-transform:rotate(90deg);transform:rotate(90deg)}.rotate-45{-webkit-transform:rotate(45deg);transform:rotate(45deg)}.rotate-270{-webkit-transform:rotate(270deg);transform:rotate(270deg)}.rotate-250{-webkit-transform:rotate(250deg);transform:rotate(250deg)}.rotate-290{-webkit-transform:rotate(290deg);transform:rotate(290deg)}.icon-flipped{-webkit-transform:scaleY(-1);transform:scaleY(-1)}"]
                }] }
    ];
    /** @nocollapse */
    DirectionsFormComponent.ctorParameters = function () { return [
        { type: FormBuilder },
        { type: DirectionsService },
        { type: LanguageService },
        { type: MessageService },
        { type: SearchService },
        { type: QueryService },
        { type: DirectionsFormService },
        { type: ChangeDetectorRef },
        { type: RouteService, decorators: [{ type: Optional }] }
    ]; };
    DirectionsFormComponent.propDecorators = {
        term: [{ type: Input }],
        debounce: [{ type: Input }],
        length: [{ type: Input }],
        map: [{ type: Input }],
        stopsStore: [{ type: Input }],
        routeStore: [{ type: Input }],
        submit: [{ type: Output }]
    };
    return DirectionsFormComponent;
}());
/**
 * Create a style for the directions stops and routes
 * @param {?} feature OlFeature
 * @param {?} resolution
 * @return {?} OL style function
 */
function stopMarker(feature, resolution) {
    /** @type {?} */
    var vertexStyle = [
        new Style({
            geometry: feature.getGeometry(),
            image: new Circle({
                radius: 7,
                stroke: new Stroke({ color: '#FF0000', width: 3 })
            })
        })
    ];
    /** @type {?} */
    var stopStyle = new Style({
        image: new Icon({
            src: './assets/igo2/geo/icons/place_' + feature.get('stopColor') + '_36px.svg',
            opacity: feature.get('stopOpacity'),
            imgSize: [36, 36],
            // for ie
            anchor: [0.5, 0.92]
        }),
        text: new Text({
            text: feature.get('stopText'),
            font: '12px Calibri,sans-serif',
            fill: new Fill({ color: '#000' }),
            stroke: new Stroke({ color: '#fff', width: 3 }),
            overflow: true
        })
    });
    /** @type {?} */
    var routeStyle = [
        new Style({
            stroke: new Stroke({ color: '#6a7982', width: 10, opacity: 0.75 })
        }),
        new Style({
            stroke: new Stroke({ color: '#4fa9dd', width: 6, opacity: 0.75 })
        })
    ];
    if (feature.get('type') === 'stop') {
        return stopStyle;
    }
    if (feature.get('type') === 'vertex') {
        return vertexStyle;
    }
    if (feature.get('type') === 'route') {
        return routeStyle;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var DirectionsFormBindingDirective = /** @class */ (function () {
    function DirectionsFormBindingDirective(component, directionsFormService, route) {
        this.component = component;
        this.directionsFormService = directionsFormService;
        this.route = route;
    }
    /**
     * @return {?}
     */
    DirectionsFormBindingDirective.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var storedStops = this.directionsFormService.getStops();
        if (!storedStops && this.route &&
            this.route.options.directionsCoordKey) {
            this.route.queryParams.subscribe((/**
             * @param {?} params
             * @return {?}
             */
            function (params) {
                /** @type {?} */
                var directionsParams = params[(/** @type {?} */ (_this.route.options.directionsCoordKey))];
                if (directionsParams) {
                    /** @type {?} */
                    var directionsCoordUrl_1 = directionsParams.split(';');
                    if (directionsCoordUrl_1.length >= 2) {
                        /** @type {?} */
                        var cnt_1 = 0;
                        directionsCoordUrl_1.forEach((/**
                         * @param {?} coord
                         * @return {?}
                         */
                        function (coord) {
                            if (cnt_1 !== 0 && cnt_1 !== directionsCoordUrl_1.length - 1) {
                                _this.component.stops.insert(cnt_1, _this.component.createStop());
                            }
                            /** @type {?} */
                            var stopCoordinatesFromURL = JSON.parse('[' + coord + ']');
                            _this.component.stops
                                .at(cnt_1)
                                .patchValue({ stopCoordinates: stopCoordinatesFromURL });
                            _this.component.stops
                                .at(cnt_1)
                                .patchValue({ stopPoint: stopCoordinatesFromURL });
                            _this.component.handleLocationProposals(stopCoordinatesFromURL, cnt_1);
                            _this.component.addStopOverlay(stopCoordinatesFromURL, cnt_1);
                            cnt_1++;
                        }));
                        _this.component.getRoutes(true);
                    }
                }
            }));
        }
        else if (storedStops) {
            for (var i = 0; i < storedStops.length; i++) {
                if (i !== 0 && i !== storedStops.length - 1) {
                    this.component.stops.insert(i, this.component.createStop());
                }
                if (storedStops[i].stopCoordinates instanceof Array) {
                    this.component.addStopOverlay(storedStops[i].stopCoordinates, i);
                    this.component.stops.at(i).patchValue(storedStops[i]);
                }
            }
            this.component.getRoutes();
        }
        this.component.writeStopsToFormService();
    };
    DirectionsFormBindingDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igoDirectionsFormBinding]'
                },] }
    ];
    /** @nocollapse */
    DirectionsFormBindingDirective.ctorParameters = function () { return [
        { type: DirectionsFormComponent, decorators: [{ type: Self }] },
        { type: DirectionsFormService },
        { type: RouteService, decorators: [{ type: Optional }] }
    ]; };
    return DirectionsFormBindingDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgoDirectionsModule = /** @class */ (function () {
    function IgoDirectionsModule() {
    }
    /**
     * @return {?}
     */
    IgoDirectionsModule.forRoot = /**
     * @return {?}
     */
    function () {
        return {
            ngModule: IgoDirectionsModule
        };
    };
    IgoDirectionsModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        FormsModule,
                        ReactiveFormsModule,
                        MatIconModule,
                        MatButtonModule,
                        MatListModule,
                        MatDividerModule,
                        MatFormFieldModule,
                        MatInputModule,
                        MatOptionModule,
                        MatSelectModule,
                        MatTooltipModule,
                        MatAutocompleteModule,
                        IgoLanguageModule
                    ],
                    exports: [DirectionsFormComponent, DirectionsFormBindingDirective],
                    declarations: [DirectionsFormComponent, DirectionsFormBindingDirective],
                    providers: [DirectionsFormService, provideDirectionsSourceService()]
                },] }
    ];
    return IgoDirectionsModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Search source factory
 * @ignore
 * @param {?} sources
 * @return {?}
 */
function searchSourceServiceFactory(sources) {
    return new SearchSourceService(sources);
}
/**
 * Function that returns a provider for the SearchSource service
 * @return {?}
 */
function provideSearchSourceService() {
    return {
        provide: SearchSourceService,
        useFactory: searchSourceServiceFactory,
        deps: [SearchSource]
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IChercheSearchResultFormatter = /** @class */ (function () {
    function IChercheSearchResultFormatter(languageService) {
        this.languageService = languageService;
    }
    /**
     * @param {?} result
     * @return {?}
     */
    IChercheSearchResultFormatter.prototype.formatResult = /**
     * @param {?} result
     * @return {?}
     */
    function (result) {
        return result;
    };
    IChercheSearchResultFormatter.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    IChercheSearchResultFormatter.ctorParameters = function () { return [
        { type: LanguageService }
    ]; };
    return IChercheSearchResultFormatter;
}());
/**
 * ICherche search source
 */
var IChercheSearchSource = /** @class */ (function (_super) {
    __extends(IChercheSearchSource, _super);
    function IChercheSearchSource(http, languageService, options, formatter, injector) {
        var _this = _super.call(this, options) || this;
        _this.http = http;
        _this.languageService = languageService;
        _this.formatter = formatter;
        _this.title$ = new BehaviorSubject('');
        _this.hashtagsLieuxToKeep = [];
        _this.languageService.translate
            .get(_this.options.title)
            .subscribe((/**
         * @param {?} title
         * @return {?}
         */
        function (title) { return _this.title$.next(title); }));
        /** @type {?} */
        var authService = injector.get(AuthService);
        if (_this.settings.length) {
            if (!authService) {
                _this.getAllowedTypes();
            }
            else {
                authService.authenticate$.subscribe((/**
                 * @return {?}
                 */
                function () {
                    _this.getAllowedTypes();
                }));
            }
        }
        return _this;
    }
    Object.defineProperty(IChercheSearchSource.prototype, "title", {
        get: /**
         * @return {?}
         */
        function () {
            return this.title$.getValue();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    IChercheSearchSource.prototype.getId = /**
     * @return {?}
     */
    function () {
        return IChercheSearchSource.id;
    };
    /**
     * @return {?}
     */
    IChercheSearchSource.prototype.getType = /**
     * @return {?}
     */
    function () {
        return IChercheSearchSource.type;
    };
    /**
     * @protected
     * @return {?}
     */
    IChercheSearchSource.prototype.getDefaultOptions = /**
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var limit = this.options.params && this.options.params.limit
            ? Number(this.options.params.limit)
            : undefined;
        /** @type {?} */
        var ecmax = this.options.params && this.options.params.ecmax
            ? Number(this.options.params.ecmax)
            : undefined;
        /** @type {?} */
        var types = this.options.params && this.options.params.type
            ? this.options.params.type
                .replace(/\s/g, '')
                .toLowerCase()
                .split(',')
            : [
                'adresses',
                'codes-postaux',
                'routes',
                'municipalites',
                'mrc',
                'regadmin',
                'lieux'
            ];
        return {
            title: 'igo.geo.search.icherche.name',
            searchUrl: 'https://geoegl.msp.gouv.qc.ca/apis/icherche',
            settings: [
                {
                    type: 'checkbox',
                    title: 'results type',
                    name: 'type',
                    values: [
                        {
                            title: 'igo.geo.search.icherche.type.address',
                            value: 'adresses',
                            enabled: types.indexOf('adresses') !== -1,
                            hashtags: ['adresse']
                        },
                        {
                            title: 'igo.geo.search.icherche.type.oldAddress',
                            value: 'anciennes-adresses',
                            enabled: types.indexOf('anciennes-adresses') !== -1,
                            hashtags: ['anciennes-adresses']
                        },
                        {
                            title: 'igo.geo.search.icherche.type.postalCode',
                            value: 'codes-postaux',
                            enabled: types.indexOf('codes-postaux') !== -1,
                            hashtags: ['code-postal']
                        },
                        {
                            title: 'igo.geo.search.icherche.type.road',
                            value: 'routes',
                            enabled: types.indexOf('routes') !== -1,
                            hashtags: ['route']
                        },
                        {
                            title: 'igo.geo.search.icherche.type.city',
                            value: 'municipalites',
                            enabled: types.indexOf('municipalites') !== -1,
                            hashtags: ['municipalité', 'mun']
                        },
                        {
                            title: 'igo.geo.search.icherche.type.oldCity',
                            value: 'anciennes-municipalites',
                            enabled: types.indexOf('anciennes-municipalites') !== -1,
                            hashtags: ['anciennes-municipalites']
                        },
                        {
                            title: 'igo.geo.search.icherche.type.mrc',
                            value: 'mrc',
                            enabled: types.indexOf('mrc') !== -1,
                            hashtags: ['mrc']
                        },
                        {
                            title: 'igo.geo.search.icherche.type.regadmin',
                            value: 'regadmin',
                            enabled: types.indexOf('regadmin') !== -1,
                            hashtags: ['région-administrative', 'regadmin']
                        },
                        {
                            title: 'igo.geo.search.icherche.type.entreprise',
                            value: 'entreprises',
                            enabled: types.indexOf('entreprises') !== -1,
                            available: false,
                            hashtags: ['entreprise']
                        },
                        {
                            title: 'igo.geo.search.icherche.type.place',
                            value: 'lieux',
                            enabled: types.indexOf('lieux') !== -1,
                            hashtags: ['lieu']
                        },
                        {
                            title: 'igo.geo.search.icherche.type.sumi',
                            value: 'bornes-sumi',
                            enabled: types.indexOf('bornes-sumi') !== -1,
                            hashtags: ['borne', 'bornes', 'sumi']
                        },
                        {
                            title: 'igo.geo.search.icherche.type.km',
                            value: 'bornes-km',
                            enabled: false,
                            hashtags: ['borne', 'bornes', 'repère', 'km']
                        }
                    ]
                },
                {
                    type: 'radiobutton',
                    title: 'results limit',
                    name: 'limit',
                    values: [
                        {
                            title: '1',
                            value: 1,
                            enabled: limit === 1
                        },
                        {
                            title: '5',
                            value: 5,
                            enabled: limit === 5 || !limit
                        },
                        {
                            title: '10',
                            value: 10,
                            enabled: limit === 10
                        },
                        {
                            title: '25',
                            value: 25,
                            enabled: limit === 25
                        },
                        {
                            title: '50',
                            value: 50,
                            enabled: limit === 50
                        }
                    ]
                },
                {
                    type: 'radiobutton',
                    title: 'ecmax',
                    name: 'ecmax',
                    values: [
                        {
                            title: '10 %',
                            value: 10,
                            enabled: ecmax === 10
                        },
                        {
                            title: '30 %',
                            value: 30,
                            enabled: ecmax === 30 || !ecmax
                        },
                        {
                            title: '50 %',
                            value: 50,
                            enabled: ecmax === 50
                        },
                        {
                            title: '75 %',
                            value: 75,
                            enabled: ecmax === 75
                        },
                        {
                            title: '100 %',
                            value: 100,
                            enabled: ecmax === 100
                        }
                    ]
                },
                {
                    type: 'radiobutton',
                    title: 'restrictExtent',
                    name: 'loc',
                    values: [
                        {
                            title: 'igo.geo.search.icherche.restrictExtent.map',
                            value: 'true',
                            enabled: false
                        },
                        {
                            title: 'igo.geo.search.icherche.restrictExtent.quebec',
                            value: 'false',
                            enabled: true
                        }
                    ]
                }
            ]
        };
    };
    /**
     * Search a location by name or keyword
     * @param term Location name or keyword
     * @returns Observable of <SearchResult<Feature>[]
     */
    /**
     * Search a location by name or keyword
     * @param {?} term Location name or keyword
     * @param {?=} options
     * @return {?} Observable of <SearchResult<Feature>[]
     */
    IChercheSearchSource.prototype.search = /**
     * Search a location by name or keyword
     * @param {?} term Location name or keyword
     * @param {?=} options
     * @return {?} Observable of <SearchResult<Feature>[]
     */
    function (term, options) {
        var _this = this;
        /** @type {?} */
        var params = this.computeRequestParams(term, options || {});
        if (!params.get('type').length) {
            return of([]);
        }
        this.options.params.page = params.get('page') || '1';
        return this.http.get(this.searchUrl + "/geocode", { params: params }).pipe(map((/**
         * @param {?} response
         * @return {?}
         */
        function (response) { return _this.extractResults(response); })), catchError((/**
         * @param {?} err
         * @return {?}
         */
        function (err) {
            err.error.toDisplay = true;
            err.error.title = _this.languageService.translate.instant(_this.getDefaultOptions().title);
            throw err;
        })));
    };
    /**
     * @private
     * @return {?}
     */
    IChercheSearchSource.prototype.getAllowedTypes = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        return this.http
            .get(this.searchUrl + "/types")
            .subscribe((/**
         * @param {?} types
         * @return {?}
         */
        function (types) {
            /** @type {?} */
            var typeSetting = _this.settings.find((/**
             * @param {?} s
             * @return {?}
             */
            function (s) { return s.name === 'type'; }));
            typeSetting.values.forEach((/**
             * @param {?} v
             * @return {?}
             */
            function (v) {
                /** @type {?} */
                var regex = new RegExp("^" + v.value + "(\\.|$)");
                /** @type {?} */
                var typesMatched = types.filter((/**
                 * @param {?} value
                 * @return {?}
                 */
                function (value) { return regex.test(value); }));
                v.available = typesMatched.length > 0;
                if (v.value === 'lieux') {
                    _this.hashtagsLieuxToKeep = __spread(((/** @type {?} */ (new Set(typesMatched
                        .map((/**
                     * @param {?} t
                     * @return {?}
                     */
                    function (t) { return t.split('.'); }))
                        .reduce((/**
                     * @param {?} a
                     * @param {?} b
                     * @return {?}
                     */
                    function (a, b) { return a.concat(b); }))
                        .filter((/**
                     * @param {?} t
                     * @return {?}
                     */
                    function (t) { return t !== 'lieux'; })))))));
                }
            }));
        }));
    };
    /**
     * @private
     * @param {?} term
     * @param {?} options
     * @return {?}
     */
    IChercheSearchSource.prototype.computeRequestParams = /**
     * @private
     * @param {?} term
     * @param {?} options
     * @return {?}
     */
    function (term, options) {
        /** @type {?} */
        var queryParams = Object.assign({
            geometry: true,
            bbox: true,
            icon: true,
            type: 'adresses,codes-postaux,municipalites,mrc,regadmin,lieux,entreprises,bornes-sumi'
        }, this.params, this.computeOptionsParam(term, options || {}).params, {
            q: this.computeTerm(term),
            page: options.page
        });
        if (queryParams.loc === 'true') {
            var _a = __read(options.extent, 4), xMin = _a[0], yMin = _a[1], xMax = _a[2], yMax = _a[3];
            queryParams.loc = xMin + "," + yMin + ";" + xMax + "," + yMin + ";" + xMax + "," + yMax + ";" + xMin + "," + yMax + ";" + xMin + "," + yMin;
        }
        else if (queryParams.loc === 'false') {
            delete queryParams.loc;
        }
        if (queryParams.q.indexOf('#') !== -1) {
            queryParams.type = 'lieux';
        }
        return new HttpParams({ fromObject: ObjectUtils.removeUndefined(queryParams) });
    };
    /**
     * @private
     * @param {?} response
     * @return {?}
     */
    IChercheSearchSource.prototype.extractResults = /**
     * @private
     * @param {?} response
     * @return {?}
     */
    function (response) {
        var _this = this;
        return response.features.map((/**
         * @param {?} data
         * @return {?}
         */
        function (data) {
            return _this.formatter.formatResult(_this.dataToResult(data, response));
        }));
    };
    /**
     * @private
     * @param {?} data
     * @param {?=} response
     * @return {?}
     */
    IChercheSearchSource.prototype.dataToResult = /**
     * @private
     * @param {?} data
     * @param {?=} response
     * @return {?}
     */
    function (data, response) {
        /** @type {?} */
        var properties = this.computeProperties(data);
        /** @type {?} */
        var id = [this.getId(), properties.type, properties.code].join('.');
        /** @type {?} */
        var titleHtml = data.highlight.title || data.properties.nom;
        /** @type {?} */
        var subtitleHtml = data.highlight.title2
            ? ' <small> ' + data.highlight.title2 + '</small>'
            : '';
        /** @type {?} */
        var subtitleHtml2 = data.highlight.title3
            ? '<br><small> ' + data.highlight.title3 + '</small>'
            : '';
        return {
            source: this,
            data: {
                type: FEATURE,
                projection: 'EPSG:4326',
                geometry: data.geometry,
                extent: data.bbox,
                properties: properties,
                meta: {
                    id: id,
                    title: data.properties.nom
                }
            },
            meta: {
                dataType: FEATURE,
                id: id,
                title: data.properties.nom,
                titleHtml: titleHtml + subtitleHtml + subtitleHtml2,
                icon: data.icon || 'map-marker',
                nextPage: response.features.length % +this.options.params.limit === 0 && +this.options.params.page < 10
            }
        };
    };
    /**
     * @private
     * @param {?} data
     * @return {?}
     */
    IChercheSearchSource.prototype.computeProperties = /**
     * @private
     * @param {?} data
     * @return {?}
     */
    function (data) {
        /** @type {?} */
        var properties = ObjectUtils.removeKeys(data.properties, IChercheSearchSource.propertiesBlacklist);
        if (data.geometry === undefined) {
            return Object.assign({ type: data.index }, properties);
        }
        /** @type {?} */
        var googleLinksProperties = {
            GoogleMaps: ''
        };
        /** @type {?} */
        var googleMaps;
        if (data.geometry.type === 'Point') {
            googleMaps = GoogleLinks.getGoogleMapsCoordLink(data.geometry.coordinates[0], data.geometry.coordinates[1]);
        }
        else {
            /** @type {?} */
            var point = pointOnFeature(data.geometry);
            googleMaps = GoogleLinks.getGoogleMapsCoordLink(point.geometry.coordinates[0], point.geometry.coordinates[1]);
        }
        /** @type {?} */
        var googleMapsNom;
        if (data.index === 'routes') {
            googleMapsNom = GoogleLinks.getGoogleMapsNameLink(data.properties.nom + ', ' + data.properties.municipalite);
        }
        else if (data.index === 'municipalites') {
            googleMapsNom = GoogleLinks.getGoogleMapsNameLink(data.properties.nom + ', ' + data.properties.regAdmin);
        }
        else {
            googleMapsNom = GoogleLinks.getGoogleMapsNameLink(data.properties.nom || data.highlight.title);
        }
        googleLinksProperties.GoogleMaps = '<a href=' + googleMaps + ' target="_blank">' +
            this.languageService.translate.instant('igo.geo.searchByCoord') + '</a> <br /> <a href=' + googleMapsNom +
            ' target="_blank">' + this.languageService.translate.instant('igo.geo.searchByName') + '</a>';
        if (data.geometry.type === 'Point') {
            googleLinksProperties.GoogleStreetView = GoogleLinks.getGoogleStreetViewLink(data.geometry.coordinates[0], data.geometry.coordinates[1]);
        }
        return Object.assign({ type: data.index }, properties, googleLinksProperties);
    };
    /**
     * Remove hashtag from query
     * @param term Query with hashtag
     */
    /**
     * Remove hashtag from query
     * @private
     * @param {?} term Query with hashtag
     * @return {?}
     */
    IChercheSearchSource.prototype.computeTerm = /**
     * Remove hashtag from query
     * @private
     * @param {?} term Query with hashtag
     * @return {?}
     */
    function (term) {
        var _this = this;
        // Keep hashtags for "lieux"
        /** @type {?} */
        var hashtags = term.match(/(#[^\s]+)/g) || [];
        /** @type {?} */
        var keep = false;
        keep = hashtags.some((/**
         * @param {?} hashtag
         * @return {?}
         */
        function (hashtag) {
            /** @type {?} */
            var hashtagKey = hashtag.substring(1);
            return _this.hashtagsLieuxToKeep.some((/**
             * @param {?} h
             * @return {?}
             */
            function (h) {
                return h
                    .toLowerCase()
                    .normalize('NFD')
                    .replace(/[\u0300-\u036f]/g, '') ===
                    hashtagKey
                        .toLowerCase()
                        .normalize('NFD')
                        .replace(/[\u0300-\u036f]/g, '');
            }));
        }));
        if (!keep) {
            term = term.replace(/(#[^\s]*)/g, '');
        }
        return term.replace(/[^\wÀ-ÿ !\-\(\),'#]+/g, '');
    };
    /**
     * Add hashtag to param if valid
     * @param term Query with hashtag
     * @param options TextSearchOptions
     */
    /**
     * Add hashtag to param if valid
     * @private
     * @param {?} term Query with hashtag
     * @param {?} options TextSearchOptions
     * @return {?}
     */
    IChercheSearchSource.prototype.computeOptionsParam = /**
     * Add hashtag to param if valid
     * @private
     * @param {?} term Query with hashtag
     * @param {?} options TextSearchOptions
     * @return {?}
     */
    function (term, options) {
        /** @type {?} */
        var hashtags = _super.prototype.getHashtagsValid.call(this, term, 'type');
        if (hashtags) {
            options.params = Object.assign(options.params || {}, {
                type: hashtags.join(',')
            });
        }
        return options;
    };
    IChercheSearchSource.id = 'icherche';
    IChercheSearchSource.type = FEATURE;
    IChercheSearchSource.propertiesBlacklist = [];
    IChercheSearchSource.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    IChercheSearchSource.ctorParameters = function () { return [
        { type: HttpClient },
        { type: LanguageService },
        { type: undefined, decorators: [{ type: Inject, args: ['options',] }] },
        { type: IChercheSearchResultFormatter, decorators: [{ type: Inject, args: [IChercheSearchResultFormatter,] }] },
        { type: Injector }
    ]; };
    return IChercheSearchSource;
}(SearchSource));
/**
 * IChercheReverse search source
 */
var IChercheReverseSearchSource = /** @class */ (function (_super) {
    __extends(IChercheReverseSearchSource, _super);
    function IChercheReverseSearchSource(http, languageService, options, injector) {
        var _this = _super.call(this, options) || this;
        _this.http = http;
        _this.languageService = languageService;
        _this.title$ = new BehaviorSubject('');
        _this.languageService.translate
            .get(_this.options.title)
            .subscribe((/**
         * @param {?} title
         * @return {?}
         */
        function (title) { return _this.title$.next(title); }));
        /** @type {?} */
        var authService = injector.get(AuthService);
        if (_this.settings.length) {
            if (!authService) {
                _this.getAllowedTypes();
            }
            else {
                authService.authenticate$.subscribe((/**
                 * @return {?}
                 */
                function () {
                    _this.getAllowedTypes();
                }));
            }
        }
        return _this;
    }
    Object.defineProperty(IChercheReverseSearchSource.prototype, "title", {
        get: /**
         * @return {?}
         */
        function () {
            return this.title$.getValue();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    IChercheReverseSearchSource.prototype.getId = /**
     * @return {?}
     */
    function () {
        return IChercheReverseSearchSource.id;
    };
    /**
     * @return {?}
     */
    IChercheReverseSearchSource.prototype.getType = /**
     * @return {?}
     */
    function () {
        return IChercheReverseSearchSource.type;
    };
    /**
     * @protected
     * @return {?}
     */
    IChercheReverseSearchSource.prototype.getDefaultOptions = /**
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var types = this.options.params && this.options.params.type
            ? this.options.params.type
                .replace(/\s/g, '')
                .toLowerCase()
                .split(',')
            : ['adresses', 'municipalites', 'mrc', 'regadmin'];
        return {
            title: 'igo.geo.search.ichercheReverse.name',
            searchUrl: 'https://geoegl.msp.gouv.qc.ca/apis/terrapi',
            settings: [
                {
                    type: 'checkbox',
                    title: 'results type',
                    name: 'type',
                    values: [
                        {
                            title: 'igo.geo.search.icherche.type.address',
                            value: 'adresses',
                            enabled: types.indexOf('adresses') !== -1
                        },
                        {
                            title: 'igo.geo.search.icherche.type.road',
                            value: 'routes',
                            enabled: types.indexOf('routes') !== -1,
                            available: false
                        },
                        {
                            title: 'igo.geo.search.icherche.type.district',
                            value: 'arrondissements',
                            enabled: types.indexOf('arrondissements') !== -1
                        },
                        {
                            title: 'igo.geo.search.icherche.type.city',
                            value: 'municipalites',
                            enabled: types.indexOf('municipalites') !== -1
                        },
                        {
                            title: 'igo.geo.search.icherche.type.mrc',
                            value: 'mrc',
                            enabled: types.indexOf('mrc') !== -1
                        },
                        {
                            title: 'igo.geo.search.icherche.type.regadmin',
                            value: 'regadmin',
                            enabled: types.indexOf('regadmin') !== -1
                        }
                    ]
                },
                {
                    type: 'radiobutton',
                    title: 'radius',
                    name: 'buffer',
                    values: [
                        {
                            title: '100 m',
                            value: 100,
                            enabled: !this.options.distance || this.options.distance === 100
                        },
                        {
                            title: '500 m',
                            value: 500,
                            enabled: this.options.distance === 500
                        },
                        {
                            title: '1 km',
                            value: 1000,
                            enabled: this.options.distance === 1000
                        },
                        {
                            title: '2 km',
                            value: 2000,
                            enabled: this.options.distance === 2000
                        },
                        {
                            title: '5 km',
                            value: 5000,
                            enabled: this.options.distance === 5000
                        }
                    ]
                }
            ]
        };
    };
    /**
     * Search a location by coordinates
     * @param lonLat Location coordinates
     * @param distance Search raidus around lonLat
     * @returns Observable of <SearchResult<Feature>[]
     */
    /**
     * Search a location by coordinates
     * @param {?} lonLat Location coordinates
     * @param {?=} options
     * @return {?} Observable of <SearchResult<Feature>[]
     */
    IChercheReverseSearchSource.prototype.reverseSearch = /**
     * Search a location by coordinates
     * @param {?} lonLat Location coordinates
     * @param {?=} options
     * @return {?} Observable of <SearchResult<Feature>[]
     */
    function (lonLat, options) {
        var _this = this;
        /** @type {?} */
        var params = this.computeRequestParams(lonLat, options || {});
        if (!params.get('type').length) {
            return of([]);
        }
        return this.http.get(this.searchUrl + "/locate", { params: params }).pipe(map((/**
         * @param {?} response
         * @return {?}
         */
        function (response) {
            return _this.extractResults(response);
        })));
    };
    /**
     * @private
     * @return {?}
     */
    IChercheReverseSearchSource.prototype.getAllowedTypes = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        return this.http
            .get(this.searchUrl + "/types")
            .subscribe((/**
         * @param {?} types
         * @return {?}
         */
        function (types) {
            /** @type {?} */
            var typeSetting = _this.settings.find((/**
             * @param {?} s
             * @return {?}
             */
            function (s) { return s.name === 'type'; }));
            typeSetting.values.forEach((/**
             * @param {?} v
             * @return {?}
             */
            function (v) {
                v.available = types.indexOf((/** @type {?} */ (v.value))) > -1;
            }));
        }));
    };
    /**
     * @private
     * @param {?} lonLat
     * @param {?=} options
     * @return {?}
     */
    IChercheReverseSearchSource.prototype.computeRequestParams = /**
     * @private
     * @param {?} lonLat
     * @param {?=} options
     * @return {?}
     */
    function (lonLat, options) {
        if (options.distance || this.options.distance) {
            options.params = Object.assign(options.params || {}, {
                buffer: options.distance || this.options.distance
            });
        }
        return new HttpParams({
            fromObject: Object.assign({
                loc: lonLat.join(','),
                sort: 'distance',
                geometry: true,
                icon: true
            }, options.params || {}, this.params)
        });
    };
    /**
     * @private
     * @param {?} response
     * @return {?}
     */
    IChercheReverseSearchSource.prototype.extractResults = /**
     * @private
     * @param {?} response
     * @return {?}
     */
    function (response) {
        var _this = this;
        return response.features.map((/**
         * @param {?} data
         * @return {?}
         */
        function (data) {
            return _this.dataToResult(data);
        }));
    };
    /**
     * @private
     * @param {?} data
     * @return {?}
     */
    IChercheReverseSearchSource.prototype.getSubtitle = /**
     * @private
     * @param {?} data
     * @return {?}
     */
    function (data) {
        if (!this.settings.length) {
            return '';
        }
        /** @type {?} */
        var subtitle = '';
        switch (data.properties.type) {
            case 'arrondissements':
                subtitle = data.properties.municipalite + ' (Arrondissement)';
                break;
            default:
                /** @type {?} */
                var typeSetting = this.settings.find((/**
                 * @param {?} s
                 * @return {?}
                 */
                function (s) { return s.name === 'type'; }));
                /** @type {?} */
                var type = typeSetting.values.find((/**
                 * @param {?} t
                 * @return {?}
                 */
                function (t) { return t.value === data.properties.type; }));
                if (type) {
                    subtitle = this.languageService.translate.instant(type.title);
                }
        }
        return subtitle;
    };
    /**
     * @private
     * @param {?} data
     * @return {?}
     */
    IChercheReverseSearchSource.prototype.dataToResult = /**
     * @private
     * @param {?} data
     * @return {?}
     */
    function (data) {
        /** @type {?} */
        var properties = this.computeProperties(data);
        /** @type {?} */
        var extent = this.computeExtent(data);
        /** @type {?} */
        var id = [this.getId(), properties.type, properties.code].join('.');
        /** @type {?} */
        var titleHtml = data.properties.nom;
        /** @type {?} */
        var subtitleHtml = ' <small> ' + this.getSubtitle(data) + '</small>';
        return {
            source: this,
            data: {
                type: FEATURE,
                projection: 'EPSG:4326',
                geometry: data.geometry,
                extent: extent,
                properties: properties,
                meta: {
                    id: id,
                    title: data.properties.nom
                }
            },
            meta: {
                dataType: FEATURE,
                id: id,
                title: data.properties.nom,
                titleHtml: titleHtml + subtitleHtml,
                icon: data.icon || 'map-marker'
            }
        };
    };
    /**
     * @private
     * @param {?} data
     * @return {?}
     */
    IChercheReverseSearchSource.prototype.computeProperties = /**
     * @private
     * @param {?} data
     * @return {?}
     */
    function (data) {
        /** @type {?} */
        var properties = ObjectUtils.removeKeys(data.properties, IChercheReverseSearchSource.propertiesBlacklist);
        return properties;
    };
    /**
     * @private
     * @param {?} data
     * @return {?}
     */
    IChercheReverseSearchSource.prototype.computeExtent = /**
     * @private
     * @param {?} data
     * @return {?}
     */
    function (data) {
        return data.bbox
            ? [data.bbox[0], data.bbox[2], data.bbox[1], data.bbox[3]]
            : undefined;
    };
    IChercheReverseSearchSource.id = 'icherchereverse';
    IChercheReverseSearchSource.type = FEATURE;
    IChercheReverseSearchSource.propertiesBlacklist = [];
    IChercheReverseSearchSource.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    IChercheReverseSearchSource.ctorParameters = function () { return [
        { type: HttpClient },
        { type: LanguageService },
        { type: undefined, decorators: [{ type: Inject, args: ['options',] }] },
        { type: Injector }
    ]; };
    return IChercheReverseSearchSource;
}(SearchSource));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * ICherche search result formatter factory
 * @ignore
 * @param {?} languageService
 * @return {?}
 */
function defaultIChercheSearchResultFormatterFactory(languageService) {
    return new IChercheSearchResultFormatter(languageService);
}
/**
 * Function that returns a provider for the ICherche search result formatter
 * @return {?}
 */
function provideDefaultIChercheSearchResultFormatter() {
    return {
        provide: IChercheSearchResultFormatter,
        useFactory: defaultIChercheSearchResultFormatterFactory,
        deps: [LanguageService]
    };
}
/**
 * ICherche search source factory
 * @ignore
 * @param {?} http
 * @param {?} languageService
 * @param {?} config
 * @param {?} formatter
 * @param {?} injector
 * @return {?}
 */
function ichercheSearchSourceFactory(http, languageService, config, formatter, injector) {
    return new IChercheSearchSource(http, languageService, config.getConfig("searchSources." + IChercheSearchSource.id), formatter, injector);
}
/**
 * Function that returns a provider for the ICherche search source
 * @return {?}
 */
function provideIChercheSearchSource() {
    return {
        provide: SearchSource,
        useFactory: ichercheSearchSourceFactory,
        multi: true,
        deps: [
            HttpClient,
            LanguageService,
            ConfigService,
            IChercheSearchResultFormatter,
            Injector
        ]
    };
}
/**
 * IChercheReverse search source factory
 * @ignore
 * @param {?} http
 * @param {?} languageService
 * @param {?} config
 * @param {?} injector
 * @return {?}
 */
function ichercheReverseSearchSourceFactory(http, languageService, config, injector) {
    return new IChercheReverseSearchSource(http, languageService, config.getConfig("searchSources." + IChercheReverseSearchSource.id), injector);
}
/**
 * Function that returns a provider for the IChercheReverse search source
 * @return {?}
 */
function provideIChercheReverseSearchSource() {
    return {
        provide: SearchSource,
        useFactory: ichercheReverseSearchSourceFactory,
        multi: true,
        deps: [HttpClient, LanguageService, ConfigService, Injector]
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var CoordinatesSearchResultFormatter = /** @class */ (function () {
    function CoordinatesSearchResultFormatter(languageService) {
        this.languageService = languageService;
    }
    /**
     * @param {?} result
     * @return {?}
     */
    CoordinatesSearchResultFormatter.prototype.formatResult = /**
     * @param {?} result
     * @return {?}
     */
    function (result) {
        return result;
    };
    CoordinatesSearchResultFormatter.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    CoordinatesSearchResultFormatter.ctorParameters = function () { return [
        { type: LanguageService }
    ]; };
    return CoordinatesSearchResultFormatter;
}());
/**
 * CoordinatesReverse search source
 */
var CoordinatesReverseSearchSource = /** @class */ (function (_super) {
    __extends(CoordinatesReverseSearchSource, _super);
    function CoordinatesReverseSearchSource(options, languageService, projections) {
        var _this = _super.call(this, options) || this;
        _this.languageService = languageService;
        _this.title$ = new BehaviorSubject('');
        _this.projections = projections;
        _this.languageService.translate
            .get(_this.options.title)
            .subscribe((/**
         * @param {?} title
         * @return {?}
         */
        function (title) { return _this.title$.next(title); }));
        return _this;
    }
    Object.defineProperty(CoordinatesReverseSearchSource.prototype, "title", {
        get: /**
         * @return {?}
         */
        function () {
            return this.title$.getValue();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    CoordinatesReverseSearchSource.prototype.getId = /**
     * @return {?}
     */
    function () {
        return CoordinatesReverseSearchSource.id;
    };
    /**
     * @return {?}
     */
    CoordinatesReverseSearchSource.prototype.getType = /**
     * @return {?}
     */
    function () {
        return CoordinatesReverseSearchSource.type;
    };
    /**
     * @protected
     * @return {?}
     */
    CoordinatesReverseSearchSource.prototype.getDefaultOptions = /**
     * @protected
     * @return {?}
     */
    function () {
        return {
            title: 'igo.geo.search.coordinates.name',
            order: 1,
            showInSettings: false
        };
    };
    /**
     * Search a location by coordinates
     * @param lonLat Location coordinates
     * @param distance Search raidus around lonLat
     * @returns Observable of <SearchResult<Feature>[]
     */
    /**
     * Search a location by coordinates
     * @param {?} lonLat Location coordinates
     * @param {?=} options
     * @return {?} Observable of <SearchResult<Feature>[]
     */
    CoordinatesReverseSearchSource.prototype.reverseSearch = /**
     * Search a location by coordinates
     * @param {?} lonLat Location coordinates
     * @param {?=} options
     * @return {?} Observable of <SearchResult<Feature>[]
     */
    function (lonLat, options) {
        return of([this.dataToResult(lonLat)]);
    };
    /**
     * @private
     * @param {?} data
     * @return {?}
     */
    CoordinatesReverseSearchSource.prototype.dataToResult = /**
     * @private
     * @param {?} data
     * @return {?}
     */
    function (data) {
        /** @type {?} */
        var convertedCoord = lonLatConversion(data, this.projections);
        /** @type {?} */
        var coords = convertedCoord.reduce((/**
         * @param {?} obj
         * @param {?} item
         * @return {?}
         */
        function (obj, item) { return (obj[item.alias] = item.igo2CoordFormat, obj); }), {});
        /** @type {?} */
        var roundedCoordString = roundCoordTo(data, 6).join(', ');
        /** @type {?} */
        var coordKey = this.languageService.translate.instant('igo.geo.search.coordinates.coord');
        /** @type {?} */
        var coordLonLat = {};
        coordLonLat[coordKey] = roundedCoordString;
        return {
            source: this,
            data: {
                type: FEATURE,
                projection: 'EPSG:4326',
                geometry: {
                    type: 'Point',
                    coordinates: [data[0], data[1]]
                },
                extent: undefined,
                properties: Object.assign({}, coordLonLat, coords, {
                    GoogleMaps: GoogleLinks.getGoogleMapsCoordLink(data[0], data[1]),
                    GoogleStreetView: GoogleLinks.getGoogleStreetViewLink(data[0], data[1]),
                    OpenStreetMap: OsmLinks.getOpenStreetMapLink(data[0], data[1], 14)
                }),
                meta: {
                    id: data[0].toString() + ',' + data[1].toString(),
                    title: roundedCoordString
                }
            },
            meta: {
                dataType: FEATURE,
                id: data[0].toString() + ',' + data[1].toString(),
                title: roundedCoordString,
                icon: 'map-marker'
            }
        };
    };
    CoordinatesReverseSearchSource.id = 'coordinatesreverse';
    CoordinatesReverseSearchSource.type = FEATURE;
    CoordinatesReverseSearchSource.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    CoordinatesReverseSearchSource.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: ['options',] }] },
        { type: LanguageService },
        { type: Array, decorators: [{ type: Inject, args: ['projections',] }] }
    ]; };
    return CoordinatesReverseSearchSource;
}(SearchSource));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * ICherche search result formatter factory
 * @ignore
 * @param {?} languageService
 * @return {?}
 */
function defaultCoordinatesSearchResultFormatterFactory(languageService) {
    return new CoordinatesSearchResultFormatter(languageService);
}
/**
 * Function that returns a provider for the ICherche search result formatter
 * @return {?}
 */
function provideDefaultCoordinatesSearchResultFormatter() {
    return {
        provide: CoordinatesSearchResultFormatter,
        useFactory: defaultCoordinatesSearchResultFormatterFactory,
        deps: [LanguageService]
    };
}
/**
 * CoordinatesReverse search source factory
 * @ignore
 * @param {?} config
 * @param {?} languageService
 * @param {?} _projectionService
 * @return {?}
 */
function CoordinatesReverseSearchSourceFactory(config, languageService, _projectionService) {
    return new CoordinatesReverseSearchSource(config.getConfig("searchSources." + CoordinatesReverseSearchSource.id), languageService, ((/** @type {?} */ (config.getConfig('projections')))) || []);
}
/**
 * Function that returns a provider for the IChercheReverse search source
 * @return {?}
 */
function provideCoordinatesReverseSearchSource() {
    return {
        provide: SearchSource,
        useFactory: CoordinatesReverseSearchSourceFactory,
        multi: true,
        deps: [ConfigService, LanguageService, ProjectionService]
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ILayerSearchResultFormatter = /** @class */ (function () {
    function ILayerSearchResultFormatter(languageService) {
        this.languageService = languageService;
    }
    /**
     * @param {?} data
     * @return {?}
     */
    ILayerSearchResultFormatter.prototype.formatResult = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        var _this = this;
        /** @type {?} */
        var allowedKey = [
            'title',
            'abstract',
            'groupTitle',
            'metadataUrl',
            'downloadUrl',
            'urlInfo',
            'name'
        ];
        /** @type {?} */
        var property = Object.entries(data.properties)
            .filter((/**
         * @param {?} __0
         * @return {?}
         */
        function (_a) {
            var _b = __read(_a, 1), key = _b[0];
            return allowedKey.indexOf(key) !== -1;
        }))
            .reduce((/**
         * @param {?} out
         * @param {?} entries
         * @return {?}
         */
        function (out, entries) {
            var _a = __read(entries, 2), key = _a[0], value = _a[1];
            /** @type {?} */
            var newKey;
            try {
                newKey = _this.languageService.translate.instant('igo.geo.search.ilayer.properties.' + key);
            }
            catch (e) {
                newKey = key;
            }
            out[newKey] = value ? value : '';
            return out;
        }), {});
        /** @type {?} */
        var dataR = Object.assign({}, data);
        dataR.properties = (/** @type {?} */ (property));
        return dataR;
    };
    ILayerSearchResultFormatter.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    ILayerSearchResultFormatter.ctorParameters = function () { return [
        { type: LanguageService }
    ]; };
    return ILayerSearchResultFormatter;
}());
/**
 * ILayer search source
 */
var ILayerSearchSource = /** @class */ (function (_super) {
    __extends(ILayerSearchSource, _super);
    function ILayerSearchSource(http, languageService, options, formatter) {
        var _this = _super.call(this, options) || this;
        _this.http = http;
        _this.languageService = languageService;
        _this.formatter = formatter;
        _this.title$ = new BehaviorSubject('');
        _this.languageService.translate
            .get(_this.options.title)
            .subscribe((/**
         * @param {?} title
         * @return {?}
         */
        function (title) { return _this.title$.next(title); }));
        return _this;
    }
    Object.defineProperty(ILayerSearchSource.prototype, "title", {
        get: /**
         * @return {?}
         */
        function () {
            return this.title$.getValue();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ILayerSearchSource.prototype.getId = /**
     * @return {?}
     */
    function () {
        return ILayerSearchSource.id;
    };
    /**
     * @return {?}
     */
    ILayerSearchSource.prototype.getType = /**
     * @return {?}
     */
    function () {
        return ILayerSearchSource.type;
    };
    /**
     * @protected
     * @return {?}
     */
    ILayerSearchSource.prototype.getDefaultOptions = /**
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var limit = this.options.params && this.options.params.limit
            ? Number(this.options.params.limit)
            : undefined;
        return {
            title: 'igo.geo.search.ilayer.name',
            searchUrl: 'https://geoegl.msp.gouv.qc.ca/apis/layers/search',
            settings: [
                {
                    type: 'checkbox',
                    title: 'results type',
                    name: 'type',
                    values: [
                        {
                            title: 'igo.geo.search.ilayer.type.layer',
                            value: 'layer',
                            enabled: true,
                            hashtags: ['layer', 'layers', 'couche', 'couches']
                        },
                        {
                            title: 'igo.geo.search.ilayer.type.groupLayer',
                            value: 'group',
                            enabled: false,
                            hashtags: ['gr-layer', 'gr-layers', 'gr-couche', 'gr-couches']
                        }
                    ]
                },
                {
                    type: 'radiobutton',
                    title: 'results limit',
                    name: 'limit',
                    values: [
                        {
                            title: '1',
                            value: 1,
                            enabled: limit === 1
                        },
                        {
                            title: '5',
                            value: 5,
                            enabled: limit === 5 || !limit
                        },
                        {
                            title: '10',
                            value: 10,
                            enabled: limit === 10
                        },
                        {
                            title: '25',
                            value: 25,
                            enabled: limit === 25
                        },
                        {
                            title: '50',
                            value: 50,
                            enabled: limit === 50
                        }
                    ]
                }
            ]
        };
    };
    /**
     * Search a layer by name or keyword
     * @param term Layer name or keyword
     * @returns Observable of <SearchResult<LayerOptions>[]
     */
    /**
     * Search a layer by name or keyword
     * @param {?} term Layer name or keyword
     * @param {?=} options
     * @return {?} Observable of <SearchResult<LayerOptions>[]
     */
    ILayerSearchSource.prototype.search = /**
     * Search a layer by name or keyword
     * @param {?} term Layer name or keyword
     * @param {?=} options
     * @return {?} Observable of <SearchResult<LayerOptions>[]
     */
    function (term, options) {
        var _this = this;
        /** @type {?} */
        var params = this.computeSearchRequestParams(term, options || {});
        if (!params.get('q') || !params.get('type')) {
            return of([]);
        }
        this.options.params.page = params.get('page') || '1';
        return this.http
            .get(this.searchUrl, { params: params })
            .pipe(map((/**
         * @param {?} response
         * @return {?}
         */
        function (response) { return _this.extractResults(response); })));
    };
    /**
     * @private
     * @param {?} term
     * @param {?} options
     * @return {?}
     */
    ILayerSearchSource.prototype.computeSearchRequestParams = /**
     * @private
     * @param {?} term
     * @param {?} options
     * @return {?}
     */
    function (term, options) {
        return new HttpParams({
            fromObject: ObjectUtils.removeUndefined(Object.assign({
                q: this.computeTerm(term)
            }, this.params, this.computeOptionsParam(term, options || {}).params, {
                page: options.page
            }))
        });
    };
    /**
     * Remove hashtag from query
     * @param term Query with hashtag
     */
    /**
     * Remove hashtag from query
     * @private
     * @param {?} term Query with hashtag
     * @return {?}
     */
    ILayerSearchSource.prototype.computeTerm = /**
     * Remove hashtag from query
     * @private
     * @param {?} term Query with hashtag
     * @return {?}
     */
    function (term) {
        return term.replace(/(#[^\s]*)/g, '').replace(/[^\wÀ-ÿ !\-\(\),'#]+/g, '');
    };
    /**
     * Add hashtag to param if valid
     * @param term Query with hashtag
     * @param options TextSearchOptions
     */
    /**
     * Add hashtag to param if valid
     * @private
     * @param {?} term Query with hashtag
     * @param {?} options TextSearchOptions
     * @return {?}
     */
    ILayerSearchSource.prototype.computeOptionsParam = /**
     * Add hashtag to param if valid
     * @private
     * @param {?} term Query with hashtag
     * @param {?} options TextSearchOptions
     * @return {?}
     */
    function (term, options) {
        /** @type {?} */
        var hashtags = _super.prototype.getHashtagsValid.call(this, term, 'type');
        if (hashtags) {
            options.params = Object.assign(options.params || {}, {
                type: hashtags.join(',')
            });
        }
        return options;
    };
    /**
     * @private
     * @param {?} response
     * @return {?}
     */
    ILayerSearchSource.prototype.extractResults = /**
     * @private
     * @param {?} response
     * @return {?}
     */
    function (response) {
        var _this = this;
        return response.items.map((/**
         * @param {?} data
         * @return {?}
         */
        function (data) {
            return _this.dataToResult(data, response);
        }));
    };
    /**
     * @private
     * @param {?} data
     * @param {?=} response
     * @return {?}
     */
    ILayerSearchSource.prototype.dataToResult = /**
     * @private
     * @param {?} data
     * @param {?=} response
     * @return {?}
     */
    function (data, response) {
        /** @type {?} */
        var layerOptions = this.computeLayerOptions(data);
        /** @type {?} */
        var titleHtml = data.highlight.title || data.properties.title;
        /** @type {?} */
        var groupTitle = data.highlight.groupTitle || data.properties.groupTitle;
        /** @type {?} */
        var subtitleHtml = groupTitle
            ? ' <small style="color: #6f6969"> ' + groupTitle + '</small>'
            : '';
        return {
            source: this,
            meta: {
                dataType: LAYER,
                id: [this.getId(), data.properties.id].join('.'),
                title: data.properties.title,
                titleHtml: titleHtml + subtitleHtml,
                icon: data.properties.type === 'Layer' ? 'layers' : 'map',
                nextPage: response.items.length % +this.options.params.limit === 0 &&
                    +this.options.params.page < 10
            },
            data: layerOptions
        };
    };
    /**
     * @private
     * @param {?} data
     * @return {?}
     */
    ILayerSearchSource.prototype.computeLayerOptions = /**
     * @private
     * @param {?} data
     * @return {?}
     */
    function (data) {
        /** @type {?} */
        var url = data.properties.url;
        /** @type {?} */
        var queryParams = this.extractQueryParamsFromSourceUrl(url);
        return ObjectUtils.removeUndefined({
            sourceOptions: {
                id: data.properties.id,
                type: data.properties.format,
                url: url,
                queryFormat: queryParams.queryFormat,
                queryHtmlTarget: queryParams.queryHtmlTarget,
                params: {
                    LAYERS: data.properties.name
                },
                optionsFromCapabilities: true,
                crossOrigin: 'anonymous'
            },
            title: data.properties.title,
            maxResolution: getResolutionFromScale(Number(data.properties.maxScaleDenom)),
            minResolution: getResolutionFromScale(Number(data.properties.minScaleDenom)),
            metadata: {
                url: data.properties.metadataUrl,
                extern: true
            },
            properties: this.formatter.formatResult(data).properties
        });
    };
    /**
     * @private
     * @param {?} url
     * @return {?}
     */
    ILayerSearchSource.prototype.extractQueryParamsFromSourceUrl = /**
     * @private
     * @param {?} url
     * @return {?}
     */
    function (url) {
        var e_1, _a;
        /** @type {?} */
        var queryFormat;
        /** @type {?} */
        var queryHtmlTarget;
        /** @type {?} */
        var formatOpt = ((/** @type {?} */ (this.options))).queryFormat;
        if (formatOpt) {
            var _loop_1 = function (key) {
                /** @type {?} */
                var value = formatOpt[key];
                if (value === '*') {
                    queryFormat = QueryFormat[key.toUpperCase()];
                    return "break";
                }
                /** @type {?} */
                var urls = ((/** @type {?} */ (((/** @type {?} */ (value)))))).urls;
                if (Array.isArray(urls)) {
                    urls.forEach((/**
                     * @param {?} urlOpt
                     * @return {?}
                     */
                    function (urlOpt) {
                        if (url.indexOf(urlOpt) !== -1) {
                            queryFormat = QueryFormat[key.toUpperCase()];
                        }
                    }));
                    return "break";
                }
            };
            try {
                for (var _b = __values(Object.keys(formatOpt)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var key = _c.value;
                    var state_1 = _loop_1(key);
                    if (state_1 === "break")
                        break;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            if (queryFormat === QueryFormat.HTML ||
                queryFormat === QueryFormat.HTMLGML2) {
                queryHtmlTarget = 'iframe';
            }
        }
        return {
            queryFormat: queryFormat,
            queryHtmlTarget: queryHtmlTarget
        };
    };
    ILayerSearchSource.id = 'ilayer';
    ILayerSearchSource.type = LAYER;
    ILayerSearchSource.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    ILayerSearchSource.ctorParameters = function () { return [
        { type: HttpClient },
        { type: LanguageService },
        { type: undefined, decorators: [{ type: Inject, args: ['options',] }] },
        { type: ILayerSearchResultFormatter, decorators: [{ type: Inject, args: [ILayerSearchResultFormatter,] }] }
    ]; };
    return ILayerSearchSource;
}(SearchSource));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * ILayer search result formatter factory
 * @ignore
 * @param {?} languageService
 * @return {?}
 */
function ilayerSearchResultFormatterFactory(languageService) {
    return new ILayerSearchResultFormatter(languageService);
}
/**
 * Function that returns a provider for the ILayer search result formatter
 * @return {?}
 */
function provideILayerSearchResultFormatter() {
    return {
        provide: ILayerSearchResultFormatter,
        useFactory: ilayerSearchResultFormatterFactory,
        deps: [LanguageService]
    };
}
/**
 * ILayer search source factory
 * @ignore
 * @param {?} http
 * @param {?} languageService
 * @param {?} config
 * @param {?} formatter
 * @return {?}
 */
function ilayerSearchSourceFactory(http, languageService, config, formatter) {
    return new ILayerSearchSource(http, languageService, config.getConfig("searchSources." + ILayerSearchSource.id), formatter);
}
/**
 * Function that returns a provider for the ILayer search source
 * @return {?}
 */
function provideILayerSearchSource() {
    return {
        provide: SearchSource,
        useFactory: ilayerSearchSourceFactory,
        multi: true,
        deps: [HttpClient, LanguageService, ConfigService, ILayerSearchResultFormatter]
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var SEARCH_TYPES = [FEATURE, LAYER];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * This component allows a user to select a search type yo enable. In it's
 * current version, only one search type can be selected at once (radio). If
 * this component were to support more than one search source enabled (checkbox),
 * the searchbar component would require a small change to it's
 * placeholder getter. The search source service already supports having
 * more than one search source enabled.
 */
var SearchSelectorComponent = /** @class */ (function () {
    function SearchSelectorComponent(searchSourceService) {
        this.searchSourceService = searchSourceService;
        this.searchType$ = new BehaviorSubject(undefined);
        /**
         * List of available search types
         */
        this.searchTypes = SEARCH_TYPES;
        /**
         * Event emitted when the enabled search type changes
         */
        this.searchTypeChange = new EventEmitter();
    }
    Object.defineProperty(SearchSelectorComponent.prototype, "searchType", {
        get: /**
         * @return {?}
         */
        function () { return this.searchType$.value; },
        /**
         * The search type enabled
         */
        set: /**
         * The search type enabled
         * @param {?} value
         * @return {?}
         */
        function (value) { this.setSearchType(value); },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    SearchSelectorComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.searchType$$ = this.searchType$
            .pipe(distinctUntilChanged())
            .subscribe((/**
         * @param {?} searchType
         * @return {?}
         */
        function (searchType) { return _this.onSetSearchType(searchType); }));
    };
    /**
     * @return {?}
     */
    SearchSelectorComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.searchType$$.unsubscribe();
    };
    /**
     * Enable the selected search type
     * @param searchType Search type
     * @internal
     */
    /**
     * Enable the selected search type
     * \@internal
     * @param {?} searchType Search type
     * @return {?}
     */
    SearchSelectorComponent.prototype.onSearchTypeChange = /**
     * Enable the selected search type
     * \@internal
     * @param {?} searchType Search type
     * @return {?}
     */
    function (searchType) {
        this.setSearchType(searchType);
    };
    /**
     * Get a search type's title. The title
     * for all availables search typers needs to be defined in the locale
     * files or an error will be thrown.
     * @param searchType Search type
     * @internal
     */
    /**
     * Get a search type's title. The title
     * for all availables search typers needs to be defined in the locale
     * files or an error will be thrown.
     * \@internal
     * @param {?} searchType Search type
     * @return {?}
     */
    SearchSelectorComponent.prototype.getSearchTypeTitle = /**
     * Get a search type's title. The title
     * for all availables search typers needs to be defined in the locale
     * files or an error will be thrown.
     * \@internal
     * @param {?} searchType Search type
     * @return {?}
     */
    function (searchType) {
        return "igo.geo.search." + searchType.toLowerCase() + ".title";
    };
    /**
     * Emit an event and enable the search sources of the given type.
     * @param searchType Search type
     */
    /**
     * Emit an event and enable the search sources of the given type.
     * @private
     * @param {?} searchType Search type
     * @return {?}
     */
    SearchSelectorComponent.prototype.setSearchType = /**
     * Emit an event and enable the search sources of the given type.
     * @private
     * @param {?} searchType Search type
     * @return {?}
     */
    function (searchType) {
        this.searchType$.next(searchType);
    };
    /**
     * @private
     * @param {?} searchType
     * @return {?}
     */
    SearchSelectorComponent.prototype.onSetSearchType = /**
     * @private
     * @param {?} searchType
     * @return {?}
     */
    function (searchType) {
        if (searchType === undefined || searchType === null) {
            return;
        }
        this.searchSourceService.enableSourcesByType(searchType);
        this.searchTypeChange.emit(searchType);
    };
    SearchSelectorComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igo-search-selector',
                    template: "<div class=\"igo-search-selector\">\r\n  <button\r\n    mat-icon-button\r\n    class=\"igo-search-selector-button\"\r\n    color=\"primary\"\r\n    tooltip-position=\"below\"\r\n    matTooltipShowDelay=\"500\"\r\n    [matTooltip]=\"'igo.geo.search.menu.tooltip' | translate\"\r\n    [matMenuTriggerFor]=\"searchSelectorMenu\">\r\n    <mat-icon svgIcon=\"menu-down\"></mat-icon>\r\n  </button>\r\n\r\n  <mat-menu\r\n    #searchSelectorMenu=\"matMenu\"\r\n    class=\"no-border-radius\"\r\n    xPosition=\"before\"\r\n    yPosition=\"above\">\r\n    <mat-radio-group\r\n      class=\"igo-search-selector-radio-group\"\r\n      [value]=\"searchType$ | async\"\r\n      (change)=\"onSearchTypeChange($event.value)\">\r\n      <mat-radio-button *ngFor=\"let searchType of searchTypes\" [value]=\"searchType\">\r\n        {{getSearchTypeTitle(searchType) | translate}}\r\n      </mat-radio-button>\r\n    </mat-radio-group>\r\n  </mat-menu>\r\n\r\n</div>\r\n",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: [".igo-search-selector-button ::ng-deep div.mat-button-ripple-round{border-radius:0}.igo-search-selector-radio-group{display:-webkit-inline-box;display:inline-flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column}.igo-search-selector-radio-group mat-radio-button{margin:5px}"]
                }] }
    ];
    /** @nocollapse */
    SearchSelectorComponent.ctorParameters = function () { return [
        { type: SearchSourceService }
    ]; };
    SearchSelectorComponent.propDecorators = {
        searchTypes: [{ type: Input }],
        searchType: [{ type: Input }],
        searchTypeChange: [{ type: Output }]
    };
    return SearchSelectorComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @ignore
 */
var IgoSearchSelectorModule = /** @class */ (function () {
    function IgoSearchSelectorModule() {
    }
    IgoSearchSelectorModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        MatTooltipModule,
                        MatIconModule,
                        MatButtonModule,
                        MatMenuModule,
                        MatRadioModule,
                        MatTabsModule,
                        MatCheckboxModule,
                        IgoLanguageModule
                    ],
                    exports: [SearchSelectorComponent],
                    declarations: [SearchSelectorComponent]
                },] }
    ];
    return IgoSearchSelectorModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * This component allows a user to select a search type yo enable. In it's
 * current version, only one search type can be selected at once (radio). If
 * this component were to support more than one search source enabled (checkbox),
 * the searchbar component would require a small change to it's
 * placeholder getter. The search source service already supports having
 * more than one search source enabled.
 */
var SearchSettingsComponent = /** @class */ (function () {
    function SearchSettingsComponent(searchSourceService, mediaService) {
        this.searchSourceService = searchSourceService;
        this.mediaService = mediaService;
        this.hasPointerReverseSearchSource = false;
        this.searchSourcesAllEnabled = false;
        this.buffer = [];
        this.lastKeyTime = Date.now();
        this.pointerSummaryEnabled = false;
        /**
         * Event emitted when the enabled search source changes
         */
        this.searchSourceChange = new EventEmitter();
        /**
         * Event emitted when the pointer summary is activated
         */
        this.pointerSummaryStatus = new EventEmitter();
    }
    Object.defineProperty(SearchSettingsComponent.prototype, "isTouchScreen", {
        get: /**
         * @return {?}
         */
        function () {
            return this.mediaService.isTouchScreen();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} event
     * @return {?}
     */
    SearchSettingsComponent.prototype.handleKeyboardEvent = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (event.keyCode === 113) {
            this.pointerSummaryEnabled = !this.pointerSummaryEnabled;
            this.pointerSummaryStatus.emit(this.pointerSummaryEnabled);
        }
    };
    /**
     * @return {?}
     */
    SearchSettingsComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.hasPointerReverseSearchSource = this.hasReverseSearchSourcesForPointerSummary();
    };
    /**
     * Get all search sources
     * @internal
     */
    /**
     * Get all search sources
     * \@internal
     * @return {?}
     */
    SearchSettingsComponent.prototype.getSearchSources = /**
     * Get all search sources
     * \@internal
     * @return {?}
     */
    function () {
        /** @type {?} */
        var textSearchSources = this.searchSourceService
            .getSources()
            .filter(sourceCanSearch)
            .filter((/**
         * @param {?} s
         * @return {?}
         */
        function (s) { return s.available && s.getId() !== 'map' && s.showInSettings; }));
        /** @type {?} */
        var reverseSearchSources = this.searchSourceService
            .getSources()
            .filter(sourceCanReverseSearch)
            .filter((/**
         * @param {?} s
         * @return {?}
         */
        function (s) { return s.available && s.getId() !== 'map' && s.showInSettings; }));
        /** @type {?} */
        var sources = textSearchSources.concat(reverseSearchSources);
        this.computeSourcesCheckAllBehavior(sources);
        return sources;
    };
    /**
     * Get all search sources usable for pointer summary
     * @internal
     */
    /**
     * Get all search sources usable for pointer summary
     * \@internal
     * @return {?}
     */
    SearchSettingsComponent.prototype.hasReverseSearchSourcesForPointerSummary = /**
     * Get all search sources usable for pointer summary
     * \@internal
     * @return {?}
     */
    function () {
        if (this.searchSourceService.getEnabledSources().filter(sourceCanReverseSearchAsSummary).length) {
            return true;
        }
        else {
            return false;
        }
    };
    /**
     * Triggered when a setting is checked (checkbox style)
     * @internal
     */
    /**
     * Triggered when a setting is checked (checkbox style)
     * \@internal
     * @param {?} event
     * @param {?} source
     * @param {?} setting
     * @param {?} settingValue
     * @return {?}
     */
    SearchSettingsComponent.prototype.settingsValueCheckedCheckbox = /**
     * Triggered when a setting is checked (checkbox style)
     * \@internal
     * @param {?} event
     * @param {?} source
     * @param {?} setting
     * @param {?} settingValue
     * @return {?}
     */
    function (event, source, setting, settingValue) {
        settingValue.enabled = event.checked;
        source.setParamFromSetting(setting);
        this.searchSourceChange.emit(source);
    };
    /**
     * Defining the action to do for check/uncheck checkboxes (settings)
     * return true if all checkbox must be checked
     * return false if all checkbox must be unchecked
     * @internal
     */
    /**
     * Defining the action to do for check/uncheck checkboxes (settings)
     * return true if all checkbox must be checked
     * return false if all checkbox must be unchecked
     * \@internal
     * @param {?} setting
     * @return {?}
     */
    SearchSettingsComponent.prototype.computeSettingCheckAllBehavior = /**
     * Defining the action to do for check/uncheck checkboxes (settings)
     * return true if all checkbox must be checked
     * return false if all checkbox must be unchecked
     * \@internal
     * @param {?} setting
     * @return {?}
     */
    function (setting) {
        if (setting.allEnabled === undefined) {
            if (setting.values.find((/**
             * @param {?} settingValue
             * @return {?}
             */
            function (settingValue) { return settingValue.enabled; }))) {
                setting.allEnabled = false;
            }
            else {
                setting.allEnabled = true;
            }
        }
        else {
            setting.allEnabled = !setting.allEnabled;
        }
    };
    /**
     * Defining the action to do for check/uncheck checkboxes (sources)
     * return true if all checkbox must be checked
     * return false if all checkbox must be unchecked
     * @internal
     */
    /**
     * Defining the action to do for check/uncheck checkboxes (sources)
     * return true if all checkbox must be checked
     * return false if all checkbox must be unchecked
     * \@internal
     * @param {?} sources
     * @return {?}
     */
    SearchSettingsComponent.prototype.computeSourcesCheckAllBehavior = /**
     * Defining the action to do for check/uncheck checkboxes (sources)
     * return true if all checkbox must be checked
     * return false if all checkbox must be unchecked
     * \@internal
     * @param {?} sources
     * @return {?}
     */
    function (sources) {
        /** @type {?} */
        var enabledSourcesCnt = sources.filter((/**
         * @param {?} source
         * @return {?}
         */
        function (source) { return source.enabled; })).length;
        /** @type {?} */
        var disabledSourcesCnt = sources.filter((/**
         * @param {?} source
         * @return {?}
         */
        function (source) { return !source.enabled; })).length;
        this.searchSourcesAllEnabled = enabledSourcesCnt >= disabledSourcesCnt ? false : true;
    };
    /**
     * Triggered when the check all / uncheck all type is clicked,
     * @internal
     */
    /**
     * Triggered when the check all / uncheck all type is clicked,
     * \@internal
     * @param {?} event
     * @param {?} source
     * @param {?} setting
     * @return {?}
     */
    SearchSettingsComponent.prototype.checkUncheckAll = /**
     * Triggered when the check all / uncheck all type is clicked,
     * \@internal
     * @param {?} event
     * @param {?} source
     * @param {?} setting
     * @return {?}
     */
    function (event, source, setting) {
        event.stopPropagation();
        this.computeSettingCheckAllBehavior(setting);
        setting.values.forEach((/**
         * @param {?} settingValue
         * @return {?}
         */
        function (settingValue) {
            settingValue.enabled = setting.allEnabled;
        }));
        source.setParamFromSetting(setting);
        this.searchSourceChange.emit(source);
    };
    /**
     * Triggered when the check all / uncheck all type is clicked,
     * @internal
     */
    /**
     * Triggered when the check all / uncheck all type is clicked,
     * \@internal
     * @param {?} event
     * @return {?}
     */
    SearchSettingsComponent.prototype.checkUncheckAllSources = /**
     * Triggered when the check all / uncheck all type is clicked,
     * \@internal
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        event.stopPropagation();
        this.getSearchSources().map((/**
         * @param {?} source
         * @return {?}
         */
        function (source) {
            source.enabled = _this.searchSourcesAllEnabled;
            _this.searchSourceChange.emit(source);
        }));
    };
    /**
     * Triggered when a setting is checked (radiobutton style)
     * @internal
     */
    /**
     * Triggered when a setting is checked (radiobutton style)
     * \@internal
     * @param {?} event
     * @param {?} source
     * @param {?} setting
     * @param {?} settingValue
     * @return {?}
     */
    SearchSettingsComponent.prototype.settingsValueCheckedRadioButton = /**
     * Triggered when a setting is checked (radiobutton style)
     * \@internal
     * @param {?} event
     * @param {?} source
     * @param {?} setting
     * @param {?} settingValue
     * @return {?}
     */
    function (event, source, setting, settingValue) {
        setting.values.forEach((/**
         * @param {?} conf
         * @return {?}
         */
        function (conf) {
            if (conf.value !== settingValue.value) {
                conf.enabled = !event.source.checked;
            }
            else {
                conf.enabled = event.source.checked;
            }
        }));
        source.setParamFromSetting(setting);
        this.searchSourceChange.emit(source);
    };
    /**
     * @param {?} event
     * @param {?} source
     * @return {?}
     */
    SearchSettingsComponent.prototype.onCheckSearchSource = /**
     * @param {?} event
     * @param {?} source
     * @return {?}
     */
    function (event, source) {
        source.enabled = event.checked;
        this.searchSourceChange.emit(source);
    };
    /**
     * @param {?} setting
     * @return {?}
     */
    SearchSettingsComponent.prototype.getAvailableValues = /**
     * @param {?} setting
     * @return {?}
     */
    function (setting) {
        return setting.values.filter((/**
         * @param {?} s
         * @return {?}
         */
        function (s) { return s.available !== false; }));
    };
    /**
     * @param {?} setting
     * @return {?}
     */
    SearchSettingsComponent.prototype.getAvailableHashtagsValues = /**
     * @param {?} setting
     * @return {?}
     */
    function (setting) {
        var e_1, _a;
        if (setting.hashtags) {
            /** @type {?} */
            var output = [];
            try {
                for (var _b = __values(setting.hashtags), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var value = _c.value;
                    value = '#' + value;
                    output.push(value);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return output;
        }
        return;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    SearchSettingsComponent.prototype.stopPropagation = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.stopPropagation();
    };
    /**
     * @param {?} event
     * @param {?=} fromTitleButton
     * @return {?}
     */
    SearchSettingsComponent.prototype.changePointerReverseSearch = /**
     * @param {?} event
     * @param {?=} fromTitleButton
     * @return {?}
     */
    function (event, fromTitleButton) {
        if (fromTitleButton) {
            event.stopPropagation();
            this.pointerSummaryEnabled = !this.pointerSummaryEnabled;
        }
        else {
            this.pointerSummaryEnabled = event.checked;
        }
        this.pointerSummaryStatus.emit(this.pointerSummaryEnabled);
    };
    SearchSettingsComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igo-search-settings',
                    template: "<div class=\"igo-search-settings\">\r\n\r\n  <button\r\n    mat-icon-button\r\n    class=\"igo-search-settings-button\"\r\n    color=\"primary\"\r\n    tooltip-position=\"below\"\r\n    matTooltipShowDelay=\"500\"\r\n    [matTooltip]=\"'igo.geo.search.menu.tooltip' | translate\"\r\n    [matMenuTriggerFor]=\"searchSettingsMenu\">\r\n    <mat-icon svgIcon=\"chevron-down\"></mat-icon>\r\n  </button>\r\n  <mat-menu\r\n    #searchSettingsMenu=\"matMenu\"\r\n    class=\"no-border-radius\">\r\n    <div class=\"checkAllButton\" *ngIf=\"getSearchSources().length>4\">\r\n      <button mat-raised-button\r\n        (click)=\"checkUncheckAllSources($event)\">{{!searchSourcesAllEnabled  ? ('igo.geo.search.searchSources.unselectAll' | translate): ('igo.geo.search.searchSources.selectAll' | translate)}}</button>\r\n    </div>\r\n      <ng-container *ngFor=\"let source of getSearchSources()\">\r\n        <span class=\"igo-search-settings-search-source\">\r\n          <mat-checkbox\r\n            class=\"igo-search-settings-checkbox\"\r\n            [checked]=\"source.enabled\"\r\n            [value]=\"source\"\r\n            (click)=\"$event.stopPropagation()\"\r\n            (change)=\"onCheckSearchSource($event, source)\">\r\n          </mat-checkbox>\r\n          <button *ngIf=\"source.settings.length\u00A0>\u00A00\"\r\n            [matMenuTriggerFor]=\"sub_menu\"\r\n            mat-menu-item>{{source.title}}\r\n          </button>\r\n          <button\r\n            mat-menu-item\r\n            *ngIf=\"source.settings.length\u00A0===\u00A00\">\r\n            {{source.title}}\r\n          </button>\r\n        </span>\r\n          <mat-menu #sub_menu=\"matMenu\">\r\n            <ng-container *ngFor=\"let setting of source.settings\">\r\n              <button\r\n                  mat-menu-item\r\n                  [matMenuTriggerFor]=\"test_sub_menu\">\r\n                {{'igo.geo.search.searchSources.settings.'+ setting.title | translate}}\r\n              </button>\r\n              <mat-menu #test_sub_menu=\"matMenu\"\r\n                [ngSwitch]=\"setting.type\"\r\n                yPosition=\"above\">\r\n                <span *ngSwitchCase=\"'radiobutton'\">\r\n                  <mat-radio-group\r\n                    class=\"igo-search-settings-radio-group\"\r\n                    [value]=\"setting\">\r\n                    <mat-radio-button *ngFor=\"let settingValue of setting.values\"\r\n                      class=\"mat-typography\"\r\n                      [value]=\"settingValue\"\r\n                      [checked]=\"settingValue.enabled\"\r\n                      (click)=\"$event.stopPropagation()\"\r\n                      (change)=\"settingsValueCheckedRadioButton($event, source, setting, settingValue)\">\r\n                      {{settingValue.title | translate}}\r\n                    </mat-radio-button>\r\n                  </mat-radio-group>\r\n                </span>\r\n                <span *ngSwitchCase=\"'checkbox'\">\r\n                  <div class=\"checkAllButton\" *ngIf=\"setting.values.length\u00A0>\u00A03\">\r\n                    <button mat-raised-button\r\n                      (click)=\"checkUncheckAll($event, source, setting)\">{{setting.allEnabled || setting.allEnabled === undefined  ? ('igo.geo.search.searchSources.settings.unselectAll' | translate): ('igo.geo.search.searchSources.settings.selectAll' | translate)}}</button>\r\n                  </div>\r\n                  <mat-checkbox *ngFor=\"let settingValue of getAvailableValues(setting)\"\r\n                    class=\"mat-menu-item\"\r\n                    [checked]=\"settingValue.enabled\"\r\n                    [value]=\"setting\"\r\n                    [matTooltip]=\"getAvailableHashtagsValues(settingValue)\"\r\n                    (click)=\"$event.stopPropagation()\"\r\n                    (change)=\"settingsValueCheckedCheckbox($event, source, setting, settingValue)\">\r\n                    {{settingValue.title | translate}}\r\n                  </mat-checkbox>\r\n                </span>\r\n              </mat-menu>\r\n            </ng-container>\r\n          </mat-menu>\r\n      </ng-container>\r\n      <span *ngIf=\"hasPointerReverseSearchSource && !isTouchScreen\">\r\n        <mat-divider></mat-divider>\r\n        <span class=\"pointer-summary-slide-toggle-container mat-typography\">\r\n          <mat-slide-toggle class=\"pointer-summary-option\" (change)=\"changePointerReverseSearch($event)\" tooltip-position=\"below\"\r\n            matTooltipShowDelay=\"500\" [matTooltip]=\"'igo.geo.search.pointerSearchSummary.tooltip' | translate\"\r\n            (click)=\"$event.stopPropagation()\" [checked]=\"pointerSummaryEnabled\" [labelPosition]=\"'after'\">\r\n            {{'igo.geo.search.pointerSearchSummary.title' | translate}}\r\n          </mat-slide-toggle>\r\n        </span>\r\n      </span>\r\n  </mat-menu>\r\n</div>\r\n",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: [".checkAllButton{text-align:center;padding:0 5px}.igo-search-settings-button ::ng-deep div.mat-button-ripple-round{border-radius:0}.igo-search-settings-radio-group{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column}.igo-search-settings-radio-group mat-radio-button{margin:5px}.igo-search-settings-checkbox mat-radio-button{display:-webkit-box;display:flex}.igo-search-settings-search-source{display:-webkit-box;display:flex;width:100%}.igo-search-settings-search-source mat-checkbox{display:-webkit-box;display:flex;margin-left:5px;margin-right:5px}.pointer-summary-option{display:block;margin-right:10px;margin-bottom:15px}.pointer-summary-slide-toggle-container{overflow-x:hidden}.pointer-summary-slide-toggle-container mat-slide-toggle{margin:10px}"]
                }] }
    ];
    /** @nocollapse */
    SearchSettingsComponent.ctorParameters = function () { return [
        { type: SearchSourceService },
        { type: MediaService }
    ]; };
    SearchSettingsComponent.propDecorators = {
        pointerSummaryEnabled: [{ type: Input }],
        searchSourceChange: [{ type: Output }],
        pointerSummaryStatus: [{ type: Output }],
        handleKeyboardEvent: [{ type: HostListener, args: ['document:keydown', ['$event'],] }]
    };
    return SearchSettingsComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @ignore
 */
var IgoSearchSettingsModule = /** @class */ (function () {
    function IgoSearchSettingsModule() {
    }
    IgoSearchSettingsModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [SearchSettingsComponent],
                    imports: [
                        CommonModule,
                        MatTooltipModule,
                        MatIconModule,
                        MatButtonModule,
                        MatMenuModule,
                        MatRadioModule,
                        MatCheckboxModule,
                        MatDividerModule,
                        MatSlideToggleModule,
                        IgoLanguageModule
                    ],
                    exports: [SearchSettingsComponent]
                },] }
    ];
    return IgoSearchSettingsModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Searchbar that triggers a research in all search sources enabled.
 * If the store input is defined, the search results will be loaded
 * into that store. An event is always emitted when a research is completed.
 */
var SearchBarComponent = /** @class */ (function () {
    function SearchBarComponent(languageService, searchService) {
        this.languageService = languageService;
        this.searchService = searchService;
        this.placeholder$ = new BehaviorSubject('igo.geo.search.placeholder');
        this.empty$ = new BehaviorSubject(true);
        /**
         * Search term stream
         */
        this.stream$ = new BehaviorSubject('');
        /**
         * List of available search types
         */
        this.searchTypes = SEARCH_TYPES;
        this.searchType$ = new BehaviorSubject(undefined);
        /**
         * Event emitted when the pointer summary is activated by the searchbar setting
         */
        this.pointerSummaryStatus = new EventEmitter();
        this.term$ = new BehaviorSubject('');
        this.disabled$ = new BehaviorSubject(false);
        this.pointerSummaryEnabled = false;
        /**
         * Whether a float label should be displayed
         */
        this.floatLabel = 'never';
        /**
         * Icons color (search and clear)
         */
        this.color = 'primary';
        /**
         * Debounce time between each keystroke
         */
        this.debounce = 200;
        /**
         * Minimum term length required to trigger a research
         */
        this.minLength = 2;
        /**
         * Search Selector
         */
        this.searchSelector = false;
        /**
         * Search Settings
         */
        this.searchSettings = false;
        /**
         * Force coordinates in north america
         */
        this.forceNA = false;
        /**
         * Event emitted when the search term changes
         */
        this.searchTermChange = new EventEmitter();
        /**
         * Event emitted when a research is completed
         */
        this.search = new EventEmitter();
        /**
         * Event emitted when the search type changes
         */
        this.searchTypeChange = new EventEmitter();
        /**
         * Event emitted when the search type changes
         */
        this.clearFeature = new EventEmitter();
        /**
         * Event emitted when the search settings changes
         */
        this.searchSettingsChange = new EventEmitter();
    }
    Object.defineProperty(SearchBarComponent.prototype, "searchType", {
        get: /**
         * @return {?}
         */
        function () {
            return this.searchType$.value;
        },
        /**
         * Search term
         */
        set: /**
         * Search term
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.setSearchType(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchBarComponent.prototype, "term", {
        get: /**
         * @return {?}
         */
        function () {
            return this.term$.value;
        },
        /**
         * Search term
         */
        set: /**
         * Search term
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.setTerm(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchBarComponent.prototype, "disabled", {
        get: /**
         * @return {?}
         */
        function () {
            return this.disabled$.value;
        },
        /**
         * Whether this component is disabled
         */
        set: /**
         * Whether this component is disabled
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.disabled$.next(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchBarComponent.prototype, "empty", {
        /**
         * Whether the search bar is empty
         * @internal
         */
        get: /**
         * Whether the search bar is empty
         * \@internal
         * @return {?}
         */
        function () {
            return this.term.length === 0;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Subscribe to the search term stream and trigger researches
     * @internal
     */
    /**
     * Subscribe to the search term stream and trigger researches
     * \@internal
     * @return {?}
     */
    SearchBarComponent.prototype.ngOnInit = /**
     * Subscribe to the search term stream and trigger researches
     * \@internal
     * @return {?}
     */
    function () {
        var _this = this;
        this.term$$ = this.term$.subscribe((/**
         * @param {?} term
         * @return {?}
         */
        function (term) {
            _this.empty$.next(term === undefined || term.length === 0);
        }));
        this.stream$$ = this.stream$
            .pipe(debounce((/**
         * @param {?} term
         * @return {?}
         */
        function (term) { return (term === '' ? EMPTY : timer(_this.debounce)); })))
            .subscribe((/**
         * @param {?} term
         * @return {?}
         */
        function (term) { return _this.onSetTerm(term); }));
        this.searchType$$ = this.searchType$
            .pipe(distinctUntilChanged())
            .subscribe((/**
         * @param {?} searchType
         * @return {?}
         */
        function (searchType) { return _this.onSetSearchType(searchType); }));
    };
    /**
     * Unsubscribe to the search term stream
     * @internal
     */
    /**
     * Unsubscribe to the search term stream
     * \@internal
     * @return {?}
     */
    SearchBarComponent.prototype.ngOnDestroy = /**
     * Unsubscribe to the search term stream
     * \@internal
     * @return {?}
     */
    function () {
        this.term$$.unsubscribe();
        this.stream$$.unsubscribe();
        this.searchType$$.unsubscribe();
    };
    /**
     * When a user types, validates the key and send it into the
     * stream if it's valid
     * @param event Keyboard event
     * @internal
     */
    /**
     * When a user types, validates the key and send it into the
     * stream if it's valid
     * \@internal
     * @param {?} event Keyboard event
     * @return {?}
     */
    SearchBarComponent.prototype.onKeyup = /**
     * When a user types, validates the key and send it into the
     * stream if it's valid
     * \@internal
     * @param {?} event Keyboard event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var key = event.key;
        if (!this.keyIsValid(key)) {
            return;
        }
        /** @type {?} */
        var term = ((/** @type {?} */ (event.target))).value;
        this.setTerm(term);
    };
    /**
     * Clear the stream and the input
     * @internal
     */
    /**
     * Clear the stream and the input
     * \@internal
     * @return {?}
     */
    SearchBarComponent.prototype.onClearButtonClick = /**
     * Clear the stream and the input
     * \@internal
     * @return {?}
     */
    function () {
        this.clear();
        this.clearFeature.emit();
    };
    /**
     * Update search type
     * @param searchType Enabled search type
     * @internal
     */
    /**
     * Update search type
     * \@internal
     * @param {?} searchType Enabled search type
     * @return {?}
     */
    SearchBarComponent.prototype.onSearchTypeChange = /**
     * Update search type
     * \@internal
     * @param {?} searchType Enabled search type
     * @return {?}
     */
    function (searchType) {
        this.setSearchType(searchType);
    };
    /**
     * Update the placeholder with the enabled search type. The placeholder
     * for all availables search typers needs to be defined in the locale
     * files or an error will be thrown.
     * @param searchType Enabled search type
     * @internal
     */
    /**
     * Update the placeholder with the enabled search type. The placeholder
     * for all availables search typers needs to be defined in the locale
     * files or an error will be thrown.
     * \@internal
     * @param {?} searchType Enabled search type
     * @return {?}
     */
    SearchBarComponent.prototype.setSearchType = /**
     * Update the placeholder with the enabled search type. The placeholder
     * for all availables search typers needs to be defined in the locale
     * files or an error will be thrown.
     * \@internal
     * @param {?} searchType Enabled search type
     * @return {?}
     */
    function (searchType) {
        this.searchType$.next(searchType);
    };
    /**
     * @return {?}
     */
    SearchBarComponent.prototype.onSearchSettingsChange = /**
     * @return {?}
     */
    function () {
        this.doSearch(this.term);
        this.searchSettingsChange.emit();
    };
    /**
     * Send the term into the stream only if this component is not disabled
     * @param term Search term
     */
    /**
     * Send the term into the stream only if this component is not disabled
     * @param {?} term Search term
     * @return {?}
     */
    SearchBarComponent.prototype.setTerm = /**
     * Send the term into the stream only if this component is not disabled
     * @param {?} term Search term
     * @return {?}
     */
    function (term) {
        if (this.disabled) {
            return;
        }
        term = term || '';
        if (term !== this.term) {
            this.term$.next(term);
        }
        /** @type {?} */
        var slug = term.replace(/(#[^\s]*)/g, '').trim();
        if (slug.length >= this.minLength || slug.length === 0) {
            this.stream$.next(term);
        }
    };
    /**
     * Clear the stream and the input
     */
    /**
     * Clear the stream and the input
     * @private
     * @return {?}
     */
    SearchBarComponent.prototype.clear = /**
     * Clear the stream and the input
     * @private
     * @return {?}
     */
    function () {
        this.term$.next('');
        this.stream$.next('');
        this.input.nativeElement.focus();
    };
    /**
     * Validate if a given key stroke is a valid input
     */
    /**
     * Validate if a given key stroke is a valid input
     * @private
     * @param {?} key
     * @return {?}
     */
    SearchBarComponent.prototype.keyIsValid = /**
     * Validate if a given key stroke is a valid input
     * @private
     * @param {?} key
     * @return {?}
     */
    function (key) {
        return SearchBarComponent.invalidKeys.indexOf(key) === -1;
    };
    /**
     * When the search term changes, emit an event and trigger a
     * research in every enabled search sources.
     * @param term Search term
     */
    /**
     * When the search term changes, emit an event and trigger a
     * research in every enabled search sources.
     * @private
     * @param {?} term Search term
     * @return {?}
     */
    SearchBarComponent.prototype.onSetTerm = /**
     * When the search term changes, emit an event and trigger a
     * research in every enabled search sources.
     * @private
     * @param {?} term Search term
     * @return {?}
     */
    function (term) {
        this.searchTermChange.emit(term);
        this.doSearch(term);
    };
    /**
     * @private
     * @param {?} searchType
     * @return {?}
     */
    SearchBarComponent.prototype.onSetSearchType = /**
     * @private
     * @param {?} searchType
     * @return {?}
     */
    function (searchType) {
        if (searchType === undefined || searchType === null) {
            return;
        }
        this.searchTypeChange.emit(searchType);
        /** @type {?} */
        var placeholder = "igo.geo.search." + searchType.toLowerCase() + ".placeholder";
        this.placeholder$.next(placeholder);
        this.setTerm(this.term);
    };
    /**
     * Execute the search
     * @param term Search term
     */
    /**
     * Execute the search
     * @private
     * @param {?} term Search term
     * @return {?}
     */
    SearchBarComponent.prototype.doSearch = /**
     * Execute the search
     * @private
     * @param {?} term Search term
     * @return {?}
     */
    function (term) {
        var _this = this;
        if (this.researches$$) {
            this.researches$$.map((/**
             * @param {?} research
             * @return {?}
             */
            function (research) { return research.unsubscribe(); }));
            this.researches$$ = undefined;
        }
        /** @type {?} */
        var slug = term ? term.replace(/(#[^\s]*)/g, '').trim() : '';
        if (slug === '') {
            if (this.store !== undefined) {
                this.store.clear();
            }
            return;
        }
        /** @type {?} */
        var researches = this.searchService.search(term, {
            forceNA: this.forceNA
        });
        this.researches$$ = researches.map((/**
         * @param {?} research
         * @return {?}
         */
        function (research) {
            return research.request.subscribe((/**
             * @param {?} results
             * @return {?}
             */
            function (results) {
                _this.onResearchCompleted(research, results);
            }));
        }));
    };
    /**
     * When a research  is completed, emit an event and update
     * the store's items.
     * @param research Research
     * @param results Research results
     */
    /**
     * When a research  is completed, emit an event and update
     * the store's items.
     * @private
     * @param {?} research Research
     * @param {?} results Research results
     * @return {?}
     */
    SearchBarComponent.prototype.onResearchCompleted = /**
     * When a research  is completed, emit an event and update
     * the store's items.
     * @private
     * @param {?} research Research
     * @param {?} results Research results
     * @return {?}
     */
    function (research, results) {
        this.search.emit({ research: research, results: results });
        if (this.store !== undefined) {
            /** @type {?} */
            var newResults = this.store
                .all()
                .filter((/**
             * @param {?} result
             * @return {?}
             */
            function (result) { return result.source !== research.source; }))
                .concat(results);
            this.store.load(newResults);
        }
    };
    /**
     * Invalid keys
     */
    SearchBarComponent.invalidKeys = [
        'Control',
        'Shift',
        'Alt',
        'ArrowDown',
        'ArrowUp',
        'ArrowRight',
        'ArrowLeft'
    ];
    SearchBarComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igo-search-bar',
                    template: "<div class=\"igo-search-bar-container\" [ngClass]=\"{empty: empty$ | async}\">\r\n  <mat-form-field [floatLabel]=\"floatLabel\">\r\n    <input\r\n      #input\r\n      matInput\r\n      autocomplete=\"off\"\r\n      [ngClass]=\"{'hasSearchIcon': searchIcon}\"\r\n      [disabled]=\"disabled$ | async\"\r\n      [placeholder]=\"(placeholder$ | async) ? (placeholder$.value | translate) : undefined\"\r\n      [value]=\"term$ | async\"\r\n      (keyup)=\"onKeyup($event)\"\r\n      (touchend)=\"onKeyup($event)\">\r\n  </mat-form-field>\r\n\r\n  <div class=\"search-bar-buttons\">\r\n    <button\r\n      mat-icon-button\r\n      [color]=\"color\"\r\n      *ngIf=\"searchIcon !== undefined\">\r\n      <mat-icon svgIcon=\"{{searchIcon}}\"></mat-icon>\r\n    </button>\r\n\r\n    <button\r\n      *ngIf=\"!(empty$ | async)\"\r\n      mat-icon-button\r\n      [color]=\"color\"\r\n      (click)=\"onClearButtonClick()\">\r\n      <mat-icon svgIcon=\"close\"></mat-icon>\r\n    </button>\r\n\r\n    <igo-search-selector\r\n      *ngIf=\"searchSelector\"\r\n      [searchTypes]=\"searchTypes\"\r\n      [searchType]=\"searchType$ | async\"\r\n      (searchTypeChange)=\"onSearchTypeChange($event)\">\r\n    </igo-search-selector>\r\n\r\n    <igo-search-settings\r\n      *ngIf=\"searchSettings\"\r\n      [pointerSummaryEnabled]=\"pointerSummaryEnabled\"\r\n      (pointerSummaryStatus)=\"pointerSummaryStatus.emit($event)\"\r\n      (searchSourceChange)=\"onSearchSettingsChange()\">\r\n    </igo-search-settings>\r\n  </div>\r\n</div>\r\n",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: [":host ::ng-deep .mat-form-field{padding:0 5px}:host ::ng-deep .mat-form-field-wrapper{margin-bottom:-1.5em}:host ::ng-deep span.mat-form-field-label-wrapper{top:-20px}:host ::ng-deep div.mat-form-field-infix{left:5px;right:5px;padding:0 0 12px!important}:host ::ng-deep div.mat-form-field-underline{display:none}.igo-search-bar-container{position:relative;width:100%;display:-webkit-inline-box;display:inline-flex;overflow:hidden}.igo-search-bar-container>mat-form-field{width:calc(100% - (2 * 40px))}.igo-search-bar-container.empty>mat-form-field{width:calc(100% - 40px)}.search-bar-buttons{position:relative;right:0;display:-webkit-inline-box;display:inline-flex;top:0}.search-bar-buttons>button:nth-child(2)::before{content:'';left:0;top:5px;border-right:1px solid #ddd;height:28px}igo-search-selector,igo-search-settings{background-color:#fff;top:0;border-radius:0}"]
                }] }
    ];
    /** @nocollapse */
    SearchBarComponent.ctorParameters = function () { return [
        { type: LanguageService },
        { type: SearchService }
    ]; };
    SearchBarComponent.propDecorators = {
        searchTypes: [{ type: Input }],
        searchType: [{ type: Input }],
        pointerSummaryStatus: [{ type: Output }],
        term: [{ type: Input }],
        disabled: [{ type: Input }],
        pointerSummaryEnabled: [{ type: Input }],
        floatLabel: [{ type: Input }],
        color: [{ type: Input }],
        debounce: [{ type: Input }],
        minLength: [{ type: Input }],
        searchIcon: [{ type: Input }],
        searchSelector: [{ type: Input }],
        searchSettings: [{ type: Input }],
        forceNA: [{ type: Input }],
        store: [{ type: Input }],
        searchTermChange: [{ type: Output }],
        search: [{ type: Output }],
        searchTypeChange: [{ type: Output }],
        clearFeature: [{ type: Output }],
        searchSettingsChange: [{ type: Output }],
        input: [{ type: ViewChild, args: ['input',] }]
    };
    return SearchBarComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SearchUrlParamDirective = /** @class */ (function () {
    function SearchUrlParamDirective(component, ref, route) {
        this.component = component;
        this.ref = ref;
        this.route = route;
    }
    /**
     * @return {?}
     */
    SearchUrlParamDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.route && this.route.options.searchKey) {
            this.route.queryParams.subscribe((/**
             * @param {?} params
             * @return {?}
             */
            function (params) {
                /** @type {?} */
                var searchParams = params[(/** @type {?} */ (_this.route.options.searchKey))];
                if (searchParams) {
                    _this.component.setTerm(searchParams);
                    _this.ref.detectChanges();
                }
            }));
        }
    };
    SearchUrlParamDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igoSearchUrlParam]'
                },] }
    ];
    /** @nocollapse */
    SearchUrlParamDirective.ctorParameters = function () { return [
        { type: SearchBarComponent, decorators: [{ type: Self }] },
        { type: ChangeDetectorRef },
        { type: RouteService, decorators: [{ type: Optional }] }
    ]; };
    return SearchUrlParamDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @ignore
 */
var IgoSearchBarModule = /** @class */ (function () {
    function IgoSearchBarModule() {
    }
    IgoSearchBarModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        FormsModule,
                        MatTooltipModule,
                        MatIconModule,
                        MatButtonModule,
                        MatMenuModule,
                        MatRadioModule,
                        MatFormFieldModule,
                        MatInputModule,
                        IgoLanguageModule,
                        IgoSearchSelectorModule,
                        IgoSearchSettingsModule
                    ],
                    exports: [
                        SearchBarComponent,
                    ],
                    declarations: [
                        SearchBarComponent,
                        SearchUrlParamDirective
                    ]
                },] }
    ];
    return IgoSearchBarModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
var SearchResultMode = {
    Grouped: 'grouped',
    Flat: 'flat',
};
/**
 * List of search results with focus and selection capabilities.
 * This component is dumb and only emits events.
 */
var SearchResultsComponent = /** @class */ (function () {
    function SearchResultsComponent(cdRef, searchService) {
        this.cdRef = cdRef;
        this.searchService = searchService;
        /**
         * Reference to the SearchResultMode enum
         * \@internal
         */
        this.searchResultMode = SearchResultMode;
        this.pageIterator = [];
        this.collapsed = [];
        /**
         * Search results display mode
         */
        this.mode = SearchResultMode.Grouped;
        /**
         * Whether there should be a zoom button
         */
        this.withZoomButton = false;
        this.settingsChange$ = new BehaviorSubject(undefined);
        /**
         * Event emitted when a result is focused
         */
        this.resultFocus = new EventEmitter();
        /**
         * Event emitted when a result is unfocused
         */
        this.resultUnfocus = new EventEmitter();
        /**
         * Event emitted when a result is selected
         */
        this.resultSelect = new EventEmitter();
        /**
         * Event emitted when a research is completed after displaying more results is clicked
         */
        this.moreResults = new EventEmitter();
        /**
         * Events emitted when a result is focus or unfocus by mouse event
         */
        this.resultMouseenter = new EventEmitter();
        this.resultMouseleave = new EventEmitter();
    }
    Object.defineProperty(SearchResultsComponent.prototype, "term", {
        /**
         * Search term
         */
        get: /**
         * Search term
         * @return {?}
         */
        function () {
            return this._term;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._term = value;
            this.pageIterator = [];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchResultsComponent.prototype, "results$", {
        get: /**
         * @return {?}
         */
        function () {
            if (this._results$ === undefined) {
                this._results$ = this.liftResults();
            }
            return this._results$;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Bind the search results store to the watcher
     * @internal
     */
    /**
     * Bind the search results store to the watcher
     * \@internal
     * @return {?}
     */
    SearchResultsComponent.prototype.ngOnInit = /**
     * Bind the search results store to the watcher
     * \@internal
     * @return {?}
     */
    function () {
        var _this = this;
        this.watcher = new EntityStoreWatcher(this.store, this.cdRef);
        this.settingsChange$.subscribe((/**
         * @return {?}
         */
        function () {
            _this.pageIterator = [];
        }));
    };
    /**
     * Unbind the search results store from the watcher
     * @internal
     */
    /**
     * Unbind the search results store from the watcher
     * \@internal
     * @return {?}
     */
    SearchResultsComponent.prototype.ngOnDestroy = /**
     * Unbind the search results store from the watcher
     * \@internal
     * @return {?}
     */
    function () {
        this.watcher.destroy();
    };
    /**
     * Compute a group title
     * @param group Search results group
     * @returns Group title
     * @internal
     */
    /**
     * Compute a group title
     * \@internal
     * @param {?} group Search results group
     * @return {?} Group title
     */
    SearchResultsComponent.prototype.computeGroupTitle = /**
     * Compute a group title
     * \@internal
     * @param {?} group Search results group
     * @return {?} Group title
     */
    function (group) {
        /** @type {?} */
        var parts = [group.source.title];
        /** @type {?} */
        var count = group.results.length;
        if (count > 1) {
            parts.push("(" + count + ")");
        }
        return parts.join(' ');
    };
    /**
     * When a result is selected, update it's state in the store and emit
     * an event. A selected result is also considered focused
     * @param result Search result
     * @internal
     */
    /**
     * When a result is selected, update it's state in the store and emit
     * an event. A selected result is also considered focused
     * \@internal
     * @param {?} result Search result
     * @return {?}
     */
    SearchResultsComponent.prototype.onResultSelect = /**
     * When a result is selected, update it's state in the store and emit
     * an event. A selected result is also considered focused
     * \@internal
     * @param {?} result Search result
     * @return {?}
     */
    function (result) {
        if (this.store.state.get(result)) {
            if (this.store.state.get(result).selected === true) {
                return;
            }
        }
        this.store.state.update(result, { focused: true, selected: true }, true);
        this.resultSelect.emit(result);
    };
    /**
     * Return an observable of the search results, grouped by search source
     * @returns Observable of grouped search results
     * @internal
     */
    /**
     * Return an observable of the search results, grouped by search source
     * \@internal
     * @private
     * @return {?} Observable of grouped search results
     */
    SearchResultsComponent.prototype.liftResults = /**
     * Return an observable of the search results, grouped by search source
     * \@internal
     * @private
     * @return {?} Observable of grouped search results
     */
    function () {
        var _this = this;
        return this.store.view.all$().pipe(debounce((/**
         * @param {?} results
         * @return {?}
         */
        function (results) {
            return results.length === 0 ? EMPTY : timer(200);
        })), map((/**
         * @param {?} results
         * @return {?}
         */
        function (results) {
            return _this.groupResults(results.sort(_this.sortByOrder));
        })));
    };
    /**
     * Sort the results by display order.
     * @param r1 First result
     * @param r2 Second result
     */
    /**
     * Sort the results by display order.
     * @private
     * @param {?} r1 First result
     * @param {?} r2 Second result
     * @return {?}
     */
    SearchResultsComponent.prototype.sortByOrder = /**
     * Sort the results by display order.
     * @private
     * @param {?} r1 First result
     * @param {?} r2 Second result
     * @return {?}
     */
    function (r1, r2) {
        return r1.source.displayOrder - r2.source.displayOrder;
    };
    /**
     * Group results by search source
     * @param results Search results from all sources
     * @returns Search results grouped by source
     */
    /**
     * Group results by search source
     * @private
     * @param {?} results Search results from all sources
     * @return {?} Search results grouped by source
     */
    SearchResultsComponent.prototype.groupResults = /**
     * Group results by search source
     * @private
     * @param {?} results Search results from all sources
     * @return {?} Search results grouped by source
     */
    function (results) {
        var _this = this;
        /** @type {?} */
        var grouped = new Map();
        results.forEach((/**
         * @param {?} result
         * @return {?}
         */
        function (result) {
            /** @type {?} */
            var source = result.source;
            /** @type {?} */
            var sourceResults = grouped.get(source);
            if (sourceResults === undefined) {
                sourceResults = [];
                grouped.set(source, sourceResults);
            }
            sourceResults.push(result);
        }));
        return Array.from(grouped.keys()).map((/**
         * @param {?} source
         * @return {?}
         */
        function (source) {
            if (_this.pageIterator[source.getId()] === undefined) {
                _this.pageIterator[source.getId()] = 1;
            }
            return { source: source, results: grouped.get(source) };
        }));
    };
    /**
     * @param {?} group
     * @return {?}
     */
    SearchResultsComponent.prototype.isMoreResults = /**
     * @param {?} group
     * @return {?}
     */
    function (group) {
        return group.results && group.results[group.results.length - 1].meta.nextPage === true;
    };
    /**
     * @param {?} group
     * @return {?}
     */
    SearchResultsComponent.prototype.displayMoreResults = /**
     * @param {?} group
     * @return {?}
     */
    function (group) {
        var _this = this;
        /** @type {?} */
        var options = {
            sourceId: group.source.getId(),
            page: ++this.pageIterator[group.source.getId()]
        };
        /** @type {?} */
        var researches = this.searchService.search(this.term, options);
        researches.map((/**
         * @param {?} research
         * @return {?}
         */
        function (research) {
            research.request.subscribe((/**
             * @param {?} results
             * @return {?}
             */
            function (results) {
                /** @type {?} */
                var newResults = group.results.concat(results);
                if (!results.length) {
                    newResults[newResults.length - 1].meta.nextPage = false;
                }
                _this.moreResults.emit({ research: research, results: newResults });
            }));
        }));
        return;
    };
    SearchResultsComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igo-search-results',
                    template: "<igo-list [navigation]=\"true\">\r\n  <ng-template\r\n    #groupTemplate\r\n    ngFor let-group\r\n    [ngForOf]=\"results$ | async\">\r\n\r\n    <igo-collapsible [class]=\"group.source.getId()\"\r\n      *ngIf=\"mode === searchResultMode.Grouped; else flatTemplate\"\r\n      [title]=\"computeGroupTitle(group)\"\r\n      [collapsed]=\"collapsed[group.source.title]\"\r\n      (toggle)=\"collapsed[group.source.title] = $event\">\r\n      <ng-container *ngTemplateOutlet=\"storeItemTemplate; context: {results: group.results}\"></ng-container>\r\n    </igo-collapsible>\r\n\r\n    <ng-template #flatTemplate>\r\n      <ng-container *ngTemplateOutlet=\"storeItemTemplate; context: {results: group.results}\"></ng-container>\r\n    </ng-template>\r\n\r\n    <ng-template #storeItemTemplate let-results=\"results\">\r\n      <ng-template ngFor let-result [ngForOf]=\"results\">\r\n        <igo-search-results-item\r\n          igoListItem\r\n          color=\"accent\"\r\n          [map]=\"map\"\r\n          [result]=\"result\"\r\n          [showIcons]=\"showIcons\"\r\n          [withZoomButton]=\"withZoomButton\"\r\n          [focused]=\"store.state.get(result).focused\"\r\n          [selected]=\"store.state.get(result).selected\"\r\n          (focus)=\"resultFocus.emit(result)\"\r\n          (unfocus)=\"resultUnfocus.emit(result)\"\r\n          (select)=\"onResultSelect(result)\"\r\n          (mouseenter)=\"resultFocus.emit(result)\"\r\n          (mouseleave)=\"resultUnfocus.emit(result)\">\r\n\r\n          <ng-container igoSearchItemToolbar\r\n            [ngTemplateOutlet]=\"templateSearchToolbar\"\r\n            [ngTemplateOutletContext]=\"{result: result}\">\r\n          </ng-container>\r\n\r\n        </igo-search-results-item>\r\n      </ng-template>\r\n      <span class=\"moreResults mat-typography\" *ngIf=\"isMoreResults(group)\" (click)=\"displayMoreResults(group)\">\r\n        <u>{{ 'igo.geo.search.displayMoreResults' | translate }}</u>\r\n      </span>\r\n    </ng-template>\r\n\r\n  </ng-template>\r\n\r\n</igo-list>\r\n",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: [".moreResults{cursor:pointer;color:#00f;float:right;margin-right:10px;margin-top:5px}igo-list ::ng-deep mat-list{height:100%}"]
                }] }
    ];
    /** @nocollapse */
    SearchResultsComponent.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: SearchService }
    ]; };
    SearchResultsComponent.propDecorators = {
        map: [{ type: Input }],
        store: [{ type: Input }],
        showIcons: [{ type: Input }],
        mode: [{ type: Input }],
        withZoomButton: [{ type: Input }],
        term: [{ type: Input }],
        settingsChange$: [{ type: Input }],
        resultFocus: [{ type: Output }],
        resultUnfocus: [{ type: Output }],
        resultSelect: [{ type: Output }],
        moreResults: [{ type: Output }],
        resultMouseenter: [{ type: Output }],
        resultMouseleave: [{ type: Output }],
        templateSearchToolbar: [{ type: ContentChild, args: ['igoSearchItemToolbar',] }]
    };
    return SearchResultsComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Search results list item
 */
var SearchResultsItemComponent = /** @class */ (function () {
    function SearchResultsItemComponent() {
        /**
         * Whether there should be a zoom button
         */
        this.withZoomButton = false;
        this.zoomEvent = new EventEmitter();
        this.format = new OlGeoJSON();
    }
    Object.defineProperty(SearchResultsItemComponent.prototype, "title", {
        get: /**
         * @return {?}
         */
        function () {
            return getEntityTitle(this.result);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchResultsItemComponent.prototype, "titleHtml", {
        /**
         * Search result HTML title
         * @internal
         */
        get: /**
         * Search result HTML title
         * \@internal
         * @return {?}
         */
        function () {
            return getEntityTitleHtml(this.result);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchResultsItemComponent.prototype, "tooltipHtml", {
        /**
         * Search result tooltip
         * @internal
         */
        get: /**
         * Search result tooltip
         * \@internal
         * @return {?}
         */
        function () {
            return this.titleHtml
                .replace(/<small?[^>]+(>|$)/g, '\n')
                .replace(/<\/?[^>]+(>|$)/g, '');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchResultsItemComponent.prototype, "icon", {
        /**
         * Search result icon
         * @internal
         */
        get: /**
         * Search result icon
         * \@internal
         * @return {?}
         */
        function () {
            return getEntityIcon(this.result);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    SearchResultsItemComponent.prototype.onZoomHandler = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var olFeature = this.format.readFeature(this.result.data, {
            dataProjection: this.result.data.projection,
            featureProjection: this.map.projection
        });
        moveToOlFeatures(this.map, [olFeature], FeatureMotion.Default);
    };
    SearchResultsItemComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igo-search-results-item',
                    template: "<mat-list-item>\r\n  <mat-icon *ngIf=\"icon\" mat-list-avatar svgIcon=\"{{showIcons ? icon : 'blank'}}\"></mat-icon>\r\n\r\n  <h4 matLine *ngIf=\"titleHtml\" [innerHtml]=\"titleHtml\" matTooltipShowDelay=\"500\" [matTooltip]=\"tooltipHtml\" matTooltipClass=\"search-result-tooltip\"></h4>\r\n  <h4 matLine *ngIf=\"!titleHtml\" matTooltipShowDelay=\"500\" [matTooltip]=\"title\">{{title}}</h4>\r\n\r\n  <button *ngIf=\"withZoomButton\"\r\n    igoStopPropagation\r\n    mat-icon-button\r\n    (click)=\"onZoomHandler()\">\r\n    <mat-icon svgIcon=\"magnify\"></mat-icon>\r\n  </button>\r\n\r\n  <ng-content\r\n    select=[igoSearchItemToolbar]>\r\n  </ng-content>\r\n\r\n</mat-list-item>\r\n",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: [":host ::ng-deep small{color:#8c8c8c}::ng-deep .search-result-tooltip{white-space:pre-line}"]
                }] }
    ];
    /** @nocollapse */
    SearchResultsItemComponent.ctorParameters = function () { return []; };
    SearchResultsItemComponent.propDecorators = {
        result: [{ type: Input }],
        map: [{ type: Input }],
        showIcons: [{ type: Input }],
        withZoomButton: [{ type: Input }],
        zoomEvent: [{ type: Output }]
    };
    return SearchResultsItemComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SearchResultAddButtonComponent = /** @class */ (function () {
    function SearchResultAddButtonComponent(layerService) {
        this.layerService = layerService;
        this.tooltip$ = new BehaviorSubject('igo.geo.catalog.layer.addToMap');
        this.inRange$ = new BehaviorSubject(true);
        this.isPreview$ = new BehaviorSubject(false);
        this.layersSubcriptions = [];
        this._color = 'primary';
    }
    Object.defineProperty(SearchResultAddButtonComponent.prototype, "color", {
        get: /**
         * @return {?}
         */
        function () {
            return this._color;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._color = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal
     */
    /**
     * \@internal
     * @return {?}
     */
    SearchResultAddButtonComponent.prototype.ngOnInit = /**
     * \@internal
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.layer.meta.dataType === 'Layer') {
            this.added =
                this.map.layers.findIndex((/**
                 * @param {?} lay
                 * @return {?}
                 */
                function (lay) { return lay.id === _this.layer.data.sourceOptions.id; })) !== -1;
        }
        this.resolution$$ = this.map.viewController.resolution$.subscribe((/**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            _this.isInResolutionsRange(value);
            _this.tooltip$.next(_this.computeTooltip());
        }));
    };
    /**
     * @return {?}
     */
    SearchResultAddButtonComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.resolution$$.unsubscribe();
    };
    /**
     * On mouse event, mouseenter /mouseleave
     * @internal
     */
    /**
     * On mouse event, mouseenter /mouseleave
     * \@internal
     * @param {?} event
     * @return {?}
     */
    SearchResultAddButtonComponent.prototype.onMouseEvent = /**
     * On mouse event, mouseenter /mouseleave
     * \@internal
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.onToggleClick(event);
    };
    /**
     * On toggle button click, emit the added change event
     * @internal
     */
    /**
     * On toggle button click, emit the added change event
     * \@internal
     * @param {?} event
     * @return {?}
     */
    SearchResultAddButtonComponent.prototype.onToggleClick = /**
     * On toggle button click, emit the added change event
     * \@internal
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        if (typeof this.lastTimeoutRequest !== 'undefined') {
            clearTimeout(this.lastTimeoutRequest);
        }
        switch (event.type) {
            case 'click':
                if (!this.isPreview$.value) {
                    if (this.added) {
                        this.remove();
                    }
                    else {
                        this.add();
                    }
                }
                this.isPreview$.next(false);
                break;
            case 'mouseenter':
                if (!this.isPreview$.value && !this.added) {
                    this.lastTimeoutRequest = setTimeout((/**
                     * @return {?}
                     */
                    function () {
                        _this.add();
                        _this.isPreview$.next(true);
                    }), 500);
                }
                break;
            case 'mouseleave':
                if (this.isPreview$.value) {
                    this.remove();
                    this.isPreview$.next(false);
                }
                break;
            default:
                break;
        }
    };
    /**
     * @private
     * @return {?}
     */
    SearchResultAddButtonComponent.prototype.add = /**
     * @private
     * @return {?}
     */
    function () {
        if (!this.added) {
            this.added = true;
            this.addLayerToMap();
        }
    };
    /**
     * @private
     * @return {?}
     */
    SearchResultAddButtonComponent.prototype.remove = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.added) {
            this.added = false;
            this.removeLayerFromMap();
            this.layersSubcriptions.map((/**
             * @param {?} s
             * @return {?}
             */
            function (s) { return s.unsubscribe(); }));
            this.layersSubcriptions = [];
        }
    };
    /**
     * Emit added change event with added = true
     */
    /**
     * Emit added change event with added = true
     * @private
     * @return {?}
     */
    SearchResultAddButtonComponent.prototype.addLayerToMap = /**
     * Emit added change event with added = true
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.map === undefined) {
            return;
        }
        if (this.layer.meta.dataType !== LAYER) {
            return undefined;
        }
        /** @type {?} */
        var layerOptions = ((/** @type {?} */ (this.layer))).data;
        if (layerOptions.sourceOptions.optionsFromApi === undefined) {
            layerOptions.sourceOptions.optionsFromApi = true;
        }
        this.layersSubcriptions.push(this.layerService
            .createAsyncLayer(layerOptions)
            .subscribe((/**
         * @param {?} layer
         * @return {?}
         */
        function (layer) { return _this.map.addLayer(layer); })));
    };
    /**
     * Emit added change event with added = false
     */
    /**
     * Emit added change event with added = false
     * @private
     * @return {?}
     */
    SearchResultAddButtonComponent.prototype.removeLayerFromMap = /**
     * Emit added change event with added = false
     * @private
     * @return {?}
     */
    function () {
        if (this.map === undefined) {
            return;
        }
        if (this.layer.meta.dataType !== LAYER) {
            return undefined;
        }
        /** @type {?} */
        var oLayer = this.map.getLayerById(this.layer.data.sourceOptions.id);
        this.map.removeLayer(oLayer);
    };
    /**
     * @param {?} resolution
     * @return {?}
     */
    SearchResultAddButtonComponent.prototype.isInResolutionsRange = /**
     * @param {?} resolution
     * @return {?}
     */
    function (resolution) {
        /** @type {?} */
        var minResolution = this.layer.data.minResolution || 0;
        /** @type {?} */
        var maxResolution = this.layer.data.maxResolution || Infinity;
        this.inRange$.next(resolution >= minResolution && resolution <= maxResolution);
    };
    /**
     * @return {?}
     */
    SearchResultAddButtonComponent.prototype.computeTooltip = /**
     * @return {?}
     */
    function () {
        if (this.added) {
            return this.inRange$.value
                ? 'igo.geo.catalog.layer.removeFromMap'
                : 'igo.geo.catalog.layer.removeFromMapOutRange';
        }
        else {
            return this.inRange$.value
                ? 'igo.geo.catalog.layer.addToMap'
                : 'igo.geo.catalog.layer.addToMapOutRange';
        }
    };
    SearchResultAddButtonComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igo-search-add-button',
                    template: "<button\r\n(mouseenter)=\"onMouseEvent($event)\" (mouseleave)=\"onMouseEvent($event)\"\r\n*ngIf=\"layer.meta.dataType === 'Layer'\"\r\nmat-icon-button\r\ntooltip-position=\"below\"\r\nmatTooltipShowDelay=\"500\"\r\n[matTooltip]=\"(tooltip$ | async) | translate\"\r\n[color]=\"(isPreview$ | async) ? '' : added ? 'warn' : ''\"\r\n(click)=\"onToggleClick($event)\">\r\n<mat-icon \r\n  matBadge\r\n  igoMatBadgeIcon=\"eye-off\"\r\n  [matBadgeHidden]=\"(inRange$ | async)\"\r\n  matBadgeColor=\"primary\" \r\n  matBadgeSize=\"small\" \r\n  matBadgePosition=\"after\"\r\n  [svgIcon]=\"(isPreview$ | async) ? 'plus' : added ? 'delete' : 'plus'\">\r\n</mat-icon>\r\n</button>",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: [".mat-badge-small .mat-badge-content{color:rgba(0,0,0,.38)}"]
                }] }
    ];
    /** @nocollapse */
    SearchResultAddButtonComponent.ctorParameters = function () { return [
        { type: LayerService }
    ]; };
    SearchResultAddButtonComponent.propDecorators = {
        layer: [{ type: Input }],
        added: [{ type: Input }],
        map: [{ type: Input }],
        color: [{ type: Input }]
    };
    return SearchResultAddButtonComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @ignore
 */
var IgoSearchResultsModule = /** @class */ (function () {
    function IgoSearchResultsModule() {
    }
    IgoSearchResultsModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        MatBadgeModule,
                        MatTooltipModule,
                        MatIconModule,
                        MatListModule,
                        MatButtonModule,
                        IgoCollapsibleModule,
                        IgoListModule,
                        IgoStopPropagationModule,
                        IgoLanguageModule,
                        IgoMatBadgeIconModule,
                        IgoMetadataModule,
                    ],
                    exports: [
                        SearchResultsComponent,
                        SearchResultAddButtonComponent
                    ],
                    declarations: [
                        SearchResultsComponent,
                        SearchResultsItemComponent,
                        SearchResultAddButtonComponent
                    ]
                },] }
    ];
    return IgoSearchResultsModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * This directive makes the mouse coordinate trigger a reverse search on available search sources.
 * The search results are placed into a label, on a cross icon, representing the mouse coordinate.
 * By default, no search sources. Config in config file must be defined.
 * the layer level.
 */
var SearchPointerSummaryDirective = /** @class */ (function () {
    function SearchPointerSummaryDirective(component, searchService, searchSourceService, mediaService) {
        this.component = component;
        this.searchService = searchService;
        this.searchSourceService = searchSourceService;
        this.mediaService = mediaService;
        this.pointerSearchStore = new EntityStore([]);
        this.reverseSearch$$ = [];
        this.hasPointerReverseSearchSource = false;
        this.searchPointerSummaryFeatureId = 'searchPointerSummaryFeatureId';
        /**
         * The delay where the mouse must be motionless before trigger the reverse search
         */
        this.igoSearchPointerSummaryDelay = 1000;
        /**
         * If the user has enabled or not the directive
         */
        this.igoSearchPointerSummaryEnabled = false;
    }
    /**
     * @return {?}
     */
    SearchPointerSummaryDirective.prototype.mouseout = /**
     * @return {?}
     */
    function () {
        clearTimeout(this.lastTimeoutRequest);
        this.clearLayer();
    };
    Object.defineProperty(SearchPointerSummaryDirective.prototype, "map", {
        /**
         * IGO map
         * @internal
         */
        get: /**
         * IGO map
         * \@internal
         * @return {?}
         */
        function () {
            return this.component.map;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchPointerSummaryDirective.prototype, "mapProjection", {
        get: /**
         * @return {?}
         */
        function () {
            return ((/** @type {?} */ (this.component.map))).projection;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Start listening to pointermove and reverse search results.
     * @internal
     */
    /**
     * Start listening to pointermove and reverse search results.
     * \@internal
     * @return {?}
     */
    SearchPointerSummaryDirective.prototype.ngOnInit = /**
     * Start listening to pointermove and reverse search results.
     * \@internal
     * @return {?}
     */
    function () {
        var _this = this;
        this.listenToMapPointerMove();
        this.subscribeToPointerStore();
        this.map.status$.pipe(take(1)).subscribe((/**
         * @return {?}
         */
        function () {
            _this.store = new FeatureStore([], { map: _this.map });
            _this.initStore();
        }));
        // To handle context change without using the contextService.
        this.layers$$ = this.map.layers$.subscribe((/**
         * @param {?} layers
         * @return {?}
         */
        function (layers) {
            if (_this.store && !layers.find((/**
             * @param {?} l
             * @return {?}
             */
            function (l) { return l.id === 'searchPointerSummaryId'; }))) {
                _this.initStore();
            }
        }));
    };
    /**
     * Initialize the pointer position store
     * @internal
     */
    /**
     * Initialize the pointer position store
     * \@internal
     * @private
     * @return {?}
     */
    SearchPointerSummaryDirective.prototype.initStore = /**
     * Initialize the pointer position store
     * \@internal
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var store = this.store;
        /** @type {?} */
        var layer = new VectorLayer({
            id: 'searchPointerSummaryId',
            title: 'searchPointerSummary',
            zIndex: 900,
            source: new FeatureDataSource(),
            showInLayerList: false,
            exportable: false,
            browsable: false,
            style: pointerPositionSummaryMarker
        });
        tryBindStoreLayer(store, layer);
    };
    /**
     * @return {?}
     */
    SearchPointerSummaryDirective.prototype.ngAfterContentChecked = /**
     * @return {?}
     */
    function () {
        if (!this.searchSourceService.getEnabledSources().filter(sourceCanReverseSearchAsSummary).length) {
            this.hasPointerReverseSearchSource = false;
        }
        else {
            this.hasPointerReverseSearchSource = true;
        }
    };
    /**
     * Stop listening to pointermove and reverse search results.
     * @internal
     */
    /**
     * Stop listening to pointermove and reverse search results.
     * \@internal
     * @return {?}
     */
    SearchPointerSummaryDirective.prototype.ngOnDestroy = /**
     * Stop listening to pointermove and reverse search results.
     * \@internal
     * @return {?}
     */
    function () {
        this.unlistenToMapPointerMove();
        this.unsubscribeToPointerStore();
        this.unsubscribeReverseSearch();
        this.layers$$.unsubscribe();
    };
    /**
     * Subscribe to pointermove result store
     * @internal
     */
    /**
     * Subscribe to pointermove result store
     * \@internal
     * @return {?}
     */
    SearchPointerSummaryDirective.prototype.subscribeToPointerStore = /**
     * Subscribe to pointermove result store
     * \@internal
     * @return {?}
     */
    function () {
        var _this = this;
        this.store$$ = this.pointerSearchStore.entities$.subscribe((/**
         * @param {?} resultsUnderPointerPosition
         * @return {?}
         */
        function (resultsUnderPointerPosition) {
            _this.entitiesToPointerOverlay(resultsUnderPointerPosition);
        }));
    };
    /**
     * Build an object based on the closest feature by type (base on type and distance properties )
     * @param results SearchResult[]
     * @returns OL style function
     */
    /**
     * Build an object based on the closest feature by type (base on type and distance properties )
     * @private
     * @param {?} results SearchResult[]
     * @return {?} OL style function
     */
    SearchPointerSummaryDirective.prototype.computeSummaryClosestFeature = /**
     * Build an object based on the closest feature by type (base on type and distance properties )
     * @private
     * @param {?} results SearchResult[]
     * @return {?} OL style function
     */
    function (results) {
        /** @type {?} */
        var closestResultByType = {};
        results.map((/**
         * @param {?} result
         * @return {?}
         */
        function (result) {
            if (result.data.properties.type && result.data.properties.distance >= 0) {
                if (closestResultByType.hasOwnProperty(result.data.properties.type)) {
                    /** @type {?} */
                    var prevDistance = closestResultByType[result.data.properties.type].distance;
                    if (result.data.properties.distance < prevDistance) {
                        closestResultByType[result.data.properties.type] = { distance: result.data.properties.distance, title: result.meta.title };
                    }
                }
                else {
                    closestResultByType[result.data.properties.type] = { distance: result.data.properties.distance, title: result.meta.title };
                }
            }
        }));
        return closestResultByType;
    };
    /**
     * convert store entities to a pointer position overlay with label summary on.
     * @param event OL map browser pointer event
     */
    /**
     * convert store entities to a pointer position overlay with label summary on.
     * @private
     * @param {?} resultsUnderPointerPosition
     * @return {?}
     */
    SearchPointerSummaryDirective.prototype.entitiesToPointerOverlay = /**
     * convert store entities to a pointer position overlay with label summary on.
     * @private
     * @param {?} resultsUnderPointerPosition
     * @return {?}
     */
    function (resultsUnderPointerPosition) {
        /** @type {?} */
        var closestResultByType = this.computeSummaryClosestFeature(resultsUnderPointerPosition);
        /** @type {?} */
        var summarizedClosestType = Object.keys(closestResultByType);
        /** @type {?} */
        var processedSummarizedClosestType = [];
        /** @type {?} */
        var summary = [];
        resultsUnderPointerPosition.map((/**
         * @param {?} result
         * @return {?}
         */
        function (result) {
            /** @type {?} */
            var typeIndex = summarizedClosestType.indexOf(result.data.properties.type);
            if (typeIndex !== -1) {
                summary.push(closestResultByType[result.data.properties.type].title);
                summarizedClosestType.splice(typeIndex, 1);
                processedSummarizedClosestType.push(result.data.properties.type);
            }
            else {
                if (processedSummarizedClosestType.indexOf(result.data.properties.type) === -1) {
                    summary.push(result.meta.title);
                }
            }
        }));
        if (summary.length) {
            this.addPointerOverlay(summary.join('\n'));
        }
    };
    /**
     * On map pointermove
     */
    /**
     * On map pointermove
     * @private
     * @return {?}
     */
    SearchPointerSummaryDirective.prototype.listenToMapPointerMove = /**
     * On map pointermove
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this.pointerMoveListener = this.map.ol.on('pointermove', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.onMapEvent(event); }));
    };
    /**
     * Unsubscribe to pointer store.
     * @internal
     */
    /**
     * Unsubscribe to pointer store.
     * \@internal
     * @return {?}
     */
    SearchPointerSummaryDirective.prototype.unsubscribeToPointerStore = /**
     * Unsubscribe to pointer store.
     * \@internal
     * @return {?}
     */
    function () {
        this.store$$.unsubscribe();
    };
    /**
     * Unsubscribe to reverse seatch store.
     * @internal
     */
    /**
     * Unsubscribe to reverse seatch store.
     * \@internal
     * @return {?}
     */
    SearchPointerSummaryDirective.prototype.unsubscribeReverseSearch = /**
     * Unsubscribe to reverse seatch store.
     * \@internal
     * @return {?}
     */
    function () {
        this.reverseSearch$$.map((/**
         * @param {?} s
         * @return {?}
         */
        function (s) { return s.unsubscribe(); }));
        this.reverseSearch$$ = [];
    };
    /**
     * Stop listening for map pointermove
     * @internal
     */
    /**
     * Stop listening for map pointermove
     * \@internal
     * @private
     * @return {?}
     */
    SearchPointerSummaryDirective.prototype.unlistenToMapPointerMove = /**
     * Stop listening for map pointermove
     * \@internal
     * @private
     * @return {?}
     */
    function () {
        this.map.ol.un(this.pointerMoveListener.type, this.pointerMoveListener.listener);
        this.pointerMoveListener = undefined;
    };
    /**
     * Trigger reverse search when the mouse is motionless during the defined delay (pointerMoveDelay).
     * @param event OL map browser pointer event
     */
    /**
     * Trigger reverse search when the mouse is motionless during the defined delay (pointerMoveDelay).
     * @private
     * @param {?} event OL map browser pointer event
     * @return {?}
     */
    SearchPointerSummaryDirective.prototype.onMapEvent = /**
     * Trigger reverse search when the mouse is motionless during the defined delay (pointerMoveDelay).
     * @private
     * @param {?} event OL map browser pointer event
     * @return {?}
     */
    function (event) {
        var _this = this;
        if (event.dragging || !this.igoSearchPointerSummaryEnabled ||
            !this.hasPointerReverseSearchSource || this.mediaService.isTouchScreen()) {
            this.clearLayer();
            return;
        }
        if (typeof this.lastTimeoutRequest !== 'undefined') { // cancel timeout when the mouse moves
            clearTimeout(this.lastTimeoutRequest);
            this.clearLayer();
            this.unsubscribeReverseSearch();
        }
        this.lonLat = transform(event.coordinate, this.mapProjection, 'EPSG:4326');
        this.lastTimeoutRequest = setTimeout((/**
         * @return {?}
         */
        function () {
            _this.onSearchCoordinate();
        }), this.igoSearchPointerSummaryDelay);
    };
    /**
     * @private
     * @return {?}
     */
    SearchPointerSummaryDirective.prototype.onSearchCoordinate = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this.pointerSearchStore.clear();
        /** @type {?} */
        var results = this.searchService.reverseSearch(this.lonLat, { params: { geometry: 'false', icon: 'false' } }, true);
        var _loop_1 = function (i) {
            if (results.length > 0) {
                this_1.reverseSearch$$.push(results[i].request.subscribe((/**
                 * @param {?} _results
                 * @return {?}
                 */
                function (_results) {
                    _this.onSearch({ research: results[i], results: _results });
                })));
            }
        };
        var this_1 = this;
        for (var i in results) {
            _loop_1(i);
        }
    };
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    SearchPointerSummaryDirective.prototype.onSearch = /**
     * @private
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var results = event.results;
        /** @type {?} */
        var newResults = this.pointerSearchStore.all()
            .filter((/**
         * @param {?} result
         * @return {?}
         */
        function (result) { return result.source !== event.research.source; }))
            .concat(results);
        this.pointerSearchStore.load(newResults);
    };
    /**
     * Add a feature to the pointer store
     * @param text string
     */
    /**
     * Add a feature to the pointer store
     * @private
     * @param {?} text string
     * @return {?}
     */
    SearchPointerSummaryDirective.prototype.addPointerOverlay = /**
     * Add a feature to the pointer store
     * @private
     * @param {?} text string
     * @return {?}
     */
    function (text) {
        this.clearLayer();
        /** @type {?} */
        var geometry = new Point(transform(this.lonLat, 'EPSG:4326', this.mapProjection));
        /** @type {?} */
        var feature = new OlFeature({ geometry: geometry });
        /** @type {?} */
        var geojsonGeom = new OlGeoJSON().writeGeometryObject(geometry, {
            featureProjection: this.mapProjection,
            dataProjection: this.mapProjection
        });
        /** @type {?} */
        var f = {
            type: FEATURE,
            geometry: geojsonGeom,
            projection: this.mapProjection,
            properties: {
                id: this.searchPointerSummaryFeatureId,
                pointerSummary: text
            },
            meta: {
                id: this.searchPointerSummaryFeatureId
            },
            ol: feature
        };
        this.store.setLayerFeatures([f], FeatureMotion.None);
    };
    /**
     * Clear the pointer store features
     */
    /**
     * Clear the pointer store features
     * @private
     * @return {?}
     */
    SearchPointerSummaryDirective.prototype.clearLayer = /**
     * Clear the pointer store features
     * @private
     * @return {?}
     */
    function () {
        if (this.store) {
            this.store.clearLayer();
        }
    };
    SearchPointerSummaryDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igoSearchPointerSummary]'
                },] }
    ];
    /** @nocollapse */
    SearchPointerSummaryDirective.ctorParameters = function () { return [
        { type: MapBrowserComponent, decorators: [{ type: Self }] },
        { type: SearchService },
        { type: SearchSourceService },
        { type: MediaService }
    ]; };
    SearchPointerSummaryDirective.propDecorators = {
        igoSearchPointerSummaryDelay: [{ type: Input }],
        igoSearchPointerSummaryEnabled: [{ type: Input }],
        mouseout: [{ type: HostListener, args: ['mouseout',] }]
    };
    return SearchPointerSummaryDirective;
}());
/**
 * Create a default style for the pointer position and it's label summary.
 * @param {?} feature OlFeature
 * @param {?} resolution
 * @return {?} OL style function
 */
function pointerPositionSummaryMarker(feature, resolution) {
    return new Style({
        image: new Icon({
            src: './assets/igo2/geo/icons/cross_black_18px.svg',
            imgSize: [18, 18],
        }),
        text: new Text({
            text: feature.get('pointerSummary'),
            textAlign: 'left',
            textBaseline: 'bottom',
            font: '12px Calibri,sans-serif',
            fill: new Fill({ color: '#000' }),
            backgroundFill: new Fill({ color: 'rgba(255, 255, 255, 0.5)' }),
            backgroundStroke: new Stroke({ color: 'rgba(200, 200, 200, 0.75)', width: 2 }),
            stroke: new Stroke({ color: '#fff', width: 3 }),
            overflow: true,
            offsetX: 10,
            offsetY: -10,
            padding: [2.5, 2.5, 2.5, 2.5]
        })
    });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgoSearchModule = /** @class */ (function () {
    function IgoSearchModule() {
    }
    /**
     * @return {?}
     */
    IgoSearchModule.forRoot = /**
     * @return {?}
     */
    function () {
        return {
            ngModule: IgoSearchModule,
            providers: [
                provideSearchSourceService(),
                provideDefaultIChercheSearchResultFormatter(),
                provideDefaultCoordinatesSearchResultFormatter(),
                provideILayerSearchResultFormatter()
            ]
        };
    };
    IgoSearchModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        IgoSearchBarModule,
                        IgoSearchSelectorModule,
                        IgoSearchResultsModule,
                        IgoSearchSettingsModule
                    ],
                    exports: [
                        IgoSearchBarModule,
                        IgoSearchSelectorModule,
                        IgoSearchResultsModule,
                        IgoSearchSettingsModule,
                        SearchPointerSummaryDirective
                    ],
                    declarations: [SearchPointerSummaryDirective]
                },] }
    ];
    return IgoSearchModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ToastComponent = /** @class */ (function () {
    function ToastComponent() {
        this.format = new OlGeoJSON();
        this.opened = new EventEmitter();
    }
    Object.defineProperty(ToastComponent.prototype, "expanded", {
        get: /**
         * @return {?}
         */
        function () {
            return this._expanded;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.state = value ? 'expanded' : 'collapsed';
            this._expanded = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ToastComponent.prototype, "map", {
        get: /**
         * @return {?}
         */
        function () {
            return this._map;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._map = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ToastComponent.prototype, "feature", {
        get: /**
         * @return {?}
         */
        function () {
            return this._feature;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._feature = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ToastComponent.prototype, "title", {
        /**
         * @internal
         */
        get: /**
         * \@internal
         * @return {?}
         */
        function () { return getEntityTitle(this.feature); },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ToastComponent.prototype.toggle = /**
     * @return {?}
     */
    function () {
        this.expanded = !this.expanded;
        this.opened.emit(this.expanded);
    };
    /**
     * @return {?}
     */
    ToastComponent.prototype.zoomToFeatureExtent = /**
     * @return {?}
     */
    function () {
        if (this.feature.geometry) {
            /** @type {?} */
            var olFeature = this.format.readFeature(this.feature, {
                dataProjection: this.feature.projection,
                featureProjection: this.map.projection
            });
            moveToOlFeatures(this.map, [olFeature], FeatureMotion.Zoom);
        }
    };
    /**
     * @param {?} action
     * @return {?}
     */
    ToastComponent.prototype.swipe = /**
     * @param {?} action
     * @return {?}
     */
    function (action) {
        if (action === ToastComponent.SWIPE_ACTION.UP) {
            if (!this.expanded) {
                this.toggle();
            }
        }
        else if (action === ToastComponent.SWIPE_ACTION.DOWN) {
            if (this.expanded) {
                this.toggle();
            }
        }
    };
    ToastComponent.SWIPE_ACTION = {
        UP: 'swipeup',
        DOWN: 'swipedown'
    };
    ToastComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igo-toast',
                    template: "<igo-flexible #flex\r\n  collapsedMobile=\"51px\"\r\n  expandedMobile=\"300px\"\r\n  [state]=\"state\"\r\n  (swipeup)=\"swipe($event.type)\"\r\n  (swipedown)=\"swipe($event.type)\">\r\n\r\n  <igo-panel [title]=\"title\">\r\n    <button\r\n      mat-icon-button\r\n      panelLeftButton\r\n      (click)=\"toggle()\">\r\n      <mat-icon [svgIcon]=\"['collapsed', 'initial'].indexOf(flex.state) >= 0 ? 'arrow_upward' : 'arrow_downward'\"></mat-icon>\r\n    </button>\r\n\r\n    <button mat-icon-button panelRightButton class=\"igo-icon-button\" (click)=\"zoomToFeatureExtent()\" *ngIf=\"feature.geometry\">\r\n      <mat-icon svgIcon=\"zoom-in\"></mat-icon>\r\n    </button>\r\n\r\n    <igo-feature-details [feature]=\"feature\"></igo-feature-details>\r\n  </igo-panel>\r\n\r\n</igo-flexible>\r\n",
                    styles: [":host{position:absolute;bottom:0;width:100%;max-height:calc(100% - 50px);background-color:#fff}igo-feature-details ::ng-deep table{width:100%}"]
                }] }
    ];
    /** @nocollapse */
    ToastComponent.ctorParameters = function () { return []; };
    ToastComponent.propDecorators = {
        expanded: [{ type: Input }],
        map: [{ type: Input }],
        feature: [{ type: Input }],
        opened: [{ type: Output }]
    };
    return ToastComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgoToastModule = /** @class */ (function () {
    function IgoToastModule() {
    }
    /**
     * @return {?}
     */
    IgoToastModule.forRoot = /**
     * @return {?}
     */
    function () {
        return {
            ngModule: IgoToastModule
        };
    };
    IgoToastModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        MatIconModule,
                        MatButtonModule,
                        IgoPanelModule,
                        IgoFlexibleModule,
                        IgoFeatureModule
                    ],
                    exports: [ToastComponent],
                    declarations: [ToastComponent]
                },] }
    ];
    return IgoToastModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var OgcFilterComponent = /** @class */ (function () {
    function OgcFilterComponent(cdRef) {
        this.cdRef = cdRef;
        /**
         * Event emitted on complete
         */
        this.complete = new EventEmitter();
        /**
         * Event emitted on cancel
         */
        this.cancel = new EventEmitter();
    }
    /**
     * Implemented as part of OnUpdateInputs
     */
    /**
     * Implemented as part of OnUpdateInputs
     * @return {?}
     */
    OgcFilterComponent.prototype.onUpdateInputs = /**
     * Implemented as part of OnUpdateInputs
     * @return {?}
     */
    function () {
        this.cdRef.detectChanges();
    };
    /**
     * On close, emit the cancel event
     */
    /**
     * On close, emit the cancel event
     * @return {?}
     */
    OgcFilterComponent.prototype.onClose = /**
     * On close, emit the cancel event
     * @return {?}
     */
    function () {
        this.cancel.emit();
    };
    OgcFilterComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igo-ogc-filter',
                    template: "<igo-ogc-filterable-item\r\n  [layer]=\"layer\" \r\n  [map]=\"map\" >\r\n</igo-ogc-filterable-item>\r\n\r\n<div>\r\n  <button\r\n    mat-button\r\n    type=\"button\"\r\n    (click)=\"onClose()\">\r\n    {{ 'igo.geo.workspace.ogcFilter.close' | translate }}\r\n  </button>\r\n</div>\r\n",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: [""]
                }] }
    ];
    /** @nocollapse */
    OgcFilterComponent.ctorParameters = function () { return [
        { type: ChangeDetectorRef }
    ]; };
    OgcFilterComponent.propDecorators = {
        layer: [{ type: Input }],
        map: [{ type: Input }],
        complete: [{ type: Output }],
        cancel: [{ type: Output }]
    };
    return OgcFilterComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var OgcFilterWidget = new InjectionToken('OgcFilterWidget');
/**
 * @param {?} widgetService
 * @return {?}
 */
function ogcFilterWidgetFactory(widgetService) {
    return widgetService.create(OgcFilterComponent);
}
/**
 * @return {?}
 */
function provideOgcFilterWidget() {
    return {
        provide: OgcFilterWidget,
        useFactory: ogcFilterWidgetFactory,
        deps: [WidgetService]
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @ignore
 */
var IgoOgcFilterModule = /** @class */ (function () {
    function IgoOgcFilterModule() {
    }
    IgoOgcFilterModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        MatButtonModule,
                        IgoLanguageModule,
                        IgoFilterModule
                    ],
                    exports: [OgcFilterComponent],
                    declarations: [OgcFilterComponent],
                    entryComponents: [OgcFilterComponent]
                },] }
    ];
    return IgoOgcFilterModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var WfsWorkspace = /** @class */ (function (_super) {
    __extends(WfsWorkspace, _super);
    function WfsWorkspace(options) {
        var _this = _super.call(this, options) || this;
        _this.options = options;
        return _this;
    }
    Object.defineProperty(WfsWorkspace.prototype, "layer", {
        get: /**
         * @return {?}
         */
        function () { return this.options.layer; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WfsWorkspace.prototype, "map", {
        get: /**
         * @return {?}
         */
        function () { return this.options.map; },
        enumerable: true,
        configurable: true
    });
    return WfsWorkspace;
}(Workspace));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var WfsWorkspaceService = /** @class */ (function () {
    function WfsWorkspaceService() {
    }
    /**
     * @param {?} layer
     * @param {?} map
     * @return {?}
     */
    WfsWorkspaceService.prototype.createWorkspace = /**
     * @param {?} layer
     * @param {?} map
     * @return {?}
     */
    function (layer, map$$1) {
        return new WfsWorkspace({
            id: layer.id,
            title: layer.title,
            layer: layer,
            map: map$$1,
            entityStore: this.createFeatureStore(layer, map$$1),
            actionStore: new ActionStore([]),
            meta: {
                tableTemplate: this.createTableTemplate(layer)
            }
        });
    };
    /**
     * @private
     * @param {?} layer
     * @param {?} map
     * @return {?}
     */
    WfsWorkspaceService.prototype.createFeatureStore = /**
     * @private
     * @param {?} layer
     * @param {?} map
     * @return {?}
     */
    function (layer, map$$1) {
        /** @type {?} */
        var store = new FeatureStore([], { map: map$$1 });
        store.bindLayer(layer);
        /** @type {?} */
        var loadingStrategy = new FeatureStoreLoadingLayerStrategy({});
        /** @type {?} */
        var selectionStrategy = new FeatureStoreSelectionStrategy({
            map: map$$1,
            hitTolerance: 5
        });
        store.addStrategy(loadingStrategy, true);
        store.addStrategy(selectionStrategy, true);
        return store;
    };
    /**
     * @private
     * @param {?} layer
     * @return {?}
     */
    WfsWorkspaceService.prototype.createTableTemplate = /**
     * @private
     * @param {?} layer
     * @return {?}
     */
    function (layer) {
        /** @type {?} */
        var fields = layer.dataSource.options.sourceFields || [];
        /** @type {?} */
        var columns = fields.map((/**
         * @param {?} field
         * @return {?}
         */
        function (field) {
            return {
                name: "properties." + field.name,
                title: field.alias ? field.alias : field.name
            };
        }));
        return {
            selection: true,
            sort: true,
            columns: columns
        };
    };
    WfsWorkspaceService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    WfsWorkspaceService.ctorParameters = function () { return []; };
    /** @nocollapse */ WfsWorkspaceService.ngInjectableDef = defineInjectable({ factory: function WfsWorkspaceService_Factory() { return new WfsWorkspaceService(); }, token: WfsWorkspaceService, providedIn: "root" });
    return WfsWorkspaceService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var WmsWorkspace = /** @class */ (function (_super) {
    __extends(WmsWorkspace, _super);
    function WmsWorkspace(options) {
        var _this = _super.call(this, options) || this;
        _this.options = options;
        return _this;
    }
    Object.defineProperty(WmsWorkspace.prototype, "layer", {
        get: /**
         * @return {?}
         */
        function () { return this.options.layer; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WmsWorkspace.prototype, "map", {
        get: /**
         * @return {?}
         */
        function () { return this.options.map; },
        enumerable: true,
        configurable: true
    });
    return WmsWorkspace;
}(Workspace));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var WmsWorkspaceService = /** @class */ (function () {
    function WmsWorkspaceService() {
    }
    /**
     * @param {?} layer
     * @param {?} map
     * @return {?}
     */
    WmsWorkspaceService.prototype.createWorkspace = /**
     * @param {?} layer
     * @param {?} map
     * @return {?}
     */
    function (layer, map$$1) {
        return new WmsWorkspace({
            id: layer.id,
            title: layer.title,
            layer: layer,
            map: map$$1,
            actionStore: new ActionStore([])
        });
    };
    WmsWorkspaceService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    WmsWorkspaceService.ctorParameters = function () { return []; };
    /** @nocollapse */ WmsWorkspaceService.ngInjectableDef = defineInjectable({ factory: function WmsWorkspaceService_Factory() { return new WmsWorkspaceService(); }, token: WmsWorkspaceService, providedIn: "root" });
    return WmsWorkspaceService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var WorkspaceSelectorDirective = /** @class */ (function () {
    function WorkspaceSelectorDirective(component, wfsWorkspaceService, wmsWorkspaceService) {
        this.component = component;
        this.wfsWorkspaceService = wfsWorkspaceService;
        this.wmsWorkspaceService = wmsWorkspaceService;
    }
    Object.defineProperty(WorkspaceSelectorDirective.prototype, "workspaceStore", {
        get: /**
         * @return {?}
         */
        function () {
            return this.component.store;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    WorkspaceSelectorDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.layers$$ = this.map.layers$
            .pipe(debounceTime(50))
            .subscribe((/**
         * @param {?} layers
         * @return {?}
         */
        function (layers) {
            return _this.onLayersChange(layers);
        }));
    };
    /**
     * @return {?}
     */
    WorkspaceSelectorDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.layers$$.unsubscribe();
    };
    /**
     * @private
     * @param {?} layers
     * @return {?}
     */
    WorkspaceSelectorDirective.prototype.onLayersChange = /**
     * @private
     * @param {?} layers
     * @return {?}
     */
    function (layers) {
        var _this = this;
        /** @type {?} */
        var editableLayers = layers.filter((/**
         * @param {?} layer
         * @return {?}
         */
        function (layer) {
            return _this.layerIsEditable(layer);
        }));
        /** @type {?} */
        var editableLayersIds = editableLayers.map((/**
         * @param {?} layer
         * @return {?}
         */
        function (layer) { return layer.id; }));
        /** @type {?} */
        var workspacesToAdd = editableLayers
            .map((/**
         * @param {?} layer
         * @return {?}
         */
        function (layer) { return _this.getOrCreateWorkspace(layer); }))
            .filter((/**
         * @param {?} workspace
         * @return {?}
         */
        function (workspace) { return workspace !== undefined; }));
        /** @type {?} */
        var workspacesToRemove = this.workspaceStore.all()
            .filter((/**
         * @param {?} workspace
         * @return {?}
         */
        function (workspace) {
            return editableLayersIds.indexOf(workspace.id) < 0;
        }));
        if (workspacesToRemove.length > 0) {
            workspacesToRemove.forEach((/**
             * @param {?} workspace
             * @return {?}
             */
            function (workspace) {
                workspace.deactivate();
            }));
            this.workspaceStore.state.updateMany(workspacesToRemove, { active: false, selected: false });
            this.workspaceStore.deleteMany(workspacesToRemove);
        }
        if (workspacesToAdd.length > 0) {
            this.workspaceStore.insertMany(workspacesToAdd);
        }
    };
    /**
     * @private
     * @param {?} layer
     * @return {?}
     */
    WorkspaceSelectorDirective.prototype.getOrCreateWorkspace = /**
     * @private
     * @param {?} layer
     * @return {?}
     */
    function (layer) {
        /** @type {?} */
        var workspace = this.workspaceStore.get(layer.id);
        if (workspace !== undefined) {
            return;
        }
        if (layer.dataSource instanceof WFSDataSource) {
            return this.wfsWorkspaceService.createWorkspace((/** @type {?} */ (layer)), this.map);
        }
        else if (layer.dataSource instanceof WMSDataSource) {
            return this.wmsWorkspaceService.createWorkspace((/** @type {?} */ (layer)), this.map);
        }
        return;
    };
    /**
     * @private
     * @param {?} layer
     * @return {?}
     */
    WorkspaceSelectorDirective.prototype.layerIsEditable = /**
     * @private
     * @param {?} layer
     * @return {?}
     */
    function (layer) {
        /** @type {?} */
        var dataSource = layer.dataSource;
        if (dataSource instanceof WFSDataSource) {
            return true;
        }
        if (dataSource instanceof WMSDataSource) {
            /** @type {?} */
            var dataSourceOptions = (/** @type {?} */ ((dataSource.options ||
                {})));
            return (dataSourceOptions.ogcFilters && dataSourceOptions.ogcFilters.enabled);
        }
        return false;
    };
    WorkspaceSelectorDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igoWorkspaceSelector]'
                },] }
    ];
    /** @nocollapse */
    WorkspaceSelectorDirective.ctorParameters = function () { return [
        { type: WorkspaceSelectorComponent },
        { type: WfsWorkspaceService },
        { type: WmsWorkspaceService }
    ]; };
    WorkspaceSelectorDirective.propDecorators = {
        map: [{ type: Input }]
    };
    return WorkspaceSelectorDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @ignore
 */
var IgoWorkspaceSelectorModule = /** @class */ (function () {
    function IgoWorkspaceSelectorModule() {
    }
    IgoWorkspaceSelectorModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule
                    ],
                    exports: [
                        WorkspaceSelectorDirective
                    ],
                    declarations: [
                        WorkspaceSelectorDirective
                    ]
                },] }
    ];
    return IgoWorkspaceSelectorModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgoGeoWorkspaceModule = /** @class */ (function () {
    function IgoGeoWorkspaceModule() {
    }
    IgoGeoWorkspaceModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        IgoWidgetModule,
                        IgoWorkspaceSelectorModule,
                        IgoOgcFilterModule
                    ],
                    exports: [
                        IgoWorkspaceSelectorModule,
                        IgoOgcFilterModule
                    ],
                    declarations: [],
                    providers: [
                        provideOgcFilterWidget()
                    ]
                },] }
    ];
    return IgoGeoWorkspaceModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgoWktModule = /** @class */ (function () {
    function IgoWktModule() {
    }
    /**
     * @return {?}
     */
    IgoWktModule.forRoot = /**
     * @return {?}
     */
    function () {
        return {
            ngModule: IgoWktModule,
            providers: []
        };
    };
    IgoWktModule.decorators = [
        { type: NgModule, args: [{
                    imports: [],
                    exports: [],
                    declarations: []
                },] }
    ];
    return IgoWktModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgoGeoModule = /** @class */ (function () {
    function IgoGeoModule() {
    }
    /**
     * @return {?}
     */
    IgoGeoModule.forRoot = /**
     * @return {?}
     */
    function () {
        return {
            ngModule: IgoGeoModule,
            providers: []
        };
    };
    IgoGeoModule.decorators = [
        { type: NgModule, args: [{
                    imports: [],
                    declarations: [],
                    exports: [
                        IgoCatalogModule,
                        IgoDataSourceModule,
                        IgoDownloadModule,
                        IgoFeatureModule,
                        IgoFilterModule,
                        IgoGeometryModule,
                        IgoImportExportModule,
                        IgoLayerModule,
                        IgoMapModule,
                        IgoMeasureModule,
                        IgoMetadataModule,
                        IgoOverlayModule,
                        IgoPrintModule,
                        IgoQueryModule,
                        IgoDirectionsModule,
                        IgoSearchModule,
                        IgoToastModule,
                        IgoGeoWorkspaceModule,
                        IgoWktModule
                    ]
                },] }
    ];
    return IgoGeoModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} http
 * @param {?} configService
 * @return {?}
 */
function optionsApiFactory(http, configService) {
    return new OptionsApiService(http, configService.getConfig('optionsApi'));
}
/**
 * @return {?}
 */
function provideOptionsApi() {
    return {
        provide: OptionsService,
        useFactory: optionsApiFactory,
        deps: [HttpClient, ConfigService]
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Cadastre search source
 */
var CadastreSearchSource = /** @class */ (function (_super) {
    __extends(CadastreSearchSource, _super);
    function CadastreSearchSource(http, options) {
        var _this = _super.call(this, options) || this;
        _this.http = http;
        return _this;
    }
    /**
     * @return {?}
     */
    CadastreSearchSource.prototype.getId = /**
     * @return {?}
     */
    function () {
        return CadastreSearchSource.id;
    };
    /**
     * @return {?}
     */
    CadastreSearchSource.prototype.getType = /**
     * @return {?}
     */
    function () {
        return CadastreSearchSource.type;
    };
    /*
     * Source : https://wiki.openstreetmap.org/wiki/Key:amenity
     */
    /*
       * Source : https://wiki.openstreetmap.org/wiki/Key:amenity
       */
    /**
     * @protected
     * @return {?}
     */
    CadastreSearchSource.prototype.getDefaultOptions = /*
       * Source : https://wiki.openstreetmap.org/wiki/Key:amenity
       */
    /**
     * @protected
     * @return {?}
     */
    function () {
        return {
            title: 'Cadastre (Québec)',
            searchUrl: 'https://carto.cptaq.gouv.qc.ca/php/find_lot_v1.php?'
        };
    };
    /**
     * Search a place by name
     * @param term Place name
     * @returns Observable of <SearchResult<Feature>[]
     */
    /**
     * Search a place by name
     * @param {?} term Place name
     * @param {?=} options
     * @return {?} Observable of <SearchResult<Feature>[]
     */
    CadastreSearchSource.prototype.search = /**
     * Search a place by name
     * @param {?} term Place name
     * @param {?=} options
     * @return {?} Observable of <SearchResult<Feature>[]
     */
    function (term, options) {
        var _this = this;
        term = term.endsWith(',') ? term.slice(0, -1) : term;
        term = term.startsWith(',') ? term.substr(1) : term;
        term = term.replace(/ /g, '');
        /** @type {?} */
        var params = this.computeSearchRequestParams(term, options || {});
        if (!params.get('numero') || !params.get('numero').match(/^[0-9,]+$/g)) {
            return of([]);
        }
        return this.http
            .get(this.searchUrl, { params: params, responseType: 'text' })
            .pipe(map((/**
         * @param {?} response
         * @return {?}
         */
        function (response) { return _this.extractResults(response); })));
    };
    /**
     * @private
     * @param {?} term
     * @param {?} options
     * @return {?}
     */
    CadastreSearchSource.prototype.computeSearchRequestParams = /**
     * @private
     * @param {?} term
     * @param {?} options
     * @return {?}
     */
    function (term, options) {
        return new HttpParams({
            fromObject: Object.assign({
                numero: term,
                epsg: '4326'
            }, this.params, options.params || {})
        });
    };
    /**
     * @private
     * @param {?} response
     * @return {?}
     */
    CadastreSearchSource.prototype.extractResults = /**
     * @private
     * @param {?} response
     * @return {?}
     */
    function (response) {
        var _this = this;
        return response
            .split('<br />')
            .filter((/**
         * @param {?} lot
         * @return {?}
         */
        function (lot) { return lot.length > 0; }))
            .map((/**
         * @param {?} lot
         * @return {?}
         */
        function (lot) { return _this.dataToResult(lot); }));
    };
    /**
     * @private
     * @param {?} data
     * @return {?}
     */
    CadastreSearchSource.prototype.dataToResult = /**
     * @private
     * @param {?} data
     * @return {?}
     */
    function (data) {
        /** @type {?} */
        var lot = data.split(';');
        /** @type {?} */
        var numero = lot[0];
        /** @type {?} */
        var wkt = lot[7];
        /** @type {?} */
        var geometry = this.computeGeometry(wkt);
        /** @type {?} */
        var properties = { NoLot: numero };
        /** @type {?} */
        var id = [this.getId(), 'cadastre', numero].join('.');
        return {
            source: this,
            meta: {
                dataType: FEATURE,
                id: id,
                title: numero,
                icon: 'map-marker'
            },
            data: {
                type: FEATURE,
                projection: 'EPSG:4326',
                geometry: geometry,
                properties: properties,
                meta: {
                    id: id,
                    title: numero
                }
            }
        };
    };
    /**
     * @private
     * @param {?} wkt
     * @return {?}
     */
    CadastreSearchSource.prototype.computeGeometry = /**
     * @private
     * @param {?} wkt
     * @return {?}
     */
    function (wkt) {
        /** @type {?} */
        var feature = new olWKT().readFeature(wkt, {
            dataProjection: 'EPSG:4326',
            featureProjection: 'EPSG:4326'
        });
        return {
            type: feature.getGeometry().getType(),
            coordinates: feature.getGeometry().getCoordinates()
        };
    };
    CadastreSearchSource.id = 'cadastre';
    CadastreSearchSource.type = FEATURE;
    CadastreSearchSource.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    CadastreSearchSource.ctorParameters = function () { return [
        { type: HttpClient },
        { type: undefined, decorators: [{ type: Inject, args: ['options',] }] }
    ]; };
    return CadastreSearchSource;
}(SearchSource));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Cadastre search source factory
 * @ignore
 * @param {?} http
 * @param {?} config
 * @return {?}
 */
function cadastreSearchSourceFactory(http, config) {
    return new CadastreSearchSource(http, config.getConfig("searchSources." + CadastreSearchSource.id));
}
/**
 * Function that returns a provider for the Cadastre search source
 * @return {?}
 */
function provideCadastreSearchSource() {
    return {
        provide: SearchSource,
        useFactory: cadastreSearchSourceFactory,
        multi: true,
        deps: [HttpClient, ConfigService]
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Nominatim search source
 */
var NominatimSearchSource = /** @class */ (function (_super) {
    __extends(NominatimSearchSource, _super);
    function NominatimSearchSource(http, options) {
        var _this = _super.call(this, options) || this;
        _this.http = http;
        return _this;
    }
    /**
     * @return {?}
     */
    NominatimSearchSource.prototype.getId = /**
     * @return {?}
     */
    function () {
        return NominatimSearchSource.id;
    };
    /**
     * @return {?}
     */
    NominatimSearchSource.prototype.getType = /**
     * @return {?}
     */
    function () {
        return NominatimSearchSource.type;
    };
    /*
     * Source : https://wiki.openstreetmap.org/wiki/Key:amenity
     */
    /*
       * Source : https://wiki.openstreetmap.org/wiki/Key:amenity
       */
    /**
     * @protected
     * @return {?}
     */
    NominatimSearchSource.prototype.getDefaultOptions = /*
       * Source : https://wiki.openstreetmap.org/wiki/Key:amenity
       */
    /**
     * @protected
     * @return {?}
     */
    function () {
        return {
            title: 'Nominatim (OSM)',
            searchUrl: 'https://nominatim.openstreetmap.org/search',
            settings: [
                {
                    type: 'checkbox',
                    title: 'results type',
                    name: 'amenity',
                    values: [
                        {
                            title: 'igo.geo.search.nominatim.type.food',
                            value: 'bar,bbq,biergaten,cafe,drinking_water,fast_food,food_court,ice_cream,pub,restaurant',
                            enabled: false
                        },
                        {
                            title: 'igo.geo.search.nominatim.type.health',
                            value: 'baby_hatch,clinic,dentist,doctors,hospital,nursing_home,pharmacy,social_facility,veterinary',
                            enabled: false
                        },
                        {
                            title: 'igo.geo.search.nominatim.type.entertainment',
                            value: 'arts_centre,brothel,casino,cinema,community_center_fountain,gambling,nightclub,planetarium \
                          ,public_bookcase,social_centre,stripclub,studio,swingerclub,theatre,internet_cafe',
                            enabled: false
                        },
                        {
                            title: 'igo.geo.search.nominatim.type.finance',
                            value: 'atm,bank,bureau_de_change',
                            enabled: false
                        }
                    ]
                },
                {
                    type: 'radiobutton',
                    title: 'results limit',
                    name: 'limit',
                    values: [
                        {
                            title: '10',
                            value: 10,
                            enabled: true
                        },
                        {
                            title: '20',
                            value: 20,
                            enabled: false
                        },
                        {
                            title: '50',
                            value: 50,
                            enabled: false
                        }
                    ]
                },
                {
                    type: 'radiobutton',
                    title: 'restrictExtent',
                    name: 'countrycodes',
                    values: [
                        {
                            title: 'igo.geo.search.nominatim.country.canada',
                            value: 'CA',
                            enabled: true
                        },
                        {
                            title: 'igo.geo.search.nominatim.country.all',
                            value: null,
                            enabled: false
                        }
                    ]
                },
                {
                    type: 'radiobutton',
                    title: 'multiple object',
                    name: 'dedupe',
                    values: [
                        {
                            title: 'igo.geo.search.searchSources.settings.true',
                            value: 0,
                            enabled: false
                        },
                        {
                            title: 'igo.geo.search.searchSources.settings.false',
                            value: 1,
                            enabled: true
                        }
                    ]
                }
            ]
        };
    };
    /**
     * Search a place by name
     * @param term Place name
     * @returns Observable of <SearchResult<Feature>[]
     */
    /**
     * Search a place by name
     * @param {?} term Place name
     * @param {?=} options
     * @return {?} Observable of <SearchResult<Feature>[]
     */
    NominatimSearchSource.prototype.search = /**
     * Search a place by name
     * @param {?} term Place name
     * @param {?=} options
     * @return {?} Observable of <SearchResult<Feature>[]
     */
    function (term, options) {
        var _this = this;
        /** @type {?} */
        var params = this.computeSearchRequestParams(term, options || {});
        if (!params.get('q')) {
            return of([]);
        }
        return this.http
            .get(this.searchUrl, { params: params })
            .pipe(map((/**
         * @param {?} response
         * @return {?}
         */
        function (response) { return _this.extractResults(response); })));
    };
    /**
     * @private
     * @param {?} term
     * @param {?} options
     * @return {?}
     */
    NominatimSearchSource.prototype.computeSearchRequestParams = /**
     * @private
     * @param {?} term
     * @param {?} options
     * @return {?}
     */
    function (term, options) {
        return new HttpParams({
            fromObject: Object.assign({
                q: this.computeTerm(term),
                format: 'json'
            }, this.params, options.params || {})
        });
    };
    /**
     * @private
     * @param {?} response
     * @return {?}
     */
    NominatimSearchSource.prototype.extractResults = /**
     * @private
     * @param {?} response
     * @return {?}
     */
    function (response) {
        var _this = this;
        return response.map((/**
         * @param {?} data
         * @return {?}
         */
        function (data) { return _this.dataToResult(data); }));
    };
    /**
     * @private
     * @param {?} data
     * @return {?}
     */
    NominatimSearchSource.prototype.dataToResult = /**
     * @private
     * @param {?} data
     * @return {?}
     */
    function (data) {
        /** @type {?} */
        var properties = this.computeProperties(data);
        /** @type {?} */
        var geometry = this.computeGeometry(data);
        /** @type {?} */
        var extent = this.computeExtent(data);
        /** @type {?} */
        var id = [this.getId(), 'place', data.place_id].join('.');
        return {
            source: this,
            meta: {
                dataType: FEATURE,
                id: id,
                title: data.display_name,
                icon: 'map-marker'
            },
            data: {
                type: FEATURE,
                projection: 'EPSG:4326',
                geometry: geometry,
                extent: extent,
                properties: properties,
                meta: {
                    id: id,
                    title: data.display_name
                }
            }
        };
    };
    /**
     * @private
     * @param {?} data
     * @return {?}
     */
    NominatimSearchSource.prototype.computeProperties = /**
     * @private
     * @param {?} data
     * @return {?}
     */
    function (data) {
        return {
            display_name: data.display_name,
            place_id: data.place_id,
            osm_type: data.osm_type,
            class: data.class,
            type: data.type
        };
    };
    /**
     * @private
     * @param {?} data
     * @return {?}
     */
    NominatimSearchSource.prototype.computeGeometry = /**
     * @private
     * @param {?} data
     * @return {?}
     */
    function (data) {
        return {
            type: 'Point',
            coordinates: [parseFloat(data.lon), parseFloat(data.lat)]
        };
    };
    /**
     * @private
     * @param {?} data
     * @return {?}
     */
    NominatimSearchSource.prototype.computeExtent = /**
     * @private
     * @param {?} data
     * @return {?}
     */
    function (data) {
        return [
            parseFloat(data.boundingbox[2]),
            parseFloat(data.boundingbox[0]),
            parseFloat(data.boundingbox[3]),
            parseFloat(data.boundingbox[1])
        ];
    };
    /**
     * @private
     * @param {?} term
     * @return {?}
     */
    NominatimSearchSource.prototype.computeTerm = /**
     * @private
     * @param {?} term
     * @return {?}
     */
    function (term) {
        return this.computeTermTags(term);
    };
    /**
     * Add hashtag from query in Nominatim's format (+[])
     * @param term Query with hashtag
     */
    /**
     * Add hashtag from query in Nominatim's format (+[])
     * @private
     * @param {?} term Query with hashtag
     * @return {?}
     */
    NominatimSearchSource.prototype.computeTermTags = /**
     * Add hashtag from query in Nominatim's format (+[])
     * @private
     * @param {?} term Query with hashtag
     * @return {?}
     */
    function (term) {
        /** @type {?} */
        var hashtags = _super.prototype.getHashtagsValid.call(this, term, 'amenity');
        if (!hashtags) {
            return this.computeTermSettings(term);
        }
        if (!hashtags.length) {
            return null;
        }
        term = term.replace(/(#[^\s]*)/g, '');
        hashtags.forEach((/**
         * @param {?} tag
         * @return {?}
         */
        function (tag) {
            term += '+[' + tag + ']';
        }));
        return term;
    };
    /**
     * Add hashtag from settings in Nominatim's format (+[])
     * @param term Query
     */
    /**
     * Add hashtag from settings in Nominatim's format (+[])
     * @private
     * @param {?} term Query
     * @return {?}
     */
    NominatimSearchSource.prototype.computeTermSettings = /**
     * Add hashtag from settings in Nominatim's format (+[])
     * @private
     * @param {?} term Query
     * @return {?}
     */
    function (term) {
        this.options.settings.forEach((/**
         * @param {?} settings
         * @return {?}
         */
        function (settings) {
            if (settings.name === 'amenity') {
                settings.values.forEach((/**
                 * @param {?} conf
                 * @return {?}
                 */
                function (conf) {
                    if (conf.enabled && typeof conf.value === 'string') {
                        /** @type {?} */
                        var splitted = conf.value.split(',');
                        splitted.forEach((/**
                         * @param {?} value
                         * @return {?}
                         */
                        function (value) {
                            term += '+[' + value + ']';
                        }));
                    }
                }));
            }
        }));
        return term;
    };
    NominatimSearchSource.id = 'nominatim';
    NominatimSearchSource.type = FEATURE;
    NominatimSearchSource.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    NominatimSearchSource.ctorParameters = function () { return [
        { type: HttpClient },
        { type: undefined, decorators: [{ type: Inject, args: ['options',] }] }
    ]; };
    return NominatimSearchSource;
}(SearchSource));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Nominatim search source factory
 * @ignore
 * @param {?} http
 * @param {?} config
 * @return {?}
 */
function nominatimSearchSourceFactory(http, config) {
    return new NominatimSearchSource(http, config.getConfig("searchSources." + NominatimSearchSource.id));
}
/**
 * Function that returns a provider for the Nominatim search source
 * @return {?}
 */
function provideNominatimSearchSource() {
    return {
        provide: SearchSource,
        useFactory: nominatimSearchSourceFactory,
        multi: true,
        deps: [HttpClient, ConfigService]
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * StoredQueries search source
 */
var StoredQueriesSearchSource = /** @class */ (function (_super) {
    __extends(StoredQueriesSearchSource, _super);
    function StoredQueriesSearchSource(http, options) {
        var _this = _super.call(this, options) || this;
        _this.http = http;
        _this.storedQueriesOptions = (/** @type {?} */ (options));
        if (_this.storedQueriesOptions && !_this.storedQueriesOptions.available) {
            return _this;
        }
        /** @type {?} */
        var defaultStoredqueryId = 'rtss';
        /** @type {?} */
        var defaultFieldSplitter = [
            { name: 'rtss', defaultValue: '-99' },
            { name: 'chainage', defaultValue: '0', splitPrefix: '\\+' }
        ];
        /** @type {?} */
        var defaultOutputformat = 'text/xml; subtype=gml/3.1.1';
        /** @type {?} */
        var defaultSrsname = 'EPSG:4326';
        /** @type {?} */
        var defaultResultTitle = 'title';
        if (!_this.storedQueriesOptions) {
            console.log(' No configuration for this search source (storedqueries). You will use the default values');
            _this.storedQueriesOptions = {
                storedquery_id: defaultStoredqueryId,
                fields: defaultFieldSplitter,
                outputformat: defaultOutputformat,
                srsname: defaultSrsname,
                resultTitle: defaultResultTitle
            };
            _this.resultTitle = defaultResultTitle;
            console.log('Default values', _this.storedQueriesOptions);
        }
        if (!_this.storedQueriesOptions.storedquery_id) {
            /** @type {?} */
            var err = 'Stored Queries :You have to set "storedquery_id" into StoredQueries options. ex: storedquery_id: "nameofstoredquerie"';
            throw new Error(err);
        }
        if (!_this.storedQueriesOptions.fields) {
            throw new Error('Stored Queries :You have to set "fields" into options. ex: fields: {"name": "rtss", "defaultValue": "-99"}');
        }
        _this.storedQueriesOptions.outputformat =
            _this.storedQueriesOptions.outputformat || 'text/xml; subtype=gml/3.1.1';
        _this.storedQueriesOptions.srsname =
            _this.storedQueriesOptions.srsname || 'EPSG:4326';
        /** @type {?} */
        var storedQueryId = _this.storedQueriesOptions.storedquery_id.toLowerCase();
        if (storedQueryId.includes('getfeaturebyid') &&
            _this.storedQueriesOptions.outputformat
                .toLowerCase()
                .includes('getfeaturebyid')) {
            /** @type {?} */
            var err = 'You must set a geojson format for your stored query. This is due to an openlayers issue)';
            err += ' (wfs 1.1.0 & gml 3.1.1 limitation)';
            throw new Error(err);
        }
        if (!(_this.storedQueriesOptions.fields instanceof Array)) {
            _this.storedQueriesOptions.fields = [_this.storedQueriesOptions.fields];
        }
        _this.multipleFieldsQuery =
            _this.storedQueriesOptions.fields.length > 1 ? true : false;
        _this.storedQueriesOptions.fields.forEach((/**
         * @param {?} field
         * @param {?} index
         * @return {?}
         */
        function (field, index) {
            if (_this.multipleFieldsQuery && !field.splitPrefix && index !== 0) {
                throw new Error('Stored Queries :You must set a field spliter into your field definition (optional for the first one!)');
            }
            if (!field.defaultValue) {
                throw new Error('Stored Queries :You must set a field default value into your field definition');
            }
        }));
        _this.storedQueriesOptions.resultTitle =
            _this.storedQueriesOptions.resultTitle || _this.resultTitle;
        return _this;
    }
    /**
     * @return {?}
     */
    StoredQueriesSearchSource.prototype.getId = /**
     * @return {?}
     */
    function () {
        return StoredQueriesSearchSource.id;
    };
    /**
     * @return {?}
     */
    StoredQueriesSearchSource.prototype.getType = /**
     * @return {?}
     */
    function () {
        return StoredQueriesSearchSource.type;
    };
    /**
     * @protected
     * @return {?}
     */
    StoredQueriesSearchSource.prototype.getDefaultOptions = /**
     * @protected
     * @return {?}
     */
    function () {
        return {
            title: 'Stored Queries',
            searchUrl: 'https://geoegl.msp.gouv.qc.ca/apis/ws/swtq'
        };
    };
    // URL CALL EXAMPLES:
    //  GetFeatureById (mandatory storedquery for wfs server) (outputformat must be in geojson)
    //  tslint:disable-next-line:max-line-length
    //  https://geoegl.msp.gouv.qc.ca/apis/ws/swtq?service=wfs&version=2.0.0&request=GetFeature&storedquery_id=urn:ogc:def:query:OGC-WFS::GetFeatureById&srsname=epsg:4326&outputformat=geojson&ID=a_num_route.132
    //  Custom StoredQuery
    //  tslint:disable-next-line:max-line-length
    //  https://geoegl.msp.gouv.qc.ca/apis/ws/swtq?service=wfs&version=1.1.0&request=GetFeature&storedquery_id=rtss&srsname=epsg:4326&outputformat=text/xml;%20subtype=gml/3.1.1&rtss=0013801110000c&chainage=12
    /**
     * Search a location by name or keyword
     * @param term Location name or keyword
     * @returns Observable of <SearchResult<Feature>[]
     */
    // URL CALL EXAMPLES:
    //  GetFeatureById (mandatory storedquery for wfs server) (outputformat must be in geojson)
    //  tslint:disable-next-line:max-line-length
    //  https://geoegl.msp.gouv.qc.ca/apis/ws/swtq?service=wfs&version=2.0.0&request=GetFeature&storedquery_id=urn:ogc:def:query:OGC-WFS::GetFeatureById&srsname=epsg:4326&outputformat=geojson&ID=a_num_route.132
    //  Custom StoredQuery
    //  tslint:disable-next-line:max-line-length
    //  https://geoegl.msp.gouv.qc.ca/apis/ws/swtq?service=wfs&version=1.1.0&request=GetFeature&storedquery_id=rtss&srsname=epsg:4326&outputformat=text/xml;%20subtype=gml/3.1.1&rtss=0013801110000c&chainage=12
    /**
     * Search a location by name or keyword
     * @param {?} term Location name or keyword
     * @param {?=} options
     * @return {?} Observable of <SearchResult<Feature>[]
     */
    StoredQueriesSearchSource.prototype.search = 
    // URL CALL EXAMPLES:
    //  GetFeatureById (mandatory storedquery for wfs server) (outputformat must be in geojson)
    //  tslint:disable-next-line:max-line-length
    //  https://geoegl.msp.gouv.qc.ca/apis/ws/swtq?service=wfs&version=2.0.0&request=GetFeature&storedquery_id=urn:ogc:def:query:OGC-WFS::GetFeatureById&srsname=epsg:4326&outputformat=geojson&ID=a_num_route.132
    //  Custom StoredQuery
    //  tslint:disable-next-line:max-line-length
    //  https://geoegl.msp.gouv.qc.ca/apis/ws/swtq?service=wfs&version=1.1.0&request=GetFeature&storedquery_id=rtss&srsname=epsg:4326&outputformat=text/xml;%20subtype=gml/3.1.1&rtss=0013801110000c&chainage=12
    /**
     * Search a location by name or keyword
     * @param {?} term Location name or keyword
     * @param {?=} options
     * @return {?} Observable of <SearchResult<Feature>[]
     */
    function (term, options) {
        var _this = this;
        /** @type {?} */
        var storedqueriesParams = this.termSplitter(term, this.storedQueriesOptions.fields);
        /** @type {?} */
        var params = this.computeRequestParams(options || {}, storedqueriesParams);
        if (new RegExp('.*?gml.*?', 'i').test(this.storedQueriesOptions.outputformat)) {
            return this.http
                .get(this.searchUrl, { params: params, responseType: 'text' })
                .pipe(map((/**
             * @param {?} response
             * @return {?}
             */
            function (response) {
                return _this.extractResults(_this.extractWFSData(response));
            })));
        }
        else {
            return this.http.get(this.searchUrl, { params: params }).pipe(map((/**
             * @param {?} response
             * @return {?}
             */
            function (response) {
                return _this.extractResults(_this.extractWFSData(response));
            })));
        }
    };
    /**
     * @private
     * @return {?}
     */
    StoredQueriesSearchSource.prototype.getFormatFromOptions = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var olFormatCls;
        /** @type {?} */
        var outputFormat = this.storedQueriesOptions.outputformat;
        /** @type {?} */
        var patternGml3 = new RegExp('.*?gml.*?', 'i');
        /** @type {?} */
        var patternGeojson = new RegExp('.*?json.*?', 'i');
        if (patternGeojson.test(outputFormat)) {
            olFormatCls = GeoJSON;
        }
        if (patternGml3.test(outputFormat)) {
            olFormatCls = WFS;
        }
        return new olFormatCls();
    };
    /**
     * @private
     * @param {?} res
     * @return {?}
     */
    StoredQueriesSearchSource.prototype.extractWFSData = /**
     * @private
     * @param {?} res
     * @return {?}
     */
    function (res) {
        /** @type {?} */
        var olFormat = this.getFormatFromOptions();
        /** @type {?} */
        var geojson = GeoJSON;
        /** @type {?} */
        var wfsfeatures = olFormat.readFeatures(res);
        /** @type {?} */
        var features = JSON.parse(new geojson().writeFeatures(wfsfeatures));
        return features;
    };
    /**
     * @private
     * @param {?} term
     * @param {?} fields
     * @return {?}
     */
    StoredQueriesSearchSource.prototype.termSplitter = /**
     * @private
     * @param {?} term
     * @param {?} fields
     * @return {?}
     */
    function (term, fields) {
        /** @type {?} */
        var splittedTerm = {};
        /** @type {?} */
        var remainingTerm = term;
        /** @type {?} */
        var cnt = 0;
        // Used to build the default values
        fields.forEach((/**
         * @param {?} field
         * @return {?}
         */
        function (field) {
            splittedTerm[field.name] = field.defaultValue;
            /** @type {?} */
            var splitterRegex = new RegExp(field.splitPrefix + '(.+)', 'i');
            if (splitterRegex.test(remainingTerm)) {
                cnt = field.splitPrefix ? (cnt += 1) : cnt;
                remainingTerm = remainingTerm.split(splitterRegex)[1];
            }
        }));
        if (cnt === 0) {
            splittedTerm[fields[0].name] = term;
            return splittedTerm;
        }
        remainingTerm = term;
        /** @type {?} */
        var localFields = __spread(fields).reverse();
        localFields.forEach((/**
         * @param {?} field
         * @return {?}
         */
        function (field) {
            /** @type {?} */
            var splitterRegex = new RegExp(field.splitPrefix || '' + '(.+)', 'i');
            if (remainingTerm || remainingTerm !== '') {
                /** @type {?} */
                var values = remainingTerm.split(splitterRegex);
                remainingTerm = values[0];
                if (values[1]) {
                    splittedTerm[field.name] = values[1].trim();
                }
            }
        }));
        return splittedTerm;
    };
    /**
     * @private
     * @param {?} options
     * @param {?} queryParams
     * @return {?}
     */
    StoredQueriesSearchSource.prototype.computeRequestParams = /**
     * @private
     * @param {?} options
     * @param {?} queryParams
     * @return {?}
     */
    function (options, queryParams) {
        /** @type {?} */
        var wfsversion = this.storedQueriesOptions.storedquery_id
            .toLowerCase()
            .includes('getfeaturebyid')
            ? '2.0.0'
            : '1.1.0';
        return new HttpParams({
            fromObject: Object.assign({
                service: 'wfs',
                version: wfsversion,
                request: 'GetFeature',
                storedquery_id: this.storedQueriesOptions.storedquery_id,
                srsname: this.storedQueriesOptions.srsname,
                outputformat: this.storedQueriesOptions.outputformat
            }, queryParams, this.params, options.params || {})
        });
    };
    /**
     * @private
     * @param {?} response
     * @return {?}
     */
    StoredQueriesSearchSource.prototype.extractResults = /**
     * @private
     * @param {?} response
     * @return {?}
     */
    function (response) {
        var _this = this;
        return response.features.map((/**
         * @param {?} data
         * @return {?}
         */
        function (data) {
            return _this.dataToResult(data);
        }));
    };
    /**
     * @private
     * @param {?} data
     * @return {?}
     */
    StoredQueriesSearchSource.prototype.dataToResult = /**
     * @private
     * @param {?} data
     * @return {?}
     */
    function (data) {
        /** @type {?} */
        var properties = this.computeProperties(data);
        /** @type {?} */
        var id = [this.getId(), properties.type, data.id].join('.');
        /** @type {?} */
        var title = data.properties[this.storedQueriesOptions.resultTitle]
            ? this.storedQueriesOptions.resultTitle
            : this.resultTitle;
        return {
            source: this,
            data: {
                type: FEATURE,
                projection: 'EPSG:4326',
                geometry: data.geometry,
                // extent: data.bbox,
                properties: properties,
                meta: {
                    id: id,
                    title: data.properties[title]
                }
            },
            meta: {
                dataType: FEATURE,
                id: id,
                title: data.properties.title,
                titleHtml: data.properties[title],
                icon: 'map-marker'
            }
        };
    };
    /**
     * @private
     * @param {?} data
     * @return {?}
     */
    StoredQueriesSearchSource.prototype.computeProperties = /**
     * @private
     * @param {?} data
     * @return {?}
     */
    function (data) {
        /** @type {?} */
        var properties = ObjectUtils.removeKeys(data.properties, StoredQueriesSearchSource.propertiesBlacklist);
        return properties;
    };
    StoredQueriesSearchSource.id = 'storedqueries';
    StoredQueriesSearchSource.type = FEATURE;
    StoredQueriesSearchSource.propertiesBlacklist = [
        'boundedBy',
        'id',
        'coord_x',
        'coord_y'
    ];
    StoredQueriesSearchSource.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    StoredQueriesSearchSource.ctorParameters = function () { return [
        { type: HttpClient },
        { type: undefined, decorators: [{ type: Inject, args: ['options',] }] }
    ]; };
    return StoredQueriesSearchSource;
}(SearchSource));
/**
 * StoredQueriesReverse search source
 */
// EXAMPLE CALLS
// tslint:disable-next-line:max-line-length
// https://ws.mapserver.transports.gouv.qc.ca/swtq?service=wfs&version=1.1.0&request=GetFeature&storedquery_id=lim_adm&srsname=epsg:4326&outputformat=text/xml;%20subtype=gml/3.1.1&long=-71.292469&lat=46.748107
//
var StoredQueriesReverseSearchSource = /** @class */ (function (_super) {
    __extends(StoredQueriesReverseSearchSource, _super);
    function StoredQueriesReverseSearchSource(http, options) {
        var _this = _super.call(this, options) || this;
        _this.http = http;
        _this.storedQueriesOptions = (/** @type {?} */ (options));
        if (!_this.storedQueriesOptions.storedquery_id) {
            /** @type {?} */
            var err = 'Stored Queries :You have to set "storedquery_id" into StoredQueries options. ex: storedquery_id: "nameofstoredquerie"';
            throw new Error(err);
        }
        if (!_this.storedQueriesOptions.longField) {
            throw new Error('Stored Queries :You have to set "longField" to map the longitude coordinate to the query params.');
        }
        if (!_this.storedQueriesOptions.latField) {
            throw new Error('Stored Queries :You have to set "latField" to map the latitude coordinate to the query params.');
        }
        _this.storedQueriesOptions.outputformat =
            _this.storedQueriesOptions.outputformat || 'text/xml; subtype=gml/3.1.1';
        _this.storedQueriesOptions.srsname =
            _this.storedQueriesOptions.srsname || 'EPSG:4326';
        _this.storedQueriesOptions.resultTitle =
            _this.storedQueriesOptions.resultTitle || _this.resultTitle;
        return _this;
    }
    /**
     * @return {?}
     */
    StoredQueriesReverseSearchSource.prototype.getId = /**
     * @return {?}
     */
    function () {
        return StoredQueriesReverseSearchSource.id;
    };
    /**
     * @return {?}
     */
    StoredQueriesReverseSearchSource.prototype.getType = /**
     * @return {?}
     */
    function () {
        return StoredQueriesReverseSearchSource.type;
    };
    /**
     * @protected
     * @return {?}
     */
    StoredQueriesReverseSearchSource.prototype.getDefaultOptions = /**
     * @protected
     * @return {?}
     */
    function () {
        return {
            title: 'Stored Queries (reverse)',
            searchUrl: 'https://ws.mapserver.transports.gouv.qc.ca/swtq'
        };
    };
    /**
     * Search a location by coordinates
     * @param lonLat Location coordinates
     * @param distance Search raidus around lonLat
     * @returns Observable of <SearchResult<Feature>[]
     */
    /**
     * Search a location by coordinates
     * @param {?} lonLat Location coordinates
     * @param {?=} options
     * @return {?} Observable of <SearchResult<Feature>[]
     */
    StoredQueriesReverseSearchSource.prototype.reverseSearch = /**
     * Search a location by coordinates
     * @param {?} lonLat Location coordinates
     * @param {?=} options
     * @return {?} Observable of <SearchResult<Feature>[]
     */
    function (lonLat, options) {
        var _this = this;
        /** @type {?} */
        var params = this.computeRequestParams(lonLat, options || {});
        if (new RegExp('.*?gml.*?', 'i').test(this.storedQueriesOptions.outputformat)) {
            return this.http
                .get(this.searchUrl, { params: params, responseType: 'text' })
                .pipe(map((/**
             * @param {?} response
             * @return {?}
             */
            function (response) {
                return _this.extractResults(_this.extractWFSData(response));
            })));
        }
        else {
            return this.http.get(this.searchUrl, { params: params }).pipe(map((/**
             * @param {?} response
             * @return {?}
             */
            function (response) {
                return _this.extractResults(_this.extractWFSData(response));
            })));
        }
    };
    /**
     * @private
     * @return {?}
     */
    StoredQueriesReverseSearchSource.prototype.getFormatFromOptions = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var olFormatCls;
        /** @type {?} */
        var outputFormat = this.storedQueriesOptions.outputformat;
        /** @type {?} */
        var patternGml3 = new RegExp('.*?gml.*?', 'i');
        /** @type {?} */
        var patternGeojson = new RegExp('.*?json.*?', 'i');
        if (patternGeojson.test(outputFormat)) {
            olFormatCls = GeoJSON;
        }
        if (patternGml3.test(outputFormat)) {
            olFormatCls = WFS;
        }
        return new olFormatCls();
    };
    /**
     * @private
     * @param {?} res
     * @return {?}
     */
    StoredQueriesReverseSearchSource.prototype.extractWFSData = /**
     * @private
     * @param {?} res
     * @return {?}
     */
    function (res) {
        /** @type {?} */
        var olFormat = this.getFormatFromOptions();
        /** @type {?} */
        var geojson = GeoJSON;
        /** @type {?} */
        var wfsfeatures = olFormat.readFeatures(res);
        /** @type {?} */
        var features = JSON.parse(new geojson().writeFeatures(wfsfeatures));
        return features;
    };
    /**
     * @private
     * @param {?} lonLat
     * @param {?=} options
     * @return {?}
     */
    StoredQueriesReverseSearchSource.prototype.computeRequestParams = /**
     * @private
     * @param {?} lonLat
     * @param {?=} options
     * @return {?}
     */
    function (lonLat, options) {
        /** @type {?} */
        var longLatParams = {};
        longLatParams[this.storedQueriesOptions.longField] = lonLat[0];
        longLatParams[this.storedQueriesOptions.latField] = lonLat[1];
        return new HttpParams({
            fromObject: Object.assign({
                service: 'WFS',
                version: '1.1.0',
                request: 'GetFeature',
                storedquery_id: this.storedQueriesOptions.storedquery_id,
                srsname: this.storedQueriesOptions.srsname,
                outputformat: this.storedQueriesOptions.outputformat
            }, longLatParams, this.params, options.params || {})
        });
    };
    /**
     * @private
     * @param {?} response
     * @return {?}
     */
    StoredQueriesReverseSearchSource.prototype.extractResults = /**
     * @private
     * @param {?} response
     * @return {?}
     */
    function (response) {
        var _this = this;
        return response.features.map((/**
         * @param {?} data
         * @return {?}
         */
        function (data) {
            return _this.dataToResult(data);
        }));
    };
    /**
     * @private
     * @param {?} data
     * @return {?}
     */
    StoredQueriesReverseSearchSource.prototype.dataToResult = /**
     * @private
     * @param {?} data
     * @return {?}
     */
    function (data) {
        /** @type {?} */
        var properties = this.computeProperties(data);
        /** @type {?} */
        var id = [this.getId(), properties.type, data.id].join('.');
        /** @type {?} */
        var title = data.properties[this.storedQueriesOptions.resultTitle]
            ? this.storedQueriesOptions.resultTitle
            : this.resultTitle;
        return {
            source: this,
            data: {
                type: FEATURE,
                projection: 'EPSG:4326',
                geometry: data.geometry,
                properties: properties,
                meta: {
                    id: id,
                    title: data.properties[title]
                }
            },
            meta: {
                dataType: FEATURE,
                id: id,
                title: data.properties[title],
                icon: 'map-marker'
            }
        };
    };
    /**
     * @private
     * @param {?} data
     * @return {?}
     */
    StoredQueriesReverseSearchSource.prototype.computeProperties = /**
     * @private
     * @param {?} data
     * @return {?}
     */
    function (data) {
        /** @type {?} */
        var properties = ObjectUtils.removeKeys(data.properties, StoredQueriesReverseSearchSource.propertiesBlacklist);
        return Object.assign(properties, { type: data.properties.doc_type });
    };
    StoredQueriesReverseSearchSource.id = 'storedqueriesreverse';
    StoredQueriesReverseSearchSource.type = FEATURE;
    StoredQueriesReverseSearchSource.propertiesBlacklist = [];
    StoredQueriesReverseSearchSource.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    StoredQueriesReverseSearchSource.ctorParameters = function () { return [
        { type: HttpClient },
        { type: undefined, decorators: [{ type: Inject, args: ['options',] }] }
    ]; };
    return StoredQueriesReverseSearchSource;
}(SearchSource));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * StoredQueries search source factory
 * @ignore
 * @param {?} http
 * @param {?} config
 * @return {?}
 */
function storedqueriesSearchSourceFactory(http, config) {
    return new StoredQueriesSearchSource(http, config.getConfig("searchSources." + StoredQueriesSearchSource.id));
}
/**
 * Function that returns a provider for the StoredQueries search source
 * @return {?}
 */
function provideStoredQueriesSearchSource() {
    return {
        provide: SearchSource,
        useFactory: storedqueriesSearchSourceFactory,
        multi: true,
        deps: [HttpClient, ConfigService]
    };
}
/**
 * StoredQueriesReverse search source factory
 * @ignore
 * @param {?} http
 * @param {?} config
 * @return {?}
 */
function storedqueriesReverseSearchSourceFactory(http, config) {
    return new StoredQueriesReverseSearchSource(http, config.getConfig("searchSources." + StoredQueriesReverseSearchSource.id));
}
/**
 * Function that returns a provider for the StoredQueriesReverse search source
 * @return {?}
 */
function provideStoredQueriesReverseSearchSource() {
    return {
        provide: SearchSource,
        useFactory: storedqueriesReverseSearchSourceFactory,
        multi: true,
        deps: [HttpClient, ConfigService]
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
var DirectionsFormat = {
    GeoJSON: 0,
    JSON: 1,
};
DirectionsFormat[DirectionsFormat.GeoJSON] = 'GeoJSON';
DirectionsFormat[DirectionsFormat.JSON] = 'JSON';
/** @enum {string} */
var SourceDirectionsType = {
    Route: 'Route',
    Trip: 'Trip',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var OsrmDirectionsSource = /** @class */ (function (_super) {
    __extends(OsrmDirectionsSource, _super);
    function OsrmDirectionsSource(http, config) {
        var _this = _super.call(this) || this;
        _this.http = http;
        _this.config = config;
        _this.directionsUrl = 'https://geoegl.msp.gouv.qc.ca/services/itineraire/route/v1/driving/';
        _this.options = _this.config.getConfig('directionsSources.osrm') || {};
        _this.directionsUrl = _this.options.url || _this.directionsUrl;
        return _this;
    }
    Object.defineProperty(OsrmDirectionsSource.prototype, "enabled", {
        get: /**
         * @return {?}
         */
        function () {
            return this.options.enabled !== false;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.options.enabled = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OsrmDirectionsSource.prototype.getName = /**
     * @return {?}
     */
    function () {
        return OsrmDirectionsSource._name;
    };
    /**
     * @param {?} coordinates
     * @param {?=} directionsOptions
     * @return {?}
     */
    OsrmDirectionsSource.prototype.route = /**
     * @param {?} coordinates
     * @param {?=} directionsOptions
     * @return {?}
     */
    function (coordinates, directionsOptions) {
        var _this = this;
        if (directionsOptions === void 0) { directionsOptions = {}; }
        /** @type {?} */
        var directionsParams = this.getRouteParams(directionsOptions);
        return this.http
            .get(this.directionsUrl + coordinates.join(';'), {
            params: directionsParams
        })
            .pipe(map((/**
         * @param {?} res
         * @return {?}
         */
        function (res) { return _this.extractRoutesData(res); })));
    };
    /**
     * @private
     * @param {?} response
     * @return {?}
     */
    OsrmDirectionsSource.prototype.extractRoutesData = /**
     * @private
     * @param {?} response
     * @return {?}
     */
    function (response) {
        var _this = this;
        /** @type {?} */
        var routeResponse = [];
        response.routes.forEach((/**
         * @param {?} route
         * @return {?}
         */
        function (route) {
            routeResponse.push(_this.formatRoute(route, response.waypoints));
        }));
        return routeResponse;
    };
    /**
     * @private
     * @param {?=} directionsOptions
     * @return {?}
     */
    OsrmDirectionsSource.prototype.getRouteParams = /**
     * @private
     * @param {?=} directionsOptions
     * @return {?}
     */
    function (directionsOptions) {
        if (directionsOptions === void 0) { directionsOptions = {}; }
        directionsOptions.alternatives = directionsOptions.alternatives !== undefined ? directionsOptions.alternatives : true;
        directionsOptions.steps = directionsOptions.steps !== undefined ? directionsOptions.steps : true;
        directionsOptions.geometries = directionsOptions.geometries !== undefined ? directionsOptions.geometries : 'geojson';
        directionsOptions.overview = directionsOptions.overview !== undefined ? directionsOptions.overview : false;
        return new HttpParams({
            fromObject: {
                alternatives: directionsOptions.alternatives ? 'true' : 'false',
                overview: directionsOptions.overview ? 'simplified' : 'full',
                steps: directionsOptions.steps ? 'true' : 'false',
                geometries: directionsOptions.geometries ? directionsOptions.geometries : 'geojson',
            }
        });
    };
    /**
     * @private
     * @param {?} roadNetworkRoute
     * @param {?} waypoints
     * @return {?}
     */
    OsrmDirectionsSource.prototype.formatRoute = /**
     * @private
     * @param {?} roadNetworkRoute
     * @param {?} waypoints
     * @return {?}
     */
    function (roadNetworkRoute, waypoints) {
        /** @type {?} */
        var stepsUI = [];
        roadNetworkRoute.legs.forEach((/**
         * @param {?} leg
         * @return {?}
         */
        function (leg) {
            leg.steps.forEach((/**
             * @param {?} step
             * @return {?}
             */
            function (step) {
                stepsUI.push(step);
            }));
        }));
        return {
            id: uuid(),
            title: roadNetworkRoute.legs[0].summary,
            source: OsrmDirectionsSource._name,
            sourceType: SourceDirectionsType.Route,
            order: 1,
            format: DirectionsFormat.GeoJSON,
            icon: 'directions',
            projection: 'EPSG:4326',
            waypoints: waypoints,
            distance: roadNetworkRoute.distance,
            duration: roadNetworkRoute.duration,
            geometry: roadNetworkRoute.geometry,
            legs: roadNetworkRoute.legs,
            steps: stepsUI,
            weight: roadNetworkRoute.weight,
            weight_name: roadNetworkRoute.weight_name
        };
    };
    OsrmDirectionsSource._name = 'OSRM Québec';
    OsrmDirectionsSource.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    OsrmDirectionsSource.ctorParameters = function () { return [
        { type: HttpClient },
        { type: ConfigService }
    ]; };
    return OsrmDirectionsSource;
}(DirectionsSource));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} http
 * @param {?} config
 * @return {?}
 */
function osrmDirectionsSourcesFactory(http, config) {
    return new OsrmDirectionsSource(http, config);
}
/**
 * @return {?}
 */
function provideOsrmDirectionsSource() {
    return {
        provide: DirectionsSource,
        useFactory: osrmDirectionsSourcesFactory,
        multi: true,
        deps: [HttpClient, ConfigService]
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ExportIonicService = /** @class */ (function (_super) {
    __extends(ExportIonicService, _super);
    function ExportIonicService(config, platform, fileOpener, file) {
        var _this = _super.call(this, config) || this;
        _this.platform = platform;
        _this.fileOpener = fileOpener;
        _this.file = file;
        return _this;
    }
    /**
     * @protected
     * @param {?} olFeatures
     * @param {?} observer
     * @param {?} format
     * @param {?} title
     * @param {?} projectionIn
     * @param {?} projectionOut
     * @return {?}
     */
    ExportIonicService.prototype.exportToFile = /**
     * @protected
     * @param {?} olFeatures
     * @param {?} observer
     * @param {?} format
     * @param {?} title
     * @param {?} projectionIn
     * @param {?} projectionOut
     * @return {?}
     */
    function (olFeatures, observer, format, title, projectionIn, projectionOut) {
        var _this = this;
        if (this.platform.is('cordova')) {
            /** @type {?} */
            var olFormat = new olformat[format]();
            /** @type {?} */
            var featuresText = olFormat.writeFeatures(olFeatures, {
                dataProjection: projectionOut,
                featureProjection: projectionIn,
                featureType: 'feature',
                featureNS: 'http://example.com/feature'
            });
            /** @type {?} */
            var fileName_1 = title + "." + format.toLowerCase();
            /** @type {?} */
            var directory_1 = this.file.externalRootDirectory + 'Download';
            console.log(directory_1);
            this.file.writeFile(directory_1, fileName_1, featuresText, { replace: true }).then((/**
             * @param {?} success
             * @return {?}
             */
            function (success) {
                return _this.fileOpener.open(directory_1 + '/' + fileName_1, 'text/plain');
            }));
            observer.complete();
        }
        else {
            _super.prototype.exportToFile.call(this, olFeatures, observer, format, title, projectionIn, projectionOut);
        }
    };
    ExportIonicService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    ExportIonicService.ctorParameters = function () { return [
        { type: ConfigService },
        { type: Platform },
        { type: FileOpener },
        { type: File }
    ]; };
    /** @nocollapse */ ExportIonicService.ngInjectableDef = defineInjectable({ factory: function ExportIonicService_Factory() { return new ExportIonicService(inject(ConfigService), inject(Platform), inject(FileOpener$1), inject(File$1)); }, token: ExportIonicService, providedIn: "root" });
    return ExportIonicService;
}(ExportService));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var PrintIonicService = /** @class */ (function (_super) {
    __extends(PrintIonicService, _super);
    function PrintIonicService(messageService, activityService, languageService, platform, fileOpener, file) {
        var _this = _super.call(this, messageService, activityService, languageService) || this;
        _this.platform = platform;
        _this.fileOpener = fileOpener;
        _this.file = file;
        return _this;
    }
    /**
     * @protected
     * @param {?} doc
     * @return {?}
     */
    PrintIonicService.prototype.saveDoc = /**
     * @protected
     * @param {?} doc
     * @return {?}
     */
    function (doc) {
        var _this = this;
        if (this.platform.is('cordova')) {
            /** @type {?} */
            var docOutput = doc.output();
            /** @type {?} */
            var buffer$$1 = new ArrayBuffer(docOutput.length);
            /** @type {?} */
            var array = new Uint8Array(buffer$$1);
            this.setDate();
            for (var i = 0; i < docOutput.length; i++) {
                array[i] = docOutput.charCodeAt(i);
            }
            /** @type {?} */
            var fileName_1 = 'map' + this.year + '-' + this.month + '-' + this.day + '-' + this.hour + '-' + this.minute + '.pdf';
            /** @type {?} */
            var directory_1 = this.file.externalRootDirectory + 'Download';
            this.file.writeFile(directory_1, fileName_1, buffer$$1, { replace: true }).then((/**
             * @param {?} success
             * @return {?}
             */
            function (success) {
                return _this.fileOpener.open(directory_1 + '/' + fileName_1, 'application/pdf');
            }));
        }
        else {
            _super.prototype.saveDoc.call(this, doc);
        }
    };
    /**
     * @private
     * @return {?}
     */
    PrintIonicService.prototype.setDate = /**
     * @private
     * @return {?}
     */
    function () {
        this.date = new Date();
        this.day = this.date.getDate().toString();
        this.month = this.date.getMonth() + 1;
        if (this.month < 10) {
            this.month = '0' + this.month.toString();
        }
        else {
            this.month = this.month.toString();
        }
        this.year = this.date.getFullYear().toString();
        this.hour = this.date.getHours().toString();
        this.minute = this.date.getMinutes().toString();
    };
    PrintIonicService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    PrintIonicService.ctorParameters = function () { return [
        { type: MessageService },
        { type: ActivityService },
        { type: LanguageService },
        { type: Platform },
        { type: FileOpener },
        { type: File }
    ]; };
    /** @nocollapse */ PrintIonicService.ngInjectableDef = defineInjectable({ factory: function PrintIonicService_Factory() { return new PrintIonicService(inject(MessageService), inject(ActivityService), inject(LanguageService), inject(Platform), inject(FileOpener$1), inject(File$1)); }, token: PrintIonicService, providedIn: "root" });
    return PrintIonicService;
}(PrintService));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { IgoGeoModule, IgoCatalogModule, IgoCatalogBrowserModule, IgoCatalogLibraryModule, IgoDataSourceModule, IgoDirectionsModule, IgoDownloadModule, IgoGeoWorkspaceModule, IgoWorkspaceSelectorModule, IgoOgcFilterModule, IgoFeatureModule, IgoFeatureFormModule, IgoFeatureDetailsModule, IgoFilterModule, IgoGeometryModule, IgoGeometryFormFieldModule, IgoImportExportModule, IgoLayerModule, IgoMapModule, IgoMeasureModule, IgoMeasurerModule, IgoMetadataModule, IgoOverlayModule, IgoPrintModule, IgoQueryModule, IgoSearchModule, IgoSearchBarModule, SearchBarComponent, IgoSearchResultsModule, IgoToastModule, IgoWktModule, optionsApiFactory, provideOptionsApi, querySearchSourceFactory, provideQuerySearchSource, cadastreSearchSourceFactory, provideCadastreSearchSource, defaultIChercheSearchResultFormatterFactory, provideDefaultIChercheSearchResultFormatter, ichercheSearchSourceFactory, provideIChercheSearchSource, ichercheReverseSearchSourceFactory, provideIChercheReverseSearchSource, defaultCoordinatesSearchResultFormatterFactory, provideDefaultCoordinatesSearchResultFormatter, CoordinatesReverseSearchSourceFactory, provideCoordinatesReverseSearchSource, ilayerSearchResultFormatterFactory, provideILayerSearchResultFormatter, ilayerSearchSourceFactory, provideILayerSearchSource, nominatimSearchSourceFactory, provideNominatimSearchSource, storedqueriesSearchSourceFactory, provideStoredQueriesSearchSource, storedqueriesReverseSearchSourceFactory, provideStoredQueriesReverseSearchSource, osrmDirectionsSourcesFactory, provideOsrmDirectionsSource, directionsSourceServiceFactory, provideDirectionsSourceService, DirectionsSourceService, provideStyleListOptions, styleListFactory, provideStyleListLoader, STYLELIST_OPTIONS, CatalogService, CatalogItemType, TypeCatalog, Catalog, CompositeCatalog, CatalogFactory, CatalogBrowserComponent, CatalogLibaryComponent, DataService, DataSource, FeatureDataSource, OSMDataSource, XYZDataSource, WFSDataSource, WFSService, WMSDataSource, formatWFSQueryString, checkWfsParams, getFormatFromOptions, defaultEpsg, defaultMaxFeatures, defaultWfsVersion, defaultFieldNameGeometry, gmlRegex, jsonRegex, WMTSDataSource, CartoDataSource, ArcGISRestDataSource, TileArcGISRestDataSource, WebSocketDataSource, MVTDataSource, ClusterDataSource, DataSourceService, TypeCapabilities, CapabilitiesService, OptionsService, OptionsApiService, EsriStyleGenerator, createDefaultTileGrid, DownloadService, DownloadButtonComponent, FEATURE, FeatureMotion, featureToOl, renderFeatureFromOl, featureFromOl, computeOlFeatureExtent, computeOlFeaturesExtent, scaleExtent, featuresAreOutOfView, featuresAreTooDeepInView, moveToOlFeatures, hideOlFeature, tryBindStoreLayer, tryAddLoadingStrategy, tryAddSelectionStrategy, computeOlFeaturesDiff, FeatureStore, FeatureStoreLoadingStrategy, FeatureStoreLoadingLayerStrategy, FeatureStoreSelectionStrategy, FeatureFormComponent, FilterableDataSourcePipe, TimeFilterType, TimeFilterStyle, TimeFilterService, OgcFilterOperatorType, OGCFilterService, OgcFilterWriter, SpatialFilterQueryType, SpatialFilterType, SpatialFilterItemType, SpatialFilterService, TimeFilterFormComponent, TimeFilterItemComponent, TimeFilterListComponent, TimeFilterListBindingDirective, OgcFilterableFormComponent, OgcFilterableItemComponent, OgcFilterableListComponent, OgcFilterableListBindingDirective, OgcFilterFormComponent, OgcFilterToggleButtonComponent, OgcFilterButtonComponent, TimeFilterButtonComponent, SpatialFilterTypeComponent, SpatialFilterListComponent, SpatialFilterItemComponent, GeometrySliceError, GeometrySliceMultiPolygonError, GeometrySliceLineStringError, GeometrySliceTooManyIntersectionError, createDrawInteractionStyle, createDrawHoleInteractionStyle, sliceOlGeometry, sliceOlLineString, sliceOlPolygon, addLinearRingToOlPolygon, getMousePositionFromOlGeometryEvent, DrawControl, ModifyControl, SliceControl, DropGeoFileDirective, ExportError, ExportInvalidFileError, ExportNothingToExportError, ExportService, ExportIonicService, ExportFormat, handleFileExportError, handleFileExportSuccess, handleNothingToExportError, exportToCSV, entitiesToRowData, ImportError, ImportInvalidFileError, ImportUnreadableFileError, ImportNothingToImportError, ImportSizeError, ImportSRSError, ImportService, addLayerAndFeaturesToMap, addLayerAndFeaturesStyledToMap, handleFileImportSuccess, handleFileImportError, handleInvalidFileImportError, handleUnreadbleFileImportError, handleSizeFileImportError, handleNothingToImportError, handleSRSImportError, getFileExtension, computeLayerTitleFromFile, ImportExportComponent, StyleListService, LayerService, LAYER, Layer, TooltipType, ImageLayer, TileLayer, VectorLayer, VectorTileLayer, StyleService, LayerItemComponent, LayerLegendComponent, LayerLegendItemComponent, LayerLegendListComponent, LayerListComponent, LayerListBindingDirective, LayerListControlsEnum, LayerListToolComponent, LayerListToolControlsEnum, LayerListToolService, TrackFeatureButtonComponent, ImageWatcher, TileWatcher, getLayersLegends, VectorWatcher, IgoMap, MapViewAction, MapService, stringToLonLat, viewStatesAreEqual, formatScale, getResolutionFromScale, getScaleFromResolution, ctrlKeyDown, roundCoordTo, lonLatConversion, utmZoneFromLonLat, mtmZoneFromLonLat, MapOfflineDirective, PointerPositionDirective, PointerPositionByKeyDirective, ProjectionService, MapController, MapViewController, MapBrowserComponent, ZoomButtonComponent, GeolocateButtonComponent, OfflineButtonComponent, BaseLayersSwitcherComponent, MiniBaseMapComponent, RotationButtonComponent, MEASURE_UNIT_AUTO, MeasureType, MeasureLengthUnit, MeasureLengthUnitAbbreviation, MeasureAreaUnit, MeasureAreaUnitAbbreviation, metersToKilometers, metersToFeet, metersToMiles, squareMetersToSquareKilometers, squareMetersToSquareMiles, squareMetersToSquareFeet, squareMetersToHectares, squareMetersToAcres, metersToUnit, squareMetersToUnit, formatMeasure, computeBestLengthUnit, computeBestAreaUnit, createMeasureInteractionStyle, createMeasureLayerStyle, measureOlGeometryLength, measureOlGeometryArea, measureOlGeometry, updateOlGeometryMidpoints, clearOlGeometryMidpoints, updateOlTooltipsAtMidpoints, getOlTooltipsAtMidpoints, updateOlGeometryCenter, updateOlTooltipAtCenter, getOlTooltipAtCenter, getTooltipsOfOlGeometry, createOlTooltipAtPoint, MeasurerComponent, MeasureFormatPipe, MetadataService, MetadataButtonComponent, Overlay, OverlayDirective, OverlayService, OverlayAction, createOverlayLayer, createOverlayDefaultStyle, createOverlayMarkerStyle, PrintService, PrintIonicService, PrintOutputFormat, PrintPaperFormat, PrintOrientation, PrintResolution, PrintSaveImageFormat, PrintComponent, PrintFormComponent, QueryService, QueryDirective, QueryFormat, QueryFormatMimeType, QueryHtmlTarget, layerIsQueryable, olLayerIsQueryable, QuerySearchSource, DirectionsService, DirectionsFormat, SourceDirectionsType, DirectionsSource, OsrmDirectionsSource, stopMarker, DirectionsFormComponent, DirectionsFormBindingDirective, DirectionsFormService, SEARCH_TYPES, pointerPositionSummaryMarker, SearchPointerSummaryDirective, SearchService, SearchSourceService, sourceCanSearch, sourceCanReverseSearch, sourceCanReverseSearchAsSummary, featureToSearchResult, CadastreSearchSource, SearchSource, IChercheSearchResultFormatter, IChercheSearchSource, IChercheReverseSearchSource, ILayerSearchResultFormatter, ILayerSearchSource, NominatimSearchSource, StoredQueriesSearchSource, StoredQueriesReverseSearchSource, CoordinatesSearchResultFormatter, CoordinatesReverseSearchSource, ToastComponent, GoogleLinks, generateIdFromSourceOptions, generateWMSIdFromSourceOptions, generateWMTSIdFromSourceOptions, generateXYZIdFromSourceOptions, generateFeatureIdFromSourceOptions, generateId, OsmLinks, WktService, CatalogBrowserGroupComponent as ɵw, CatalogBrowserLayerComponent as ɵx, CatalogBrowserComponent as ɵv, CatalogLibaryItemComponent as ɵz, CatalogLibaryComponent as ɵy, CapabilitiesService as ɵf, DataSourceService as ɵp, DataService as ɵs, WFSService as ɵr, OptionsApiService as ɵeo, OptionsService as ɵq, DirectionsFormBindingDirective as ɵdn, DirectionsFormComponent as ɵdh, DirectionsFormService as ɵdm, DirectionsSource as ɵdj, OsrmDirectionsSource as ɵew, DirectionsService as ɵdi, DownloadButtonComponent as ɵba, DownloadService as ɵbb, FeatureDetailsComponent as ɵbc, FeatureFormComponent as ɵbd, OgcFilterButtonComponent as ɵbp, OgcFilterFormComponent as ɵbn, OgcFilterToggleButtonComponent as ɵbq, OgcFilterableFormComponent as ɵbs, OgcFilterableItemComponent as ɵbt, OgcFilterableListBindingDirective as ɵbv, OgcFilterableListComponent as ɵbu, FilterableDataSourcePipe as ɵbg, OGCFilterService as ɵbr, SpatialFilterService as ɵby, TimeFilterService as ɵbk, SpatialFilterItemComponent as ɵbz, SpatialFilterListComponent as ɵbx, SpatialFilterTypeComponent as ɵbw, TimeFilterButtonComponent as ɵbh, TimeFilterFormComponent as ɵbi, TimeFilterItemComponent as ɵbj, TimeFilterListBindingDirective as ɵbm, TimeFilterListComponent as ɵbl, GeometryFormFieldInputComponent as ɵbf, GeometryFormFieldComponent as ɵbe, ExportButtonComponent as ɵch, ImportExportComponent as ɵcc, DropGeoFileDirective as ɵcf, ExportService as ɵce, ImportService as ɵcd, IgoStyleListModule as ɵca, StyleListService as ɵcb, LayerItemComponent as ɵc, LayerLegendItemComponent as ɵd, LayerLegendListBindingDirective as ɵl, LayerLegendListComponent as ɵi, LayerLegendComponent as ɵe, LayerListToolComponent as ɵh, LayerListToolService as ɵu, LayerListBindingDirective as ɵj, LayerListComponent as ɵg, LayerService as ɵn, StyleService as ɵo, TrackFeatureButtonComponent as ɵm, baseLayersSwitcherSlideInOut as ɵcm, BaseLayersSwitcherComponent as ɵcl, MiniBaseMapComponent as ɵcn, GeolocateButtonComponent as ɵcj, MapBrowserComponent as ɵcg, OfflineButtonComponent as ɵcp, RotationButtonComponent as ɵck, PointerPositionByKeyDirective as ɵcr, PointerPositionDirective as ɵcq, MapService as ɵk, MapOfflineDirective as ɵco, ProjectionService as ɵt, ZoomButtonComponent as ɵci, MeasureFormatPipe as ɵcs, MeasurerDialogComponent as ɵcv, MeasurerItemComponent as ɵct, MeasurerComponent as ɵcu, MetadataButtonComponent as ɵa, MetadataService as ɵb, OverlayDirective as ɵcx, OverlayService as ɵcy, PrintFormComponent as ɵdb, PrintComponent as ɵcz, PrintService as ɵda, QuerySearchSource as ɵdg, QueryDirective as ɵdc, QueryService as ɵdd, SearchUrlParamDirective as ɵds, SearchResultAddButtonComponent as ɵdu, SearchResultsItemComponent as ɵdv, SearchResultsComponent as ɵdt, SearchSelectorComponent as ɵdp, IgoSearchSelectorModule as ɵdo, SearchSettingsComponent as ɵdr, IgoSearchSettingsModule as ɵdq, SearchPointerSummaryDirective as ɵdw, provideSearchSourceService as ɵdy, searchSourceServiceFactory as ɵdx, SearchSourceService as ɵdl, SearchService as ɵdk, CadastreSearchSource as ɵeq, CoordinatesReverseSearchSource as ɵed, CoordinatesSearchResultFormatter as ɵec, IChercheReverseSearchSource as ɵeb, IChercheSearchResultFormatter as ɵdz, IChercheSearchSource as ɵea, ILayerSearchResultFormatter as ɵee, ILayerSearchSource as ɵef, NominatimSearchSource as ɵet, SearchSource as ɵde, StoredQueriesReverseSearchSource as ɵev, StoredQueriesSearchSource as ɵeu, ToastComponent as ɵeg, WktService as ɵbo, WfsWorkspaceService as ɵei, WmsWorkspaceService as ɵej, OgcFilterComponent as ɵek, OgcFilterWidget as ɵel, ogcFilterWidgetFactory as ɵem, provideOgcFilterWidget as ɵen, WorkspaceSelectorDirective as ɵeh };

//# sourceMappingURL=igo2-geo.js.map